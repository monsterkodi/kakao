###
000   000  00000000  00000000   00     00  000  000000000
000  000   000       000   000  000   000  000     000   
0000000    0000000   0000000    000000000  000     000   
000  000   000       000   000  000 0 000  000     000   
000   000  00000000  000   000  000   000  000     000   
###

use ◆ kstr gonzo
    
wrapIndex = (ctx,offset) -> (ctx.pind+offset) % ctx.ptn.length
    
strongMatchAhead = (splt, ctx) -> splt[0] == ctx.ptn[wrapIndex(ctx,1)][0][0]
    
#  0000000   0000000    0000000    00     00   0000000   000000000   0000000  000   000  
# 000   000  000   000  000   000  000   000  000   000     000     000       000   000  
# 000000000  000   000  000   000  000000000  000000000     000     000       000000000  
# 000   000  000   000  000   000  000 0 000  000   000     000     000       000   000  
# 000   000  0000000    0000000    000   000  000   000     000      0000000  000   000  

addMatch = (splt, ctx) ->
            
    cpt = ctx.ptn[ctx.pind][0]
    # log r2('▸▸▸▸▸▸▸'), y5(splt), b5(cpt), g3 kstr ctx
            
    strongMatch = false
    weakMatch = false
    varName = null
    
    ci = 0
    si = 0
    rslt = {}
    
    while ci < cpt.length
        
        cp = cpt[ci]
        
        if cp == splt[si]
            # log 'strmatch' cp
            strongMatch = true
            varName = null
            si++
            ci++
            continue
            
        if cp?[0] in '●'
            
            weakMatch = true
            varName = cp[1..]
            rslt[varName] = splt[si]
            si++
            ci++
            # log 'add var' varName, rslt
            continue
            
        else if weakMatch and varName and valid splt[si+1]
            
            # log 'swallow'
            rslt[varName] += ' ' + splt[si]
            si++
            continue
        else
            log 'bail?' cp, splt[si], g4 kstr ctx
            ci++
            continue
    
    if ci == cpt.length and varName and si < splt.length
        rslt[varName] += ' ' + splt[si..].join ' '
        # log 'add rest' varName, rslt[varName]

    # log r2('add -----------'), r5(kstr rslt)
    
    if not strongMatch and strongMatchAhead splt, ctx
        ctx.pind = wrapIndex ctx, 1
        return addMatch splt, ctx
    
    if strongMatch or weakMatch
        type = strongMatch ? 'strong' : 'weak'
        ctx.matches.push type:type, rslt:rslt, pind:ctx.pind, arr:clone ctx.ptn[ctx.pind][1]
        if strongMatch ➜ ctx.pind = wrapIndex ctx, 1
    
# 000000000  00000000    0000000   000   000  00000000  00000000    0000000  00000000  
#    000     000   000  000   000  000   000  000       000   000  000       000       
#    000     0000000    000000000   000 000   0000000   0000000    0000000   0000000   
#    000     000   000  000   000     000     000       000   000       000  000       
#    000     000   000  000   000      0      00000000  000   000  0000000   00000000  

traverse = (lines, ctx) ->
    
    ctx.matches = []
    while line = lines.shift()
        splt = trim(line).split /\s+/
        addMatch splt, ctx

    log 'matches:' y5 kstr ctx.matches
    collect ctx
    ctx
    
#  0000000   0000000   000      000      00000000   0000000  000000000  
# 000       000   000  000      000      000       000          000     
# 000       000   000  000      000      0000000   000          000     
# 000       000   000  000      000      000       000          000     
#  0000000   0000000   0000000  0000000  00000000   0000000     000     

collect = (ctx) ->
    
    ctx.result = []
    
    lm = pind:Infinity
    pa = []
    
    for match in ctx.matches
        
        if match.pind < lm.pind
            ctx.result.push {}
            
        if match.pind == lm.pind
            ctx.result.push {}
            
        ma = ctx.ptn[match.pind][1]
            
        lo = last ctx.result
        if lo
            if valid ma
                for ai in ma
                    if not lo[ai]?
                        lo[ai] = [{}]
                    lo = last lo[ai]
            
            for k,v of match.rslt
                lo[k] = v
        lm = match 
        pa = ma
    
    ctx.result = ctx.result.filter (o) -> valid o
    ctx.result
             
# 00000000    0000000   000000000  000000000  00000000  00000000   000   000  
# 000   000  000   000     000        000     000       000   000  0000  000  
# 00000000   000000000     000        000     0000000   0000000    000 0 000  
# 000        000   000     000        000     000       000   000  000  0000  
# 000        000   000     000        000     00000000  000   000  000   000  

pattern = (kmt) ->
    
    p = []
    ars = []
    parseGonzo = (gzo) ->
        
        for gz in gzo
            lpt = trim(gz.line).split /\s+/
            if lpt[0][0] == '■'
                ars.push lpt[0][1..]
                parseGonzo gz.blck, ars 
                ars.pop()
            else
                p.push [lpt, clone ars]
    
    gzo = gonzo kmt
    return p if empty gzo
    parseGonzo gzo
    p
        
# 000   000  00000000  00000000   00     00  000  000000000  
# 000  000   000       000   000  000   000  000     000     
# 0000000    0000000   0000000    000000000  000     000     
# 000  000   000       000   000  000 0 000  000     000     
# 000   000  00000000  000   000  000   000  000     000     

kermit = (kmt, str) ->

    lines = str.split '\n'
    lines = lines.filter (l) -> valid trim l

    ctx = traverse lines, pind:0 ptn:pattern kmt
    ctx.result
    
kermit.pattern = pattern

export kermit
