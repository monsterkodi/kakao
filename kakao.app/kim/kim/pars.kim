
import std/[strformat, strutils]
import kommon
import lexi

type
    NodeKind* = enum
    
        ●error,
        ●block,
        ●comment,
        ●literal,
        ●identifier,  
        ●preOp, 
        ●operation, 
        ●postOp,
        ●call,
        ●if, 
        ●condThen,
        ●for, 
        ●while,
        ●switch,
        ●switchCase,
        ●var,        
        ●propertyAccess,        
        ●func, 
        ●arg,
        ●return, 
        ●break, 
        ●continue,          
        ●use, 
        ●class,
        ●enum,
        ●testSuite,
        ●testSection,
        ●testCase,
        ●eof
    
    # ███   ███   ███████   ███████    ████████
    # ████  ███  ███   ███  ███   ███  ███     
    # ███ █ ███  ███   ███  ███   ███  ███████ 
    # ███  ████  ███   ███  ███   ███  ███     
    # ███   ███   ███████   ███████    ████████

    Node* = ref object

        token : Token
            
        case kind*: NodeKind
        
            of ●block:
                
                expressions*    : seq[Node]
        
            of ●operation
            
                left*           : Node
                right*          : Node
                
            of ●postOp, ●preOp
            
                operand*        : Node 
                
            of ●return
            
                return_value*   : Node  

            of ●call
            
                callee*         : Node
                call_args*      : seq[Node]

            of ●propertyAccess
            
                owner*          : Node
                property*       : Node
                
            of ●if 
            
                cond_thens*     : seq[Node]
                `else`*         : Node
                
            of ●condThen
            
                cond*           : Node
                then*           : Node
                
            of ●switch
                
                switch_value*   : Node
                switch_cases*   : seq[Node]
                switch_default* : Node
                
            of ●switchCase
            
                case_when*      : seq[Node]
                case_then*      : Node
                
            of ●while
            
                while_cond*     : Node
                while_body*     : Node
                
            of ●for
            
                for_value*      : Node
                for_range*      : Node
                for_body*       : Node
                
            of ●var
            
                var_name*       : Node
                var_type*       : Node
                var_value*      : Node
                
            of ●func
            
                func_name*      : Node
                func_type*      : Node
                func_args*      : Node
                func_body*      : Node
                            
            of ●testCase
                
                test_expression* : Node
                test_expected*   : Node
                
            else
                discard
                
template choose*(cond, a, b: untyped): untyped =

    when typeof(cond) is bool:
        if cond 
            a 
        else 
            b
    elif typeof(cond) is ref:
        if cond != nil 
            a 
        else 
            b
    else:
        {.error: "Condition must be bool or ref type".}

# ████████    ███████   ████████    ███████  ████████  ████████ 
# ███   ███  ███   ███  ███   ███  ███       ███       ███   ███
# ████████   █████████  ███████    ███████   ███████   ███████  
# ███        ███   ███  ███   ███       ███  ███       ███   ███
# ███        ███   ███  ███   ███  ███████   ████████  ███   ███

type

    RHS = proc(p: var Parser): Node
    LHS = proc(p: var Parser, left: Node): Node
    
    Pratt = object
        rhs: RHS
        lhs: LHS
        precedence: int
         
    Parser* = object
    
        tokens* : seq[Token]
        pratts* : seq[Pratt]
        pos*    : int
    
    ParseError* = object
    
        msg*    : string
        line*   : int
        col*    : int


proc current*(p: Parser): Token =

    if p.pos < p.tokens.len
        ⮐  p.tokens[p.pos]
        
    Token(tok:◆eof)
    
proc tok*(p: Parser) : tok = p.current().tok

# ████████   ████████   ███  ███   ███  █████████  
# ███   ███  ███   ███  ███  ████  ███     ███     
# ████████   ███████    ███  ███ █ ███     ███     
# ███        ███   ███  ███  ███  ████     ███     
# ███        ███   ███  ███  ███   ███     ███     

proc `$`*(p: Parser): string = 

    let s = &"▪▪▪ {p.current()}"
    s

proc `$`*(n: Node): string = 

    var s = &"{n.token.tok}"
    
    case n.kind
        of ●block
            for e in n.expressions
                s &= &"\n {e}"
        of ●operation
            s = &"({n.left} {s} {n.right})"
        of ●preOp
            s = &"({s} {n.operand})"
        of ●postOp
            s = &"({n.operand} {s})"
        of ●return
            let e = choose(n.return_value, &" {n.return_value}", "")
            s = &"({s}{e})"
        of ●call
            s = &"({n.callee} ◆call {n.callargs})"
        of ●propertyAccess
            s = &"({n.owner} {s} {n.property})"
        of ●if
            let e = choose(n.else, &" {n.else}", "")
            s = &"({s} {n.cond_thens}{e})"
        of ●condThen
            s = &"({n.cond} {n.then})"
        of ●switch
            let e = choose(n.switch_default, &" {n.switch_default}", "")
            s = &"({s} {n.switch_value} {n.switch_cases}{e})"
        of ●switchCase
            s = &"({n.case_when} {n.case_then})"
        of ●for 
            s = &"({s} {n.for_value} {n.for_range} {n.for_body})"
        of ●while
            s = &"({s} {n.while_cond} {n.while_body})"
        of ●func
            s = &"({s} {n.func_name} {n.func_type} {n.func_args}) {n.func_body})"
        of ●testCase
            s = &"({n.test_expression} {s} {n.test_expected})"
        else
            discard
    s

proc formatValue*(result:var string, n:Node,   specifier: string) = result.add $n
proc formatValue*(result:var string, p:Parser, specifier: string) = result.add $p
proc error*(p: var Parser, msg: string) : Node =

    log &"parse error: {msg}"
    nil
    
#  ███████   ███████   ███   ███   ███████  ███   ███  ██     ██  ████████
# ███       ███   ███  ████  ███  ███       ███   ███  ███   ███  ███     
# ███       ███   ███  ███ █ ███  ███████   ███   ███  █████████  ███████ 
# ███       ███   ███  ███  ████       ███  ███   ███  ███ █ ███  ███     
#  ███████   ███████   ███   ███  ███████    ███████   ███   ███  ████████

proc consume(p: var Parser): Token =

    let t = p.current()
    if p.pos < p.tokens.len
        p.pos += 1
    t

proc swallow(p: var Parser) =

    discard p.consume()

proc swallow(p: var Parser, tok: tok) =

    if p.tok() == tok
        p.swallow()
        
proc swallowError(p: var Parser, tok: tok, err: string) = 

    if p.tok() != tok
        discard p.error(err)
        ⮐  
    p.swallow()
    
proc peek*(p: Parser, ahead: int = 1): Token =

    p.tokens[p.pos + ahead]
    
proc getPrecedence(p: Parser, token: Token): int =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].precedence
    0
    
proc rightHandSide(p: Parser, token: Token): RHS =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].rhs

proc leftHandSide(p: Parser, token: Token): LHS =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].lhs

# ████████  ███   ███  ████████   ████████   ████████   ███████   ███████  ███   ███████   ███   ███
# ███        ███ ███   ███   ███  ███   ███  ███       ███       ███       ███  ███   ███  ████  ███
# ███████     █████    ████████   ███████    ███████   ███████   ███████   ███  ███   ███  ███ █ ███
# ███        ███ ███   ███        ███   ███  ███            ███       ███  ███  ███   ███  ███  ████
# ████████  ███   ███  ███        ███   ███  ████████  ███████   ███████   ███   ███████   ███   ███

proc expression(p: var Parser, precedenceRight = 0): Node =

    let token = p.current()
    
    if token.tok == ◆eof
        ⮐  nil
    
    let rhs = p.rightHandSide(token)
    
    if rhs == nil
    
        if token.tok == ◆else
            ⮐  nil
        ⮐  p.error(&"expected expression but found: {token}")
        
    var left: Node = rhs(p)

    while true
        
        let token = p.current()
        var precedence = p.getPrecedence(token)
        
        if token.tok in {◆assign, ◆test}
            precedence += 1
        
        if precedenceRight >= precedence
            break
    
        let lhs = p.leftHandSide(token)
        if lhs == nil
            break
            
        left = lhs(p, left)
    
    left
    
proc expression(p: var Parser, tokenRight:Token ): Node =

    expression(p, p.getPrecedence(tokenRight))

# ███████    ███       ███████    ███████  ███   ███
# ███   ███  ███      ███   ███  ███       ███  ███ 
# ███████    ███      ███   ███  ███       ███████  
# ███   ███  ███      ███   ███  ███       ███  ███ 
# ███████    ███████   ███████    ███████  ███   ███

proc parseBlock*(p: var Parser): Node =

    var expressions = default seq[Node]
    
    while p.tok() == ◆indent 
        p.swallow ◆indent # swallow indentation to enable simple test cases
    
    var expr : Node = p.expression()
    while expr != nil
        expressions.add expr
        expr = p.expression()
    
    Node(token:Token(tok:◆root), kind:●block, expressions:expressions)

proc parse*(p: var Parser): Node = 

    parseBlock(p)
    
# ███  ████████
# ███  ███     
# ███  ██████  
# ███  ███     
# ███  ███     

proc parseIf(p: var Parser): Node =

    let token = p.consume() # if
    
    var condThens: seq[Node] = @[]
    
    p.swallow ◆indent # block indentation
    
    var cond = p.expression() # initial condition
            
    p.swallowError(◆then, "Expected 'then' after if condition") # initial then
    
    var then = p.expression()
    
    condThens.add(Node(kind:●condThen, cond:cond, then:then))
    
    while p.tok() in {◆elif, ◆indent}
    
        p.swallow() # elif or indent
        
        if p.tok() == ◆then
            break # then without condition -> else
        
        cond = p.expression()
        
        p.swallowError(◆then, "Expected 'then' after elif condition")
            
        then = p.expression()
        
        condThens.add(Node(kind:●condThen, cond:cond, then:then))
        
    var `else`: Node
    
    if p.tok() in {◆else, ◆then}
        p.swallow() # else or then without condition
        `else` = p.expression()
    
    Node(
        token:      token,
        kind:       ●if,
        cond_thens: condThens,
        `else`:     `else`
        )

#  ███████  ███   ███  ███  █████████   ███████  ███   ███
# ███       ███ █ ███  ███     ███     ███       ███   ███
# ███████   █████████  ███     ███     ███       █████████
#      ███  ███   ███  ███     ███     ███       ███   ███
# ███████   ██     ██  ███     ███      ███████  ███   ███

proc parseSwitchCase(p: var Parser, baseIndent: int): Node =

    var case_when: seq[Node]
    let case_token = p.current()
    
    while p.tok() notin {◆else, ◆then, ◆indent, ◆eof}
        case_when.add p.expression()
    
    # if case_when.len == 0
    #     ⮐  p.error("Switch case needs at least one pattern")
    
    p.swallow ◆then
    
    if p.tok() == ◆indent and p.current().str.len > baseIndent
        p.swallow ◆indent
        
    let case_then = p.expression()
    
    if case_then == nil
        ⮐  p.error "Expected case body after matches"
    
    Node(
        token:      case_token,
        kind:       ●switchCase,
        case_when:  case_when,
        case_then:  case_then
        )

proc parseSwitch*(p: var Parser): Node =

    let token = p.consume()
    let switch_value = p.expression()
    
    if switch_value == nil
        ⮐  p.error "Expected value after switch keyword"
    
    let baseIndent = p.current().str.len 
    
    p.swallowError(◆indent, "Expected indentation after switch statement")
    
    var switch_cases: seq[Node]
    
    while p.tok() notin {◆else, ◆then, ◆eof}
        if p.tok() == ◆indent
            if p.current().str.len < baseIndent
                break
            p.swallow ◆indent
            continue
        let switch_case = p.parseSwitchCase(baseIndent)
        if switch_case == nil
            ⮐  p.error "failed to parse switch statement"
        else
            switch_cases.add switch_case
    
    var switch_default: Node
    
    if p.tok() in {◆else, ◆then}
        p.swallow()
        switch_default = 
            if p.tok() == ◆indent and p.current().str.len > baseIndent
                p.swallow()
                p.expression()
            else
                p.expression()
        
        if switch_default == nil
            ⮐  p.error "Expected default value"
    
    Node(
        token:          token,
        kind:           ●switch,
        switch_value:   switch_value,
        switch_cases:   switch_cases,
        switch_default: switch_default
        )
        
# proc parseFor*(p: var Parser): Node =
# 
# proc parseFunction*(p: var Parser): Node =
# 
# proc parseVariable*(p: var Parser): Node =
    
proc parseArgs(p: var Parser): seq[Node] =
    
    var args = default seq[Node]
    while p.tok() != ◆paren_close
        args.add p.expression()
    p.swallowError(◆paren_close, "Missing closing paren for call arguments")    
    args    

proc parseCall(p: var Parser, callee: Node): Node =

    let token = p.consume() # (
    let args  = p.parseArgs()
    Node(token:token, kind:●call, callee:callee, callargs:args)
    
proc parsePropertyAccess(p: var Parser, owner: Node): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind:●propertyAccess, owner:owner, property:right)

proc parseLiteral(p: var Parser): Node =

    let token = p.consume()
    Node(token:token, kind: ●literal)

proc parseString(p: var Parser): Node =

    p.swallow() # string start
    let token = p.consume()
    p.swallowError(◆string_end, "Expected closing string delimiter")
    Node(token:token, kind: ●literal)

proc parsePostOp(p: var Parser, left: Node): Node =

    let token = p.consume()
    Node(token:token, kind: ●postOp, operand:left)

proc parsePreOp(p: var Parser): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind:●preOp, operand:right)

proc parseReturn(p: var Parser): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind:●return, return_value:right)

proc parseOperation(p: var Parser, left: Node): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind: ●operation, left: left, right: right)
        
proc parseParenExpr(p: var Parser): Node =

    p.swallow() # '('
    let expr = p.expression()
    p.swallowError(◆paren_close, "Expected closing parenthesis")
    expr
    
proc parseTestCase(p: var Parser, left: Node): Node =

    let token = p.consume() # ▸
    p.swallow(◆indent) # todo: check if indent is larger than that of the test expression
    let right = p.expression()
    Node(token:token, kind: ●testCase, test_expression:left, test_expected:right)

proc parseTestSuite(p: var Parser): Node =

    let token = p.consume() # ▸
    let kind = choose(token.col == 0, ●testSuite, ●testSection)
    Node(token:token, kind:kind)
        
#  ███████  ████████  █████████  ███   ███  ████████ 
# ███       ███          ███     ███   ███  ███   ███
# ███████   ███████      ███     ███   ███  ████████ 
#      ███  ███          ███     ███   ███  ███      
# ███████   ████████     ███      ███████   ███      

proc pratt(p: var Parser, t:tok, lhs:LHS, rhs:RHS, precedence:int) = 

    if p.pratts.len <= t.ord
        p.pratts.setLen(t.ord + 1)
    
    p.pratts[t.ord] = Pratt(lhs:lhs, rhs:rhs, precedence:precedence)

proc setup(p: var Parser) =

    p.pratt ◆test,           parseTestCase,         parseTestSuite,    0
    p.pratt ◆number,         nil,                   parseLiteral,      0
    p.pratt ◆string_start,   nil,                   parseString,       0
    p.pratt ◆true,           nil,                   parseLiteral,      0
    p.pratt ◆false,          nil,                   parseLiteral,      0
    p.pratt ◆null,           nil,                   parseLiteral,      0
    p.pratt ◆name,           nil,                   parseLiteral,      0
                                                                      
    p.pratt ◆return,         nil,                   parseReturn,       5
                                                                      
    p.pratt ◆assign,         parseOperation,        nil,              10

    p.pratt ◆if,             nil,                   parseIf,          15  
    p.pratt ◆switch,         nil,                   parseSwitch,      15  

    p.pratt ◆equal,          parseOperation,        nil,              20

    p.pratt ◆or,             parseOperation,        nil,              22
    p.pratt ◆and,            parseOperation,        nil,              25

    p.pratt ◆plus,           parseOperation,        nil,              30

    p.pratt ◆multiply,       parseOperation,        nil,              40
    p.pratt ◆divide,         parseOperation,        nil,              40
                                                                                           
    p.pratt ◆not,            nil,                   parsePreOp,       50
    p.pratt ◆minus,          parseOperation,        parsePreOp,       50
                                                                                           
    p.pratt ◆increment,      parsePostOp,           nil,              60
    p.pratt ◆decrement,      parsePostOp,           nil,              60
                                                                                     
    p.pratt ◆dot,            parsePropertyAccess,   nil,             100
                                
    p.pratt ◆paren_open,     parseCall,             parseParenExpr, 1000
    
#  ███████    ███████  █████████
# ███   ███  ███          ███   
# █████████  ███████      ███   
# ███   ███       ███     ███   
# ███   ███  ███████      ███   

proc ast*(text:string) : Node =

    var p = Parser(tokens:lexi.tokenize(text), pos:0)
    p.setup()
    p.parse()
    