
#  ███████  ███       ███████    ███████  ███   ███
# ███       ███      ███   ███  ███       ███   ███
# ███████   ███      █████████  ███████   █████████
#      ███  ███      ███   ███       ███  ███   ███
# ███████   ███████  ███   ███  ███████   ███   ███

use ffi os
use ./array
use ./kstr
use ./kseg

ffi.cdef """
    typedef struct DIR DIR;
    struct dirent {
        unsigned long  d_ino;       
        unsigned long  d_seekoff;   
        unsigned short d_reclen;    
        unsigned short d_namlen;    
        unsigned char  d_type;      
        char           d_name[1024];
    };
    DIR *opendir(const char *filename);
    struct dirent *readdir(DIR *dirp);
    int closedir(DIR *dirp);
    const char *strerror(int errnum);
    
    struct stat {
        uint32_t    st_dev;
        uint16_t    st_mode;
        uint16_t    st_nlink;
        uint64_t    st_ino;
        uint32_t    st_uid;               
        uint32_t    st_gid;                
        uint32_t    st_rdev;                
        int64_t     st_atime;        
        int64_t     st_atimensec;    
        int64_t     st_mtime;        
        int64_t     st_mtimensec;    
        int64_t     st_ctime;        
        int64_t     st_ctimensec;    
        int64_t     st_btime;    
        int64_t     st_btimensec;
        int64_t     st_size;                
        int64_t     st_blocks;              
        int32_t     st_blksize;             
        uint32_t    st_flags;               
        uint32_t    st_gen;                 
        int32_t     st_lspare;              
        int64_t     st_qspare[2];
    };
    
    int stat64(const char *path, struct stat *buf);
    int lstat64(const char *path, struct stat *buf);
"""
    
slash = {}
    
slash.cwd = -> process.cwd()

slash.normalize = path ->

    p = kseg.segs path
    frst = p[1]
    # log "START" p.len, frst
    swallow = 0xffff
    for i in p.len..1
        if i >= swallow
            table.remove p i
            if i == swallow or i == 1
                if p[1] == '/' and frst != '/'
                    kseg.shift p 
                ⮐  slash.normalize(kseg.str(p))
        else
            if p[i] == '\\' ➜ p[i] = '/'
            if i < p.len and p[i] == '/'
                if i < p.len - 1
                    if p[i+1] == '.' and p[i+2] == '/' 
                        p = kseg.splice p i+1 2
                    if p[i+1] == '.' and p[i+2] == '.' and i > 1 and p[i-1] != '.'
                        p = kseg.splice p i 3
                        swallow = i-1
                        while swallow > 0 and p[swallow] != '/'
                            swallow -= 1
                if p[i+1] == '/'
                    p = kseg.splice p i+1 1
    
    if p.len >= 4 and kseg.str(kseg.sub(p 1 4)) == "./.."
        kseg.shift p
        kseg.shift p
    if p.len > 1 and p[p.len] == '/'
        kseg.pop p
    if p.len > 1 and p[1] == '/' and frst != '/' and frst != '\\'
        kseg.shift p
    kseg.str p

slash.path = (...) ->

    slsh = s -> string.gsub(s "\\" "/")
    mpty = s -> s.len > 0
    fpth = table.concat(array.map(array.filter({...}, mpty), slsh), "/")
    slash.normalize fpth

slash.isRelative = path -> path.len == 0 or path.len > 0 and string.sub(path 1 1) != '/' and string.sub(path 1 1) != '~'

slash.home = -> os.getenv "HOME"
slash.untilde = path -> 

    if path[1] == '~' 
        ⮐  slash.path slash.home() kstr.shift(path)
    slash.path path

slash.absolute = path parent ->

    if slash.isRelative path
        parent ?= slash.cwd()
        ⮐  slash.path parent path
    else
        ⮐  slash.untilde path

slash.split = path -> kstr.split path "/"
slash.join  = ... -> table.concat {...} "/"
        
slash.parse = path ->
    path  = slash.untilde slash.normalize(path)
    split = slash.split path
    dir   = ""
    file  = array.pop split
    dir = slash.join unpack(split)
    name  = file
    ext   = ""
    
    if dir.len == 0 and path != "." and path != ".."
        if path[0] == '/' ➜ dir = "/" ➜ dir = "."
    
    nmspl = kstr.split file "."
    if nmspl.len > 1
        ext  = array.pop nmspl
        name = table.concat nmspl "."
        
    {dir: dir name: name ext: ext file: file path: path}
        
slash.dir  = path -> slash.parse(path).dir
slash.file = path -> slash.parse(path).file
slash.name = path -> slash.parse(path).name
slash.ext  = path -> slash.parse(path).ext
    
prettyTimeSpan = seconds ->

    if seconds == 0 ➜ ⮐  "0"
    seconds = math.abs seconds

    days = math.floor(seconds / 86400)
    seconds = seconds % 86400

    hours = math.floor(seconds / 3600)
    seconds = seconds % 3600

    minutes = math.floor(seconds / 60)
    seconds = seconds % 60

    parts = {}
    if days > 0
        table.insert(parts, string.format("%d day%s", days, days == 1 and "" or "s"))

    if hours > 0
        table.insert(parts, string.format("%d hour%s", hours, hours == 1 and "" or "s"))

    if minutes > 0
        table.insert(parts, string.format("%d minute%s", minutes, minutes == 1 and "" or "s"))

    if seconds > 0 or parts.len == 0
        table.insert(parts, string.format("%.2f second%s", seconds, seconds == 1 and "" or "s"))

    table.concat parts " "

sbuf = ffi.new("struct stat")

slash.stat = path ->

    if ffi.C.stat64(path, sbuf) == 0
    
        ⮐   {
                mode:       tonumber(sbuf.st_mode)
                nlink:      tonumber(sbuf.st_nlink)
                ino:        tonumber(sbuf.st_ino)
                uid:        tonumber(sbuf.st_uid)
                gid:        tonumber(sbuf.st_gid)
                atime:      tonumber(sbuf.st_atime)
                mtime:      tonumber(sbuf.st_mtime)
                ctime:      tonumber(sbuf.st_ctime)
                btime:      tonumber(sbuf.st_btime)
                blksize:    tonumber(sbuf.st_blksize)
                blocks:     tonumber(sbuf.st_blocks)
                # modage:     prettyTimeSpan(os.time()-tonumber(sbuf.st_mtime))
            }
    
slash.walk = path ->

    dir = ffi.C.opendir path
    if dir == nil
        error "Failed to open directory: " & path & " " & ffi.string(ffi.C.strerror(ffi.errno()))
    
    files = {}
    while true
        entry = ffi.C.readdir dir
        if entry != nil
            name = ffi.string entry.d_name
            if name != "." and name != ".."
                typ = "???"
                if   entry.d_type == 4  ➜ typ = "dir"
                elif entry.d_type == 8  ➜ typ = "file"
                elif entry.d_type == 10 ➜ typ = "link"
                    
                info = { "name": name "type": typ "path": slash.absolute(path & "/" & name) }
                table.insert files info
        else
            break
    ffi.C.closedir dir
    table.sort(files, (a b) -> ⮐  a.path < b.path)
    files

slash.files = path ext ->

    files = array.map(slash.walk(path), (info) -> ⮐  info.path)
    if ext 
        fext = (f) -> slash.ext(f) == ext
        files = array.filter files fext
    files
            
⮐  slash
