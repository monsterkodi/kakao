# ████████    ███████   ████████    ███████
# ███   ███  ███   ███  ███   ███  ███     
# ████████   █████████  ███████    ███████ 
# ███        ███   ███  ███   ███       ███
# ███        ███   ███  ███   ███  ███████ 

import kommon
import tknz

type NodeKind* = enum
    
    ●error
    ●block
    ●comment
    ●literal
    ●string
    ●stripol
    ●keyword  
    ●preOp 
    ●operation 
    ●postOp
    ●call
    ●if,
    ●condThen
    ●for 
    ●list
    ●curly
    ●squarely
    ●range 
    ●while
    ●switch
    ●switchCase
    ●var        
    ●let        
    ●propertyAccess        
    ●arrayAccess
    ●arrayLike
    ●func
    ●type
    ●signature
    ●return 
    ●discard 
    ●break 
    ●continue          
    ●use 
    ●import
    ●class
    ●enum
    ●testSuite
    ●testSection
    ●testCase
    ●eof
    
# ███   ███   ███████   ███████    ████████
# ████  ███  ███   ███  ███   ███  ███     
# ███ █ ███  ███   ███  ███   ███  ███████ 
# ███  ████  ███   ███  ███   ███  ███     
# ███   ███   ███████   ███████    ████████

type Node* = ref object

    token* : Token
        
    case kind* : NodeKind
    
        of ●block
            
            expressions*    : seq[Node]
            
        of ●operation
        
            operand_left*   : Node
            operand_right*  : Node
            
        of ●string
        
            string_content*  : Node
            string_stripols* : seq[Node]
            
        of ●comment
        
            comment_content* : Node
            
        of ●stripol
        
            stripol_xprssns* : seq[Node]
            stripol_content* : Node
    
        of ●range
        
            range_start*    : Node
            range_end*      : Node
            
        of ●postOp, ●preOp
        
            operand*        : Node 
            
        of ●return
        
            return_value*   : Node  
    
        of ●discard
        
            discard_value*  : Node  
    
        of ●call
        
            callee*         : Node
            call_args*      : seq[Node]
    
        of ●propertyAccess
        
            owner*          : Node
            property*       : Node
            
        of ●arrayAccess
        
            array_owner*    : Node
            array_index*    : Node
            
        of ●if
            # also handles when
            cond_thens*     : seq[Node]
            `else`*         : Node
            
        of ●condThen
        
            cond*           : Node
            then*           : Node
            
        of ●switch
            
            switch_value*   : Node
            switch_cases*   : seq[Node]
            switch_default* : Node
            
        of ●switchCase
        
            case_when*      : seq[Node]
            case_then*      : Node
            
        of ●while
        
            while_cond*     : Node
            while_body*     : Node
            
        of ●for
        
            for_value*      : Node
            for_range*      : Node
            for_body*       : Node
            
        of ●list, ●curly, ●squarely
        
            list_values*    : seq[Node] 
            
        of ●var
        
            var_type*       : Node
            var_name*       : Node
            var_value*      : Node
            
        of ●let
            
            let_expr*       : Node
            
        of ●signature
        
            sig_args*       : Node
            sig_type*       : Node
            
        of ●func
        
            func_signature* : Node
            func_mod*       : Node
            func_body*      : Node
            
        of ●use
        
            use_module*     : Node
            use_kind*       : Node
            use_items*      : seq[Node]
            
        of ●testSuite, ●testSection
        
            test_block*     : Node
                        
        of ●testCase
            
            test_value*     : Node
            test_expected*  : Node
            
        else
            discard
                
template choose*(cond, a, b: untyped): untyped =

    when typeof(cond) is bool:
        if cond 
            a 
        else 
            b
    elif typeof(cond) is ref:
        if cond != nil 
            a 
        else 
            b
    else:
        {.error: "Condition must be bool or ref type".}

# ████████    ███████   ████████    ███████  ████████  ████████ 
# ███   ███  ███   ███  ███   ███  ███       ███       ███   ███
# ████████   █████████  ███████    ███████   ███████   ███████  
# ███        ███   ███  ███   ███       ███  ███       ███   ███
# ███        ███   ███  ███   ███  ███████   ████████  ███   ███

type

    RHS = proc(p: Parser): Node
    LHS = proc(p: Parser, left: Node): Node
    
    Pratt = object
        rhs: RHS
        lhs: LHS
        precedence: int
         
    Parser* = ref object
        text     : string # used in `$` for debugging. should be removed eventually 
        tokens*  : seq[Token]
        pratts*  : seq[Pratt]
        blocks*  : seq[Node]
        implicit : bool
        listless : bool
        returning: bool
        pos*     : int
    
proc current(p: Parser): Token =

    if p.pos < p.tokens.len
        ⮐  p.tokens[p.pos]
        
    Token(tok:◆eof, line: -1, col: -1)
    
proc tok(p: Parser) : tok = p.current.tok

proc peek(p: Parser, ahead=1): Token =

    if p.pos + ahead < p.tokens.len
        p.tokens[p.pos + ahead]
    else
        Token(tok:◆eof)

# ████████   ████████   ███  ███   ███  █████████  
# ███   ███  ███   ███  ███  ████  ███     ███     
# ████████   ███████    ███  ███ █ ███     ███     
# ███        ███   ███  ███  ███  ████     ███     
# ███        ███   ███  ███  ███   ███     ███     

proc `$`(p: Parser): string = 

    var s : string
    if p.tok != ◆eof
        s = &"▪▪▪ {p.current} {p.pos}"
        let l = p.text.split("\n")[p.current.line]
        s &= &"\n{p.current.line}: {l}"
    else
        s = p.text
    s

proc `$`*(n: Node): string = 

    if n == nil
        ⮐  "NIL"
        
    var s = &"{n.token.tok}"
    
    case n.kind
        of ●block
            s = "▪["
            for e in n.expressions
                if e != nil
                    s &= &"{e}"
                else
                    s &= "NIL"
            s &= "]"
        of ●operation
            s = &"({n.operand_left} {s} {n.operand_right})"
        of ●range
            s = &"({n.range_start} {s} {n.range_end})"
        of ●string
            var ips = ""
            for i,s in n.string_stripols
                if i == 0
                    ips &= "#{"
                ips &= $s.stripol_xprssns
                if 0 < i < n.string_stripols.len-1
                    ips &= " "
                if i == n.string_stripols.len-1
                    ips &= "}"
            s = &"◆string{ips}"
        of ●preOp
            s = &"({s} {n.operand})"
        of ●postOp
            s = &"({n.operand} {s})"
        of ●return
            let e = choose(n.return_value, &" {n.return_value}", "")
            s = &"({s}{e})"
        of ●call
            s = &"({n.callee} ◆call {n.callargs})"
        of ●propertyAccess
            s = &"({n.owner} {s} {n.property})"
        of ●if
            let e = choose(n.else, &" {n.else}", "")
            s = &"({s} {n.cond_thens}{e})"
        of ●condThen
            s = &"({n.cond} {n.then})"
        of ●switch
            let e = choose(n.switch_default, &" {n.switch_default}", "")
            s = &"({s} {n.switch_value} {n.switch_cases}{e})"
        of ●switchCase
            s = &"({n.case_when} {n.case_then})"
        of ●for
            let b = choose(n.for_body, &" {n.for_body}", "")
            s = &"({s} {n.for_value} in {n.for_range}{b})"
        of ●list
            s = &"{n.list_values}"
            s = "◆" & s[1..^1]
        of ●curly
            s = &"{n.list_values}"
            s = "{" & s[2..^2] & "}"
        of ●squarely
            s = &"{n.list_values}"
            s = "[" & s[1..^1] & "]]"
        of ●while
            let b = choose(n.while_body, &" {n.while_body}", "")
            s = &"({s} {n.while_cond}{b})"
        of ●func
            let sig = choose(n.func_signature, &"{n.func_signature} ", "")
            let mdf = choose(n.func_mod, &" {n.func_mod.token.str} ", "")
            let bdy = choose(n.func_body, &" {n.func_body}", "")
            s = &"({sig}{s}{mdf}{bdy})"
        of ●arrayAccess
            let i = choose(n.array_index, &"{n.array_index}", "")
            s = &"({n.array_owner}[{i}])"
        of ●var
            let t = choose(n.var_type, &"{n.var_type}", "")
            let v = choose(n.var_value, &" (= {n.var_value})", "")
            s = &"({s}{t} {n.var_name}{v})"
        of ●let
            s = &"({s} {n.let_expr})"
        of ●type
            s = &"type({n.token.str})"
        of ●signature
            let a = choose(n.sig_args, &"{n.sig_args}", "")
            let t = choose(n.sig_type, &" ➜ {n.sig_type}", "")
            s = &"{a}{t}"
        of ●use
            let k = choose(n.use_kind, &" {n.use_kind.token.str}", "")
            let i = choose(n.use_items.len>0, &" {n.use_items}", "")
            s = &"({s} {n.use_module}{k}{i})"
        of ●testSuite
            let b = choose(n.test_block, &" {n.test_block}", "")
            s = &"({s} suite{b})"
        of ●testSection
            let b = choose(n.test_block, &" {n.test_block}", "")
            s = &"({s} section{b})"
        of ●testCase
            s = &"({n.test_value} {s} {n.test_expected})"
        else
            discard
    s

proc formatValue*(result:var string, n:Node,   specifier: string) = result.add $n
proc formatValue*(result:var string, p:Parser, specifier: string) = result.add $p
proc error(p: Parser, msg: string, token=Token(tok:◆eof)) : Node =

    styledEcho fgRed, styleDim, "△ ", resetStyle, fgYellow, msg
    if token.tok != ◆eof
        let line = p.text.split("\n")[token.line]
        styledEcho fgWhite, styleDim, &"{token.line}", resetStyle, fgGreen, &"{line}"
    elif p.tok != ◆eof
        let line = p.text.split("\n")[p.current.line]
        styledEcho fgWhite, styleDim, &"{p.current.line}", resetStyle, fgGreen, &"{line}"
        
    nil
    
#  ███████   ███████   ███   ███   ███████  ███   ███  ██     ██  ████████
# ███       ███   ███  ████  ███  ███       ███   ███  ███   ███  ███     
# ███       ███   ███  ███ █ ███  ███████   ███   ███  █████████  ███████ 
# ███       ███   ███  ███  ████       ███  ███   ███  ███ █ ███  ███     
#  ███████   ███████   ███   ███  ███████    ███████   ███   ███  ████████

proc consume(p: Parser): Token =

    let t = p.current
    if p.pos < p.tokens.len
        p.pos += 1
    t

proc swallow(p: Parser) =

    discard p.consume()

proc swallow(p: Parser, tok: tok) =

    if p.tok == tok
        p.swallow()
        
proc swallowError(p: Parser, tok: tok, err: string) = 

    if p.tok != tok
        discard p.error(&"Expected {tok} to swallow, but found {p.tok} instead")
        discard p.error(err)
        ⮐  
    p.swallow()
            
proc swallowSameIndent(p: Parser, indent:int): bool = 

    if p.tok == ◆indent and p.current.str.len == indent
        p.swallow()
        ⮐  true
    false
    
proc atIndent(p: Parser) : bool =

    p.current.col == 0 or p.peek(-1).tok == ◆indent
        
proc atEnd(p:Parser): bool = p.pos >= p.tokens.len

proc isDedent(p: Parser, indent:int): bool =

    if p.tok == ◆indent
        p.current.str.len < indent
    else
        p.current.col < indent
        
proc isNextLineIndented(p: Parser, token:Token): bool =

    var n = 0
    while p.peek(n).tok != ◆indent
        n += 1
        if p.peek(n).tok == ◆eof
            ⮐  false
        
    ⮐  p.peek(n).str.len > token.col
    
proc getPrecedence(p: Parser, token: Token): int =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].precedence
    0
    
proc rightHandSide(p: Parser, token: Token): RHS =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].rhs

proc leftHandSide(p: Parser, token: Token): LHS =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].lhs

proc expression(p: Parser, precedenceRight = 0): Node
    
proc expression(p: Parser, tokenRight:Token ): Node =

    expression(p, p.getPrecedence(tokenRight))

proc value(p: Parser) : Node = p.expression(-2)

# ███████    ███       ███████    ███████  ███   ███
# ███   ███  ███      ███   ███  ███       ███  ███ 
# ███████    ███      ███   ███  ███       ███████  
# ███   ███  ███      ███   ███  ███       ███  ███ 
# ███████    ███████   ███████    ███████  ███   ███

proc parseBlock(p:Parser, bn:Node=nil): Node =

    var token: Token
    var block_indent : int
    if p.tok == ◆indent
        token = p.consume() 
        block_indent = p.current.col
    
    var bn = bn
    if bn == nil
        bn = Node(token:token, kind:●block, expressions:default seq[Node])
        
    var expr : Node = p.expression()
    while expr != nil
    
        if expr.kind == ●func and bn.expressions.len
            var prevExpr = bn.expressions[^1]
            if prevExpr.token.line == expr.token.line and prevExpr.token.tok == ◆assign
                prevExpr = bn.expressions.pop()
                if prevExpr.operand_right.kind == ●operation
                    var varToken = prevExpr.operand_right.operand_left.token
                    varToken.tok = ◆val_type
                    let varNode = Node(token:varToken, kind:●var, var_name:prevExpr.operand_right.operand_left, var_value:prevExpr.operand_right.operand_right)
                    expr.func_signature.sig_args.list_values.unshift(varNode)
                else
                    expr.func_signature.sig_args.list_values.unshift(prevExpr.operand_right)
                prevExpr.operand_right = expr
                expr = prevExpr
                
        bn.expressions.add expr
        if p.tok == ◆indent
            let ind = p.current.str.len
            if ind < block_indent
                break
            elif ind > block_indent
                p.blocks.add bn
                expr = p.parseBlock()
                bn = p.blocks.pop()
                continue
            else
                p.swallow()
                
        if p.current.col < block_indent
            break
            
        expr = p.expression()
    bn
    
proc rBlock(p:Parser) : Node =

    p.parseBlock()
    
proc isTokAhead(p: Parser, tokAhead:tok) : bool =

    var n = 0
    var c = p.current
    let line = c.line
    while c.tok != ◆eof
        if c.line > line
            ⮐  false
        if c.tok == tokAhead
            ⮐  true
        n += 1
        c = p.peek n
    false    
    
proc parseCallArgList(p:Parser) : seq[Node] = 

    p.implicit = true
    p.listless = true
    var list : seq[Node]
    let line = p.current.line
    var expr : Node = p.expression()
    while expr != nil
        list.add expr        
        if p.current.line != line
            break
        if p.tok in {◆comment_start}
            break
        p.swallow ◆comma
        expr = p.expression()
    p.listless = false
    p.implicit = false
    list
    
proc lCall(p: Parser, callee: Node): Node =

    let token = p.consume() # (
    let args = p.parseCallArgList()
    p.swallowError(◆paren_close, "Missing closing paren for call arguments")    
    Node(token:token, kind:●call, callee:callee, callargs:args)
    
proc rSymbol(p: Parser): Node =

    let token = p.consume()
    let currt = p.peek(0)
    if not p.implicit and currt.tok notin {◆indent} and not p.isTokAhead(◆func)
        if currt.col > token.col+token.str.len
            const optoks= { ◆then, ◆else, ◆elif, ◆test,
                            ◆plus, ◆minus, ◆divide, ◆multiply, ◆and, ◆or, ◆ampersand, 
                            ◆equal, ◆not_equal, ◆greater_equal, ◆less_equal, ◆greater, ◆less,
                            ◆assign, ◆divide_assign, ◆multiply_assign, ◆plus_assign, ◆minus_assign}
            if currt.tok notin optoks
                let args = p.parseCallArgList()
                ⮐  Node(token:token, kind:●call, callee:Node(token:token, kind:●literal), callargs:args)

    Node(token:token, kind:●literal)
        
proc parseNames(p:Parser) : seq[Node] = 

    var list : seq[Node]
    let line = p.current.line
    p.implicit = true
    var expr : Node = p.rSymbol()
    while expr != nil
        list.add expr        
        if p.current.line != line
            break
        p.swallow ◆comma
        expr = p.rSymbol()
    p.implicit = false
    list

proc parseNamesUntil(p: Parser, stop: tok) : Node =

    let token = p.current
                                
    var list_values: seq[Node]
    p.implicit = true
    while p.tok != stop
        if p.tok == ◆eof
            ⮐  p.error("Missing 'in' for 'for' loop (eof detected)!", token)
        if p.current.line != token.line
            ⮐  p.error("Missing 'in' for 'for' loop (linebreak detected)!", token)
        list_values.add p.rSymbol()
        p.swallow ◆comma
    p.implicit = false
    if list_values.len == 1
        list_values[0]
    else
        Node(token:token, kind:●list, list_values:list_values)

proc parseModule(p:Parser) : Node = 

    let line = p.current.line
    var s = ""
    while p.current.str notin @["▪", "◆"]
        let e = p.current.col + p.current.str.len
        s &= p.consume().str
        if p.atEnd() or p.current.line != line
            break 
        if p.current.col > e and p.current.str notin @["▪", "◆"] 
            s &= " "
        
    Node(token:Token(str:s))
    
proc then(p: Parser) : Node = 

    if p.tok == ◆then
        p.swallow ◆then
        
    if p.tok == ◆indent
        p.parseBlock()
    else
        p.expression()

# ███  ████████
# ███  ███     
# ███  ██████  
# ███  ███     
# ███  ███     

proc rIf(p: Parser): Node =

    let token = p.consume() # if or when
    var condThens: seq[Node]

    let ifIndent = token.col
    var condIndt = ifIndent
    
    if p.tok == ◆indent
        condIndt = p.current.str.len
        if condIndt <= ifIndent
            ⮐  p.error "Expected indentation after 'if' without condition"
        p.swallow ◆indent # block indentation
    
    var cond = p.expression() # initial condition
            
    var then = p.then()
    
    condThens.add(Node(token:cond.token, kind:●condThen, cond:cond, then:then))
    
    while p.tok in {◆elif, ◆indent}
    
        if p.tok == ◆indent            
            if p.current.str.len < ifIndent
                break
            if ifIndent < condIndt 
                if p.current.str.len < condIndt
                    break
            if p.peek(1).tok != ◆elif and p.current.str.len == ifIndent
                break
            p.swallow ◆indent
            if p.tok == ◆comment_start
                p.swallow()
                p.swallow ◆comment
            if p.tok == ◆indent
                continue
                
        p.swallow(◆elif)
        if p.tok in {◆then, ◆else}
            break # then without condition -> else
        
        cond = p.expression()
        
        then = p.then()
        
        condThens.add(Node(token:cond.token, kind:●condThen, cond:cond, then:then))
        
    var elseBranch: Node
    
    p.swallow(◆indent)
    
    if p.tok in {◆else, ◆then}
        p.swallow() # else or then without condition
        elseBranch = p.expression()
    
    Node(token:token, kind:●if, cond_thens:condThens,`else`:elseBranch)

# █████████   ███████   ███  ███         ███  ████████
#    ███     ███   ███  ███  ███         ███  ███     
#    ███     █████████  ███  ███         ███  ██████  
#    ███     ███   ███  ███  ███         ███  ███     
#    ███     ███   ███  ███  ███████     ███  ███     

proc lTailIf(p: Parser, left: Node) : Node =

    if p.returning
        ⮐  
    if left.token.line != p.current.line
        ⮐  
    # log &"TAILIF {left} {left.token.line} {p.current.line}"
    let token = p.consume()
    var cond  = p.expression()
    let condThen = Node(token:cond.token, kind:●condThen, cond:cond, then:left)

    Node(token:token, kind:●if, cond_thens: @[condThen])
        
# ████████   ███████   ████████ 
# ███       ███   ███  ███   ███
# ██████    ███   ███  ███████  
# ███       ███   ███  ███   ███
# ███        ███████   ███   ███

proc rFor(p: Parser): Node = 

    let token = p.consume()
    let for_value = p.parseNamesUntil ◆in
    p.swallowError(◆in, "Expected 'in' after for value")
    let for_range = p.expression()
    let for_body  = p.then()

    Node(token:token, kind:●for, for_value:for_value, for_range:for_range, for_body:for_body)

proc rWhile(p: Parser): Node =

    Node(token:p.consume(), kind:●while, while_cond:p.expression(), while_body:p.then())

#  ███████  ███   ███  ███  █████████   ███████  ███   ███
# ███       ███ █ ███  ███     ███     ███       ███   ███
# ███████   █████████  ███     ███     ███       █████████
#      ███  ███   ███  ███     ███     ███       ███   ███
# ███████   ██     ██  ███     ███      ███████  ███   ███

proc switchCase(p: Parser, baseIndent: int): Node =

    var case_when: seq[Node]
    let token = p.current
    
    p.implicit = true
    while p.tok notin {◆else, ◆then, ◆indent, ◆eof}
        case_when.add p.value()
        p.swallow ◆comma
    p.implicit = false
    
    let case_then = p.then()
                
    if case_then == nil
        ⮐  p.error("Expected case body after match(es)", token)
    
    Node(token:token, kind:●switchCase, case_when:case_when, case_then:case_then)

proc rSwitch(p: Parser): auto =

    let token = p.consume()
    let switch_value = p.expression()
    
    if switch_value == nil
        ⮐  p.error("Expected value after switch keyword", token)
    
    let baseIndent = p.current.str.len 
    
    p.swallowError(◆indent, "Expected indentation after switch statement")
    
    var switch_cases: seq[Node]
    
    while p.tok notin {◆else, ◆then, ◆eof}
        if p.isDedent baseIndent
            break
        if p.tok == ◆indent and p.peek(1).tok == ◆then
            p.swallow() # indent followed by a ➜ is else
            break
        if p.swallowSameIndent baseIndent
            continue

        let switch_case = p.switchCase(baseIndent)
        if switch_case == nil
            ⮐  p.error("Failed to parse switch case", token)
        else
            switch_cases.add switch_case
    
    var switch_default: Node
    
    if p.tok in {◆else, ◆then}
        p.swallow()
        switch_default = 
            if p.tok == ◆indent and p.current.str.len > baseIndent
                p.swallow()
                p.expression()
            else
                p.expression()
        
        if switch_default == nil
            ⮐  p.error("Expected default value", token)
    
    Node(token:token, kind:●switch, switch_value:switch_value, switch_cases:switch_cases, switch_default:switch_default)
        
proc parseParenList(p: Parser): seq[Node] =

    let token = p.consume() # (
    
    var args : seq[Node]
    p.implicit = true
    while p.tok != ◆paren_close and p.tok != ◆eof
        args.add p.expression()
        p.swallow ◆comma
    p.swallowError(◆paren_close, "Missing closing parenthesis")
    p.implicit = false
    if args.len == 1 and args[0].kind == ●list
        ⮐  args[0].list_values
    args
    
proc parseDelimitedList(p: Parser, open:tok, close:tok): seq[Node] =

    let token = p.consume()
    
    var args : seq[Node]
    p.implicit = true
    while p.tok != close and p.tok != ◆eof
        args.add p.expression()
        p.swallow ◆comma
    p.swallowError(close, "Missing closing bracket")
    p.implicit = false
    if args.len == 1 and args[0].kind == ●list
        ⮐  args[0].list_values
    args
        
proc lArrayAccess(p: Parser, array_owner: Node): Node =

    let token = p.consume() # [
    if p.tok == ◆square_close
        p.swallow()
        Node(token:token, kind:●arrayAccess, array_owner:array_owner)
    else
        let array_index = p.expression()
        p.swallowError(◆square_close, "Missing closing square bracket for array access")
        
        Node(token:token, kind:●arrayAccess, array_owner:array_owner, array_index:array_index)

proc rLiteral(p: Parser): Node =

    Node(token:p.consume(), kind: ●literal)
    
proc lPropertyAccess(p: Parser, owner: Node): Node =

    Node(token:p.consume(), kind:●propertyAccess, owner:owner, property:p.rLiteral())

proc rKeyword(p: Parser): Node =

    Node(token:p.consume(), kind: ●keyword)
    
proc rImport(p: Parser): Node =

    Node(token:p.consume(), kind: ●import)
    
proc rLet(p: Parser): Node =

    Node(token:p.consume(), kind: ●let, let_expr:p.expression())
    
#  ███████  █████████  ████████   ███  ███   ███   ███████ 
# ███          ███     ███   ███  ███  ████  ███  ███      
# ███████      ███     ███████    ███  ███ █ ███  ███  ████
#      ███     ███     ███   ███  ███  ███  ████  ███   ███
# ███████      ███     ███   ███  ███  ███   ███   ███████ 

proc rString(p: Parser): Node =

    let token = p.consume() # string start

    if p.tok == ◆string_end
        p.swallow()
        Node(token:token, kind:●string, string_content:Node(token:Token(str:"", tok:◆string), kind:●literal))
    else
        var string_content : Node 
        if p.tok != ◆stripol_start
            string_content = Node(token:p.consume(), kind:●literal)
        else
            string_content = Node(token:Token(str:"", tok:◆string, line:p.current.line, col:p.current.col), kind:●literal)
        var string_stripols : seq[Node]
        while p.tok notin {◆string_end, ◆eof}
        
            p.swallowError(◆stripol_start, "Expected string interpolation start")
            
            var stripol = Node(token:p.current, kind:●stripol)
            
            var stripol_xprssns : seq[Node]
            while p.tok notin {◆stripol_end, ◆eof}
                let xpr = p.expression()
                stripol_xprssns.add xpr
                
            stripol.stripol_xprssns = stripol_xprssns
            
            p.swallowError(◆stripol_end, "Expected string interpolation end")
            if p.tok notin {◆string_end, ◆eof}
                stripol.stripol_content = Node(token:p.consume(), kind:●literal)
            
            string_stripols.add stripol
            
        p.swallowError(◆string_end, "Expected closing string delimiter")
        Node(token:token, kind:●string, string_content:string_content, string_stripols:string_stripols)

proc rUse(p: Parser): Node =

    let token = p.consume()
    let use_module = p.parseModule()
    if not p.atEnd() and p.current.line == token.line
        let use_kind = p.rSymbol()
        let use_items  = p.parseNames()
        Node(token:token, kind:●use, use_module:use_module, use_kind:use_kind, use_items:use_items) 
    else
        Node(token:token, kind:●use, use_module:use_module) 
        
proc rComment(p: Parser): Node = 

     Node(token:p.consume(), kind:●comment, comment_content:Node(token:p.consume()))

proc parseType(p: Parser): Node =
    
    var token = p.consume()
    token.tok = ◆type
    
    if p.tok == ◆square_open
        while p.tok notin {◆eof}
            let t = p.consume()
            token.str &= t.str
            if t.tok == ◆square_close
                break
    
    Node(token:token, kind:●type)
    
proc rReturnType(p: Parser): Node =

    Node(token:p.consume(), kind:●signature, sig_type:p.parseType())

proc lReturnType(p: Parser, left: Node): Node =

    if not p.isTokAhead(◆func)
        ⮐  

    if left.kind in {●list, ●var, ●operation}
        if left.kind == ●operation 
            if left.token.tok == ◆assign
                var sig = p.rReturnType()
                let vartoken = Token(tok:◆val_type, line:left.token.line, col:left.token.col)
                let varNode  = Node(token:vartoken, kind:●var, var_name:left.operand_left, var_value:left.operand_right)
                sig.sig_args = Node(token:left.token, kind:●list, list_values: @[varNode])
                ⮐  sig
        elif left.kind == ●list
            var sig = p.rReturnType()
            sig.sig_args = left
            ⮐  sig
        elif left.kind == ●var
            var sig = p.rReturnType()
            sig.sig_args = Node(token:left.token, kind:●list, list_values: @[left])
            ⮐  sig
                    
proc rVar(p: Parser) : Node =

    let token    = p.consume() # ◆ or ◇
    let var_type = p.parseType()
    let var_name = p.value()
    var var_value : Node
    
    if p.tok == ◆assign
        let t = p.consume() # =
        var_value = p.expression() 
    
    Node(token:token, kind:●var, var_type:var_type, var_name:var_name, var_value:var_value)

proc lSymbolList(p: Parser, left: Node) : Node =

    if p.listless
        ⮐  

    case left.kind 
        of ●list
            var list_values = left.list_values
            # todo: check if all list items are symbols?
            list_values.add p.rSymbol()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        of ●literal
            if left.token.tok != ◆name
                ⮐  
            var list_values : seq[Node]
            list_values.add left
            list_values.add p.rSymbol()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        else
            discard

proc lVarList(p: Parser, left: Node) : Node =
    
    case left.kind 
        of ●list
            var list_values = left.list_values
            list_values.add p.rVar()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        of ●var
            var list_values : seq[Node]
            list_values.add left
            list_values.add p.rVar()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        else
            ⮐  

# ████████  ███   ███  ███   ███   ███████
# ███       ███   ███  ████  ███  ███     
# ██████    ███   ███  ███ █ ███  ███     
# ███       ███   ███  ███  ████  ███     
# ███        ███████   ███   ███   ███████

proc lFunc(p: Parser, left: Node): Node =

    if left.kind notin {●signature, ●list, ●var, ●operation}
        ⮐ 
        
    var func_signature = left
    
    # log &"lFunc LEFT {left}"
    
    if left.kind == ●operation
        if left.token.tok != ◆assign
            ⮐  
        if left.operand_left.token.tok != ◆name
            ⮐  
        if left.operand_left.token.col == 0 
            var left = left
            let vartoken = Token(tok:◆val_type, line:left.operand_right.token.line,col:left.operand_right.token.col)
            left.operand_right = p.lFunc(Node(token:vartoken, kind:●var, var_name:left.operand_right))
            ⮐  left
            
        let vartoken = Token(tok:◆val_type, line:left.operand_left.token.line,col:left.operand_left.token.col)
        let varNode = Node(token:vartoken, kind:●var, var_name:left.operand_left, var_value:left.operand_right)
        let sig_args = Node(token:vartoken, kind:●list, list_values: @[varNode])
        func_signature = Node(token:left.token, kind:●signature, sig_args:sig_args)
        
    elif left.kind == ●list
        var sig_args = left
        for i,a in sig_args.list_values
            if a.kind == ●operation and a.token.tok == ◆assign
                let vartoken = Token(tok:◆val_type, line:a.operand_left.token.line,col:a.operand_left.token.col)
                sig_args.list_values[i] = Node(token:vartoken, kind:●var, var_name:a.operand_left, var_value:a.operand_right)
            elif a.kind == ●literal and a.token.tok == ◆name
                let vartoken = Token(tok:◆val_type, line:a.token.line,col:a.token.col)
                sig_args.list_values[i] = Node(token:vartoken, kind:●var, var_name:a)
        func_signature = Node(token:left.token, kind:●signature, sig_args:sig_args)
    elif left.kind == ●var
        let sig_args = Node(token:left.token, kind:●list, list_values: @[left])
        func_signature = Node(token:left.token, kind:●signature, sig_args:sig_args)
    
    let token = p.consume() # ->
    
    var func_mod : Node
    if p.tok == ◆mod
        func_mod = p.rLiteral
    
    let func_body = p.then()
    
    Node(token:token, kind:●func, func_signature:func_signature, func_mod:func_mod, func_body:func_body)

proc rFunc(p: Parser): Node =

    let token = p.consume() # ->
    
    var func_mod : Node
    if p.tok == ◆mod
        func_mod = p.rLiteral
    
    let func_body = p.then()
    
    Node(token:token, kind:●func, func_body:func_body)

proc isThenlessIf(p:Parser, token:Token) : bool =

    if p.isNextLineIndented token
        ⮐  false

    not p.isTokAhead ◆then

proc rReturn(p: Parser): Node =

    let token = p.consume()
    
    if p.tok == ◆if and p.isThenlessIf(token)
        Node(token:token, kind:●return)
    else
        p.returning = true
        let right = p.expression(token)
        p.returning = false
        Node(token:token, kind:●return, return_value:right)

proc rDiscard(p: Parser): Node =

    let token = p.consume()
    if p.isDedent token.col
        Node(token:token, kind:●discard)
    else
        let right = p.value()
        Node(token:token, kind:●discard, discard_value:right)

#  ███████   ████████   ████████  ████████    ███████   █████████  ███   ███████   ███   ███
# ███   ███  ███   ███  ███       ███   ███  ███   ███     ███     ███  ███   ███  ████  ███
# ███   ███  ████████   ███████   ███████    █████████     ███     ███  ███   ███  ███ █ ███
# ███   ███  ███        ███       ███   ███  ███   ███     ███     ███  ███   ███  ███  ████
#  ███████   ███        ████████  ███   ███  ███   ███     ███     ███   ███████   ███   ███

proc lOperation(p: Parser, left: Node): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind: ●operation, operand_left: left, operand_right:right)

proc lPostOp(p: Parser, left: Node): Node =

    Node(token:p.consume(), kind: ●postOp, operand:left)

proc rPreOp(p: Parser): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind:●preOp, operand:right)

proc lAssign(p: Parser, left: Node): Node =

    let token = p.consume()
    let right = p.expression(token)

    Node(token:token, kind: ●operation, operand_left: left, operand_right: right)

proc lRange(p: Parser, left: Node): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind: ●range, range_start: left, range_end: right)
        
proc rParenExpr(p: Parser): Node =

    Node(token:p.current, kind:●list, list_values:p.parseParenList())

proc rCurly(p: Parser): Node =

    Node(token:p.current, kind:●curly, list_values:p.parseDelimitedList(◆bracket_open, ◆bracket_close))

proc rSquarely(p: Parser): Node =

    Node(token:p.current, kind:●squarely, list_values:p.parseDelimitedList(◆square_open, ◆square_close))
    
proc lTestCase(p: Parser, left: Node): Node =

    let token = p.consume() # ▸
    p.swallow(◆indent) # todo: check if indent is larger than that of the test expression
    let right = p.expression()
    Node(token:token, kind: ●testCase, test_value:left, test_expected:right)

proc rTestSuite(p: Parser): Node =

    let token = p.consume() # ▸
    let test_block = p.then()
    if token.col == 0
        Node(token:token, kind:●testSuite, test_block:test_block)
    else
        Node(token:token, kind:●testSection, test_block:test_block)

# ████████  ███   ███  ████████   ████████   ████████   ███████   ███████  ███   ███████   ███   ███
# ███        ███ ███   ███   ███  ███   ███  ███       ███       ███       ███  ███   ███  ████  ███
# ███████     █████    ████████   ███████    ███████   ███████   ███████   ███  ███   ███  ███ █ ███
# ███        ███ ███   ███        ███   ███  ███            ███       ███  ███  ███   ███  ███  ████
# ████████  ███   ███  ███        ███   ███  ████████  ███████   ███████   ███   ███████   ███   ███

###
   ◆R      ◆LR     ◆L      ◆R      ◆L      ◆LR     ◆R 
   │       │       │       │       │       │ 
   ◆R➜●    │       │       ◆R➜●    │       │ 
      │    │       │          │    │       │
      ╰───●◆L➜●───●◆L➜●       ╰───●◆L➜●───●◆L➜●
                      │                       │
                      ▾                       ▾
###

proc expression(p: Parser, precedenceRight = 0): Node =

    let token = p.current
    if token.tok in {◆eof, ◆stripol_end, ◆paren_close}
        ⮐  nil
    
    let rhs = p.rightHandSide(token)
    
    if rhs == nil
    
        ⮐  p.error(&"Expected expression but found {token.str} {token}", token)
        
    var node: Node = rhs(p)

    if precedenceRight < -1
        ⮐  node

    while true
        
        let token = p.current
        var precedence = p.getPrecedence(token)
        
        if token.tok in {◆assign, ◆test}
            precedence += 1
        
        let lhs = p.leftHandSide(token)
        
        if precedenceRight >= precedence
            break
    
        if lhs == nil
            break
            
        let lhn = p.lhs(node)
        if lhn != nil
            node = lhn
        else
            break 
            
        if p.tok == ◆indent and p.peek(1).tok in {◆dot}
             p.swallow()
             node = p.lPropertyAccess node
    node
            
# ████████   ████████    ███████   █████████  █████████
# ███   ███  ███   ███  ███   ███     ███        ███   
# ████████   ███████    █████████     ███        ███   
# ███        ███   ███  ███   ███     ███        ███   
# ███        ███   ███  ███   ███     ███        ███   

proc pratt(p: Parser, t:tok, lhs:LHS, rhs:RHS, precedence:int) = 

    if p.pratts.len <= t.ord
        p.pratts.setLen(t.ord + 1)
    
    p.pratts[t.ord] = Pratt(lhs:lhs, rhs:rhs, precedence:precedence)

#  ███████  ████████  █████████  ███   ███  ████████ 
# ███       ███          ███     ███   ███  ███   ███
# ███████   ███████      ███     ███   ███  ████████ 
#      ███  ███          ███     ███   ███  ███      
# ███████   ████████     ███      ███████   ███      

proc setup(p: Parser) =

    p.pratt ◆true,              nil,               rLiteral,        0
    p.pratt ◆false,             nil,               rLiteral,        0
    p.pratt ◆mod,               nil,               rLiteral,        0
    p.pratt ◆null,              nil,               rLiteral,        0
    p.pratt ◆number,            nil,               rLiteral,        0
    p.pratt ◆string_start,      nil,               rString,         0
    p.pratt ◆comment_start,     nil,               rComment,        0
    p.pratt ◆name,              lSymbolList,       rSymbol,        13 # higher than assign
    p.pratt ◆import,            nil,               rImport,         0
    p.pratt ◆use,               nil,               rUse,            0
    p.pratt ◆let,               nil,               rLet,            0
    p.pratt ◆var,               nil,               rLet,            0
    p.pratt ◆return,            nil,               rReturn,         0
    p.pratt ◆discard,           nil,               rDiscard,        0
    p.pratt ◆indent,            nil,               rBlock,          0
    p.pratt ◆test,              lTestCase,         rTestSuite,      0
    
    p.pratt ◆continue,          nil,               rKeyword,        0
    p.pratt ◆break,             nil,               rKeyword,        0
                                                                    
    p.pratt ◆assign,            lAssign,           nil,            10
    p.pratt ◆plus_assign,       lAssign,           nil,            10
    p.pratt ◆minus_assign,      lAssign,           nil,            10
    p.pratt ◆divide_assign,     lAssign,           nil,            10
    p.pratt ◆multiply_assign,   lAssign,           nil,            10

    p.pratt ◆if,                lTailIf,           rIf,            20  
    p.pratt ◆when,              nil,               rIf,            20  
    p.pratt ◆for,               nil,               rFor,           20  
    p.pratt ◆switch,            nil,               rSwitch,        20  
    p.pratt ◆while,             nil,               rWhile,         20  
    p.pratt ◆func,              lFunc,             rFunc,          20
    
    p.pratt ◆or,                lOperation,        nil,            30 
    p.pratt ◆and,               lOperation,        nil,            31 
                                
    p.pratt ◆equal,             lOperation,        nil,            40
    p.pratt ◆not_equal,         lOperation,        nil,            40
    p.pratt ◆greater_equal,     lOperation,        nil,            40
    p.pratt ◆less_equal,        lOperation,        nil,            40
    p.pratt ◆less,              lOperation,        nil,            40
    p.pratt ◆greater,           lOperation,        nil,            40
    
    p.pratt ◆doubledot,         lRange,            nil,            40
    p.pratt ◆ampersand,         lOperation,        nil,            40
                                                   
    p.pratt ◆plus,              lOperation,        nil,            50
    p.pratt ◆minus,             lOperation,        rPreOp,         50
                                                   
    p.pratt ◆multiply,          lOperation,        nil,            60
    p.pratt ◆divide,            lOperation,        nil,            60

    p.pratt ◆not,               nil,               rPreOp,         70

    p.pratt ◆increment,         lPostOp,           nil,            80
    p.pratt ◆decrement,         lPostOp,           nil,            80

    p.pratt ◆square_open,       lArrayAccess,      rSquarely,      90
    p.pratt ◆paren_open,        lCall,             rParenExpr,     90
    p.pratt ◆bracket_open,      nil,               rCurly,         90
    p.pratt ◆then,              lReturnType,       rReturnType,    99
    p.pratt ◆val_type,          lVarList,          rVar,          100
    p.pratt ◆var_type,          lVarList,          rVar,          100
    p.pratt ◆dot,               lPropertyAccess,   nil,           102
    
#  ███████    ███████  █████████
# ███   ███  ███          ███   
# █████████  ███████      ███   
# ███   ███       ███     ███   
# ███   ███  ███████      ███   

proc ast*(text:string) : Node =

    let tokens = tokenize text
    var p = Parser(tokens:tokens, pos:0, text:text)
    p.setup()
    p.parseBlock()
    