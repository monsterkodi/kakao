#  ███████  ███       ███████   ███████
# ███       ███      ███       ███     
# ███       ███      ███████   ███████ 
# ███       ███           ███       ███
#  ███████  ███████  ███████   ███████ 

use pars

type NodeIt = proc(node:Node):Node

traverse = ◇Node n ◇NodeIt iter ➜ Node -> 

    ⮐  if n == nil
    
    n = n
    switch n.kind
        ●block
            for i e in n.expressions
                n.expressions.splice i 1 @[traverse(e iter)]
        ●literal
            n = iter n
        ●operation
            n.operand_left  = traverse n.operand_left  iter
            n.operand_right = traverse n.operand_right iter
        ●call
            n.callee = traverse n.callee    iter
            for i e in n.call_args
                n.call_args.splice i 1 @[traverse(e iter)]
        ●for
            n.for_body  = traverse n.for_body  iter
            n.for_range = traverse n.for_range iter
        ●if
            for i e in n.cond_thens
                n.cond_thens.splice i 1 @[traverse(e iter)]
            n.else_branch = traverse n.else_branch iter
        ●condThen
            n.condition   = traverse n.condition iter
            n.then_branch = traverse n.then_branch iter
        ●switch
            n.switch_value = traverse n.switch_value iter
            for i e in n.switch_cases
                n.switch_cases.splice i 1 @[traverse(e iter)]
            n.switch_default = traverse n.switch_default iter
        ●switchCase
            for i e in n.case_when
                n.case_when.splice i 1 @[traverse(e iter)]
            n.case_then = traverse n.case_then iter
        ●propertyAccess
            n.owner = traverse n.owner iter
        ●arrayAccess
            n.array_owner = traverse n.array_owner iter
            n.array_index = traverse n.array_index iter
        ●return
            n.return_value = traverse n.return_value iter
        ➜ 
            log "clss.traverse -- unhandled #{n.kind}"
    n

methodify = ◇Node clss ➜ seq[Node] ->
    
    isMethod = ◇Node it ➜bool -> it.kind == ●member and it.member_value.kind == ●func
    
    (funcs members) = pullIf(clss.class_body.expressions isMethod)

    clss.class_body.expressions = members
    
    className = clss.class_name.token.str
    if className[^1] == '*'
        className = className[0..^2]
    
    thisify = ◇Node n ➜ Node -> 
        if n.token.tok == ◂name and n.token.str[0] == '@'
            owner    = nod ●literal tkn(◂name "this")
            property = nod ●literal tkn(◂name n.token.str[1..^1])
            ⮐  nod ●propertyAccess  tkn(◂dot  ".") owner property
        n
    
    convert = ◇Node it ➜ Node -> 
        token = tkn(◂assign it.token.line it.token.col)
        funcn = it.member_value
        arg_type = nod ●type    tkn(◂val_type className)
        arg_name = nod ●literal tkn(◂name "this")
        this_arg = nod ●arg     tkn(◂type) arg_type arg_name
        if funcn.func_signature
            funcn.func_signature.sig_args.list_values.unshift this_arg
        else
            sig_args = nod ●list tkn(◂square_open) @[this_arg]
            funcn.func_signature = nod ●signature tkn() sig_args nil
            
        funcn.func_body = traverse funcn.func_body thisify
        nod ●operation token it.member_key funcn

    methods = funcs.map convert
    
    methods

classify* = ◇Node body ➜Node ->

    if body == nil or body.kind != ●block or body.expressions.len == 0
        ⮐  body 

    for i e in body.expressions
    
        if e.kind == ●class
        
            methods = methodify e
            body.expressions.insert methods i+1

    body