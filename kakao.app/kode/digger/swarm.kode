###
 0000000  000   000   0000000   00000000   00     00
000       000 0 000  000   000  000   000  000   000
0000000   000000000  000000000  0000000    000000000
     000  000   000  000   000  000   000  000 0 000
0000000   00     00  000   000  000   000  000   000
###

import * as three from 'three'

use ./lib/geom

function Swarm

    @: @scene ->
        
        @count = 1000
        cylinder = geom.cylinder length:4 radius:0.5 sgmt:6 material:'flatwhite'
        @dummy = new three.Object3D()
        @color = new three.Color()
        @pos   = new three.Vector3()
        @norm  = new three.Vector3()
        @rot   = new three.Quaternion()
        @scale = new three.Vector3()
        @mesh = new three.InstancedMesh(cylinder.geometry cylinder.material @count)
        @mesh.instanceMatrix.setUsage three.StaticDrawUsage
        @mesh.castShadow = true
        @scene.scene.add @mesh
        
    spawn: num ->
        
        i = 0
        while i < num
            
            @scene.sampler.sample @pos @norm
            @pos.multiplyScalar 50
            # log @pos @norm
            if @pos.length() < 40
                continue
                
            # @dummy.position.set Math.random()-0.5 Math.random()-0.5 Math.random()-0.5
            # @dummy.position.normalize()
            # @dummy.position.multiplyScalar 40
            @dummy.position.copy @pos
            
            @pos.normalize()
            # log @norm.dot(@pos)
            if @norm.dot(@pos) < 0.7
                continue
                
            @norm.multiplyScalar -1
            @norm.add @dummy.position
            
            color = @scene.mc.getColor parseInt(@dummy.position.x+@scene.resolution/2) parseInt(@dummy.position.y+@scene.resolution/2) parseInt(@dummy.position.z+@scene.resolution/2)
            if Math.random() < color[0]*50 + color[2]*50
            # if true
                # @dummy.lookAt (Math.random()-0.5)*8 (Math.random()-0.5)*8 (Math.random()-0.5)*8
                @dummy.lookAt @norm
                @dummy.scale.set 1 1 color[0]*150
                @dummy.updateMatrix()
                @mesh.setMatrixAt i @dummy.matrix
                @color.set color[0]*5 color[1]*5 color[2]*5
                @mesh.setColorAt i @color
                i++
        
        @mesh.instanceMatrix.needsUpdate = true
        @mesh.instanceColor.needsUpdate = true
        
    update: deltaSec tickInfo ->
        
        for i in 0...@count
            
            @mesh.getMatrixAt i @dummy.matrix
            @dummy.matrix.decompose @pos @rot @scale
            color = @scene.mc.getColor parseInt(@pos.x+@scene.resolution/2) parseInt(@pos.y+@scene.resolution/2) parseInt(@pos.z+@scene.resolution/2)
            @color.set color[0] color[1] color[2]
            f = (Math.sin(tickInfo.time/(2000-(color[0]+color[2])*900))+1.2)*2
            @color.multiplyScalar f
            @mesh.setColorAt i @color
            @scale.set 1 1 color[0]*(50+(f-2.4)*10)
            # @scale.set 1 1 color[0]*(10+(f-2.4)*2)
            @dummy.matrix.compose @pos @rot @scale
            @mesh.setMatrixAt i @dummy.matrix

        @mesh.instanceMatrix.needsUpdate = true
        @mesh.instanceColor.needsUpdate = true
            
export Swarm
