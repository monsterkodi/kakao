###
     ███████  █████████   ███████   █████████  ████████  
    ███          ███     ███   ███     ███     ███       
    ███████      ███     █████████     ███     ███████   
         ███     ███     ███   ███     ███     ███       
    ███████      ███     ███   ███     ███     ████████  

    handles basic text editing for the editor
    wraps text and editor state like cursors and selections 
        in an immutable to simplify undo
    delegates almost all text manipulation to pure functions
        in tool▸belt to simplify testing
###

use util.syntax

class state extends events

    @: cells name ->
    
        @cells = cells
        @name  = name & '.state'

        @allowedModes = {}

        @syntax   = syntax @name & '.syntax'
        @hasFocus = false

        @clearSingle()
        
    $: -> @name

    handleKey: key event ->
    
        ⮐  if 'unhandled' != mode.handleKey(@ key event)
        
        switch key                  
                         
            'up'                                ➜ ⮐  @moveCursors 'up'   
            'down'                              ➜ ⮐  @moveCursors 'down' 
            'left'                              ➜ ⮐  @moveCursors 'left' 
            'right'                             ➜ ⮐  @moveCursors 'right'
                                                     
            'ctrl+alt+up'                       ➜ ⮐  @singleCursorPage 'up'  
            'ctrl+alt+down'                     ➜ ⮐  @singleCursorPage 'down'
            'shift+ctrl+alt+up'                 ➜ ⮐  @moveCursors 'up'    {count:16}
            'shift+ctrl+alt+down'               ➜ ⮐  @moveCursors 'down'  {count:16}
                                                     
            'cmd+left'  'ctrl+left'             ➜ ⮐  @moveCursors ['bos' 'ind_bol']
            'cmd+right' 'ctrl+right'            ➜ ⮐  @moveCursors ['eos' 'ind_eol']
                                                     
            'alt+left'                          ➜ ⮐  @moveCursors 'left'  {jump:['ws' 'word' 'empty' 'punct']}
            'alt+right'                         ➜ ⮐  @moveCursors 'right' {jump:['ws' 'word' 'empty' 'punct']}
                                                     
            'shift+alt+right'                   ➜ ⮐  @moveCursorsAndSelect 'right' {jump:['ws' 'word' 'empty' 'punct']}
            'shift+alt+left'                    ➜ ⮐  @moveCursorsAndSelect 'left'  {jump:['ws' 'word' 'empty' 'punct']}
            'shift+up'                          ➜ ⮐  @moveCursorsAndSelect 'up'
            'shift+down'                        ➜ ⮐  @moveCursorsAndSelect 'down'
            'shift+left'                        ➜ ⮐  @moveCursorsAndSelect 'left'
            'shift+right'                       ➜ ⮐  @moveCursorsAndSelect 'right'
            'shift+cmd+right'                   ➜ ⮐  @moveCursorsAndSelect 'ind_eol'
            'shift+cmd+left'                    ➜ ⮐  @moveCursorsAndSelect 'ind_bol'
            'shift+ctrl+h'                      ➜ ⮐  @moveCursorsAndSelect 'bof'
            'shift+ctrl+j'                      ➜ ⮐  @moveCursorsAndSelect 'eof'
                                                     
            'shift+alt+cmd+up'                  ➜ ⮐  @moveMainCursorInDirection 'up'    {keep:true} # 'paint' cursors
            'shift+alt+cmd+down'                ➜ ⮐  @moveMainCursorInDirection 'down'  {keep:true} # 'paint' cursors
            'shift+alt+cmd+left'                ➜ ⮐  @moveMainCursorInDirection 'left'  {keep:true} # 'paint' cursors
            'shift+alt+cmd+right'               ➜ ⮐  @moveMainCursorInDirection 'right' {keep:true} # 'paint' cursors
                                                     
            'alt+up'                            ➜ ⮐  @moveSelectionOrCursorLines 'up'
            'alt+down'                          ➜ ⮐  @moveSelectionOrCursorLines 'down'
            'shift+alt+up'                      ➜ ⮐  @cloneSelectionAndCursorLines 'up'
            'shift+alt+down'                    ➜ ⮐  @cloneSelectionAndCursorLines 'down'
                                                     
            'cmd+up'   'ctrl+up'                ➜ ⮐  @expandCursors   'up'
            'cmd+down' 'ctrl+down'              ➜ ⮐  @expandCursors   'down'
            'shift+cmd+up'   'shift+ctrl+up'    ➜ ⮐  @contractCursors 'up'
            'shift+cmd+down' 'shift+ctrl+down'  ➜ ⮐  @contractCursors 'down'
                                                     
            'pageup'                            ➜ ⮐  @singleCursorPage 'up'
            'pagedown'                          ➜ ⮐  @singleCursorPage 'down'
                                                     
            'home'                              ➜ ⮐  @singleCursorAtIndentOrStartOfLine()
            'end'                               ➜ ⮐  @singleCursorAtEndOfLine()
                                                     
            'ctrl+h'                            ➜ ⮐  @setMainCursor 1 1
            'ctrl+j'                            ➜ ⮐  @setMainCursor @s.lines[@s.lines∙len()]∙len() @s.lines∙len()
                                                     
            'alt+d'                             ➜ ⮐  @delete 'next' true
            'shift+ctrl+k' 'entf'               ➜ ⮐  @delete 'next'
            'ctrl+k'                            ➜ ⮐  @delete 'eol'
            'delete'                            ➜ ⮐  @delete 'back'
            'ctrl+delete'                       ➜ ⮐  @delete 'back' true
            'cmd+delete'                        ➜ ⮐  @delete 'back' true
                                                     
            'shift+tab'                         ➜ ⮐  @deindentSelectedOrCursorLines()
            'tab'                               ➜ ⮐  @insert '\t'
                                                     
            'alt+x' 'cmd+x' 'ctrl+x'            ➜ ⮐  @cut()     
            'alt+c' 'cmd+c' 'ctrl+c'            ➜ ⮐  @copy()        
            'alt+v' 'cmd+v' 'ctrl+v'            ➜ ⮐  @paste()
                                                     
            'cmd+z' 'ctrl+z'                    ➜ ⮐  @undo()
            'shift+cmd+z'                            
            'cmd+y' 'ctrl+y'                    ➜ ⮐  @redo()
                                                     
            'cmd+a'       'ctrl+a'              ➜ ⮐  @selectAllLines()
            'cmd+j'       'ctrl+j'              ➜ ⮐  @joinLines()
            'cmd+l'       'ctrl+l'              ➜ ⮐  @selectMoreLines()
            'shift+cmd+l' 'shift+ctrl+l'        ➜ ⮐  @selectLessLines()
                                                     
            'cmd+e' 'ctrl+e'                    ➜ ⮐  @highlightWordAtCursor_deselectCursorHighlight_moveCursorToNextHighlight()
            'cmd+d' 'ctrl+d'                    ➜ ⮐  @selectWordAtCursor_highlightSelection_addNextHighlightToSelection()
            'cmd+g' 'ctrl+g'                    ➜ ⮐  @selectWordAtCursor_highlightSelection_selectNextHighlight()
                                                     
            'shift+cmd+e' 'shift+ctrl+e'        ➜ ⮐  @highlightWordAtCursor_deselectCursorHighlight_moveCursorToPrevHighlight()
            'shift+cmd+d' 'shift+ctrl+d'        ➜ ⮐  @selectWordAtCursor_highlightSelection_addPrevHighlightToSelection()
            'shift+cmd+g' 'shift+ctrl+g'        ➜ ⮐  @selectWordAtCursor_highlightSelection_selectPrevHighlight()
                                                     
            'alt+y'                             ➜ ⮐  @toggleMode 'unype'
            'alt+r'                             ➜ ⮐  @toggleMode 'record'
            'alt+u'                             ➜ ⮐  @toggleMode 'uniko'
            'alt+;'                             ➜ ⮐  @toggleMode 'vimple'
            'alt+3'                             ➜ ⮐  @toggleMode 'salter'
                                                     
            'cmd+3' 'ctrl+3'                    ➜ ⮐  @insertAsciiHeaderForSelectionOrWordAtCursor()
            'alt+cmd+d' 'alt+ctrl+d'            ➜ ⮐  @selectWordAtCursor_highlightSelection_selectAllHighlights()
                                                     
            'cmd+/' 'ctrl+/'                    ➜ ⮐  @toggleCommentAtSelectionOrCursorLines()
            'alt+cmd+/' 'ctrl+alt+/'            ➜ ⮐  @toggleCommentTypeAtSelectionOrCursorLines()
                                                     
            'esc'                               ➜ ⮐  @clearCursorsHighlightsAndSelections()
        
        'unhandled'

    toggleMode: name -> mode.toggle(@ name) if @allowedModes[name]
    startMode:  name -> mode.start(@ name) if @allowedModes[name]
    stopMode:   name -> mode.stop(@ name) if @allowedModes[name]
        
    owner: -> 
        
        if kstr.endsWith @name '.state'
            string.sub @name 1 -6
        else
            @name
        
    clearHistory: ->
    
        @h = [@s] # undo states (history)
        @r = []   # redo states

    #  0000000  00000000  000000000
    # 000       000          000
    # 0000000   0000000      000
    #      000  000          000
    # 0000000   00000000     000

    set: item arg ->

        @s = @s∙set item arg
        @swapState()
        @

    setSelections: selections -> 
    
        sels = belt.mergeLineRanges(@s.lines selections)
        @set "selections" sels
        
    setHighlights: highlights -> @set 'highlights' belt.normalizeSpans(highlights)

    #  0000000  000   000  00000000    0000000   0000000   00000000    0000000
    # 000       000   000  000   000  000       000   000  000   000  000
    # 000       000   000  0000000    0000000   000   000  0000000    0000000
    # 000       000   000  000   000       000  000   000  000   000       000
    #  0000000   0000000   000   000  0000000    0000000   000   000  0000000

    setCursors: cursors opt ->
        
        opt ?= {}
        opt.mc ?= @mainCursor()
        
        main = opt.main

        if empty cursors 
            log "empty cursors?" cursors
            cursors = [[1 1]]

        if main is "table" ➜ main = belt.indexOfPosInPositions main cursors
        if main is "number" and main < 0 ➜ main = cursors∙len()+main-1

        mc = @mainCursor()
        
        if main and main > 0
            mc = cursors[clamp(1 cursors∙len() main)]

        cursors = belt.normalizePositions cursors @s.lines∙len()
        
        @s = @s∙set 'cursors' cursors

        main = -1
        for idx cur in cursors
            if cur∙eql mc
                main = idx
                break

        if main < 1 ➜ main = @s.main 
        main = clamp 1 @s.cursors∙len() main

        @s = @s∙set 'main' main
        
        @adjustViewForMainCursor opt
        
        @swapState()
        
        mode.cursorsSet @
        @emit 'cursorsSet'
        # log 'cursorsSet' @s.cursors, @s.main
        @
            
    textOfSelectionOrWordAtCursor: -> 
        
        if @s.selections∙len()
            ⮐  @textOfSelection()
        else
            ⮐  @wordAtCursor()

    # 000      000  000   000  00000000   0000000
    # 000      000  0000  000  000       000
    # 000      000  000 0 000  0000000   0000000
    # 000      000  000  0000  000            000
    # 0000000  000  000   000  00000000  0000000

    setLines: lines ->
        
        if empty lines ➜ lines = ['']
        # write ◌y "state.setLines lines " ◌c " " (lines.class or "nil")  ◌b " " lines.len or lines∙len() ◌m " lines " array.str(lines)
        segls = kseg.segls(lines)
        # write ◌y "state.setLines segls " ◌m segls
        @setSegls segls
        
    setSegls: segls ->
    
        @segls = segls
        
        if empty @segls ➜ @segls = [[]]
        
        @syntax∙setSegls @segls
        
        @changeLinesSegls()
        
        @r = []
        
        @maxLineWidth = belt.widthOfLines @s.lines
        
        @pushState()
        
    loadLines: lines -> 
    
        if valid(lines) and not (lines[1] is "string")
            error "#{@name}.loadLines - first line not a string? #{type(lines[1])}" 
        
        @loadSegls kseg.segls(lines)
    
    loadSegls: segls ->

        @clearEmpty()
        @setSegls segls

    # clearSingle: -> @clearSegls [[]]
    clearSingle: -> @clearSegls kseg.segls("")
    clearEmpty:  -> @clearSegls [  ]
    clearSegls: segls ->
    
        @segls = segls

        @s = immutable {
            lines:       @segls
            selections:  []
            highlights:  []
            cursors:     [[1 1]]
            main:        1
            view:        [1 1]
            }
            
        @syntax∙clear()
        
        @h = []
        @r = []
        
    addLine: line ext ->

        segl = kseg line
        @syntax.addSegl segl ext
        @segls ?= []
        @segls∙push segl

        @changeLinesSegls()
        
    appendLines: lines ext ->

        segls = kseg.segls lines
        @syntax.appendSegls segls ext
        @segls ?= []
        @segls = @segls.concat segls

        @changeLinesSegls()
        
    #  ███████  ███   ███   ███████   ███   ███   ███████   ████████        ███      ███  ███   ███  ████████   ███████
    # ███       ███   ███  ███   ███  ████  ███  ███        ███             ███      ███  ████  ███  ███       ███     
    # ███       █████████  █████████  ███ █ ███  ███  ████  ███████         ███      ███  ███ █ ███  ███████   ███████ 
    # ███       ███   ███  ███   ███  ███  ████  ███   ███  ███             ███      ███  ███  ████  ███            ███
    #  ███████  ███   ███  ███   ███  ███   ███   ███████   ████████        ███████  ███  ███   ███  ████████  ███████ 

    changeLinesSegls: ->
    
         # oldLines = @s.lines
         
         # write "--- changeLinesSegls #{@s.class} #{@s}"
         # write ◌m "--> " @segls
         
         @s = @s∙set 'lines' @segls
         
         # write "<-> changeLinesSegls #{@s}"
         
         # @s.lines = @segls
         #
         # if oldLines != @s.lines
         #    diff = belt.diffLines oldLines @s.lines            
         #    @emit 'lines.changed' diff

    linesInView: -> @s.lines∙slice(@s.view[1] @s.view[1]+@cells.rows)

    clearLines: ->

        @setSegls [[]]
        @setMainCursor 1 1

    isValidLineIndex:   li -> 1 <= li and li <= @s.lines∙len()
    isInvalidLineIndex: li -> not @isValidLineIndex li

    # 000   000  000   000  0000000     0000000
    # 000   000  0000  000  000   000  000   000
    # 000   000  000 0 000  000   000  000   000
    # 000   000  000  0000  000   000  000   000
    #  0000000   000   000  0000000     0000000

    undo: ->

        ⮐  if @h.len <= 1
        @r∙push @h∙pop()
        @s = @h[^1]
        @syntax∙setSegls @s.lines

    redo: ->

        ⮐  if empty @r
        @h∙push @r∙pop()
        @s = @h[^1]
        @syntax.setSegls @s.lines

    begin: -> @beginIndex = @h.len

    ende: ->

        if valid @beginIndex

            @h∙splice @beginIndex @h.len-@beginIndex-1
            @beginIndex = nil
        @

    pushState: -> 
        @h∙push @s  
        @
        
    swapState: -> 
    
        @h∙pop()  
        @pushState()

    isDirty: -> @h.len > 1
    hasRedo: -> @r.len > 0

    gutterWidth: -> max 4 2 + ceil(math.log10(@s.lines∙len()+1))

    #  0000000  000   000  000000000
    # 000       000   000     000
    # 000       000   000     000
    # 000       000   000     000
    #  0000000   0000000      000

    cut: ->

        @copy {deselect:false}
        if empty @s.selections
            @selectCursorLines()
        @deleteSelection()

    #  0000000   0000000   00000000   000   000
    # 000       000   000  000   000   000 000
    # 000       000   000  00000000     00000
    # 000       000   000  000           000
    #  0000000   0000000   000           000

    copy: opt ->
    
        opt ?= {}
        text = @textOfSelectionOrCursorLines()
        if text and text.len > 0
            log "COPY" text
            love.system.setClipboardText text

        #switch os.platform()
        #
        #    'darwin'
        #
        #        prcs = child_process.spawn 'pbcopy'
        #        prcs.stdin.write @textOfSelectionOrCursorLines()
        #        prcs.stdin.close()
        #
        #    'linux'
        #
        #        prcs = child_process.spawn("xsel", {"-i", "--clipboard"})
        #        prcs.stdin.write @textOfSelectionOrCursorLines()
        #        prcs.stdin.close()
        #
        #    'win32'
        #
        #        prcs = child_process.spawn "#{slash.cwd()}/../../bin/utf8clip.exe"
        #        prcs.stdin.write @textOfSelectionOrCursorLines()
        #        prcs.stdin.close()
                
        @deselect() if opt.deselect != false

    # 00000000    0000000    0000000  000000000  00000000
    # 000   000  000   000  000          000     000
    # 00000000   000000000  0000000      000     0000000
    # 000        000   000       000     000     000
    # 000        000   000  0000000      000     00000000

    paste: ->
    
        @insert love.system.getClipboardText()

        #switch os.platform()
        #
        #    'darwin'
        #
        #        @insert child_process.execSync('pbpaste').toString("utf8")
        #
        #    'linux'
        #
        #        text = child_process.execSync('xsel -o --clipboard')
        #
        #        log 'paste\n' noon(text.toString("utf8"))
        #
        #        @insert text.toString("utf8")
        #
        #    'win32'
        #
        #        @insert child_process.execSync("#{slash.cwd()}/../../bin/utf8clip.exe").toString("utf8")

    #  0000000   0000000  00000000    0000000   000      000          000   000  000  00000000  000   000  
    # 000       000       000   000  000   000  000      000          000   000  000  000       000 0 000  
    # 0000000   000       0000000    000   000  000      000           000 000   000  0000000   000000000  
    #      000  000       000   000  000   000  000      000             000     000  000       000   000  
    # 0000000    0000000  000   000   0000000   0000000  0000000          0      000  00000000  00     00  

    scrollView: dir steps=1 ->

        sx = 1 
        sy = 1

        switch dir
            'left'  ➜ sx = -1
            'right' ➜ sx =  1
            'up'    ➜ sy = -steps
            'down'  ➜ sy =  steps

        view = @s.view∙arr()

        view[1] += sx
        view[2] += sy

        view[2] = clamp 1 max(1 @s.lines∙len()-@cells.rows) view[2]

        maxOffsetX = max 1 @maxLineWidth-@cells.cols+2
        maxOffsetX = max maxOffsetX @mainCursor()[1]-@cells.cols+2
        view[1] = clamp 1 maxOffsetX view[1]
        
        ⮐  if view∙eql @s.view

        log "SETVIEW SCROLLVIEW" view
        @setView view

    #  0000000   0000000          000  000   000   0000000  000000000       000   000  000  00000000  000   000  
    # 000   000  000   000        000  000   000  000          000          000   000  000  000       000 0 000  
    # 000000000  000   000        000  000   000  0000000      000           000 000   000  0000000   000000000  
    # 000   000  000   000  000   000  000   000       000     000             000     000  000       000   000  
    # 000   000  0000000     0000000    0000000   0000000      000              0      000  00000000  00     00  
    
    adjustViewForMainCursor: opt ->
        
        opt ?= {}
        
        ⮐  if @cells.cols < 1 or @cells.rows < 1
        
        ⮐  if opt.adjust == false

        mc = @mainCursor()
        x = mc[1]
        y = mc[2]

        view = @s.view∙arr()

        topBotDelta = 7
        topDelta = 7
        botDelta = max topDelta floor(@cells.rows/2)
        
        if opt.adjust == 'topDelta'
            
            view[2] = y - topDelta
            
        elif opt.adjust == 'topBotDeltaGrow' and opt.mc
        
            dtt = y-view[2]
            dtb = y-view[2]-@cells.rows-1
            if dtt < 0 
                view[2] = y - topDelta
            elif dtb > 0
                view[2] = y - (@cells.rows-botDelta)
            else
                dir = y - opt.mc[2]
                if dtt < topDelta and dir < 0  or -dtb < botDelta and dir > 0
                    view[2] += dir
        else        
            if opt.adjust != 'topBotDelta'
                topBotDelta = 0
    
            if y >= view[2] + @cells.rows - 1 - topBotDelta
                view[2] = y - @cells.rows + 1 + topBotDelta
            elif y < view[2] + topBotDelta
                view[2] = y - topBotDelta

        if view[2] > 1 and @s.lines∙len() <= @cells.rows
            view[2] = 1

        if not @skipAdjustViewForMainCursor
            view[1] = math.max 1 x - @cells.cols + 2 # adding one for wide graphemes
        
        ⮐  if view∙eql @s.view

        @setView view

    initView: ->

        view = @s.view∙arr()
        
        view[2] = clamp 1 max(1 @s.lines∙len()-@cells.rows+1) view[2]
        view[1] = max 1 view[1] or 1

        @setView view

    setView: view ->
        
        ⮐  if @s.view[1] == view[1] and @s.view[2] == view[2]

        @set 'view' view
        @emit 'view.changed' @s.view
        @

    rangeForVisibleLines: ->

        [@s.view[1] @s.view[2] @s.view[1]+@cells.cols-1 @s.view[2]+@cells.rows-1]

    setMain: m -> 
    
        mc = @mainCursor()
        @s = @s∙set 'main' clamp(1 @s.cursors∙len() m)
        @adjustViewForMainCursor {adjust:'topBotDeltaGrow' mc:mc}
        
    mainCursor: ->
     
        if @s.main < 1 or @s.main > @s.cursors∙len() 
            write ◌r "wrong mainCursor! " ◌m " main " @s.main ◌b " cursors " @s.cursors∙len() 
            ⮐  [1 1]
        mc = @s.cursors[@s.main]∙mut()
        if not mc
            write ◌r "no mainCursor!"
            # error "no mainCursor!"
            ⮐  [1 1]
        mc
    
    #  ███████  ████████  █████████
    # ███       ███          ███   
    # ███████   ███████      ███   
    #      ███  ███          ███   
    # ███████   ████████     ███   

    setMainCursor: x y ->

        (x y) = belt.pos x y
        y = clamp 1 @s.lines∙len() y
        x = max 1 x
        @setCursors [[x y]]
        
    # ██     ██   ███████   ███   ███  ████████
    # ███   ███  ███   ███  ███   ███  ███     
    # █████████  ███   ███   ███ ███   ███████ 
    # ███ █ ███  ███   ███     ███     ███     
    # ███   ███   ███████       █      ████████

    moveMainCursorInDirection: dir opt={} ->
        
        mc = belt.positionInDirection @mainCursor() dir
        
        if opt.keep
            @addCursor mc
        else
            @moveMainCursor mc
                        
    moveMainCursor: x y ->
                
        (x y) = belt.pos x y
        
        y = clamp 1 @s.lines∙len() y
        x = max 1 x
        
        mainCursor = @mainCursor()
        
        ⮐  if mainCursor == [x y]

        cursors = @allCursors()

        cursors∙splice belt.indexOfPosInPositions(mainCursor cursors) 1
        
        main = belt.indexOfPosInPositions [x y] cursors
        if main < 1
            cursors∙push [x y]
            main = cursors.len
        
        @setCursors cursors {main:main}
                
    # ████████   ███████    ███    
    # ███       ███   ███   ███    
    # ███████   ███   ███   ███    
    # ███       ███   ███   ███    
    # ████████   ███████    ███████

    singleCursorAtEndOfLine: ->
        
        rng = belt.lineRangeAtPos @s.lines @mainCursor()
        mc  = belt.endOfRange rng
        
        @deselect()
        @setCursors [mc]
        
    # ███  ███   ███  ███████            ███████     ███████   ███      
    # ███  ████  ███  ███   ███          ███   ███  ███   ███  ███      
    # ███  ███ █ ███  ███   ███          ███████    ███   ███  ███      
    # ███  ███  ████  ███   ███          ███   ███  ███   ███  ███      
    # ███  ███   ███  ███████    ██████  ███████     ███████   ███████  

    singleCursorAtIndentOrStartOfLine: ->
        
        lines = @s.lines
        mc    = @mainCursor()
        
        rng   = belt.lineRangeAtPos  lines mc
        ind   = belt.lineIndentAtPos lines mc
        
        if ind < mc[1]
            mc[1] = ind
        else
            mc  = belt.startOfRange rng
        
        @deselect()
        @setCursors [mc]

    # ████████    ███████    ███████   ████████
    # ███   ███  ███   ███  ███        ███     
    # ████████   █████████  ███  ████  ███████ 
    # ███        ███   ███  ███   ███  ███     
    # ███        ███   ███   ███████   ████████

    singleCursorPage: dir ->

        mc = @mainCursor()
        
        switch dir
            'up'   ➜  mc[2] -= @cells.rows
            'down' ➜  mc[2] += @cells.rows

        @deselect()
        @setCursors [mc]
                                    
    wordAtCursor:      -> belt.wordAtPos      @s.lines @mainCursor()
    chunkBeforeCursor: -> belt.chunkBeforePos @s.lines @mainCursor()
    chunkAfterCursor:  -> belt.chunkAfterPos  @s.lines @mainCursor()
        
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    setMainCursorAndSelect: x y ->
        
        @setSelections belt.extendLineRangesFromPositionToPosition @s.lines @allSelections() @mainCursor() [x y]
        @setCursors [[x y]] {adjust:'topBotDelta'}

    #  0000000   000      000      
    # 000   000  000      000      
    # 000000000  000      000      
    # 000   000  000      000      
    # 000   000  0000000  0000000  
    
    allCursors: -> 

        @s.cursors∙arr()
    
    # 00000000  000   000  00000000    0000000   000   000  0000000    
    # 000        000 000   000   000  000   000  0000  000  000   000  
    # 0000000     00000    00000000   000000000  000 0 000  000   000  
    # 000        000 000   000        000   000  000  0000  000   000  
    # 00000000  000   000  000        000   000  000   000  0000000    
    
    expandCursors: dir ->
        
        cursors = @allCursors()
        dy = if dir == 'up' ➜ -1 ➜ 1
        
        newCursors = []
        for c in cursors
            newCursors∙push c
            newCursors∙push [c[1] c[2]+dy]
        mc = belt.traversePositionsInDirection newCursors @mainCursor() dir

        @setCursors newCursors {main:mc adjust:'topBotDelta'}
        
    contractCursors: dir ->
        
        cursors = @allCursors()
        newCursors = []
        for ci c in cursors
            nbup = belt.positionsContain cursors belt.positionInDirection(c 'down')
            nbdn = belt.positionsContain cursors belt.positionInDirection(c 'up')
            solo = not (nbup or nbdn)
            add = switch dir
                'up'   ➜ nbup or solo
                'down' ➜ nbdn or solo
            
            if add
                newCursors∙push c 
        @setCursors newCursors
        
    #  0000000   0000000    0000000    
    # 000   000  000   000  000   000  
    # 000000000  000   000  000   000  
    # 000   000  000   000  000   000  
    # 000   000  0000000    0000000    
    
    addCursor: x y ->
        
        pos = belt.pos x y
        cursors = @allCursors()
        cursors∙push pos
        @setCursors cursors {main:-1}
        
    addCursors: cursors ->
        
        @setCursors @allCursors().concat(cursors)
        
    delCursorsInRange: rng ->
        
        outside = belt.positionsOutsideRange @allCursors() rng
        outside∙push belt.endOfRange(rng)
        @setCursors outside {main:-1}
        
    # 00     00   0000000   000   000  00000000  
    # 000   000  000   000  000   000  000       
    # 000000000  000   000   000 000   0000000   
    # 000 0 000  000   000     000     000       
    # 000   000   0000000       0      00000000  
    
    moveCursors: dir opt ->
    
        if dir is array
            switch dir[1]
                'bos' ➜ 
                    if @moveCursorsToStartOfSelections() ➜ ⮐  
                    dir = dir∙slice(2)
                'eos' ➜ 
                    if @moveCursorsToEndOfSelections() ➜ ⮐     
                    dir = dir∙slice(2)
                    
            dir = dir[1]
        
        opt ?= {}
        opt.count ?= 1
        opt.jumpWords ?= false
        
        if @s.highlights∙len() > 0
            @deselect()
        
        cursors = @allCursors()
        lines   = @s.lines
        for ci c in cursors
            
            line = lines[c[2]]
            
            switch dir
                'left'  
                'right'     ➜ c[1] += belt.numCharsFromPosToWordOrPunctInDirection(lines c dir opt)
                'up'        ➜ c[2] -= opt.count
                'down'      ➜ c[2] += opt.count
                'eol'       ➜ c[1] = kseg.width(@s.lines[c[2]])+1
                'bol'       ➜ c[1] = 1
                'bof'       ➜ c[1] = 1; c[2] = 1
                'eof'       ➜ c[2] = @s.lines∙len()-1; c[1] = kseg.width(line)+1
                'ind'       ➜ c[1] = belt.numIndent(line)
                'ind_eol'   ➜ ind  = belt.numIndent(line); c[1] = if c[1] <= ind ➜ ind+1 ➜ kseg.width(line)+1
                'ind_bol'   ➜ ind  = belt.numIndent(line); c[1] = if c[1] > ind+1 ➜ ind+1 ➜ 1
                
        main   = @s.main
        adjust = opt.adjust or 'topBotDelta'
        
        switch dir
            'up' 'down' 'left' 'right'                 
                main = belt.indexOfExtremePositionInDirection cursors dir main
                adjust = 'topBotDeltaGrow'
                
        @setCursors cursors {main:main adjust:adjust}
        
        true
        
    moveCursorsToStartOfSelections: ->
        
        selections = @allSelections()
        
        ⮐  if empty selections
        
        rngs = belt.splitLineRanges @s.lines selections false
        @setCursors belt.startPositionsOfRanges(rngs)
        
        true
        
    moveCursorsToEndOfSelections: ->
        
        selections = @allSelections()
         
        ⮐  if empty selections
         
        rngs = belt.splitLineRanges @s.lines selections false
        @setCursors belt.endPositionsOfRanges(rngs)
        
        true
        
    moveCursorsToEndOfLines: ->
        
        cursors = @allCursors()
        
        for cur in cursors
            cur[1] = belt.lineRangeAtPos(@s.lines cur)[3]
        
        @setCursors cursors
        
        true
                
    isAnyCursorInLine: y ->
        
        for c in @s.cursors
            ⮐  true if c[2] == y
            
    #  0000000  000   000  000   000  000   000   0000000  0000000    00000000  00000000   0000000   00000000   00000000  
    # 000       000   000  0000  000  000  000   000       000   000  000       000       000   000  000   000  000       
    # 000       000000000  000 0 000  0000000    0000000   0000000    0000000   000000    000   000  0000000    0000000   
    # 000       000   000  000  0000  000  000        000  000   000  000       000       000   000  000   000  000       
    #  0000000  000   000  000   000  000   000  0000000   0000000    00000000  000        0000000   000   000  00000000  
    
    chunksBeforeCursors: -> array.map(@s.cursors, (c) -> belt.chunkBeforePos(@s.lines c))
            
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    moveCursorsAndSelect: dir opt ->
        
        (selections cursors) = belt.extendLineRangesByMovingPositionsInDirection @s.lines @s.selections @s.cursors dir opt
        @setSelections selections
        @setCursors cursors {adjust:'topBotDelta'}

    select: from to ->
    
        selections = []
        
        @setMainCursor to[1] to[2]
        
        if from[2] > to[2] or from[2] == to[2] and from[1] > to[1]
            (from to) = (to from)

        to[2]   = clamp 1 @s.lines∙len() to[2]
        from[2] = clamp 1 @s.lines∙len() from[2]
            
        to[1]   = clamp 1 @s.lines[to[2]]∙len()+1 to[1]
        from[1] = clamp 1 @s.lines[from[2]]∙len()+1 from[1]
        
        selections∙push [from[1] from[2] to[1] to[2]]
        
        @setSelections selections
        
    allSelections: -> @s.selections∙arr()
    allHighlights: -> @s.highlights∙arr()
        
    # 000   000  000   0000000   000   000  000      000   0000000   000   000  000000000  
    # 000   000  000  000        000   000  000      000  000        000   000     000     
    # 000000000  000  000  0000  000000000  000      000  000  0000  000000000     000     
    # 000   000  000  000   000  000   000  000      000  000   000  000   000     000     
    # 000   000  000   0000000   000   000  0000000  000   0000000   000   000     000     
    
    selectWordAtCursor_highlightSelection_selectAllHighlights: ->
        # alt+cmd+d alt+ctrl+d
        if valid @s.highlights 
            pos = @mainCursor()
            if @s.selections∙len() < @s.highlights∙len()
                @selectAllHighlights()
            else
                @addNextHighlightToSelection()
            ⮐ 
        
        @selectWordAtCursor_highlightSelection()
        @selectAllHighlights()
    
    highlightWordAtCursor_deselectCursorHighlight_moveCursorToNextHighlight: ->
        # cmd+e ctrl+e
        if valid @s.highlights 
            if not @deselectCursorHighlight()
                @moveCursorToNextHighlight()
            ⮐ 
            
        @selectWordAtCursor_highlightSelection()
        @deselectCursorHighlight()
    
    selectWordAtCursor_highlightSelection_addNextHighlightToSelection: ->
        # cmd+d ctrl+d
        if valid @s.highlights ➜ ⮐  @addCurrentOrNextHighlightToSelection()
            
        @selectWordAtCursor_highlightSelection()
        
    selectWordAtCursor_highlightSelection_selectNextHighlight: ->
        # cmd+g ctrl+g
        if valid @s.highlights 
            @clearCursors()
            @selectNextHighlight()
            
        @selectWordAtCursor_highlightSelection()
        
    highlightWordAtCursor_deselectCursorHighlight_moveCursorToPrevHighlight: ->
        # shift+cmd+e shift+ctrl+e
        if valid @s.highlights 
            if not @deselectCursorHighlight()
                @moveCursorToPrevHighlight()
            ⮐ 
            
        @selectWordAtCursor_highlightSelection()
        @deselectCursorHighlight()
    
    selectWordAtCursor_highlightSelection_addPrevHighlightToSelection: ->
        # shift+cmd+d shift+ctrl+d
        if valid @s.highlights ➜ ⮐  @addCurrentOrPrevHighlightToSelection()
            
        @selectWordAtCursor_highlightSelection()
        
    selectWordAtCursor_highlightSelection_selectPrevHighlight: ->
        # shift+cmd+g shift+ctrl+g
        if valid @s.highlights 
            @clearCursors()
            @selectPrevHighlight()
            
        @selectWordAtCursor_highlightSelection()
        
    selectWordAtCursor_highlightSelection: ->
        
        if empty @s.selections
            @selectWord @mainCursor() 
        
        @highlightSelection()
    
    highlightSelection: ->
        
        ⮐  if empty @s.selections
        
        spans = []
        for ri rng in ipairs @allSelections()
            if rng[2] == rng[4]
                text  = belt.textForLineRange @s.lines rng
                spans += belt.lineSpansForText(@s.lines text)
        
        @setHighlights spans
        
    highlightText: text ->
        
        ⮐  if empty text
        
        @setHighlights belt.lineSpansForText(@s.lines text)
    
    deselectCursorHighlight: ->
        
        ⮐  if empty @s.highlights
        ⮐  if empty @s.selections
        prev = belt.prevSpanBeforePos @s.highlights @mainCursor()
        if prev
            @deselectSpan prev

    selectAllHighlights: ->
        
        ⮐  if empty @s.highlights
        
        selections = []
        cursors = []
        for si span in ipairs @s.highlights
            selections∙push belt.rangeForSpan(span)
            cursors∙push belt.endOfSpan(span)
            
        @addCursors cursors        
        @setSelections selections
                    
    selectNextHighlight: ->
        
        ⮐  if empty @s.highlights
        next = belt.nextSpanAfterPos @s.highlights @mainCursor()
        if next
            @selectSpan next
            @setMainCursor belt.endOfSpan(next)

    selectPrevHighlight: ->
        
        ⮐  if empty @s.highlights
        
        pos = @mainCursor()
        prev = belt.prevSpanBeforePos @s.highlights pos
        if prev
            if belt.endOfSpan(prev) == pos
                prev = belt.prevSpanBeforePos @s.highlights belt.startOfSpan(prev)
            if prev
                @selectSpan prev
                @setMainCursor belt.endOfSpan(prev)
            
    addCurrentOrNextHighlightToSelection: ->            
        prev = belt.prevSpanBeforePos @s.highlights @mainCursor()
        if prev
            if not belt.rangesContainSpan @s.selections prev
                @addSpanToSelection prev
                @addCursor belt.endOfSpan(prev)
                ⮐ 
                
        @addNextHighlightToSelection()

    addCurrentOrPrevHighlightToSelection: ->            
        prev = belt.prevSpanBeforePos @s.highlights @mainCursor()
        if prev
            if not belt.rangesContainSpan @s.selections prev
                @addSpanToSelection prev
                @addCursor belt.endOfSpan(prev)
                ⮐ 
                
        @addPrevHighlightToSelection()
        
    addNextHighlightToSelection: ->
        
        ⮐  if empty @s.highlights
        next = belt.nextSpanAfterPos @s.highlights @mainCursor()
        if next
            @addSpanToSelection next
            @addCursor belt.endOfSpan(next)

    addPrevHighlightToSelection: ->
        
        ⮐  if empty @s.highlights
        
        pos = @mainCursor()
        prev = belt.prevSpanBeforePos @s.highlights pos
        if prev
            if belt.endOfSpan(prev) == pos
                prev = belt.prevSpanBeforePos @s.highlights belt.startOfSpan(prev)
            if prev
                @addSpanToSelection prev
                @addCursor belt.endOfSpan(prev)
            
    moveCursorToNextHighlight: pos ->
        
        ⮐  if empty @s.highlights
        
        pos ?= @mainCursor()
        next = belt.nextSpanAfterPos @s.highlights pos
        if next
            @moveMainCursor belt.endOfSpan(next)

    moveCursorToPrevHighlight: pos ->
        
        ⮐  if empty @s.highlights
        
        pos ?= @mainCursor()
        prev = belt.prevSpanBeforePos @s.highlights pos
        if prev
            if belt.endOfSpan(prev) == pos
                prev = belt.prevSpanBeforePos @s.highlights belt.startOfSpan(prev)
            if prev
                @moveMainCursor belt.endOfSpan(prev)
            
    selectSpan: span ->
        
        @setSelections [belt.rangeForSpan(span)]
        
    deselectSpan: span ->
        
        rng = belt.rangeForSpan span
        
        selections = @allSelections()
        for index selection in ipairs selections
            if belt.isSameRange selection rng
                selections∙splice index 1
                @setSelections selections
                ⮐  true
        false
        
    addRangeToSelectionWithMainCursorAtEnd: rng ->
        
        @addRangeToSelection rng
        @delCursorsInRange rng
        
    addRangeToSelection: rng ->
        
        selections = @allSelections()
        
        selections∙push rng
        
        @setSelections selections
                    
    addSpanToSelection: span -> @addRangeToSelection belt.rangeForSpan(span)
                
    #  0000000  000   000  000   000  000   000  000   000  
    # 000       000   000  000   000  0000  000  000  000   
    # 000       000000000  000   000  000 0 000  0000000    
    # 000       000   000  000   000  000  0000  000  000   
    #  0000000  000   000   0000000   000   000  000   000  
    
    selectChunk: x y ->
        rng = belt.rangeOfClosestChunkToPos @s.lines belt.pos(x y)
        if rng
            @addRangeToSelectionWithMainCursorAtEnd rng
        @

    # 000   000   0000000   00000000   0000000    
    # 000 0 000  000   000  000   000  000   000  
    # 000000000  000   000  0000000    000   000  
    # 000   000  000   000  000   000  000   000  
    # 00     00   0000000   000   000  0000000    
    
    selectWord: x y ->
        rng = belt.rangeOfClosestWordToPos @s.lines belt.pos(x y)
        if rng
            @addRangeToSelectionWithMainCursorAtEnd rng
        @
                
    # 000      000  000   000  00000000  
    # 000      000  0000  000  000       
    # 000      000  000 0 000  0000000   
    # 000      000  000  0000  000       
    # 0000000  000  000   000  00000000  
    
    selectLine: y ->
        
        y ?= @mainCursor()[2]
        if 1 <= y and y <= @s.lines∙len()
            @select [1 y] [@s.lines[y]∙len() y]
        @
        
    selectPrevLine: y ->
        
        y ?= @mainCursor()[2]
        @selectLine y-1
        
    selectNextLine: y ->
        
        y ?= @mainCursor()[2]
        @selectLine y+1
        
    selectCursorLines: ->
                    
        selections = belt.lineRangesForPositions(@s.lines @s.cursors)
        
        ▴ selections∙len() == @s.cursors∙len()
                    
        @setSelections selections
        
    selectAllLines: ->
        
        allsel = [[1 1 kseg.width(@s.lines[@s.lines∙len()])+1 @s.lines∙len()]]
        if allsel∙eql @s.selections
            @deselect()
        else
            @setSelections allsel
        
    # 00     00   0000000   00000000   00000000  
    # 000   000  000   000  000   000  000       
    # 000000000  000   000  0000000    0000000   
    # 000 0 000  000   000  000   000  000       
    # 000   000   0000000   000   000  00000000  
    
    selectMoreLines: ->
        
        (cursors selections) = belt.addLinesBelowPositionsToRanges @s.lines @s.cursors @s.selections
        
        @setSelections selections
        @setCursors cursors {main:-1}

    # 000      00000000   0000000   0000000  
    # 000      000       000       000       
    # 000      0000000   0000000   0000000   
    # 000      000            000       000  
    # 0000000  00000000  0000000   0000000   
    
    selectLessLines: ->
        
        (cursors selections) = belt.removeLinesAtPositionsFromRanges @s.lines @s.cursors @s.selections
        
        @setSelections selections
        @setCursors cursors {main:-1}
                
    # 000000000  00000000  000   000  000000000  
    #    000     000        000 000      000     
    #    000     0000000     00000       000     
    #    000     000        000 000      000     
    #    000     00000000  000   000     000     
    
    textOfSelection: -> belt.textForLineRanges @s.lines @s.selections
    selectedText:    -> belt.textForLineRanges @s.lines @s.selections
    
    selectionsOrCursorLineRanges: -> 
        if @s.selections∙len() > 0 
            @s.selections 
        else
            belt.lineRangesForPositions @s.lines @s.cursors true
    
    textOfSelectionOrCursorLines: -> 

        belt.textForLineRanges @s.lines @selectionsOrCursorLineRanges()

    isSingleLineSelected: ->
        
        @s.selections∙len() == 1 and @s.selections[1][2] == @s.selections[1][4]
        
    isSelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if not (selection[4] == y and selection[3] == 0)
                if selection[2] <= y and y <= selection[4]
                    ⮐  true
        false
        
    isFullySelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if selection[2] <= y and y <= selection[4]
                ⮐  belt.isFullLineRange(@s.lines selection)
        false
        
    isPartiallySelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if selection[2] <= y and y <= selection[4]
                ⮐  not belt.isFullLineRange(@s.lines selection)
        false
        
    isSpanSelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if selection[2] <= y and y <= selection[4]
                span = belt.isSpanLineRange(@s.lines selection)
                if span
                    ⮐  true 
            ⮐  false if selection[2] > y
        false
        
    isHighlightedLine: y ->

        for hi highlight in ipairs @s.highlights
            ⮐  true if highlight[2] == y
                
        false
        
    # 0000000    00000000   0000000  00000000  000      00000000   0000000  000000000  
    # 000   000  000       000       000       000      000       000          000     
    # 000   000  0000000   0000000   0000000   000      0000000   000          000     
    # 000   000  000            000  000       000      000       000          000     
    # 0000000    00000000  0000000   00000000  0000000  00000000   0000000     000     
    
    deselect: ->
        
        if valid @s.selections
            @setSelections []
            
    clearHighlights: ->

        if valid @s.highlights
            @setHighlights []
            
    clearCursors: ->
            
        if @s.cursors∙len() > 1
            @setCursors [@mainCursor()]
            
    clearCursorsHighlightsAndSelections: ->
        
        @pushState() if @s.cursors∙len()>1 or valid @s.selections
        @clearCursors()
        @clearHighlights()
        @deselect()

    # █████████  ████████  ███   ███  █████████
    #    ███     ███        ███ ███      ███   
    #    ███     ███████     █████       ███   
    #    ███     ███        ███ ███      ███   
    #    ███     ████████  ███   ███     ███   
    
    insert: text ->
    
        text = mode.insert @ text
        
        if valid @s.selections
            ⮐  @indentSelectedLines() if text == '\t'
            @deleteSelection()
        (lines cursors) = belt.insertTextAtPositions @s.lines text @s.cursors
        
        @clearHighlights()

        @setLines   lines
        @setCursors cursors
        mode.postInsert @
        
    # ███   ███  ████████   ███████   ███████    ████████  ████████ 
    # ███   ███  ███       ███   ███  ███   ███  ███       ███   ███
    # █████████  ███████   █████████  ███   ███  ███████   ███████  
    # ███   ███  ███       ███   ███  ███   ███  ███       ███   ███
    # ███   ███  ████████  ███   ███  ███████    ████████  ███   ███
    
    insertAsciiHeaderForSelectionOrWordAtCursor: ->
    
        (lines cursors selections) = belt.insertAsciiHeaderForPositionsAndRanges @s.lines @s.cursors @s.selections
        
        @clearHighlights()
        @setLines      lines
        @setSelections selections
        @setCursors    cursors
        
    #  ███████  ███   ███  ████████   ████████    ███████   ███   ███  ███   ███  ███████  
    # ███       ███   ███  ███   ███  ███   ███  ███   ███  ███   ███  ████  ███  ███   ███
    # ███████   ███   ███  ███████    ███████    ███   ███  ███   ███  ███ █ ███  ███   ███
    #      ███  ███   ███  ███   ███  ███   ███  ███   ███  ███   ███  ███  ████  ███   ███
    # ███████    ███████   ███   ███  ███   ███   ███████    ███████   ███   ███  ███████  
    
    surroundSelection: trigger pair ->
        
        (lines posl) = belt.insertSurroundAtRanges @s.lines @s.selections trigger pair
        @setLines      lines
        @setSelections []
        @setCursors    posl

    # 000      000  000   000  00000000   0000000  
    # 000      000  0000  000  000       000       
    # 000      000  000 0 000  0000000   0000000   
    # 000      000  000  0000  000            000  
    # 0000000  000  000   000  00000000  0000000   
    
    joinLines: ->
        
        @moveCursorsToEndOfLines()
        
        idxs = belt.lineIndicesForPositions @s.cursors
        rngs = belt.rangesForJoiningLines @s.lines idxs

        @deleteRanges rngs @allCursors()
        
    # ██     ██   ███████   ███   ███  ████████
    # ███   ███  ███   ███  ███   ███  ███     
    # █████████  ███   ███   ███ ███   ███████ 
    # ███ █ ███  ███   ███     ███     ███     
    # ███   ███   ███████       █      ████████

    moveSelectionOrCursorLines: dir ->
        
        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors
        (lines selections cursors) = belt.moveLineRangesAndPositionsAtIndicesInDirection @s.lines @s.selections @s.cursors indices dir
        
        @setLines lines
        @setSelections selections
        @setCursors cursors
        
    #  ███████  ███       ███████   ███   ███  ████████
    # ███       ███      ███   ███  ████  ███  ███     
    # ███       ███      ███   ███  ███ █ ███  ███████ 
    # ███       ███      ███   ███  ███  ████  ███     
    #  ███████  ███████   ███████   ███   ███  ████████

    cloneSelectionAndCursorLines: dir ->
        
        blocks = belt.blockRangesForRangesAndPositions @s.lines @s.selections @s.cursors
        
        (lines selections cursors) = belt.cloneLineBlockRangesAndMoveRangesAndPositionsInDirection @s.lines blocks @s.selections @s.cursors dir
        
        @setLines lines
        @setSelections selections
        @setCursors cursors
        
    #  ███████   ███████   ██     ██  ██     ██  ████████  ███   ███  █████████
    # ███       ███   ███  ███   ███  ███   ███  ███       ████  ███     ███   
    # ███       ███   ███  █████████  █████████  ███████   ███ █ ███     ███   
    # ███       ███   ███  ███ █ ███  ███ █ ███  ███       ███  ████     ███   
    #  ███████   ███████   ███   ███  ███   ███  ████████  ███   ███     ███   

    toggleCommentAtSelectionOrCursorLines: ->

        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors

        (lines selections cursors) = belt.toggleCommentsInLineRangesAtIndices @s.lines @s.selections @s.cursors indices
                
        @setLines lines        
        @setSelections selections
        @setCursors cursors

    toggleCommentTypeAtSelectionOrCursorLines: ->

        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors

        (lines selections cursors) = belt.toggleCommentTypesInLineRangesAtIndices @s.lines @s.selections @s.cursors indices
                
        @setLines lines        
        @setSelections selections
        @setCursors cursors

    #  0000000  00000000  000      00000000   0000000  000000000  00000000  0000000    
    # 000       000       000      000       000          000     000       000   000  
    # 0000000   0000000   000      0000000   000          000     0000000   000   000  
    #      000  000       000      000       000          000     000       000   000  
    # 0000000   00000000  0000000  00000000   0000000     000     00000000  0000000    
    
    indentSelectedLines: ->
        
        ⮐  if empty @s.selections
        
        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors
        
        (lines selections cursors) = belt.indentLineRangesAndPositionsAtIndices @s.lines @s.selections @s.cursors indices
        
        @setLines lines
        @setSelections selections
        @setCursors cursors
        
    # 0000000    00000000  000  000   000  0000000    00000000  000   000  000000000  
    # 000   000  000       000  0000  000  000   000  000       0000  000     000     
    # 000   000  0000000   000  000 0 000  000   000  0000000   000 0 000     000     
    # 000   000  000       000  000  0000  000   000  000       000  0000     000     
    # 0000000    00000000  000  000   000  0000000    00000000  000   000     000     
    
    deindentSelectedOrCursorLines: ->
        
        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors
        
        (lines selections cursors) = belt.deindentLineRangesAndPositionsAtIndices @s.lines @s.selections @s.cursors indices
        
        @setLines lines
        @setSelections selections
        @setCursors cursors
    
    # 0000000    00000000  000      00000000  000000000  00000000  
    # 000   000  000       000      000          000     000       
    # 000   000  0000000   000      0000000      000     0000000   
    # 000   000  000       000      000          000     000       
    # 0000000    00000000  0000000  00000000     000     00000000  
    
    delete: typ jump ->
                
        ⮐  @deleteSelection() if ['back' 'next']∙has(typ) and valid @s.selections

        lines = @s.lines∙arr()
        
        cursors = @allCursors()
        
        if cursors∙len() == 1 and ['back' 'next']∙has(typ) and belt.isLinesPosOutside(lines cursors[1])
            ⮐  @setMainCursor kseg.width(lines[cursors[1][2]])+1 cursors[1][2]
            
        minBeforeWs = Infinity
        if typ == 'back'
            for cursor in cursors
                rng = belt.rangeOfWhitespaceLeftToPos lines cursor
                minBeforeWs = min minBeforeWs rng[3]-rng[1]
                
        for ci in cursors.len..1
            
            cursor = cursors[ci]
            
            x = cursor[1]
            y = cursor[2]
                            
            line = lines[y]
            
            remove = 1
            dc = 1

            switch typ
                
                'eol'  ➜ line = line∙slice(1 x)
                
                'back' 
                    if x == 1
                        if cursors∙len() == 1
                            ⮐  if y <= 1
                            y -= 1
                            x = kseg.width(lines[y])+1
                            remove = 2
                            line = lines[y] + line
                            cursor[1] = x
                            cursor[2] = y
                    else
                        if jump
                            rng = belt.rangeOfWordOrWhitespaceLeftToPos lines cursor
                            if rng
                                dc = rng[3] - rng[1]
                        else
                            if minBeforeWs > 1
                                dc = (x-1) % 4
                                if dc == 0
                                    dc = 4 
                                dc = min minBeforeWs dc
                                
                        if x <= kseg.width(line)+1
                            # segi = kseg.indexAtWidth line x
                            segi = kseg.segiAtWidth line x
                            line = line∙slice(1 segi-dc-1) + line∙slice(segi)

                'next'
                    if x == kseg.width(lines[y]) 
                        if cursors.len == 1
                            ⮐  if y > lines.len
                            x = kseg.width(lines[y])
                            remove = 2
                            line = line + lines[y+1]
                            cursor[1] = x
                            cursor[2] = y
                    else
                        if jump
                            rng = belt.rangeOfWordOrWhitespaceRightToPos lines cursor
                            if rng
                                dc = rng[3] - rng[1]
                                line = line∙slice(1 x) + line∙slice(x+dc)
                        else
                            dc = 1
                            line = line∙slice(1 x) + line∙slice(x+dc)
                        cursor[1] += dc
                                
            belt.moveCursorsInSameLineBy cursors cursor -dc
            
            lines∙splice y remove line
            
        @clearHighlights()
        @setLines   lines
        @setCursors cursors
            
    #  0000000  00000000  000      00000000   0000000  000000000  000   0000000   000   000  
    # 000       000       000      000       000          000     000  000   000  0000  000  
    # 0000000   0000000   000      0000000   000          000     000  000   000  000 0 000  
    #      000  000       000      000       000          000     000  000   000  000  0000  
    # 0000000   00000000  0000000  00000000   0000000     000     000   0000000   000   000  
    
    deleteSelection: -> 
        
        ⮐  if mode.deleteSelection @
    
        @deleteRanges @allSelections() @allCursors()
        
    deleteRanges: rngs posl ->
        
        ⮐  if empty rngs
        
        posl ?= @allCursors()
        
        @pushState() if not @beginIndex

        (lines cursors) = belt.deleteLineRangesAndAdjustPositions @s.lines rngs posl

        @deselect()
        @clearHighlights()
        @setLines   lines
        @setCursors cursors
    
⮐  state
