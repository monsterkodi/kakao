import {createRequire as qG} from "node:module";
var FG = Object.create;
var { defineProperty: vQ, getPrototypeOf: RG, getOwnPropertyNames: jG } = Object;
var OG = Object.prototype.hasOwnProperty;
var BG = (Z, Q, J) => {
  J = Z != null ? FG(RG(Z)) : {};
  const X = Q || !Z || !Z.__esModule ? vQ(J, "default", { value: Z, enumerable: !0 }) : J;
  for (let z of jG(Z))
    if (!OG.call(X, z))
      vQ(X, z, {
        get: () => Z[z],
        enumerable: !0
      });
  return X;
};
var P = (Z, Q) => () => (Q || Z((Q = { exports: {} }).exports, Q), Q.exports);
var A0 = qG(import.meta.url);

// node_modules/acorn/dist/acorn.js
var EQ = P((h8, bQ) => {
  (function(Z, Q) {
    typeof h8 === "object" && typeof bQ !== "undefined" ? Q(h8) : typeof define === "function" && define.amd ? define(["exports"], Q) : (Z = Z || self, Q(Z.acorn = {}));
  })(h8, function(Z) {
    var Q = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    }, J = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", X = {
      5: J,
      "5module": J + " export import",
      6: J + " const class extends export import super"
    }, z = /^in(stanceof)?$/, Y = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", W = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", U = new RegExp("[" + Y + "]"), V = new RegExp("[" + Y + W + "]");
    Y = W = null;
    var M = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], q = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function L(H, G) {
      var K = 65536;
      for (var j = 0;j < G.length; j += 2) {
        if (K += G[j], K > H)
          return !1;
        if (K += G[j + 1], K >= H)
          return !0;
      }
    }
    function N(H, G) {
      if (H < 65)
        return H === 36;
      if (H < 91)
        return !0;
      if (H < 97)
        return H === 95;
      if (H < 123)
        return !0;
      if (H <= 65535)
        return H >= 170 && U.test(String.fromCharCode(H));
      if (G === !1)
        return !1;
      return L(H, M);
    }
    function T(H, G) {
      if (H < 48)
        return H === 36;
      if (H < 58)
        return !0;
      if (H < 65)
        return !1;
      if (H < 91)
        return !0;
      if (H < 97)
        return H === 95;
      if (H < 123)
        return !0;
      if (H <= 65535)
        return H >= 170 && V.test(String.fromCharCode(H));
      if (G === !1)
        return !1;
      return L(H, M) || L(H, q);
    }
    var E = function H(G, K) {
      if (K === void 0)
        K = {};
      this.label = G, this.keyword = K.keyword, this.beforeExpr = !!K.beforeExpr, this.startsExpr = !!K.startsExpr, this.isLoop = !!K.isLoop, this.isAssign = !!K.isAssign, this.prefix = !!K.prefix, this.postfix = !!K.postfix, this.binop = K.binop || null, this.updateContext = null;
    };
    function g(H, G) {
      return new E(H, { beforeExpr: !0, binop: G });
    }
    var n = { beforeExpr: !0 }, x = { startsExpr: !0 }, d = {};
    function y(H, G) {
      if (G === void 0)
        G = {};
      return G.keyword = H, d[H] = new E(H, G);
    }
    var R = {
      num: new E("num", x),
      regexp: new E("regexp", x),
      string: new E("string", x),
      name: new E("name", x),
      eof: new E("eof"),
      bracketL: new E("[", { beforeExpr: !0, startsExpr: !0 }),
      bracketR: new E("]"),
      braceL: new E("{", { beforeExpr: !0, startsExpr: !0 }),
      braceR: new E("}"),
      parenL: new E("(", { beforeExpr: !0, startsExpr: !0 }),
      parenR: new E(")"),
      comma: new E(",", n),
      semi: new E(";", n),
      colon: new E(":", n),
      dot: new E("."),
      question: new E("?", n),
      questionDot: new E("?."),
      arrow: new E("=>", n),
      template: new E("template"),
      invalidTemplate: new E("invalidTemplate"),
      ellipsis: new E("...", n),
      backQuote: new E("`", x),
      dollarBraceL: new E("${", { beforeExpr: !0, startsExpr: !0 }),
      eq: new E("=", { beforeExpr: !0, isAssign: !0 }),
      assign: new E("_=", { beforeExpr: !0, isAssign: !0 }),
      incDec: new E("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
      prefix: new E("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
      logicalOR: g("||", 1),
      logicalAND: g("&&", 2),
      bitwiseOR: g("|", 3),
      bitwiseXOR: g("^", 4),
      bitwiseAND: g("&", 5),
      equality: g("==/!=/===/!==", 6),
      relational: g("</>/<=/>=", 7),
      bitShift: g("<</>>/>>>", 8),
      plusMin: new E("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
      modulo: g("%", 10),
      star: g("*", 10),
      slash: g("/", 10),
      starstar: new E("**", { beforeExpr: !0 }),
      coalesce: g("??", 1),
      _break: y("break"),
      _case: y("case", n),
      _catch: y("catch"),
      _continue: y("continue"),
      _debugger: y("debugger"),
      _default: y("default", n),
      _do: y("do", { isLoop: !0, beforeExpr: !0 }),
      _else: y("else", n),
      _finally: y("finally"),
      _for: y("for", { isLoop: !0 }),
      _function: y("function", x),
      _if: y("if"),
      _return: y("return", n),
      _switch: y("switch"),
      _throw: y("throw", n),
      _try: y("try"),
      _var: y("var"),
      _const: y("const"),
      _while: y("while", { isLoop: !0 }),
      _with: y("with"),
      _new: y("new", { beforeExpr: !0, startsExpr: !0 }),
      _this: y("this", x),
      _super: y("super", x),
      _class: y("class", x),
      _extends: y("extends", n),
      _export: y("export"),
      _import: y("import", x),
      _null: y("null", x),
      _true: y("true", x),
      _false: y("false", x),
      _in: y("in", { beforeExpr: !0, binop: 7 }),
      _instanceof: y("instanceof", { beforeExpr: !0, binop: 7 }),
      _typeof: y("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
      _void: y("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
      _delete: y("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
    }, L0 = /\r\n?|\n|\u2028|\u2029/, B0 = new RegExp(L0.source, "g");
    function e(H, G) {
      return H === 10 || H === 13 || !G && (H === 8232 || H === 8233);
    }
    var q0 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Z0 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, s0 = Object.prototype, p = s0.hasOwnProperty, Q0 = s0.toString;
    function $0(H, G) {
      return p.call(H, G);
    }
    var H0 = Array.isArray || function(H) {
      return Q0.call(H) === "[object Array]";
    };
    function R0(H) {
      return new RegExp("^(?:" + H.replace(/ /g, "|") + ")$");
    }
    var v0 = function H(G, K) {
      this.line = G, this.column = K;
    };
    v0.prototype.offset = function H(G) {
      return new v0(this.line, this.column + G);
    };
    var O0 = function H(G, K, j) {
      if (this.start = K, this.end = j, G.sourceFile !== null)
        this.source = G.sourceFile;
    };
    function D0(H, G) {
      for (var K = 1, j = 0;; ) {
        B0.lastIndex = j;
        var I = B0.exec(H);
        if (I && I.index < G)
          ++K, j = I.index + I[0].length;
        else
          return new v0(K, G - j);
      }
    }
    var b0 = {
      ecmaVersion: 10,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowAwaitOutsideFunction: !1,
      allowHashBang: !1,
      locations: !1,
      onToken: null,
      onComment: null,
      ranges: !1,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: !1
    };
    function Y1(H) {
      var G = {};
      for (var K in b0)
        G[K] = H && $0(H, K) ? H[K] : b0[K];
      if (G.ecmaVersion >= 2015)
        G.ecmaVersion -= 2009;
      if (G.allowReserved == null)
        G.allowReserved = G.ecmaVersion < 5;
      if (H0(G.onToken)) {
        var j = G.onToken;
        G.onToken = function(I) {
          return j.push(I);
        };
      }
      if (H0(G.onComment))
        G.onComment = $1(G, G.onComment);
      return G;
    }
    function $1(H, G) {
      return function(K, j, I, w, v, f) {
        var l = {
          type: K ? "Block" : "Line",
          value: j,
          start: I,
          end: w
        };
        if (H.locations)
          l.loc = new O0(this, v, f);
        if (H.ranges)
          l.range = [I, w];
        G.push(l);
      };
    }
    var k0 = 1, N0 = 2, k1 = k0 | N0, W1 = 4, D1 = 8, Q1 = 16, n1 = 32, s1 = 64, f1 = 128;
    function B5(H, G) {
      return N0 | (H ? W1 : 0) | (G ? D1 : 0);
    }
    var UQ = 0, g7 = 1, I1 = 2, VQ = 3, KQ = 4, MQ = 5, C0 = function H(G, K, j) {
      this.options = G = Y1(G), this.sourceFile = G.sourceFile, this.keywords = R0(X[G.ecmaVersion >= 6 ? 6 : G.sourceType === "module" ? "5module" : 5]);
      var I = "";
      if (G.allowReserved !== !0) {
        for (var w = G.ecmaVersion;; w--)
          if (I = Q[w])
            break;
        if (G.sourceType === "module")
          I += " await";
      }
      this.reservedWords = R0(I);
      var v = (I ? I + " " : "") + Q.strict;
      if (this.reservedWordsStrict = R0(v), this.reservedWordsStrictBind = R0(v + " " + Q.strictBind), this.input = String(K), this.containsEsc = !1, j)
        this.pos = j, this.lineStart = this.input.lastIndexOf("\n", j - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(L0).length;
      else
        this.pos = this.lineStart = 0, this.curLine = 1;
      if (this.type = R.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = G.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && G.allowHashBang && this.input.slice(0, 2) === "#!")
        this.skipLineComment(2);
      this.scopeStack = [], this.enterScope(k0), this.regexpState = null;
    }, t1 = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 } };
    C0.prototype.parse = function H() {
      var G = this.options.program || this.startNode();
      return this.nextToken(), this.parseTopLevel(G);
    }, t1.inFunction.get = function() {
      return (this.currentVarScope().flags & N0) > 0;
    }, t1.inGenerator.get = function() {
      return (this.currentVarScope().flags & D1) > 0;
    }, t1.inAsync.get = function() {
      return (this.currentVarScope().flags & W1) > 0;
    }, t1.allowSuper.get = function() {
      return (this.currentThisScope().flags & s1) > 0;
    }, t1.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & f1) > 0;
    }, t1.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }, C0.prototype.inNonArrowFunction = function H() {
      return (this.currentThisScope().flags & N0) > 0;
    }, C0.extend = function H() {
      var G = [], K = arguments.length;
      while (K--)
        G[K] = arguments[K];
      var j = this;
      for (var I = 0;I < G.length; I++)
        j = G[I](j);
      return j;
    }, C0.parse = function H(G, K) {
      return new this(K, G).parse();
    }, C0.parseExpressionAt = function H(G, K, j) {
      var I = new this(j, G, K);
      return I.nextToken(), I.parseExpression();
    }, C0.tokenizer = function H(G, K) {
      return new this(K, G);
    }, Object.defineProperties(C0.prototype, t1);
    var c0 = C0.prototype, nW = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    c0.strictDirective = function(H) {
      for (;; ) {
        Z0.lastIndex = H, H += Z0.exec(this.input)[0].length;
        var G = nW.exec(this.input.slice(H));
        if (!G)
          return !1;
        if ((G[1] || G[2]) === "use strict") {
          Z0.lastIndex = H + G[0].length;
          var K = Z0.exec(this.input), j = K.index + K[0].length, I = this.input.charAt(j);
          return I === ";" || I === "}" || L0.test(K[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(I) || I === "!" && this.input.charAt(j + 1) === "=");
        }
        if (H += G[0].length, Z0.lastIndex = H, H += Z0.exec(this.input)[0].length, this.input[H] === ";")
          H++;
      }
    }, c0.eat = function(H) {
      if (this.type === H)
        return this.next(), !0;
      else
        return !1;
    }, c0.isContextual = function(H) {
      return this.type === R.name && this.value === H && !this.containsEsc;
    }, c0.eatContextual = function(H) {
      if (!this.isContextual(H))
        return !1;
      return this.next(), !0;
    }, c0.expectContextual = function(H) {
      if (!this.eatContextual(H))
        this.unexpected();
    }, c0.canInsertSemicolon = function() {
      return this.type === R.eof || this.type === R.braceR || L0.test(this.input.slice(this.lastTokEnd, this.start));
    }, c0.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon)
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        return !0;
      }
    }, c0.semicolon = function() {
      if (!this.eat(R.semi) && !this.insertSemicolon())
        this.unexpected();
    }, c0.afterTrailingComma = function(H, G) {
      if (this.type === H) {
        if (this.options.onTrailingComma)
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        if (!G)
          this.next();
        return !0;
      }
    }, c0.expect = function(H) {
      this.eat(H) || this.unexpected();
    }, c0.unexpected = function(H) {
      this.raise(H != null ? H : this.start, "Unexpected token");
    };
    function N8() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    }
    c0.checkPatternErrors = function(H, G) {
      if (!H)
        return;
      if (H.trailingComma > -1)
        this.raiseRecoverable(H.trailingComma, "Comma is not permitted after the rest element");
      var K = G ? H.parenthesizedAssign : H.parenthesizedBind;
      if (K > -1)
        this.raiseRecoverable(K, "Parenthesized pattern");
    }, c0.checkExpressionErrors = function(H, G) {
      if (!H)
        return !1;
      var { shorthandAssign: K, doubleProto: j } = H;
      if (!G)
        return K >= 0 || j >= 0;
      if (K >= 0)
        this.raise(K, "Shorthand property assignments are valid only in destructuring patterns");
      if (j >= 0)
        this.raiseRecoverable(j, "Redefinition of __proto__ property");
    }, c0.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      if (this.awaitPos)
        this.raise(this.awaitPos, "Await expression cannot be a default value");
    }, c0.isSimpleAssignTarget = function(H) {
      if (H.type === "ParenthesizedExpression")
        return this.isSimpleAssignTarget(H.expression);
      return H.type === "Identifier" || H.type === "MemberExpression";
    };
    var o = C0.prototype;
    o.parseTopLevel = function(H) {
      var G = {};
      if (!H.body)
        H.body = [];
      while (this.type !== R.eof) {
        var K = this.parseStatement(null, !0, G);
        H.body.push(K);
      }
      if (this.inModule)
        for (var j = 0, I = Object.keys(this.undefinedExports);j < I.length; j += 1) {
          var w = I[j];
          this.raiseRecoverable(this.undefinedExports[w].start, "Export '" + w + "' is not defined");
        }
      return this.adaptDirectivePrologue(H.body), this.next(), H.sourceType = this.options.sourceType, this.finishNode(H, "Program");
    };
    var h7 = { kind: "loop" }, sW = { kind: "switch" };
    o.isLet = function(H) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
        return !1;
      Z0.lastIndex = this.pos;
      var G = Z0.exec(this.input), K = this.pos + G[0].length, j = this.input.charCodeAt(K);
      if (j === 91)
        return !0;
      if (H)
        return !1;
      if (j === 123)
        return !0;
      if (N(j, !0)) {
        var I = K + 1;
        while (T(this.input.charCodeAt(I), !0))
          ++I;
        var w = this.input.slice(K, I);
        if (!z.test(w))
          return !0;
      }
      return !1;
    }, o.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
        return !1;
      Z0.lastIndex = this.pos;
      var H = Z0.exec(this.input), G = this.pos + H[0].length;
      return !L0.test(this.input.slice(this.pos, G)) && this.input.slice(G, G + 8) === "function" && (G + 8 === this.input.length || !T(this.input.charAt(G + 8)));
    }, o.parseStatement = function(H, G, K) {
      var j = this.type, I = this.startNode(), w;
      if (this.isLet(H))
        j = R._var, w = "let";
      switch (j) {
        case R._break:
        case R._continue:
          return this.parseBreakContinueStatement(I, j.keyword);
        case R._debugger:
          return this.parseDebuggerStatement(I);
        case R._do:
          return this.parseDoStatement(I);
        case R._for:
          return this.parseForStatement(I);
        case R._function:
          if (H && (this.strict || H !== "if" && H !== "label") && this.options.ecmaVersion >= 6)
            this.unexpected();
          return this.parseFunctionStatement(I, !1, !H);
        case R._class:
          if (H)
            this.unexpected();
          return this.parseClass(I, !0);
        case R._if:
          return this.parseIfStatement(I);
        case R._return:
          return this.parseReturnStatement(I);
        case R._switch:
          return this.parseSwitchStatement(I);
        case R._throw:
          return this.parseThrowStatement(I);
        case R._try:
          return this.parseTryStatement(I);
        case R._const:
        case R._var:
          if (w = w || this.value, H && w !== "var")
            this.unexpected();
          return this.parseVarStatement(I, w);
        case R._while:
          return this.parseWhileStatement(I);
        case R._with:
          return this.parseWithStatement(I);
        case R.braceL:
          return this.parseBlock(!0, I);
        case R.semi:
          return this.parseEmptyStatement(I);
        case R._export:
        case R._import:
          if (this.options.ecmaVersion > 10 && j === R._import) {
            Z0.lastIndex = this.pos;
            var v = Z0.exec(this.input), f = this.pos + v[0].length, l = this.input.charCodeAt(f);
            if (l === 40 || l === 46)
              return this.parseExpressionStatement(I, this.parseExpression());
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!G)
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            if (!this.inModule)
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
          return j === R._import ? this.parseImport(I) : this.parseExport(I, K);
        default:
          if (this.isAsyncFunction()) {
            if (H)
              this.unexpected();
            return this.next(), this.parseFunctionStatement(I, !0, !H);
          }
          var G0 = this.value, I0 = this.parseExpression();
          if (j === R.name && I0.type === "Identifier" && this.eat(R.colon))
            return this.parseLabeledStatement(I, G0, I0, H);
          else
            return this.parseExpressionStatement(I, I0);
      }
    }, o.parseBreakContinueStatement = function(H, G) {
      var K = G === "break";
      if (this.next(), this.eat(R.semi) || this.insertSemicolon())
        H.label = null;
      else if (this.type !== R.name)
        this.unexpected();
      else
        H.label = this.parseIdent(), this.semicolon();
      var j = 0;
      for (;j < this.labels.length; ++j) {
        var I = this.labels[j];
        if (H.label == null || I.name === H.label.name) {
          if (I.kind != null && (K || I.kind === "loop"))
            break;
          if (H.label && K)
            break;
        }
      }
      if (j === this.labels.length)
        this.raise(H.start, "Unsyntactic " + G);
      return this.finishNode(H, K ? "BreakStatement" : "ContinueStatement");
    }, o.parseDebuggerStatement = function(H) {
      return this.next(), this.semicolon(), this.finishNode(H, "DebuggerStatement");
    }, o.parseDoStatement = function(H) {
      if (this.next(), this.labels.push(h7), H.body = this.parseStatement("do"), this.labels.pop(), this.expect(R._while), H.test = this.parseParenExpression(), this.options.ecmaVersion >= 6)
        this.eat(R.semi);
      else
        this.semicolon();
      return this.finishNode(H, "DoWhileStatement");
    }, o.parseForStatement = function(H) {
      this.next();
      var G = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
      if (this.labels.push(h7), this.enterScope(0), this.expect(R.parenL), this.type === R.semi) {
        if (G > -1)
          this.unexpected(G);
        return this.parseFor(H, null);
      }
      var K = this.isLet();
      if (this.type === R._var || this.type === R._const || K) {
        var j = this.startNode(), I = K ? "let" : this.value;
        if (this.next(), this.parseVar(j, !0, I), this.finishNode(j, "VariableDeclaration"), (this.type === R._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && j.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9)
            if (this.type === R._in) {
              if (G > -1)
                this.unexpected(G);
            } else
              H.await = G > -1;
          return this.parseForIn(H, j);
        }
        if (G > -1)
          this.unexpected(G);
        return this.parseFor(H, j);
      }
      var w = new N8, v = this.parseExpression(!0, w);
      if (this.type === R._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
        if (this.options.ecmaVersion >= 9)
          if (this.type === R._in) {
            if (G > -1)
              this.unexpected(G);
          } else
            H.await = G > -1;
        return this.toAssignable(v, !1, w), this.checkLVal(v), this.parseForIn(H, v);
      } else
        this.checkExpressionErrors(w, !0);
      if (G > -1)
        this.unexpected(G);
      return this.parseFor(H, v);
    }, o.parseFunctionStatement = function(H, G, K) {
      return this.next(), this.parseFunction(H, l5 | (K ? 0 : _7), !1, G);
    }, o.parseIfStatement = function(H) {
      return this.next(), H.test = this.parseParenExpression(), H.consequent = this.parseStatement("if"), H.alternate = this.eat(R._else) ? this.parseStatement("if") : null, this.finishNode(H, "IfStatement");
    }, o.parseReturnStatement = function(H) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction)
        this.raise(this.start, "'return' outside of function");
      if (this.next(), this.eat(R.semi) || this.insertSemicolon())
        H.argument = null;
      else
        H.argument = this.parseExpression(), this.semicolon();
      return this.finishNode(H, "ReturnStatement");
    }, o.parseSwitchStatement = function(H) {
      this.next(), H.discriminant = this.parseParenExpression(), H.cases = [], this.expect(R.braceL), this.labels.push(sW), this.enterScope(0);
      var G;
      for (var K = !1;this.type !== R.braceR; )
        if (this.type === R._case || this.type === R._default) {
          var j = this.type === R._case;
          if (G)
            this.finishNode(G, "SwitchCase");
          if (H.cases.push(G = this.startNode()), G.consequent = [], this.next(), j)
            G.test = this.parseExpression();
          else {
            if (K)
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            K = !0, G.test = null;
          }
          this.expect(R.colon);
        } else {
          if (!G)
            this.unexpected();
          G.consequent.push(this.parseStatement(null));
        }
      if (this.exitScope(), G)
        this.finishNode(G, "SwitchCase");
      return this.next(), this.labels.pop(), this.finishNode(H, "SwitchStatement");
    }, o.parseThrowStatement = function(H) {
      if (this.next(), L0.test(this.input.slice(this.lastTokEnd, this.start)))
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      return H.argument = this.parseExpression(), this.semicolon(), this.finishNode(H, "ThrowStatement");
    };
    var tW = [];
    o.parseTryStatement = function(H) {
      if (this.next(), H.block = this.parseBlock(), H.handler = null, this.type === R._catch) {
        var G = this.startNode();
        if (this.next(), this.eat(R.parenL)) {
          G.param = this.parseBindingAtom();
          var K = G.param.type === "Identifier";
          this.enterScope(K ? n1 : 0), this.checkLVal(G.param, K ? KQ : I1), this.expect(R.parenR);
        } else {
          if (this.options.ecmaVersion < 10)
            this.unexpected();
          G.param = null, this.enterScope(0);
        }
        G.body = this.parseBlock(!1), this.exitScope(), H.handler = this.finishNode(G, "CatchClause");
      }
      if (H.finalizer = this.eat(R._finally) ? this.parseBlock() : null, !H.handler && !H.finalizer)
        this.raise(H.start, "Missing catch or finally clause");
      return this.finishNode(H, "TryStatement");
    }, o.parseVarStatement = function(H, G) {
      return this.next(), this.parseVar(H, !1, G), this.semicolon(), this.finishNode(H, "VariableDeclaration");
    }, o.parseWhileStatement = function(H) {
      return this.next(), H.test = this.parseParenExpression(), this.labels.push(h7), H.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(H, "WhileStatement");
    }, o.parseWithStatement = function(H) {
      if (this.strict)
        this.raise(this.start, "'with' in strict mode");
      return this.next(), H.object = this.parseParenExpression(), H.body = this.parseStatement("with"), this.finishNode(H, "WithStatement");
    }, o.parseEmptyStatement = function(H) {
      return this.next(), this.finishNode(H, "EmptyStatement");
    }, o.parseLabeledStatement = function(H, G, K, j) {
      for (var I = 0, w = this.labels;I < w.length; I += 1) {
        var v = w[I];
        if (v.name === G)
          this.raise(K.start, "Label '" + G + "' is already declared");
      }
      var f = this.type.isLoop ? "loop" : this.type === R._switch ? "switch" : null;
      for (var l = this.labels.length - 1;l >= 0; l--) {
        var G0 = this.labels[l];
        if (G0.statementStart === H.start)
          G0.statementStart = this.start, G0.kind = f;
        else
          break;
      }
      return this.labels.push({ name: G, kind: f, statementStart: this.start }), H.body = this.parseStatement(j ? j.indexOf("label") === -1 ? j + "label" : j : "label"), this.labels.pop(), H.label = K, this.finishNode(H, "LabeledStatement");
    }, o.parseExpressionStatement = function(H, G) {
      return H.expression = G, this.semicolon(), this.finishNode(H, "ExpressionStatement");
    }, o.parseBlock = function(H, G, K) {
      if (H === void 0)
        H = !0;
      if (G === void 0)
        G = this.startNode();
      if (G.body = [], this.expect(R.braceL), H)
        this.enterScope(0);
      while (this.type !== R.braceR) {
        var j = this.parseStatement(null);
        G.body.push(j);
      }
      if (K)
        this.strict = !1;
      if (this.next(), H)
        this.exitScope();
      return this.finishNode(G, "BlockStatement");
    }, o.parseFor = function(H, G) {
      return H.init = G, this.expect(R.semi), H.test = this.type === R.semi ? null : this.parseExpression(), this.expect(R.semi), H.update = this.type === R.parenR ? null : this.parseExpression(), this.expect(R.parenR), H.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(H, "ForStatement");
    }, o.parseForIn = function(H, G) {
      var K = this.type === R._in;
      if (this.next(), G.type === "VariableDeclaration" && G.declarations[0].init != null && (!K || this.options.ecmaVersion < 8 || this.strict || G.kind !== "var" || G.declarations[0].id.type !== "Identifier"))
        this.raise(G.start, (K ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
      else if (G.type === "AssignmentPattern")
        this.raise(G.start, "Invalid left-hand side in for-loop");
      return H.left = G, H.right = K ? this.parseExpression() : this.parseMaybeAssign(), this.expect(R.parenR), H.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(H, K ? "ForInStatement" : "ForOfStatement");
    }, o.parseVar = function(H, G, K) {
      H.declarations = [], H.kind = K;
      for (;; ) {
        var j = this.startNode();
        if (this.parseVarId(j, K), this.eat(R.eq))
          j.init = this.parseMaybeAssign(G);
        else if (K === "const" && !(this.type === R._in || this.options.ecmaVersion >= 6 && this.isContextual("of")))
          this.unexpected();
        else if (j.id.type !== "Identifier" && !(G && (this.type === R._in || this.isContextual("of"))))
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        else
          j.init = null;
        if (H.declarations.push(this.finishNode(j, "VariableDeclarator")), !this.eat(R.comma))
          break;
      }
      return H;
    }, o.parseVarId = function(H, G) {
      H.id = this.parseBindingAtom(), this.checkLVal(H.id, G === "var" ? g7 : I1, !1);
    };
    var l5 = 1, _7 = 2, FQ = 4;
    o.parseFunction = function(H, G, K, j) {
      if (this.initFunction(H), this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !j) {
        if (this.type === R.star && G & _7)
          this.unexpected();
        H.generator = this.eat(R.star);
      }
      if (this.options.ecmaVersion >= 8)
        H.async = !!j;
      if (G & l5) {
        if (H.id = G & FQ && this.type !== R.name ? null : this.parseIdent(), H.id && !(G & _7))
          this.checkLVal(H.id, this.strict || H.generator || H.async ? this.treatFunctionsAsVar ? g7 : I1 : VQ);
      }
      var I = this.yieldPos, w = this.awaitPos, v = this.awaitIdentPos;
      if (this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(B5(H.async, H.generator)), !(G & l5))
        H.id = this.type === R.name ? this.parseIdent() : null;
      return this.parseFunctionParams(H), this.parseFunctionBody(H, K, !1), this.yieldPos = I, this.awaitPos = w, this.awaitIdentPos = v, this.finishNode(H, G & l5 ? "FunctionDeclaration" : "FunctionExpression");
    }, o.parseFunctionParams = function(H) {
      this.expect(R.parenL), H.params = this.parseBindingList(R.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
    }, o.parseClass = function(H, G) {
      this.next();
      var K = this.strict;
      this.strict = !0, this.parseClassId(H, G), this.parseClassSuper(H);
      var j = this.startNode(), I = !1;
      j.body = [], this.expect(R.braceL);
      while (this.type !== R.braceR) {
        var w = this.parseClassElement(H.superClass !== null);
        if (w) {
          if (j.body.push(w), w.type === "MethodDefinition" && w.kind === "constructor") {
            if (I)
              this.raise(w.start, "Duplicate constructor in the same class");
            I = !0;
          }
        }
      }
      return this.strict = K, this.next(), H.body = this.finishNode(j, "ClassBody"), this.finishNode(H, G ? "ClassDeclaration" : "ClassExpression");
    }, o.parseClassElement = function(H) {
      var G = this;
      if (this.eat(R.semi))
        return null;
      var K = this.startNode(), j = function(l, G0) {
        if (G0 === void 0)
          G0 = !1;
        var { start: I0, startLoc: f0 } = G;
        if (!G.eatContextual(l))
          return !1;
        if (G.type !== R.parenL && (!G0 || !G.canInsertSemicolon()))
          return !0;
        if (K.key)
          G.unexpected();
        return K.computed = !1, K.key = G.startNodeAt(I0, f0), K.key.name = l, G.finishNode(K.key, "Identifier"), !1;
      };
      K.kind = "method", K.static = j("static");
      var I = this.eat(R.star), w = !1;
      if (!I) {
        if (this.options.ecmaVersion >= 8 && j("async", !0))
          w = !0, I = this.options.ecmaVersion >= 9 && this.eat(R.star);
        else if (j("get"))
          K.kind = "get";
        else if (j("set"))
          K.kind = "set";
      }
      if (!K.key)
        this.parsePropertyName(K);
      var v = K.key, f = !1;
      if (!K.computed && !K.static && (v.type === "Identifier" && v.name === "constructor" || v.type === "Literal" && v.value === "constructor")) {
        if (K.kind !== "method")
          this.raise(v.start, "Constructor can't have get/set modifier");
        if (I)
          this.raise(v.start, "Constructor can't be a generator");
        if (w)
          this.raise(v.start, "Constructor can't be an async method");
        K.kind = "constructor", f = H;
      } else if (K.static && v.type === "Identifier" && v.name === "prototype")
        this.raise(v.start, "Classes may not have a static property named prototype");
      if (this.parseClassMethod(K, I, w, f), K.kind === "get" && K.value.params.length !== 0)
        this.raiseRecoverable(K.value.start, "getter should have no params");
      if (K.kind === "set" && K.value.params.length !== 1)
        this.raiseRecoverable(K.value.start, "setter should have exactly one param");
      if (K.kind === "set" && K.value.params[0].type === "RestElement")
        this.raiseRecoverable(K.value.params[0].start, "Setter cannot use rest params");
      return K;
    }, o.parseClassMethod = function(H, G, K, j) {
      return H.value = this.parseMethod(G, K, j), this.finishNode(H, "MethodDefinition");
    }, o.parseClassId = function(H, G) {
      if (this.type === R.name) {
        if (H.id = this.parseIdent(), G)
          this.checkLVal(H.id, I1, !1);
      } else {
        if (G === !0)
          this.unexpected();
        H.id = null;
      }
    }, o.parseClassSuper = function(H) {
      H.superClass = this.eat(R._extends) ? this.parseExprSubscripts() : null;
    }, o.parseExport = function(H, G) {
      if (this.next(), this.eat(R.star)) {
        if (this.options.ecmaVersion >= 11)
          if (this.eatContextual("as"))
            H.exported = this.parseIdent(!0), this.checkExport(G, H.exported.name, this.lastTokStart);
          else
            H.exported = null;
        if (this.expectContextual("from"), this.type !== R.string)
          this.unexpected();
        return H.source = this.parseExprAtom(), this.semicolon(), this.finishNode(H, "ExportAllDeclaration");
      }
      if (this.eat(R._default)) {
        this.checkExport(G, "default", this.lastTokStart);
        var K;
        if (this.type === R._function || (K = this.isAsyncFunction())) {
          var j = this.startNode();
          if (this.next(), K)
            this.next();
          H.declaration = this.parseFunction(j, l5 | FQ, !1, K);
        } else if (this.type === R._class) {
          var I = this.startNode();
          H.declaration = this.parseClass(I, "nullableID");
        } else
          H.declaration = this.parseMaybeAssign(), this.semicolon();
        return this.finishNode(H, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        if (H.declaration = this.parseStatement(null), H.declaration.type === "VariableDeclaration")
          this.checkVariableExport(G, H.declaration.declarations);
        else
          this.checkExport(G, H.declaration.id.name, H.declaration.id.start);
        H.specifiers = [], H.source = null;
      } else {
        if (H.declaration = null, H.specifiers = this.parseExportSpecifiers(G), this.eatContextual("from")) {
          if (this.type !== R.string)
            this.unexpected();
          H.source = this.parseExprAtom();
        } else {
          for (var w = 0, v = H.specifiers;w < v.length; w += 1) {
            var f = v[w];
            this.checkUnreserved(f.local), this.checkLocalExport(f.local);
          }
          H.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(H, "ExportNamedDeclaration");
    }, o.checkExport = function(H, G, K) {
      if (!H)
        return;
      if ($0(H, G))
        this.raiseRecoverable(K, "Duplicate export '" + G + "'");
      H[G] = !0;
    }, o.checkPatternExport = function(H, G) {
      var K = G.type;
      if (K === "Identifier")
        this.checkExport(H, G.name, G.start);
      else if (K === "ObjectPattern")
        for (var j = 0, I = G.properties;j < I.length; j += 1) {
          var w = I[j];
          this.checkPatternExport(H, w);
        }
      else if (K === "ArrayPattern")
        for (var v = 0, f = G.elements;v < f.length; v += 1) {
          var l = f[v];
          if (l)
            this.checkPatternExport(H, l);
        }
      else if (K === "Property")
        this.checkPatternExport(H, G.value);
      else if (K === "AssignmentPattern")
        this.checkPatternExport(H, G.left);
      else if (K === "RestElement")
        this.checkPatternExport(H, G.argument);
      else if (K === "ParenthesizedExpression")
        this.checkPatternExport(H, G.expression);
    }, o.checkVariableExport = function(H, G) {
      if (!H)
        return;
      for (var K = 0, j = G;K < j.length; K += 1) {
        var I = j[K];
        this.checkPatternExport(H, I.id);
      }
    }, o.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    }, o.parseExportSpecifiers = function(H) {
      var G = [], K = !0;
      this.expect(R.braceL);
      while (!this.eat(R.braceR)) {
        if (!K) {
          if (this.expect(R.comma), this.afterTrailingComma(R.braceR))
            break;
        } else
          K = !1;
        var j = this.startNode();
        j.local = this.parseIdent(!0), j.exported = this.eatContextual("as") ? this.parseIdent(!0) : j.local, this.checkExport(H, j.exported.name, j.exported.start), G.push(this.finishNode(j, "ExportSpecifier"));
      }
      return G;
    }, o.parseImport = function(H) {
      if (this.next(), this.type === R.string)
        H.specifiers = tW, H.source = this.parseExprAtom();
      else
        H.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), H.source = this.type === R.string ? this.parseExprAtom() : this.unexpected();
      return this.semicolon(), this.finishNode(H, "ImportDeclaration");
    }, o.parseImportSpecifiers = function() {
      var H = [], G = !0;
      if (this.type === R.name) {
        var K = this.startNode();
        if (K.local = this.parseIdent(), this.checkLVal(K.local, I1), H.push(this.finishNode(K, "ImportDefaultSpecifier")), !this.eat(R.comma))
          return H;
      }
      if (this.type === R.star) {
        var j = this.startNode();
        return this.next(), this.expectContextual("as"), j.local = this.parseIdent(), this.checkLVal(j.local, I1), H.push(this.finishNode(j, "ImportNamespaceSpecifier")), H;
      }
      this.expect(R.braceL);
      while (!this.eat(R.braceR)) {
        if (!G) {
          if (this.expect(R.comma), this.afterTrailingComma(R.braceR))
            break;
        } else
          G = !1;
        var I = this.startNode();
        if (I.imported = this.parseIdent(!0), this.eatContextual("as"))
          I.local = this.parseIdent();
        else
          this.checkUnreserved(I.imported), I.local = I.imported;
        this.checkLVal(I.local, I1), H.push(this.finishNode(I, "ImportSpecifier"));
      }
      return H;
    }, o.adaptDirectivePrologue = function(H) {
      for (var G = 0;G < H.length && this.isDirectiveCandidate(H[G]); ++G)
        H[G].directive = H[G].expression.raw.slice(1, -1);
    }, o.isDirectiveCandidate = function(H) {
      return H.type === "ExpressionStatement" && H.expression.type === "Literal" && typeof H.expression.value === "string" && (this.input[H.start] === "\"" || this.input[H.start] === "'");
    };
    var C1 = C0.prototype;
    C1.toAssignable = function(H, G, K) {
      if (this.options.ecmaVersion >= 6 && H)
        switch (H.type) {
          case "Identifier":
            if (this.inAsync && H.name === "await")
              this.raise(H.start, "Cannot use 'await' as identifier inside an async function");
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            if (H.type = "ObjectPattern", K)
              this.checkPatternErrors(K, !0);
            for (var j = 0, I = H.properties;j < I.length; j += 1) {
              var w = I[j];
              if (this.toAssignable(w, G), w.type === "RestElement" && (w.argument.type === "ArrayPattern" || w.argument.type === "ObjectPattern"))
                this.raise(w.argument.start, "Unexpected token");
            }
            break;
          case "Property":
            if (H.kind !== "init")
              this.raise(H.key.start, "Object pattern can't contain getter or setter");
            this.toAssignable(H.value, G);
            break;
          case "ArrayExpression":
            if (H.type = "ArrayPattern", K)
              this.checkPatternErrors(K, !0);
            this.toAssignableList(H.elements, G);
            break;
          case "SpreadElement":
            if (H.type = "RestElement", this.toAssignable(H.argument, G), H.argument.type === "AssignmentPattern")
              this.raise(H.argument.start, "Rest elements cannot have a default value");
            break;
          case "AssignmentExpression":
            if (H.operator !== "=")
              this.raise(H.left.end, "Only '=' operator can be used for specifying default value.");
            H.type = "AssignmentPattern", delete H.operator, this.toAssignable(H.left, G);
          case "AssignmentPattern":
            break;
          case "ParenthesizedExpression":
            this.toAssignable(H.expression, G, K);
            break;
          case "ChainExpression":
            this.raiseRecoverable(H.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!G)
              break;
          default:
            this.raise(H.start, "Assigning to rvalue");
        }
      else if (K)
        this.checkPatternErrors(K, !0);
      return H;
    }, C1.toAssignableList = function(H, G) {
      var K = H.length;
      for (var j = 0;j < K; j++) {
        var I = H[j];
        if (I)
          this.toAssignable(I, G);
      }
      if (K) {
        var w = H[K - 1];
        if (this.options.ecmaVersion === 6 && G && w && w.type === "RestElement" && w.argument.type !== "Identifier")
          this.unexpected(w.argument.start);
      }
      return H;
    }, C1.parseSpread = function(H) {
      var G = this.startNode();
      return this.next(), G.argument = this.parseMaybeAssign(!1, H), this.finishNode(G, "SpreadElement");
    }, C1.parseRestBinding = function() {
      var H = this.startNode();
      if (this.next(), this.options.ecmaVersion === 6 && this.type !== R.name)
        this.unexpected();
      return H.argument = this.parseBindingAtom(), this.finishNode(H, "RestElement");
    }, C1.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6)
        switch (this.type) {
          case R.bracketL:
            var H = this.startNode();
            return this.next(), H.elements = this.parseBindingList(R.bracketR, !0, !0), this.finishNode(H, "ArrayPattern");
          case R.braceL:
            return this.parseObj(!0);
        }
      return this.parseIdent();
    }, C1.parseBindingList = function(H, G, K) {
      var j = [], I = !0;
      while (!this.eat(H)) {
        if (I)
          I = !1;
        else
          this.expect(R.comma);
        if (G && this.type === R.comma)
          j.push(null);
        else if (K && this.afterTrailingComma(H))
          break;
        else if (this.type === R.ellipsis) {
          var w = this.parseRestBinding();
          if (this.parseBindingListItem(w), j.push(w), this.type === R.comma)
            this.raise(this.start, "Comma is not permitted after the rest element");
          this.expect(H);
          break;
        } else {
          var v = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(v), j.push(v);
        }
      }
      return j;
    }, C1.parseBindingListItem = function(H) {
      return H;
    }, C1.parseMaybeDefault = function(H, G, K) {
      if (K = K || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(R.eq))
        return K;
      var j = this.startNodeAt(H, G);
      return j.left = K, j.right = this.parseMaybeAssign(), this.finishNode(j, "AssignmentPattern");
    }, C1.checkLVal = function(H, G, K) {
      if (G === void 0)
        G = UQ;
      switch (H.type) {
        case "Identifier":
          if (G === I1 && H.name === "let")
            this.raiseRecoverable(H.start, "let is disallowed as a lexically bound name");
          if (this.strict && this.reservedWordsStrictBind.test(H.name))
            this.raiseRecoverable(H.start, (G ? "Binding " : "Assigning to ") + H.name + " in strict mode");
          if (K) {
            if ($0(K, H.name))
              this.raiseRecoverable(H.start, "Argument name clash");
            K[H.name] = !0;
          }
          if (G !== UQ && G !== MQ)
            this.declareName(H.name, G, H.start);
          break;
        case "ChainExpression":
          this.raiseRecoverable(H.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (G)
            this.raiseRecoverable(H.start, "Binding member expression");
          break;
        case "ObjectPattern":
          for (var j = 0, I = H.properties;j < I.length; j += 1) {
            var w = I[j];
            this.checkLVal(w, G, K);
          }
          break;
        case "Property":
          this.checkLVal(H.value, G, K);
          break;
        case "ArrayPattern":
          for (var v = 0, f = H.elements;v < f.length; v += 1) {
            var l = f[v];
            if (l)
              this.checkLVal(l, G, K);
          }
          break;
        case "AssignmentPattern":
          this.checkLVal(H.left, G, K);
          break;
        case "RestElement":
          this.checkLVal(H.argument, G, K);
          break;
        case "ParenthesizedExpression":
          this.checkLVal(H.expression, G, K);
          break;
        default:
          this.raise(H.start, (G ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    var J0 = C0.prototype;
    J0.checkPropClash = function(H, G, K) {
      if (this.options.ecmaVersion >= 9 && H.type === "SpreadElement")
        return;
      if (this.options.ecmaVersion >= 6 && (H.computed || H.method || H.shorthand))
        return;
      var j = H.key, I;
      switch (j.type) {
        case "Identifier":
          I = j.name;
          break;
        case "Literal":
          I = String(j.value);
          break;
        default:
          return;
      }
      var w = H.kind;
      if (this.options.ecmaVersion >= 6) {
        if (I === "__proto__" && w === "init") {
          if (G.proto)
            if (K) {
              if (K.doubleProto < 0)
                K.doubleProto = j.start;
            } else
              this.raiseRecoverable(j.start, "Redefinition of __proto__ property");
          G.proto = !0;
        }
        return;
      }
      I = "$" + I;
      var v = G[I];
      if (v) {
        var f;
        if (w === "init")
          f = this.strict && v.init || v.get || v.set;
        else
          f = v.init || v[w];
        if (f)
          this.raiseRecoverable(j.start, "Redefinition of property");
      } else
        v = G[I] = {
          init: !1,
          get: !1,
          set: !1
        };
      v[w] = !0;
    }, J0.parseExpression = function(H, G) {
      var K = this.start, j = this.startLoc, I = this.parseMaybeAssign(H, G);
      if (this.type === R.comma) {
        var w = this.startNodeAt(K, j);
        w.expressions = [I];
        while (this.eat(R.comma))
          w.expressions.push(this.parseMaybeAssign(H, G));
        return this.finishNode(w, "SequenceExpression");
      }
      return I;
    }, J0.parseMaybeAssign = function(H, G, K) {
      if (this.isContextual("yield"))
        if (this.inGenerator)
          return this.parseYield(H);
        else
          this.exprAllowed = !1;
      var j = !1, I = -1, w = -1;
      if (G)
        I = G.parenthesizedAssign, w = G.trailingComma, G.parenthesizedAssign = G.trailingComma = -1;
      else
        G = new N8, j = !0;
      var v = this.start, f = this.startLoc;
      if (this.type === R.parenL || this.type === R.name)
        this.potentialArrowAt = this.start;
      var l = this.parseMaybeConditional(H, G);
      if (K)
        l = K.call(this, l, v, f);
      if (this.type.isAssign) {
        var G0 = this.startNodeAt(v, f);
        if (G0.operator = this.value, G0.left = this.type === R.eq ? this.toAssignable(l, !1, G) : l, !j)
          G.parenthesizedAssign = G.trailingComma = G.doubleProto = -1;
        if (G.shorthandAssign >= G0.left.start)
          G.shorthandAssign = -1;
        return this.checkLVal(l), this.next(), G0.right = this.parseMaybeAssign(H), this.finishNode(G0, "AssignmentExpression");
      } else if (j)
        this.checkExpressionErrors(G, !0);
      if (I > -1)
        G.parenthesizedAssign = I;
      if (w > -1)
        G.trailingComma = w;
      return l;
    }, J0.parseMaybeConditional = function(H, G) {
      var K = this.start, j = this.startLoc, I = this.parseExprOps(H, G);
      if (this.checkExpressionErrors(G))
        return I;
      if (this.eat(R.question)) {
        var w = this.startNodeAt(K, j);
        return w.test = I, w.consequent = this.parseMaybeAssign(), this.expect(R.colon), w.alternate = this.parseMaybeAssign(H), this.finishNode(w, "ConditionalExpression");
      }
      return I;
    }, J0.parseExprOps = function(H, G) {
      var K = this.start, j = this.startLoc, I = this.parseMaybeUnary(G, !1);
      if (this.checkExpressionErrors(G))
        return I;
      return I.start === K && I.type === "ArrowFunctionExpression" ? I : this.parseExprOp(I, K, j, -1, H);
    }, J0.parseExprOp = function(H, G, K, j, I) {
      var w = this.type.binop;
      if (w != null && (!I || this.type !== R._in)) {
        if (w > j) {
          var v = this.type === R.logicalOR || this.type === R.logicalAND, f = this.type === R.coalesce;
          if (f)
            w = R.logicalAND.binop;
          var l = this.value;
          this.next();
          var G0 = this.start, I0 = this.startLoc, f0 = this.parseExprOp(this.parseMaybeUnary(null, !1), G0, I0, w, I), o1 = this.buildBinary(G, K, H, f0, l, v || f);
          if (v && this.type === R.coalesce || f && (this.type === R.logicalOR || this.type === R.logicalAND))
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          return this.parseExprOp(o1, G, K, j, I);
        }
      }
      return H;
    }, J0.buildBinary = function(H, G, K, j, I, w) {
      var v = this.startNodeAt(H, G);
      return v.left = K, v.operator = I, v.right = j, this.finishNode(v, w ? "LogicalExpression" : "BinaryExpression");
    }, J0.parseMaybeUnary = function(H, G) {
      var K = this.start, j = this.startLoc, I;
      if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
        I = this.parseAwait(), G = !0;
      else if (this.type.prefix) {
        var w = this.startNode(), v = this.type === R.incDec;
        if (w.operator = this.value, w.prefix = !0, this.next(), w.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(H, !0), v)
          this.checkLVal(w.argument);
        else if (this.strict && w.operator === "delete" && w.argument.type === "Identifier")
          this.raiseRecoverable(w.start, "Deleting local variable in strict mode");
        else
          G = !0;
        I = this.finishNode(w, v ? "UpdateExpression" : "UnaryExpression");
      } else {
        if (I = this.parseExprSubscripts(H), this.checkExpressionErrors(H))
          return I;
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var f = this.startNodeAt(K, j);
          f.operator = this.value, f.prefix = !1, f.argument = I, this.checkLVal(I), this.next(), I = this.finishNode(f, "UpdateExpression");
        }
      }
      if (!G && this.eat(R.starstar))
        return this.buildBinary(K, j, I, this.parseMaybeUnary(null, !1), "**", !1);
      else
        return I;
    }, J0.parseExprSubscripts = function(H) {
      var G = this.start, K = this.startLoc, j = this.parseExprAtom(H);
      if (j.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
        return j;
      var I = this.parseSubscripts(j, G, K);
      if (H && I.type === "MemberExpression") {
        if (H.parenthesizedAssign >= I.start)
          H.parenthesizedAssign = -1;
        if (H.parenthesizedBind >= I.start)
          H.parenthesizedBind = -1;
      }
      return I;
    }, J0.parseSubscripts = function(H, G, K, j) {
      var I = this.options.ecmaVersion >= 8 && H.type === "Identifier" && H.name === "async" && this.lastTokEnd === H.end && !this.canInsertSemicolon() && H.end - H.start === 5 && this.potentialArrowAt === H.start, w = !1;
      while (!0) {
        var v = this.parseSubscript(H, G, K, j, I, w);
        if (v.optional)
          w = !0;
        if (v === H || v.type === "ArrowFunctionExpression") {
          if (w) {
            var f = this.startNodeAt(G, K);
            f.expression = v, v = this.finishNode(f, "ChainExpression");
          }
          return v;
        }
        H = v;
      }
    }, J0.parseSubscript = function(H, G, K, j, I, w) {
      var v = this.options.ecmaVersion >= 11, f = v && this.eat(R.questionDot);
      if (j && f)
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      var l = this.eat(R.bracketL);
      if (l || f && this.type !== R.parenL && this.type !== R.backQuote || this.eat(R.dot)) {
        var G0 = this.startNodeAt(G, K);
        if (G0.object = H, G0.property = l ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), G0.computed = !!l, l)
          this.expect(R.bracketR);
        if (v)
          G0.optional = f;
        H = this.finishNode(G0, "MemberExpression");
      } else if (!j && this.eat(R.parenL)) {
        var I0 = new N8, f0 = this.yieldPos, o1 = this.awaitPos, q5 = this.awaitIdentPos;
        this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
        var g8 = this.parseExprList(R.parenR, this.options.ecmaVersion >= 8, !1, I0);
        if (I && !f && !this.canInsertSemicolon() && this.eat(R.arrow)) {
          if (this.checkPatternErrors(I0, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0)
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          return this.yieldPos = f0, this.awaitPos = o1, this.awaitIdentPos = q5, this.parseArrowExpression(this.startNodeAt(G, K), g8, !0);
        }
        this.checkExpressionErrors(I0, !0), this.yieldPos = f0 || this.yieldPos, this.awaitPos = o1 || this.awaitPos, this.awaitIdentPos = q5 || this.awaitIdentPos;
        var $5 = this.startNodeAt(G, K);
        if ($5.callee = H, $5.arguments = g8, v)
          $5.optional = f;
        H = this.finishNode($5, "CallExpression");
      } else if (this.type === R.backQuote) {
        if (f || w)
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        var D5 = this.startNodeAt(G, K);
        D5.tag = H, D5.quasi = this.parseTemplate({ isTagged: !0 }), H = this.finishNode(D5, "TaggedTemplateExpression");
      }
      return H;
    }, J0.parseExprAtom = function(H) {
      if (this.type === R.slash)
        this.readRegexp();
      var G, K = this.potentialArrowAt === this.start;
      switch (this.type) {
        case R._super:
          if (!this.allowSuper)
            this.raise(this.start, "'super' keyword outside a method");
          if (G = this.startNode(), this.next(), this.type === R.parenL && !this.allowDirectSuper)
            this.raise(G.start, "super() call outside constructor of a subclass");
          if (this.type !== R.dot && this.type !== R.bracketL && this.type !== R.parenL)
            this.unexpected();
          return this.finishNode(G, "Super");
        case R._this:
          return G = this.startNode(), this.next(), this.finishNode(G, "ThisExpression");
        case R.name:
          var j = this.start, I = this.startLoc, w = this.containsEsc, v = this.parseIdent(!1);
          if (this.options.ecmaVersion >= 8 && !w && v.name === "async" && !this.canInsertSemicolon() && this.eat(R._function))
            return this.parseFunction(this.startNodeAt(j, I), 0, !1, !0);
          if (K && !this.canInsertSemicolon()) {
            if (this.eat(R.arrow))
              return this.parseArrowExpression(this.startNodeAt(j, I), [v], !1);
            if (this.options.ecmaVersion >= 8 && v.name === "async" && this.type === R.name && !w) {
              if (v = this.parseIdent(!1), this.canInsertSemicolon() || !this.eat(R.arrow))
                this.unexpected();
              return this.parseArrowExpression(this.startNodeAt(j, I), [v], !0);
            }
          }
          return v;
        case R.regexp:
          var f = this.value;
          return G = this.parseLiteral(f.value), G.regex = { pattern: f.pattern, flags: f.flags }, G;
        case R.num:
        case R.string:
          return this.parseLiteral(this.value);
        case R._null:
        case R._true:
        case R._false:
          return G = this.startNode(), G.value = this.type === R._null ? null : this.type === R._true, G.raw = this.type.keyword, this.next(), this.finishNode(G, "Literal");
        case R.parenL:
          var l = this.start, G0 = this.parseParenAndDistinguishExpression(K);
          if (H) {
            if (H.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(G0))
              H.parenthesizedAssign = l;
            if (H.parenthesizedBind < 0)
              H.parenthesizedBind = l;
          }
          return G0;
        case R.bracketL:
          return G = this.startNode(), this.next(), G.elements = this.parseExprList(R.bracketR, !0, !0, H), this.finishNode(G, "ArrayExpression");
        case R.braceL:
          return this.parseObj(!1, H);
        case R._function:
          return G = this.startNode(), this.next(), this.parseFunction(G, 0);
        case R._class:
          return this.parseClass(this.startNode(), !1);
        case R._new:
          return this.parseNew();
        case R.backQuote:
          return this.parseTemplate();
        case R._import:
          if (this.options.ecmaVersion >= 11)
            return this.parseExprImport();
          else
            return this.unexpected();
        default:
          this.unexpected();
      }
    }, J0.parseExprImport = function() {
      var H = this.startNode();
      if (this.containsEsc)
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      var G = this.parseIdent(!0);
      switch (this.type) {
        case R.parenL:
          return this.parseDynamicImport(H);
        case R.dot:
          return H.meta = G, this.parseImportMeta(H);
        default:
          this.unexpected();
      }
    }, J0.parseDynamicImport = function(H) {
      if (this.next(), H.source = this.parseMaybeAssign(), !this.eat(R.parenR)) {
        var G = this.start;
        if (this.eat(R.comma) && this.eat(R.parenR))
          this.raiseRecoverable(G, "Trailing comma is not allowed in import()");
        else
          this.unexpected(G);
      }
      return this.finishNode(H, "ImportExpression");
    }, J0.parseImportMeta = function(H) {
      this.next();
      var G = this.containsEsc;
      if (H.property = this.parseIdent(!0), H.property.name !== "meta")
        this.raiseRecoverable(H.property.start, "The only valid meta property for import is 'import.meta'");
      if (G)
        this.raiseRecoverable(H.start, "'import.meta' must not contain escaped characters");
      if (this.options.sourceType !== "module")
        this.raiseRecoverable(H.start, "Cannot use 'import.meta' outside a module");
      return this.finishNode(H, "MetaProperty");
    }, J0.parseLiteral = function(H) {
      var G = this.startNode();
      if (G.value = H, G.raw = this.input.slice(this.start, this.end), G.raw.charCodeAt(G.raw.length - 1) === 110)
        G.bigint = G.raw.slice(0, -1).replace(/_/g, "");
      return this.next(), this.finishNode(G, "Literal");
    }, J0.parseParenExpression = function() {
      this.expect(R.parenL);
      var H = this.parseExpression();
      return this.expect(R.parenR), H;
    }, J0.parseParenAndDistinguishExpression = function(H) {
      var G = this.start, K = this.startLoc, j, I = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var w = this.start, v = this.startLoc, f = [], l = !0, G0 = !1, I0 = new N8, f0 = this.yieldPos, o1 = this.awaitPos, q5;
        this.yieldPos = 0, this.awaitPos = 0;
        while (this.type !== R.parenR)
          if (l ? l = !1 : this.expect(R.comma), I && this.afterTrailingComma(R.parenR, !0)) {
            G0 = !0;
            break;
          } else if (this.type === R.ellipsis) {
            if (q5 = this.start, f.push(this.parseParenItem(this.parseRestBinding())), this.type === R.comma)
              this.raise(this.start, "Comma is not permitted after the rest element");
            break;
          } else
            f.push(this.parseMaybeAssign(!1, I0, this.parseParenItem));
        var g8 = this.start, $5 = this.startLoc;
        if (this.expect(R.parenR), H && !this.canInsertSemicolon() && this.eat(R.arrow))
          return this.checkPatternErrors(I0, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f0, this.awaitPos = o1, this.parseParenArrowList(G, K, f);
        if (!f.length || G0)
          this.unexpected(this.lastTokStart);
        if (q5)
          this.unexpected(q5);
        if (this.checkExpressionErrors(I0, !0), this.yieldPos = f0 || this.yieldPos, this.awaitPos = o1 || this.awaitPos, f.length > 1)
          j = this.startNodeAt(w, v), j.expressions = f, this.finishNodeAt(j, "SequenceExpression", g8, $5);
        else
          j = f[0];
      } else
        j = this.parseParenExpression();
      if (this.options.preserveParens) {
        var D5 = this.startNodeAt(G, K);
        return D5.expression = j, this.finishNode(D5, "ParenthesizedExpression");
      } else
        return j;
    }, J0.parseParenItem = function(H) {
      return H;
    }, J0.parseParenArrowList = function(H, G, K) {
      return this.parseArrowExpression(this.startNodeAt(H, G), K);
    };
    var oW = [];
    J0.parseNew = function() {
      if (this.containsEsc)
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      var H = this.startNode(), G = this.parseIdent(!0);
      if (this.options.ecmaVersion >= 6 && this.eat(R.dot)) {
        H.meta = G;
        var K = this.containsEsc;
        if (H.property = this.parseIdent(!0), H.property.name !== "target")
          this.raiseRecoverable(H.property.start, "The only valid meta property for new is 'new.target'");
        if (K)
          this.raiseRecoverable(H.start, "'new.target' must not contain escaped characters");
        if (!this.inNonArrowFunction())
          this.raiseRecoverable(H.start, "'new.target' can only be used in functions");
        return this.finishNode(H, "MetaProperty");
      }
      var j = this.start, I = this.startLoc, w = this.type === R._import;
      if (H.callee = this.parseSubscripts(this.parseExprAtom(), j, I, !0), w && H.callee.type === "ImportExpression")
        this.raise(j, "Cannot use new with import()");
      if (this.eat(R.parenL))
        H.arguments = this.parseExprList(R.parenR, this.options.ecmaVersion >= 8, !1);
      else
        H.arguments = oW;
      return this.finishNode(H, "NewExpression");
    }, J0.parseTemplateElement = function(H) {
      var G = H.isTagged, K = this.startNode();
      if (this.type === R.invalidTemplate) {
        if (!G)
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        K.value = {
          raw: this.value,
          cooked: null
        };
      } else
        K.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      return this.next(), K.tail = this.type === R.backQuote, this.finishNode(K, "TemplateElement");
    }, J0.parseTemplate = function(H) {
      if (H === void 0)
        H = {};
      var G = H.isTagged;
      if (G === void 0)
        G = !1;
      var K = this.startNode();
      this.next(), K.expressions = [];
      var j = this.parseTemplateElement({ isTagged: G });
      K.quasis = [j];
      while (!j.tail) {
        if (this.type === R.eof)
          this.raise(this.pos, "Unterminated template literal");
        this.expect(R.dollarBraceL), K.expressions.push(this.parseExpression()), this.expect(R.braceR), K.quasis.push(j = this.parseTemplateElement({ isTagged: G }));
      }
      return this.next(), this.finishNode(K, "TemplateLiteral");
    }, J0.isAsyncProp = function(H) {
      return !H.computed && H.key.type === "Identifier" && H.key.name === "async" && (this.type === R.name || this.type === R.num || this.type === R.string || this.type === R.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === R.star) && !L0.test(this.input.slice(this.lastTokEnd, this.start));
    }, J0.parseObj = function(H, G) {
      var K = this.startNode(), j = !0, I = {};
      K.properties = [], this.next();
      while (!this.eat(R.braceR)) {
        if (!j) {
          if (this.expect(R.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(R.braceR))
            break;
        } else
          j = !1;
        var w = this.parseProperty(H, G);
        if (!H)
          this.checkPropClash(w, I, G);
        K.properties.push(w);
      }
      return this.finishNode(K, H ? "ObjectPattern" : "ObjectExpression");
    }, J0.parseProperty = function(H, G) {
      var K = this.startNode(), j, I, w, v;
      if (this.options.ecmaVersion >= 9 && this.eat(R.ellipsis)) {
        if (H) {
          if (K.argument = this.parseIdent(!1), this.type === R.comma)
            this.raise(this.start, "Comma is not permitted after the rest element");
          return this.finishNode(K, "RestElement");
        }
        if (this.type === R.parenL && G) {
          if (G.parenthesizedAssign < 0)
            G.parenthesizedAssign = this.start;
          if (G.parenthesizedBind < 0)
            G.parenthesizedBind = this.start;
        }
        if (K.argument = this.parseMaybeAssign(!1, G), this.type === R.comma && G && G.trailingComma < 0)
          G.trailingComma = this.start;
        return this.finishNode(K, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        if (K.method = !1, K.shorthand = !1, H || G)
          w = this.start, v = this.startLoc;
        if (!H)
          j = this.eat(R.star);
      }
      var f = this.containsEsc;
      if (this.parsePropertyName(K), !H && !f && this.options.ecmaVersion >= 8 && !j && this.isAsyncProp(K))
        I = !0, j = this.options.ecmaVersion >= 9 && this.eat(R.star), this.parsePropertyName(K, G);
      else
        I = !1;
      return this.parsePropertyValue(K, H, j, I, w, v, G, f), this.finishNode(K, "Property");
    }, J0.parsePropertyValue = function(H, G, K, j, I, w, v, f) {
      if ((K || j) && this.type === R.colon)
        this.unexpected();
      if (this.eat(R.colon))
        H.value = G ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, v), H.kind = "init";
      else if (this.options.ecmaVersion >= 6 && this.type === R.parenL) {
        if (G)
          this.unexpected();
        H.kind = "init", H.method = !0, H.value = this.parseMethod(K, j);
      } else if (!G && !f && this.options.ecmaVersion >= 5 && !H.computed && H.key.type === "Identifier" && (H.key.name === "get" || H.key.name === "set") && (this.type !== R.comma && this.type !== R.braceR && this.type !== R.eq)) {
        if (K || j)
          this.unexpected();
        H.kind = H.key.name, this.parsePropertyName(H), H.value = this.parseMethod(!1);
        var l = H.kind === "get" ? 0 : 1;
        if (H.value.params.length !== l) {
          var G0 = H.value.start;
          if (H.kind === "get")
            this.raiseRecoverable(G0, "getter should have no params");
          else
            this.raiseRecoverable(G0, "setter should have exactly one param");
        } else if (H.kind === "set" && H.value.params[0].type === "RestElement")
          this.raiseRecoverable(H.value.params[0].start, "Setter cannot use rest params");
      } else if (this.options.ecmaVersion >= 6 && !H.computed && H.key.type === "Identifier") {
        if (K || j)
          this.unexpected();
        if (this.checkUnreserved(H.key), H.key.name === "await" && !this.awaitIdentPos)
          this.awaitIdentPos = I;
        if (H.kind = "init", G)
          H.value = this.parseMaybeDefault(I, w, H.key);
        else if (this.type === R.eq && v) {
          if (v.shorthandAssign < 0)
            v.shorthandAssign = this.start;
          H.value = this.parseMaybeDefault(I, w, H.key);
        } else
          H.value = H.key;
        H.shorthand = !0;
      } else
        this.unexpected();
    }, J0.parsePropertyName = function(H) {
      if (this.options.ecmaVersion >= 6)
        if (this.eat(R.bracketL))
          return H.computed = !0, H.key = this.parseMaybeAssign(), this.expect(R.bracketR), H.key;
        else
          H.computed = !1;
      return H.key = this.type === R.num || this.type === R.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    }, J0.initFunction = function(H) {
      if (H.id = null, this.options.ecmaVersion >= 6)
        H.generator = H.expression = !1;
      if (this.options.ecmaVersion >= 8)
        H.async = !1;
    }, J0.parseMethod = function(H, G, K) {
      var j = this.startNode(), I = this.yieldPos, w = this.awaitPos, v = this.awaitIdentPos;
      if (this.initFunction(j), this.options.ecmaVersion >= 6)
        j.generator = H;
      if (this.options.ecmaVersion >= 8)
        j.async = !!G;
      return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(B5(G, j.generator) | s1 | (K ? f1 : 0)), this.expect(R.parenL), j.params = this.parseBindingList(R.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(j, !1, !0), this.yieldPos = I, this.awaitPos = w, this.awaitIdentPos = v, this.finishNode(j, "FunctionExpression");
    }, J0.parseArrowExpression = function(H, G, K) {
      var j = this.yieldPos, I = this.awaitPos, w = this.awaitIdentPos;
      if (this.enterScope(B5(K, !1) | Q1), this.initFunction(H), this.options.ecmaVersion >= 8)
        H.async = !!K;
      return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, H.params = this.toAssignableList(G, !0), this.parseFunctionBody(H, !0, !1), this.yieldPos = j, this.awaitPos = I, this.awaitIdentPos = w, this.finishNode(H, "ArrowFunctionExpression");
    }, J0.parseFunctionBody = function(H, G, K) {
      var j = G && this.type !== R.braceL, I = this.strict, w = !1;
      if (j)
        H.body = this.parseMaybeAssign(), H.expression = !0, this.checkParams(H, !1);
      else {
        var v = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(H.params);
        if (!I || v) {
          if (w = this.strictDirective(this.end), w && v)
            this.raiseRecoverable(H.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        }
        var f = this.labels;
        if (this.labels = [], w)
          this.strict = !0;
        if (this.checkParams(H, !I && !w && !G && !K && this.isSimpleParamList(H.params)), this.strict && H.id)
          this.checkLVal(H.id, MQ);
        H.body = this.parseBlock(!1, void 0, w && !I), H.expression = !1, this.adaptDirectivePrologue(H.body.body), this.labels = f;
      }
      this.exitScope();
    }, J0.isSimpleParamList = function(H) {
      for (var G = 0, K = H;G < K.length; G += 1) {
        var j = K[G];
        if (j.type !== "Identifier")
          return !1;
      }
      return !0;
    }, J0.checkParams = function(H, G) {
      var K = {};
      for (var j = 0, I = H.params;j < I.length; j += 1) {
        var w = I[j];
        this.checkLVal(w, g7, G ? null : K);
      }
    }, J0.parseExprList = function(H, G, K, j) {
      var I = [], w = !0;
      while (!this.eat(H)) {
        if (!w) {
          if (this.expect(R.comma), G && this.afterTrailingComma(H))
            break;
        } else
          w = !1;
        var v = void 0;
        if (K && this.type === R.comma)
          v = null;
        else if (this.type === R.ellipsis) {
          if (v = this.parseSpread(j), j && this.type === R.comma && j.trailingComma < 0)
            j.trailingComma = this.start;
        } else
          v = this.parseMaybeAssign(!1, j);
        I.push(v);
      }
      return I;
    }, J0.checkUnreserved = function(H) {
      var { start: G, end: K, name: j } = H;
      if (this.inGenerator && j === "yield")
        this.raiseRecoverable(G, "Cannot use 'yield' as identifier inside a generator");
      if (this.inAsync && j === "await")
        this.raiseRecoverable(G, "Cannot use 'await' as identifier inside an async function");
      if (this.keywords.test(j))
        this.raise(G, "Unexpected keyword '" + j + "'");
      if (this.options.ecmaVersion < 6 && this.input.slice(G, K).indexOf("\\") !== -1)
        return;
      var I = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (I.test(j)) {
        if (!this.inAsync && j === "await")
          this.raiseRecoverable(G, "Cannot use keyword 'await' outside an async function");
        this.raiseRecoverable(G, "The keyword '" + j + "' is reserved");
      }
    }, J0.parseIdent = function(H, G) {
      var K = this.startNode();
      if (this.type === R.name)
        K.name = this.value;
      else if (this.type.keyword) {
        if (K.name = this.type.keyword, (K.name === "class" || K.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))
          this.context.pop();
      } else
        this.unexpected();
      if (this.next(!!H), this.finishNode(K, "Identifier"), !H) {
        if (this.checkUnreserved(K), K.name === "await" && !this.awaitIdentPos)
          this.awaitIdentPos = K.start;
      }
      return K;
    }, J0.parseYield = function(H) {
      if (!this.yieldPos)
        this.yieldPos = this.start;
      var G = this.startNode();
      if (this.next(), this.type === R.semi || this.canInsertSemicolon() || this.type !== R.star && !this.type.startsExpr)
        G.delegate = !1, G.argument = null;
      else
        G.delegate = this.eat(R.star), G.argument = this.parseMaybeAssign(H);
      return this.finishNode(G, "YieldExpression");
    }, J0.parseAwait = function() {
      if (!this.awaitPos)
        this.awaitPos = this.start;
      var H = this.startNode();
      return this.next(), H.argument = this.parseMaybeUnary(null, !1), this.finishNode(H, "AwaitExpression");
    };
    var P8 = C0.prototype;
    P8.raise = function(H, G) {
      var K = D0(this.input, H);
      G += " (" + K.line + ":" + K.column + ")";
      var j = new SyntaxError(G);
      throw j.pos = H, j.loc = K, j.raisedAt = this.pos, j;
    }, P8.raiseRecoverable = P8.raise, P8.curPosition = function() {
      if (this.options.locations)
        return new v0(this.curLine, this.pos - this.lineStart);
    };
    var y1 = C0.prototype, eW = function H(G) {
      this.flags = G, this.var = [], this.lexical = [], this.functions = [];
    };
    y1.enterScope = function(H) {
      this.scopeStack.push(new eW(H));
    }, y1.exitScope = function() {
      this.scopeStack.pop();
    }, y1.treatFunctionsAsVarInScope = function(H) {
      return H.flags & N0 || !this.inModule && H.flags & k0;
    }, y1.declareName = function(H, G, K) {
      var j = !1;
      if (G === I1) {
        var I = this.currentScope();
        if (j = I.lexical.indexOf(H) > -1 || I.functions.indexOf(H) > -1 || I.var.indexOf(H) > -1, I.lexical.push(H), this.inModule && I.flags & k0)
          delete this.undefinedExports[H];
      } else if (G === KQ) {
        var w = this.currentScope();
        w.lexical.push(H);
      } else if (G === VQ) {
        var v = this.currentScope();
        if (this.treatFunctionsAsVar)
          j = v.lexical.indexOf(H) > -1;
        else
          j = v.lexical.indexOf(H) > -1 || v.var.indexOf(H) > -1;
        v.functions.push(H);
      } else
        for (var f = this.scopeStack.length - 1;f >= 0; --f) {
          var l = this.scopeStack[f];
          if (l.lexical.indexOf(H) > -1 && !(l.flags & n1 && l.lexical[0] === H) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(H) > -1) {
            j = !0;
            break;
          }
          if (l.var.push(H), this.inModule && l.flags & k0)
            delete this.undefinedExports[H];
          if (l.flags & k1)
            break;
        }
      if (j)
        this.raiseRecoverable(K, "Identifier '" + H + "' has already been declared");
    }, y1.checkLocalExport = function(H) {
      if (this.scopeStack[0].lexical.indexOf(H.name) === -1 && this.scopeStack[0].var.indexOf(H.name) === -1)
        this.undefinedExports[H.name] = H;
    }, y1.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    }, y1.currentVarScope = function() {
      for (var H = this.scopeStack.length - 1;; H--) {
        var G = this.scopeStack[H];
        if (G.flags & k1)
          return G;
      }
    }, y1.currentThisScope = function() {
      for (var H = this.scopeStack.length - 1;; H--) {
        var G = this.scopeStack[H];
        if (G.flags & k1 && !(G.flags & Q1))
          return G;
      }
    };
    var S8 = function H(G, K, j) {
      if (this.type = "", this.start = K, this.end = 0, G.options.locations)
        this.loc = new O0(G, j);
      if (G.options.directSourceFile)
        this.sourceFile = G.options.directSourceFile;
      if (G.options.ranges)
        this.range = [K, 0];
    }, w8 = C0.prototype;
    w8.startNode = function() {
      return new S8(this, this.start, this.startLoc);
    }, w8.startNodeAt = function(H, G) {
      return new S8(this, H, G);
    };
    function RQ(H, G, K, j) {
      if (H.type = G, H.end = K, this.options.locations)
        H.loc.end = j;
      if (this.options.ranges)
        H.range[1] = K;
      return H;
    }
    w8.finishNode = function(H, G) {
      return RQ.call(this, H, G, this.lastTokEnd, this.lastTokEndLoc);
    }, w8.finishNodeAt = function(H, G, K, j) {
      return RQ.call(this, H, G, K, j);
    };
    var J1 = function H(G, K, j, I, w) {
      this.token = G, this.isExpr = !!K, this.preserveSpace = !!j, this.override = I, this.generator = !!w;
    }, P0 = {
      b_stat: new J1("{", !1),
      b_expr: new J1("{", !0),
      b_tmpl: new J1("${", !1),
      p_stat: new J1("(", !1),
      p_expr: new J1("(", !0),
      q_tmpl: new J1("`", !0, !0, function(H) {
        return H.tryReadTemplateToken();
      }),
      f_stat: new J1("function", !1),
      f_expr: new J1("function", !0),
      f_expr_gen: new J1("function", !0, !1, null, !0),
      f_gen: new J1("function", !1, !1, null, !0)
    }, T8 = C0.prototype;
    T8.initialContext = function() {
      return [P0.b_stat];
    }, T8.braceIsBlock = function(H) {
      var G = this.curContext();
      if (G === P0.f_expr || G === P0.f_stat)
        return !0;
      if (H === R.colon && (G === P0.b_stat || G === P0.b_expr))
        return !G.isExpr;
      if (H === R._return || H === R.name && this.exprAllowed)
        return L0.test(this.input.slice(this.lastTokEnd, this.start));
      if (H === R._else || H === R.semi || H === R.eof || H === R.parenR || H === R.arrow)
        return !0;
      if (H === R.braceL)
        return G === P0.b_stat;
      if (H === R._var || H === R._const || H === R.name)
        return !1;
      return !this.exprAllowed;
    }, T8.inGeneratorContext = function() {
      for (var H = this.context.length - 1;H >= 1; H--) {
        var G = this.context[H];
        if (G.token === "function")
          return G.generator;
      }
      return !1;
    }, T8.updateContext = function(H) {
      var G, K = this.type;
      if (K.keyword && H === R.dot)
        this.exprAllowed = !1;
      else if (G = K.updateContext)
        G.call(this, H);
      else
        this.exprAllowed = K.beforeExpr;
    }, R.parenR.updateContext = R.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = !0;
        return;
      }
      var H = this.context.pop();
      if (H === P0.b_stat && this.curContext().token === "function")
        H = this.context.pop();
      this.exprAllowed = !H.isExpr;
    }, R.braceL.updateContext = function(H) {
      this.context.push(this.braceIsBlock(H) ? P0.b_stat : P0.b_expr), this.exprAllowed = !0;
    }, R.dollarBraceL.updateContext = function() {
      this.context.push(P0.b_tmpl), this.exprAllowed = !0;
    }, R.parenL.updateContext = function(H) {
      var G = H === R._if || H === R._for || H === R._with || H === R._while;
      this.context.push(G ? P0.p_stat : P0.p_expr), this.exprAllowed = !0;
    }, R.incDec.updateContext = function() {
    }, R._function.updateContext = R._class.updateContext = function(H) {
      if (H.beforeExpr && H !== R.semi && H !== R._else && !(H === R._return && L0.test(this.input.slice(this.lastTokEnd, this.start))) && !((H === R.colon || H === R.braceL) && this.curContext() === P0.b_stat))
        this.context.push(P0.f_expr);
      else
        this.context.push(P0.f_stat);
      this.exprAllowed = !1;
    }, R.backQuote.updateContext = function() {
      if (this.curContext() === P0.q_tmpl)
        this.context.pop();
      else
        this.context.push(P0.q_tmpl);
      this.exprAllowed = !1;
    }, R.star.updateContext = function(H) {
      if (H === R._function) {
        var G = this.context.length - 1;
        if (this.context[G] === P0.f_expr)
          this.context[G] = P0.f_expr_gen;
        else
          this.context[G] = P0.f_gen;
      }
      this.exprAllowed = !0;
    }, R.name.updateContext = function(H) {
      var G = !1;
      if (this.options.ecmaVersion >= 6 && H !== R.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext())
          G = !0;
      }
      this.exprAllowed = G;
    };
    var jQ = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", OQ = jQ + " Extended_Pictographic", ZG = OQ, QG = {
      9: jQ,
      10: OQ,
      11: ZG
    }, BQ = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", qQ = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", $Q = qQ + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", JG = $Q + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", XG = {
      9: qQ,
      10: $Q,
      11: JG
    }, DQ = {};
    function k7(H) {
      var G = DQ[H] = {
        binary: R0(QG[H] + " " + BQ),
        nonBinary: {
          General_Category: R0(BQ),
          Script: R0(XG[H])
        }
      };
      G.nonBinary.Script_Extensions = G.nonBinary.Script, G.nonBinary.gc = G.nonBinary.General_Category, G.nonBinary.sc = G.nonBinary.Script, G.nonBinary.scx = G.nonBinary.Script_Extensions;
    }
    k7(9), k7(10), k7(11);
    var a = C0.prototype, A1 = function H(G) {
      this.parser = G, this.validFlags = "gim" + (G.options.ecmaVersion >= 6 ? "uy" : "") + (G.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = DQ[G.options.ecmaVersion >= 11 ? 11 : G.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
    };
    A1.prototype.reset = function H(G, K, j) {
      var I = j.indexOf("u") !== -1;
      this.start = G | 0, this.source = K + "", this.flags = j, this.switchU = I && this.parser.options.ecmaVersion >= 6, this.switchN = I && this.parser.options.ecmaVersion >= 9;
    }, A1.prototype.raise = function H(G) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + G);
    }, A1.prototype.at = function H(G, K) {
      if (K === void 0)
        K = !1;
      var j = this.source, I = j.length;
      if (G >= I)
        return -1;
      var w = j.charCodeAt(G);
      if (!(K || this.switchU) || w <= 55295 || w >= 57344 || G + 1 >= I)
        return w;
      var v = j.charCodeAt(G + 1);
      return v >= 56320 && v <= 57343 ? (w << 10) + v - 56613888 : w;
    }, A1.prototype.nextIndex = function H(G, K) {
      if (K === void 0)
        K = !1;
      var j = this.source, I = j.length;
      if (G >= I)
        return I;
      var w = j.charCodeAt(G), v;
      if (!(K || this.switchU) || w <= 55295 || w >= 57344 || G + 1 >= I || (v = j.charCodeAt(G + 1)) < 56320 || v > 57343)
        return G + 1;
      return G + 2;
    }, A1.prototype.current = function H(G) {
      if (G === void 0)
        G = !1;
      return this.at(this.pos, G);
    }, A1.prototype.lookahead = function H(G) {
      if (G === void 0)
        G = !1;
      return this.at(this.nextIndex(this.pos, G), G);
    }, A1.prototype.advance = function H(G) {
      if (G === void 0)
        G = !1;
      this.pos = this.nextIndex(this.pos, G);
    }, A1.prototype.eat = function H(G, K) {
      if (K === void 0)
        K = !1;
      if (this.current(K) === G)
        return this.advance(K), !0;
      return !1;
    };
    function v8(H) {
      if (H <= 65535)
        return String.fromCharCode(H);
      return H -= 65536, String.fromCharCode((H >> 10) + 55296, (H & 1023) + 56320);
    }
    a.validateRegExpFlags = function(H) {
      var { validFlags: G, flags: K } = H;
      for (var j = 0;j < K.length; j++) {
        var I = K.charAt(j);
        if (G.indexOf(I) === -1)
          this.raise(H.start, "Invalid regular expression flag");
        if (K.indexOf(I, j + 1) > -1)
          this.raise(H.start, "Duplicate regular expression flag");
      }
    }, a.validateRegExpPattern = function(H) {
      if (this.regexp_pattern(H), !H.switchN && this.options.ecmaVersion >= 9 && H.groupNames.length > 0)
        H.switchN = !0, this.regexp_pattern(H);
    }, a.regexp_pattern = function(H) {
      if (H.pos = 0, H.lastIntValue = 0, H.lastStringValue = "", H.lastAssertionIsQuantifiable = !1, H.numCapturingParens = 0, H.maxBackReference = 0, H.groupNames.length = 0, H.backReferenceNames.length = 0, this.regexp_disjunction(H), H.pos !== H.source.length) {
        if (H.eat(41))
          H.raise("Unmatched ')'");
        if (H.eat(93) || H.eat(125))
          H.raise("Lone quantifier brackets");
      }
      if (H.maxBackReference > H.numCapturingParens)
        H.raise("Invalid escape");
      for (var G = 0, K = H.backReferenceNames;G < K.length; G += 1) {
        var j = K[G];
        if (H.groupNames.indexOf(j) === -1)
          H.raise("Invalid named capture referenced");
      }
    }, a.regexp_disjunction = function(H) {
      this.regexp_alternative(H);
      while (H.eat(124))
        this.regexp_alternative(H);
      if (this.regexp_eatQuantifier(H, !0))
        H.raise("Nothing to repeat");
      if (H.eat(123))
        H.raise("Lone quantifier brackets");
    }, a.regexp_alternative = function(H) {
      while (H.pos < H.source.length && this.regexp_eatTerm(H))
        ;
    }, a.regexp_eatTerm = function(H) {
      if (this.regexp_eatAssertion(H)) {
        if (H.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(H)) {
          if (H.switchU)
            H.raise("Invalid quantifier");
        }
        return !0;
      }
      if (H.switchU ? this.regexp_eatAtom(H) : this.regexp_eatExtendedAtom(H))
        return this.regexp_eatQuantifier(H), !0;
      return !1;
    }, a.regexp_eatAssertion = function(H) {
      var G = H.pos;
      if (H.lastAssertionIsQuantifiable = !1, H.eat(94) || H.eat(36))
        return !0;
      if (H.eat(92)) {
        if (H.eat(66) || H.eat(98))
          return !0;
        H.pos = G;
      }
      if (H.eat(40) && H.eat(63)) {
        var K = !1;
        if (this.options.ecmaVersion >= 9)
          K = H.eat(60);
        if (H.eat(61) || H.eat(33)) {
          if (this.regexp_disjunction(H), !H.eat(41))
            H.raise("Unterminated group");
          return H.lastAssertionIsQuantifiable = !K, !0;
        }
      }
      return H.pos = G, !1;
    }, a.regexp_eatQuantifier = function(H, G) {
      if (G === void 0)
        G = !1;
      if (this.regexp_eatQuantifierPrefix(H, G))
        return H.eat(63), !0;
      return !1;
    }, a.regexp_eatQuantifierPrefix = function(H, G) {
      return H.eat(42) || H.eat(43) || H.eat(63) || this.regexp_eatBracedQuantifier(H, G);
    }, a.regexp_eatBracedQuantifier = function(H, G) {
      var K = H.pos;
      if (H.eat(123)) {
        var j = 0, I = -1;
        if (this.regexp_eatDecimalDigits(H)) {
          if (j = H.lastIntValue, H.eat(44) && this.regexp_eatDecimalDigits(H))
            I = H.lastIntValue;
          if (H.eat(125)) {
            if (I !== -1 && I < j && !G)
              H.raise("numbers out of order in {} quantifier");
            return !0;
          }
        }
        if (H.switchU && !G)
          H.raise("Incomplete quantifier");
        H.pos = K;
      }
      return !1;
    }, a.regexp_eatAtom = function(H) {
      return this.regexp_eatPatternCharacters(H) || H.eat(46) || this.regexp_eatReverseSolidusAtomEscape(H) || this.regexp_eatCharacterClass(H) || this.regexp_eatUncapturingGroup(H) || this.regexp_eatCapturingGroup(H);
    }, a.regexp_eatReverseSolidusAtomEscape = function(H) {
      var G = H.pos;
      if (H.eat(92)) {
        if (this.regexp_eatAtomEscape(H))
          return !0;
        H.pos = G;
      }
      return !1;
    }, a.regexp_eatUncapturingGroup = function(H) {
      var G = H.pos;
      if (H.eat(40)) {
        if (H.eat(63) && H.eat(58)) {
          if (this.regexp_disjunction(H), H.eat(41))
            return !0;
          H.raise("Unterminated group");
        }
        H.pos = G;
      }
      return !1;
    }, a.regexp_eatCapturingGroup = function(H) {
      if (H.eat(40)) {
        if (this.options.ecmaVersion >= 9)
          this.regexp_groupSpecifier(H);
        else if (H.current() === 63)
          H.raise("Invalid group");
        if (this.regexp_disjunction(H), H.eat(41))
          return H.numCapturingParens += 1, !0;
        H.raise("Unterminated group");
      }
      return !1;
    }, a.regexp_eatExtendedAtom = function(H) {
      return H.eat(46) || this.regexp_eatReverseSolidusAtomEscape(H) || this.regexp_eatCharacterClass(H) || this.regexp_eatUncapturingGroup(H) || this.regexp_eatCapturingGroup(H) || this.regexp_eatInvalidBracedQuantifier(H) || this.regexp_eatExtendedPatternCharacter(H);
    }, a.regexp_eatInvalidBracedQuantifier = function(H) {
      if (this.regexp_eatBracedQuantifier(H, !0))
        H.raise("Nothing to repeat");
      return !1;
    }, a.regexp_eatSyntaxCharacter = function(H) {
      var G = H.current();
      if (IQ(G))
        return H.lastIntValue = G, H.advance(), !0;
      return !1;
    };
    function IQ(H) {
      return H === 36 || H >= 40 && H <= 43 || H === 46 || H === 63 || H >= 91 && H <= 94 || H >= 123 && H <= 125;
    }
    a.regexp_eatPatternCharacters = function(H) {
      var G = H.pos, K = 0;
      while ((K = H.current()) !== -1 && !IQ(K))
        H.advance();
      return H.pos !== G;
    }, a.regexp_eatExtendedPatternCharacter = function(H) {
      var G = H.current();
      if (G !== -1 && G !== 36 && !(G >= 40 && G <= 43) && G !== 46 && G !== 63 && G !== 91 && G !== 94 && G !== 124)
        return H.advance(), !0;
      return !1;
    }, a.regexp_groupSpecifier = function(H) {
      if (H.eat(63)) {
        if (this.regexp_eatGroupName(H)) {
          if (H.groupNames.indexOf(H.lastStringValue) !== -1)
            H.raise("Duplicate capture group name");
          H.groupNames.push(H.lastStringValue);
          return;
        }
        H.raise("Invalid group");
      }
    }, a.regexp_eatGroupName = function(H) {
      if (H.lastStringValue = "", H.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(H) && H.eat(62))
          return !0;
        H.raise("Invalid capture group name");
      }
      return !1;
    }, a.regexp_eatRegExpIdentifierName = function(H) {
      if (H.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(H)) {
        H.lastStringValue += v8(H.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(H))
          H.lastStringValue += v8(H.lastIntValue);
        return !0;
      }
      return !1;
    }, a.regexp_eatRegExpIdentifierStart = function(H) {
      var G = H.pos, K = this.options.ecmaVersion >= 11, j = H.current(K);
      if (H.advance(K), j === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(H, K))
        j = H.lastIntValue;
      if (zG(j))
        return H.lastIntValue = j, !0;
      return H.pos = G, !1;
    };
    function zG(H) {
      return N(H, !0) || H === 36 || H === 95;
    }
    a.regexp_eatRegExpIdentifierPart = function(H) {
      var G = H.pos, K = this.options.ecmaVersion >= 11, j = H.current(K);
      if (H.advance(K), j === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(H, K))
        j = H.lastIntValue;
      if (HG(j))
        return H.lastIntValue = j, !0;
      return H.pos = G, !1;
    };
    function HG(H) {
      return T(H, !0) || H === 36 || H === 95 || H === 8204 || H === 8205;
    }
    a.regexp_eatAtomEscape = function(H) {
      if (this.regexp_eatBackReference(H) || this.regexp_eatCharacterClassEscape(H) || this.regexp_eatCharacterEscape(H) || H.switchN && this.regexp_eatKGroupName(H))
        return !0;
      if (H.switchU) {
        if (H.current() === 99)
          H.raise("Invalid unicode escape");
        H.raise("Invalid escape");
      }
      return !1;
    }, a.regexp_eatBackReference = function(H) {
      var G = H.pos;
      if (this.regexp_eatDecimalEscape(H)) {
        var K = H.lastIntValue;
        if (H.switchU) {
          if (K > H.maxBackReference)
            H.maxBackReference = K;
          return !0;
        }
        if (K <= H.numCapturingParens)
          return !0;
        H.pos = G;
      }
      return !1;
    }, a.regexp_eatKGroupName = function(H) {
      if (H.eat(107)) {
        if (this.regexp_eatGroupName(H))
          return H.backReferenceNames.push(H.lastStringValue), !0;
        H.raise("Invalid named reference");
      }
      return !1;
    }, a.regexp_eatCharacterEscape = function(H) {
      return this.regexp_eatControlEscape(H) || this.regexp_eatCControlLetter(H) || this.regexp_eatZero(H) || this.regexp_eatHexEscapeSequence(H) || this.regexp_eatRegExpUnicodeEscapeSequence(H, !1) || !H.switchU && this.regexp_eatLegacyOctalEscapeSequence(H) || this.regexp_eatIdentityEscape(H);
    }, a.regexp_eatCControlLetter = function(H) {
      var G = H.pos;
      if (H.eat(99)) {
        if (this.regexp_eatControlLetter(H))
          return !0;
        H.pos = G;
      }
      return !1;
    }, a.regexp_eatZero = function(H) {
      if (H.current() === 48 && !b8(H.lookahead()))
        return H.lastIntValue = 0, H.advance(), !0;
      return !1;
    }, a.regexp_eatControlEscape = function(H) {
      var G = H.current();
      if (G === 116)
        return H.lastIntValue = 9, H.advance(), !0;
      if (G === 110)
        return H.lastIntValue = 10, H.advance(), !0;
      if (G === 118)
        return H.lastIntValue = 11, H.advance(), !0;
      if (G === 102)
        return H.lastIntValue = 12, H.advance(), !0;
      if (G === 114)
        return H.lastIntValue = 13, H.advance(), !0;
      return !1;
    }, a.regexp_eatControlLetter = function(H) {
      var G = H.current();
      if (CQ(G))
        return H.lastIntValue = G % 32, H.advance(), !0;
      return !1;
    };
    function CQ(H) {
      return H >= 65 && H <= 90 || H >= 97 && H <= 122;
    }
    a.regexp_eatRegExpUnicodeEscapeSequence = function(H, G) {
      if (G === void 0)
        G = !1;
      var K = H.pos, j = G || H.switchU;
      if (H.eat(117)) {
        if (this.regexp_eatFixedHexDigits(H, 4)) {
          var I = H.lastIntValue;
          if (j && I >= 55296 && I <= 56319) {
            var w = H.pos;
            if (H.eat(92) && H.eat(117) && this.regexp_eatFixedHexDigits(H, 4)) {
              var v = H.lastIntValue;
              if (v >= 56320 && v <= 57343)
                return H.lastIntValue = (I - 55296) * 1024 + (v - 56320) + 65536, !0;
            }
            H.pos = w, H.lastIntValue = I;
          }
          return !0;
        }
        if (j && H.eat(123) && this.regexp_eatHexDigits(H) && H.eat(125) && YG(H.lastIntValue))
          return !0;
        if (j)
          H.raise("Invalid unicode escape");
        H.pos = K;
      }
      return !1;
    };
    function YG(H) {
      return H >= 0 && H <= 1114111;
    }
    a.regexp_eatIdentityEscape = function(H) {
      if (H.switchU) {
        if (this.regexp_eatSyntaxCharacter(H))
          return !0;
        if (H.eat(47))
          return H.lastIntValue = 47, !0;
        return !1;
      }
      var G = H.current();
      if (G !== 99 && (!H.switchN || G !== 107))
        return H.lastIntValue = G, H.advance(), !0;
      return !1;
    }, a.regexp_eatDecimalEscape = function(H) {
      H.lastIntValue = 0;
      var G = H.current();
      if (G >= 49 && G <= 57) {
        do
          H.lastIntValue = 10 * H.lastIntValue + (G - 48), H.advance();
        while ((G = H.current()) >= 48 && G <= 57);
        return !0;
      }
      return !1;
    }, a.regexp_eatCharacterClassEscape = function(H) {
      var G = H.current();
      if (WG(G))
        return H.lastIntValue = -1, H.advance(), !0;
      if (H.switchU && this.options.ecmaVersion >= 9 && (G === 80 || G === 112)) {
        if (H.lastIntValue = -1, H.advance(), H.eat(123) && this.regexp_eatUnicodePropertyValueExpression(H) && H.eat(125))
          return !0;
        H.raise("Invalid property name");
      }
      return !1;
    };
    function WG(H) {
      return H === 100 || H === 68 || H === 115 || H === 83 || H === 119 || H === 87;
    }
    a.regexp_eatUnicodePropertyValueExpression = function(H) {
      var G = H.pos;
      if (this.regexp_eatUnicodePropertyName(H) && H.eat(61)) {
        var K = H.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(H)) {
          var j = H.lastStringValue;
          return this.regexp_validateUnicodePropertyNameAndValue(H, K, j), !0;
        }
      }
      if (H.pos = G, this.regexp_eatLoneUnicodePropertyNameOrValue(H)) {
        var I = H.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(H, I), !0;
      }
      return !1;
    }, a.regexp_validateUnicodePropertyNameAndValue = function(H, G, K) {
      if (!$0(H.unicodeProperties.nonBinary, G))
        H.raise("Invalid property name");
      if (!H.unicodeProperties.nonBinary[G].test(K))
        H.raise("Invalid property value");
    }, a.regexp_validateUnicodePropertyNameOrValue = function(H, G) {
      if (!H.unicodeProperties.binary.test(G))
        H.raise("Invalid property name");
    }, a.regexp_eatUnicodePropertyName = function(H) {
      var G = 0;
      H.lastStringValue = "";
      while (AQ(G = H.current()))
        H.lastStringValue += v8(G), H.advance();
      return H.lastStringValue !== "";
    };
    function AQ(H) {
      return CQ(H) || H === 95;
    }
    a.regexp_eatUnicodePropertyValue = function(H) {
      var G = 0;
      H.lastStringValue = "";
      while (GG(G = H.current()))
        H.lastStringValue += v8(G), H.advance();
      return H.lastStringValue !== "";
    };
    function GG(H) {
      return AQ(H) || b8(H);
    }
    a.regexp_eatLoneUnicodePropertyNameOrValue = function(H) {
      return this.regexp_eatUnicodePropertyValue(H);
    }, a.regexp_eatCharacterClass = function(H) {
      if (H.eat(91)) {
        if (H.eat(94), this.regexp_classRanges(H), H.eat(93))
          return !0;
        H.raise("Unterminated character class");
      }
      return !1;
    }, a.regexp_classRanges = function(H) {
      while (this.regexp_eatClassAtom(H)) {
        var G = H.lastIntValue;
        if (H.eat(45) && this.regexp_eatClassAtom(H)) {
          var K = H.lastIntValue;
          if (H.switchU && (G === -1 || K === -1))
            H.raise("Invalid character class");
          if (G !== -1 && K !== -1 && G > K)
            H.raise("Range out of order in character class");
        }
      }
    }, a.regexp_eatClassAtom = function(H) {
      var G = H.pos;
      if (H.eat(92)) {
        if (this.regexp_eatClassEscape(H))
          return !0;
        if (H.switchU) {
          var K = H.current();
          if (K === 99 || PQ(K))
            H.raise("Invalid class escape");
          H.raise("Invalid escape");
        }
        H.pos = G;
      }
      var j = H.current();
      if (j !== 93)
        return H.lastIntValue = j, H.advance(), !0;
      return !1;
    }, a.regexp_eatClassEscape = function(H) {
      var G = H.pos;
      if (H.eat(98))
        return H.lastIntValue = 8, !0;
      if (H.switchU && H.eat(45))
        return H.lastIntValue = 45, !0;
      if (!H.switchU && H.eat(99)) {
        if (this.regexp_eatClassControlLetter(H))
          return !0;
        H.pos = G;
      }
      return this.regexp_eatCharacterClassEscape(H) || this.regexp_eatCharacterEscape(H);
    }, a.regexp_eatClassControlLetter = function(H) {
      var G = H.current();
      if (b8(G) || G === 95)
        return H.lastIntValue = G % 32, H.advance(), !0;
      return !1;
    }, a.regexp_eatHexEscapeSequence = function(H) {
      var G = H.pos;
      if (H.eat(120)) {
        if (this.regexp_eatFixedHexDigits(H, 2))
          return !0;
        if (H.switchU)
          H.raise("Invalid escape");
        H.pos = G;
      }
      return !1;
    }, a.regexp_eatDecimalDigits = function(H) {
      var G = H.pos, K = 0;
      H.lastIntValue = 0;
      while (b8(K = H.current()))
        H.lastIntValue = 10 * H.lastIntValue + (K - 48), H.advance();
      return H.pos !== G;
    };
    function b8(H) {
      return H >= 48 && H <= 57;
    }
    a.regexp_eatHexDigits = function(H) {
      var G = H.pos, K = 0;
      H.lastIntValue = 0;
      while (LQ(K = H.current()))
        H.lastIntValue = 16 * H.lastIntValue + NQ(K), H.advance();
      return H.pos !== G;
    };
    function LQ(H) {
      return H >= 48 && H <= 57 || H >= 65 && H <= 70 || H >= 97 && H <= 102;
    }
    function NQ(H) {
      if (H >= 65 && H <= 70)
        return 10 + (H - 65);
      if (H >= 97 && H <= 102)
        return 10 + (H - 97);
      return H - 48;
    }
    a.regexp_eatLegacyOctalEscapeSequence = function(H) {
      if (this.regexp_eatOctalDigit(H)) {
        var G = H.lastIntValue;
        if (this.regexp_eatOctalDigit(H)) {
          var K = H.lastIntValue;
          if (G <= 3 && this.regexp_eatOctalDigit(H))
            H.lastIntValue = G * 64 + K * 8 + H.lastIntValue;
          else
            H.lastIntValue = G * 8 + K;
        } else
          H.lastIntValue = G;
        return !0;
      }
      return !1;
    }, a.regexp_eatOctalDigit = function(H) {
      var G = H.current();
      if (PQ(G))
        return H.lastIntValue = G - 48, H.advance(), !0;
      return H.lastIntValue = 0, !1;
    };
    function PQ(H) {
      return H >= 48 && H <= 55;
    }
    a.regexp_eatFixedHexDigits = function(H, G) {
      var K = H.pos;
      H.lastIntValue = 0;
      for (var j = 0;j < G; ++j) {
        var I = H.current();
        if (!LQ(I))
          return H.pos = K, !1;
        H.lastIntValue = 16 * H.lastIntValue + NQ(I), H.advance();
      }
      return !0;
    };
    var E8 = function H(G) {
      if (this.type = G.type, this.value = G.value, this.start = G.start, this.end = G.end, G.options.locations)
        this.loc = new O0(G, G.startLoc, G.endLoc);
      if (G.options.ranges)
        this.range = [G.start, G.end];
    }, Y0 = C0.prototype;
    if (Y0.next = function(H) {
      if (!H && this.type.keyword && this.containsEsc)
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      if (this.options.onToken)
        this.options.onToken(new E8(this));
      this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
    }, Y0.getToken = function() {
      return this.next(), new E8(this);
    }, typeof Symbol !== "undefined")
      Y0[Symbol.iterator] = function() {
        var H = this;
        return {
          next: function() {
            var G = H.getToken();
            return {
              done: G.type === R.eof,
              value: G
            };
          }
        };
      };
    Y0.curContext = function() {
      return this.context[this.context.length - 1];
    }, Y0.nextToken = function() {
      var H = this.curContext();
      if (!H || !H.preserveSpace)
        this.skipSpace();
      if (this.start = this.pos, this.options.locations)
        this.startLoc = this.curPosition();
      if (this.pos >= this.input.length)
        return this.finishToken(R.eof);
      if (H.override)
        return H.override(this);
      else
        this.readToken(this.fullCharCodeAtPos());
    }, Y0.readToken = function(H) {
      if (N(H, this.options.ecmaVersion >= 6) || H === 92)
        return this.readWord();
      return this.getTokenFromCode(H);
    }, Y0.fullCharCodeAtPos = function() {
      var H = this.input.charCodeAt(this.pos);
      if (H <= 55295 || H >= 57344)
        return H;
      var G = this.input.charCodeAt(this.pos + 1);
      return (H << 10) + G - 56613888;
    }, Y0.skipBlockComment = function() {
      var H = this.options.onComment && this.curPosition(), G = this.pos, K = this.input.indexOf("*/", this.pos += 2);
      if (K === -1)
        this.raise(this.pos - 2, "Unterminated comment");
      if (this.pos = K + 2, this.options.locations) {
        B0.lastIndex = G;
        var j;
        while ((j = B0.exec(this.input)) && j.index < this.pos)
          ++this.curLine, this.lineStart = j.index + j[0].length;
      }
      if (this.options.onComment)
        this.options.onComment(!0, this.input.slice(G + 2, K), G, this.pos, H, this.curPosition());
    }, Y0.skipLineComment = function(H) {
      var G = this.pos, K = this.options.onComment && this.curPosition(), j = this.input.charCodeAt(this.pos += H);
      while (this.pos < this.input.length && !e(j))
        j = this.input.charCodeAt(++this.pos);
      if (this.options.onComment)
        this.options.onComment(!1, this.input.slice(G + H, this.pos), G, this.pos, K, this.curPosition());
    }, Y0.skipSpace = function() {
      Z:
        while (this.pos < this.input.length) {
          var H = this.input.charCodeAt(this.pos);
          switch (H) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10)
                ++this.pos;
            case 10:
            case 8232:
            case 8233:
              if (++this.pos, this.options.locations)
                ++this.curLine, this.lineStart = this.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break Z;
              }
              break;
            default:
              if (H > 8 && H < 14 || H >= 5760 && q0.test(String.fromCharCode(H)))
                ++this.pos;
              else
                break Z;
          }
        }
    }, Y0.finishToken = function(H, G) {
      if (this.end = this.pos, this.options.locations)
        this.endLoc = this.curPosition();
      var K = this.type;
      this.type = H, this.value = G, this.updateContext(K);
    }, Y0.readToken_dot = function() {
      var H = this.input.charCodeAt(this.pos + 1);
      if (H >= 48 && H <= 57)
        return this.readNumber(!0);
      var G = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && H === 46 && G === 46)
        return this.pos += 3, this.finishToken(R.ellipsis);
      else
        return ++this.pos, this.finishToken(R.dot);
    }, Y0.readToken_slash = function() {
      var H = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed)
        return ++this.pos, this.readRegexp();
      if (H === 61)
        return this.finishOp(R.assign, 2);
      return this.finishOp(R.slash, 1);
    }, Y0.readToken_mult_modulo_exp = function(H) {
      var G = this.input.charCodeAt(this.pos + 1), K = 1, j = H === 42 ? R.star : R.modulo;
      if (this.options.ecmaVersion >= 7 && H === 42 && G === 42)
        ++K, j = R.starstar, G = this.input.charCodeAt(this.pos + 2);
      if (G === 61)
        return this.finishOp(R.assign, K + 1);
      return this.finishOp(j, K);
    }, Y0.readToken_pipe_amp = function(H) {
      var G = this.input.charCodeAt(this.pos + 1);
      if (G === H) {
        if (this.options.ecmaVersion >= 12) {
          var K = this.input.charCodeAt(this.pos + 2);
          if (K === 61)
            return this.finishOp(R.assign, 3);
        }
        return this.finishOp(H === 124 ? R.logicalOR : R.logicalAND, 2);
      }
      if (G === 61)
        return this.finishOp(R.assign, 2);
      return this.finishOp(H === 124 ? R.bitwiseOR : R.bitwiseAND, 1);
    }, Y0.readToken_caret = function() {
      var H = this.input.charCodeAt(this.pos + 1);
      if (H === 61)
        return this.finishOp(R.assign, 2);
      return this.finishOp(R.bitwiseXOR, 1);
    }, Y0.readToken_plus_min = function(H) {
      var G = this.input.charCodeAt(this.pos + 1);
      if (G === H) {
        if (G === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || L0.test(this.input.slice(this.lastTokEnd, this.pos))))
          return this.skipLineComment(3), this.skipSpace(), this.nextToken();
        return this.finishOp(R.incDec, 2);
      }
      if (G === 61)
        return this.finishOp(R.assign, 2);
      return this.finishOp(R.plusMin, 1);
    }, Y0.readToken_lt_gt = function(H) {
      var G = this.input.charCodeAt(this.pos + 1), K = 1;
      if (G === H) {
        if (K = H === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + K) === 61)
          return this.finishOp(R.assign, K + 1);
        return this.finishOp(R.bitShift, K);
      }
      if (G === 33 && H === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45)
        return this.skipLineComment(4), this.skipSpace(), this.nextToken();
      if (G === 61)
        K = 2;
      return this.finishOp(R.relational, K);
    }, Y0.readToken_eq_excl = function(H) {
      var G = this.input.charCodeAt(this.pos + 1);
      if (G === 61)
        return this.finishOp(R.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      if (H === 61 && G === 62 && this.options.ecmaVersion >= 6)
        return this.pos += 2, this.finishToken(R.arrow);
      return this.finishOp(H === 61 ? R.eq : R.prefix, 1);
    }, Y0.readToken_question = function() {
      var H = this.options.ecmaVersion;
      if (H >= 11) {
        var G = this.input.charCodeAt(this.pos + 1);
        if (G === 46) {
          var K = this.input.charCodeAt(this.pos + 2);
          if (K < 48 || K > 57)
            return this.finishOp(R.questionDot, 2);
        }
        if (G === 63) {
          if (H >= 12) {
            var j = this.input.charCodeAt(this.pos + 2);
            if (j === 61)
              return this.finishOp(R.assign, 3);
          }
          return this.finishOp(R.coalesce, 2);
        }
      }
      return this.finishOp(R.question, 1);
    }, Y0.getTokenFromCode = function(H) {
      switch (H) {
        case 46:
          return this.readToken_dot();
        case 40:
          return ++this.pos, this.finishToken(R.parenL);
        case 41:
          return ++this.pos, this.finishToken(R.parenR);
        case 59:
          return ++this.pos, this.finishToken(R.semi);
        case 44:
          return ++this.pos, this.finishToken(R.comma);
        case 91:
          return ++this.pos, this.finishToken(R.bracketL);
        case 93:
          return ++this.pos, this.finishToken(R.bracketR);
        case 123:
          return ++this.pos, this.finishToken(R.braceL);
        case 125:
          return ++this.pos, this.finishToken(R.braceR);
        case 58:
          return ++this.pos, this.finishToken(R.colon);
        case 96:
          if (this.options.ecmaVersion < 6)
            break;
          return ++this.pos, this.finishToken(R.backQuote);
        case 48:
          var G = this.input.charCodeAt(this.pos + 1);
          if (G === 120 || G === 88)
            return this.readRadixNumber(16);
          if (this.options.ecmaVersion >= 6) {
            if (G === 111 || G === 79)
              return this.readRadixNumber(8);
            if (G === 98 || G === 66)
              return this.readRadixNumber(2);
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(!1);
        case 34:
        case 39:
          return this.readString(H);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(H);
        case 124:
        case 38:
          return this.readToken_pipe_amp(H);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(H);
        case 60:
        case 62:
          return this.readToken_lt_gt(H);
        case 61:
        case 33:
          return this.readToken_eq_excl(H);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(R.prefix, 1);
      }
      this.raise(this.pos, "Unexpected character '" + f7(H) + "'");
    }, Y0.finishOp = function(H, G) {
      var K = this.input.slice(this.pos, this.pos + G);
      return this.pos += G, this.finishToken(H, K);
    }, Y0.readRegexp = function() {
      var H, G, K = this.pos;
      for (;; ) {
        if (this.pos >= this.input.length)
          this.raise(K, "Unterminated regular expression");
        var j = this.input.charAt(this.pos);
        if (L0.test(j))
          this.raise(K, "Unterminated regular expression");
        if (!H) {
          if (j === "[")
            G = !0;
          else if (j === "]" && G)
            G = !1;
          else if (j === "/" && !G)
            break;
          H = j === "\\";
        } else
          H = !1;
        ++this.pos;
      }
      var I = this.input.slice(K, this.pos);
      ++this.pos;
      var w = this.pos, v = this.readWord1();
      if (this.containsEsc)
        this.unexpected(w);
      var f = this.regexpState || (this.regexpState = new A1(this));
      f.reset(K, I, v), this.validateRegExpFlags(f), this.validateRegExpPattern(f);
      var l = null;
      try {
        l = new RegExp(I, v);
      } catch (G0) {
      }
      return this.finishToken(R.regexp, { pattern: I, flags: v, value: l });
    }, Y0.readInt = function(H, G, K) {
      var j = this.options.ecmaVersion >= 12 && G === void 0, I = K && this.input.charCodeAt(this.pos) === 48, w = this.pos, v = 0, f = 0;
      for (var l = 0, G0 = G == null ? Infinity : G;l < G0; ++l, ++this.pos) {
        var I0 = this.input.charCodeAt(this.pos), f0 = void 0;
        if (j && I0 === 95) {
          if (I)
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          if (f === 95)
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          if (l === 0)
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          f = I0;
          continue;
        }
        if (I0 >= 97)
          f0 = I0 - 97 + 10;
        else if (I0 >= 65)
          f0 = I0 - 65 + 10;
        else if (I0 >= 48 && I0 <= 57)
          f0 = I0 - 48;
        else
          f0 = Infinity;
        if (f0 >= H)
          break;
        f = I0, v = v * H + f0;
      }
      if (j && f === 95)
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      if (this.pos === w || G != null && this.pos - w !== G)
        return null;
      return v;
    };
    function UG(H, G) {
      if (G)
        return parseInt(H, 8);
      return parseFloat(H.replace(/_/g, ""));
    }
    function SQ(H) {
      if (typeof BigInt !== "function")
        return null;
      return BigInt(H.replace(/_/g, ""));
    }
    Y0.readRadixNumber = function(H) {
      var G = this.pos;
      this.pos += 2;
      var K = this.readInt(H);
      if (K == null)
        this.raise(this.start + 2, "Expected number in radix " + H);
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110)
        K = SQ(this.input.slice(G, this.pos)), ++this.pos;
      else if (N(this.fullCharCodeAtPos()))
        this.raise(this.pos, "Identifier directly after number");
      return this.finishToken(R.num, K);
    }, Y0.readNumber = function(H) {
      var G = this.pos;
      if (!H && this.readInt(10, void 0, !0) === null)
        this.raise(G, "Invalid number");
      var K = this.pos - G >= 2 && this.input.charCodeAt(G) === 48;
      if (K && this.strict)
        this.raise(G, "Invalid number");
      var j = this.input.charCodeAt(this.pos);
      if (!K && !H && this.options.ecmaVersion >= 11 && j === 110) {
        var I = SQ(this.input.slice(G, this.pos));
        if (++this.pos, N(this.fullCharCodeAtPos()))
          this.raise(this.pos, "Identifier directly after number");
        return this.finishToken(R.num, I);
      }
      if (K && /[89]/.test(this.input.slice(G, this.pos)))
        K = !1;
      if (j === 46 && !K)
        ++this.pos, this.readInt(10), j = this.input.charCodeAt(this.pos);
      if ((j === 69 || j === 101) && !K) {
        if (j = this.input.charCodeAt(++this.pos), j === 43 || j === 45)
          ++this.pos;
        if (this.readInt(10) === null)
          this.raise(G, "Invalid number");
      }
      if (N(this.fullCharCodeAtPos()))
        this.raise(this.pos, "Identifier directly after number");
      var w = UG(this.input.slice(G, this.pos), K);
      return this.finishToken(R.num, w);
    }, Y0.readCodePoint = function() {
      var H = this.input.charCodeAt(this.pos), G;
      if (H === 123) {
        if (this.options.ecmaVersion < 6)
          this.unexpected();
        var K = ++this.pos;
        if (G = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, G > 1114111)
          this.invalidStringToken(K, "Code point out of bounds");
      } else
        G = this.readHexChar(4);
      return G;
    };
    function f7(H) {
      if (H <= 65535)
        return String.fromCharCode(H);
      return H -= 65536, String.fromCharCode((H >> 10) + 55296, (H & 1023) + 56320);
    }
    Y0.readString = function(H) {
      var G = "", K = ++this.pos;
      for (;; ) {
        if (this.pos >= this.input.length)
          this.raise(this.start, "Unterminated string constant");
        var j = this.input.charCodeAt(this.pos);
        if (j === H)
          break;
        if (j === 92)
          G += this.input.slice(K, this.pos), G += this.readEscapedChar(!1), K = this.pos;
        else {
          if (e(j, this.options.ecmaVersion >= 10))
            this.raise(this.start, "Unterminated string constant");
          ++this.pos;
        }
      }
      return G += this.input.slice(K, this.pos++), this.finishToken(R.string, G);
    };
    var wQ = {};
    Y0.tryReadTemplateToken = function() {
      this.inTemplateElement = !0;
      try {
        this.readTmplToken();
      } catch (H) {
        if (H === wQ)
          this.readInvalidTemplateToken();
        else
          throw H;
      }
      this.inTemplateElement = !1;
    }, Y0.invalidStringToken = function(H, G) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9)
        throw wQ;
      else
        this.raise(H, G);
    }, Y0.readTmplToken = function() {
      var H = "", G = this.pos;
      for (;; ) {
        if (this.pos >= this.input.length)
          this.raise(this.start, "Unterminated template");
        var K = this.input.charCodeAt(this.pos);
        if (K === 96 || K === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === R.template || this.type === R.invalidTemplate))
            if (K === 36)
              return this.pos += 2, this.finishToken(R.dollarBraceL);
            else
              return ++this.pos, this.finishToken(R.backQuote);
          return H += this.input.slice(G, this.pos), this.finishToken(R.template, H);
        }
        if (K === 92)
          H += this.input.slice(G, this.pos), H += this.readEscapedChar(!0), G = this.pos;
        else if (e(K)) {
          switch (H += this.input.slice(G, this.pos), ++this.pos, K) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10)
                ++this.pos;
            case 10:
              H += "\n";
              break;
            default:
              H += String.fromCharCode(K);
              break;
          }
          if (this.options.locations)
            ++this.curLine, this.lineStart = this.pos;
          G = this.pos;
        } else
          ++this.pos;
      }
    }, Y0.readInvalidTemplateToken = function() {
      for (;this.pos < this.input.length; this.pos++)
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{")
              break;
          case "`":
            return this.finishToken(R.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      this.raise(this.start, "Unterminated template");
    }, Y0.readEscapedChar = function(H) {
      var G = this.input.charCodeAt(++this.pos);
      switch (++this.pos, G) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return f7(this.readCodePoint());
        case 116:
          return "\t";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10)
            ++this.pos;
        case 10:
          if (this.options.locations)
            this.lineStart = this.pos, ++this.curLine;
          return "";
        case 56:
        case 57:
          if (H) {
            var K = this.pos - 1;
            return this.invalidStringToken(K, "Invalid escape sequence in template string"), null;
          }
        default:
          if (G >= 48 && G <= 55) {
            var j = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], I = parseInt(j, 8);
            if (I > 255)
              j = j.slice(0, -1), I = parseInt(j, 8);
            if (this.pos += j.length - 1, G = this.input.charCodeAt(this.pos), (j !== "0" || G === 56 || G === 57) && (this.strict || H))
              this.invalidStringToken(this.pos - 1 - j.length, H ? "Octal literal in template string" : "Octal literal in strict mode");
            return String.fromCharCode(I);
          }
          if (e(G))
            return "";
          return String.fromCharCode(G);
      }
    }, Y0.readHexChar = function(H) {
      var G = this.pos, K = this.readInt(16, H);
      if (K === null)
        this.invalidStringToken(G, "Bad character escape sequence");
      return K;
    }, Y0.readWord1 = function() {
      this.containsEsc = !1;
      var H = "", G = !0, K = this.pos, j = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var I = this.fullCharCodeAtPos();
        if (T(I, j))
          this.pos += I <= 65535 ? 1 : 2;
        else if (I === 92) {
          this.containsEsc = !0, H += this.input.slice(K, this.pos);
          var w = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117)
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          ++this.pos;
          var v = this.readCodePoint();
          if (!(G ? N : T)(v, j))
            this.invalidStringToken(w, "Invalid Unicode escape");
          H += f7(v), K = this.pos;
        } else
          break;
        G = !1;
      }
      return H + this.input.slice(K, this.pos);
    }, Y0.readWord = function() {
      var H = this.readWord1(), G = R.name;
      if (this.keywords.test(H))
        G = d[H];
      return this.finishToken(G, H);
    };
    var TQ = "7.4.1";
    C0.acorn = {
      Parser: C0,
      version: TQ,
      defaultOptions: b0,
      Position: v0,
      SourceLocation: O0,
      getLineInfo: D0,
      Node: S8,
      TokenType: E,
      tokTypes: R,
      keywordTypes: d,
      TokContext: J1,
      tokContexts: P0,
      isIdentifierChar: T,
      isIdentifierStart: N,
      Token: E8,
      isNewLine: e,
      lineBreak: L0,
      lineBreakG: B0,
      nonASCIIwhitespace: q0
    };
    function VG(H, G) {
      return C0.parse(H, G);
    }
    function KG(H, G, K) {
      return C0.parseExpressionAt(H, G, K);
    }
    function MG(H, G) {
      return C0.tokenizer(H, G);
    }
    Z.Node = S8, Z.Parser = C0, Z.Position = v0, Z.SourceLocation = O0, Z.TokContext = J1, Z.Token = E8, Z.TokenType = E, Z.defaultOptions = b0, Z.getLineInfo = D0, Z.isIdentifierChar = T, Z.isIdentifierStart = N, Z.isNewLine = e, Z.keywordTypes = d, Z.lineBreak = L0, Z.lineBreakG = B0, Z.nonASCIIwhitespace = q0, Z.parse = VG, Z.parseExpressionAt = KG, Z.tokContexts = P0, Z.tokTypes = R, Z.tokenizer = MG, Z.version = TQ, Object.defineProperty(Z, "__esModule", { value: !0 });
  });
});

// node_modules/object-assign/index.js
var y7 = P((ht, hQ) => {
  var IG = function(Z) {
    if (Z === null || Z === void 0)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(Z);
  }, CG = function() {
    try {
      if (!Object.assign)
        return !1;
      var Z = new String("abc");
      if (Z[5] = "de", Object.getOwnPropertyNames(Z)[0] === "5")
        return !1;
      var Q = {};
      for (var J = 0;J < 10; J++)
        Q["_" + String.fromCharCode(J)] = J;
      var X = Object.getOwnPropertyNames(Q).map(function(Y) {
        return Q[Y];
      });
      if (X.join("") !== "0123456789")
        return !1;
      var z = {};
      if ("abcdefghijklmnopqrst".split("").forEach(function(Y) {
        z[Y] = Y;
      }), Object.keys(Object.assign({}, z)).join("") !== "abcdefghijklmnopqrst")
        return !1;
      return !0;
    } catch (Y) {
      return !1;
    }
  }, gQ = Object.getOwnPropertySymbols, $G = Object.prototype.hasOwnProperty, DG = Object.prototype.propertyIsEnumerable;
  hQ.exports = CG() ? Object.assign : function(Z, Q) {
    var J, X = IG(Z), z;
    for (var Y = 1;Y < arguments.length; Y++) {
      J = Object(arguments[Y]);
      for (var W in J)
        if ($G.call(J, W))
          X[W] = J[W];
      if (gQ) {
        z = gQ(J);
        for (var U = 0;U < z.length; U++)
          if (DG.call(J, z[U]))
            X[z[U]] = J[z[U]];
      }
    }
    return X;
  };
});

// node_modules/is-expression/index.js
var fQ = P((_t, kQ) => {
  var NG = function(Z, Q) {
    Q = AG({}, LG, Q);
    try {
      var J = new _Q.Parser(Q, Z, 0);
      if (Q.strict)
        J.strict = !0;
      if (!Q.lineComment)
        J.skipLineComment = function(X) {
          this.raise(this.pos, "Line comments not allowed in an expression");
        };
      if (J.nextToken(), J.parseExpression(), J.type !== _Q.tokTypes.eof)
        J.unexpected();
    } catch (X) {
      if (!Q.throw)
        return !1;
      throw X;
    }
    return !0;
  }, _Q = EQ(), AG = y7();
  kQ.exports = NG;
  var LG = {
    throw: !1,
    strict: !1,
    lineComment: !1
  };
});

// node_modules/es-errors/index.js
var mQ = P((kt, yQ) => {
  yQ.exports = Error;
});

// node_modules/es-errors/eval.js
var xQ = P((ft, uQ) => {
  uQ.exports = EvalError;
});

// node_modules/es-errors/range.js
var lQ = P((yt, cQ) => {
  cQ.exports = RangeError;
});

// node_modules/es-errors/ref.js
var dQ = P((mt, iQ) => {
  iQ.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var m7 = P((ut, pQ) => {
  pQ.exports = SyntaxError;
});

// node_modules/es-errors/type.js
var i5 = P((xt, aQ) => {
  aQ.exports = TypeError;
});

// node_modules/es-errors/uri.js
var nQ = P((ct, rQ) => {
  rQ.exports = URIError;
});

// node_modules/has-symbols/shams.js
var u7 = P((lt, sQ) => {
  sQ.exports = function Z() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function")
      return !1;
    if (typeof Symbol.iterator === "symbol")
      return !0;
    var Q = {}, J = Symbol("test"), X = Object(J);
    if (typeof J === "string")
      return !1;
    if (Object.prototype.toString.call(J) !== "[object Symbol]")
      return !1;
    if (Object.prototype.toString.call(X) !== "[object Symbol]")
      return !1;
    var z = 42;
    Q[J] = z;
    for (J in Q)
      return !1;
    if (typeof Object.keys === "function" && Object.keys(Q).length !== 0)
      return !1;
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(Q).length !== 0)
      return !1;
    var Y = Object.getOwnPropertySymbols(Q);
    if (Y.length !== 1 || Y[0] !== J)
      return !1;
    if (!Object.prototype.propertyIsEnumerable.call(Q, J))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var W = Object.getOwnPropertyDescriptor(Q, J);
      if (W.value !== z || W.enumerable !== !0)
        return !1;
    }
    return !0;
  };
});

// node_modules/has-symbols/index.js
var eQ = P((it, oQ) => {
  var tQ = typeof Symbol !== "undefined" && Symbol, PG = u7();
  oQ.exports = function Z() {
    if (typeof tQ !== "function")
      return !1;
    if (typeof Symbol !== "function")
      return !1;
    if (typeof tQ("foo") !== "symbol")
      return !1;
    if (typeof Symbol("bar") !== "symbol")
      return !1;
    return PG();
  };
});

// node_modules/has-proto/index.js
var QJ = P((dt, ZJ) => {
  var x7 = {
    __proto__: null,
    foo: {}
  }, SG = Object;
  ZJ.exports = function Z() {
    return { __proto__: x7 }.foo === x7.foo && !(x7 instanceof SG);
  };
});

// node_modules/function-bind/implementation.js
var zJ = P((pt, XJ) => {
  var wG = "Function.prototype.bind called on incompatible ", TG = Object.prototype.toString, vG = Math.max, bG = "[object Function]", JJ = function Z(Q, J) {
    var X = [];
    for (var z = 0;z < Q.length; z += 1)
      X[z] = Q[z];
    for (var Y = 0;Y < J.length; Y += 1)
      X[Y + Q.length] = J[Y];
    return X;
  }, EG = function Z(Q, J) {
    var X = [];
    for (var z = J || 0, Y = 0;z < Q.length; z += 1, Y += 1)
      X[Y] = Q[z];
    return X;
  }, gG = function(Z, Q) {
    var J = "";
    for (var X = 0;X < Z.length; X += 1)
      if (J += Z[X], X + 1 < Z.length)
        J += Q;
    return J;
  };
  XJ.exports = function Z(Q) {
    var J = this;
    if (typeof J !== "function" || TG.apply(J) !== bG)
      throw new TypeError(wG + J);
    var X = EG(arguments, 1), z, Y = function() {
      if (this instanceof z) {
        var q = J.apply(this, JJ(X, arguments));
        if (Object(q) === q)
          return q;
        return this;
      }
      return J.apply(Q, JJ(X, arguments));
    }, W = vG(0, J.length - X.length), U = [];
    for (var V = 0;V < W; V++)
      U[V] = "$" + V;
    if (z = Function("binder", "return function (" + gG(U, ",") + "){ return binder.apply(this,arguments); }")(Y), J.prototype) {
      var M = function q() {
      };
      M.prototype = J.prototype, z.prototype = new M, M.prototype = null;
    }
    return z;
  };
});

// node_modules/function-bind/index.js
var _8 = P((at, HJ) => {
  var hG = zJ();
  HJ.exports = Function.prototype.bind || hG;
});

// node_modules/hasown/index.js
var c7 = P((rt, YJ) => {
  var _G = Function.prototype.call, kG = Object.prototype.hasOwnProperty, fG = _8();
  YJ.exports = fG.call(_G, kG);
});

// node_modules/get-intrinsic/index.js
var N5 = P((nt, KJ) => {
  var W0, yG = mQ(), mG = xQ(), uG = lQ(), xG = dQ(), L5 = m7(), A5 = i5(), cG = nQ(), VJ = Function, l7 = function(Z) {
    try {
      return VJ('"use strict"; return (' + Z + ").constructor;")();
    } catch (Q) {
    }
  }, e1 = Object.getOwnPropertyDescriptor;
  if (e1)
    try {
      e1({}, "");
    } catch (Z) {
      e1 = null;
    }
  var i7 = function() {
    throw new A5;
  }, lG = e1 ? function() {
    try {
      return arguments.callee, i7;
    } catch (Z) {
      try {
        return e1(arguments, "callee").get;
      } catch (Q) {
        return i7;
      }
    }
  }() : i7, I5 = eQ()(), iG = QJ()(), E0 = Object.getPrototypeOf || (iG ? function(Z) {
    return Z.__proto__;
  } : null), C5 = {}, dG = typeof Uint8Array === "undefined" || !E0 ? W0 : E0(Uint8Array), Z5 = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? W0 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? W0 : ArrayBuffer,
    "%ArrayIteratorPrototype%": I5 && E0 ? E0([][Symbol.iterator]()) : W0,
    "%AsyncFromSyncIteratorPrototype%": W0,
    "%AsyncFunction%": C5,
    "%AsyncGenerator%": C5,
    "%AsyncGeneratorFunction%": C5,
    "%AsyncIteratorPrototype%": C5,
    "%Atomics%": typeof Atomics === "undefined" ? W0 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? W0 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? W0 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? W0 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? W0 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": yG,
    "%eval%": eval,
    "%EvalError%": mG,
    "%Float32Array%": typeof Float32Array === "undefined" ? W0 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? W0 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? W0 : FinalizationRegistry,
    "%Function%": VJ,
    "%GeneratorFunction%": C5,
    "%Int8Array%": typeof Int8Array === "undefined" ? W0 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? W0 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? W0 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": I5 && E0 ? E0(E0([][Symbol.iterator]())) : W0,
    "%JSON%": typeof JSON === "object" ? JSON : W0,
    "%Map%": typeof Map === "undefined" ? W0 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !I5 || !E0 ? W0 : E0((new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? W0 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? W0 : Proxy,
    "%RangeError%": uG,
    "%ReferenceError%": xG,
    "%Reflect%": typeof Reflect === "undefined" ? W0 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? W0 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !I5 || !E0 ? W0 : E0((new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? W0 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": I5 && E0 ? E0(""[Symbol.iterator]()) : W0,
    "%Symbol%": I5 ? Symbol : W0,
    "%SyntaxError%": L5,
    "%ThrowTypeError%": lG,
    "%TypedArray%": dG,
    "%TypeError%": A5,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? W0 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? W0 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? W0 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? W0 : Uint32Array,
    "%URIError%": cG,
    "%WeakMap%": typeof WeakMap === "undefined" ? W0 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? W0 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? W0 : WeakSet
  };
  if (E0)
    try {
      null.error;
    } catch (Z) {
      WJ = E0(E0(Z)), Z5["%Error.prototype%"] = WJ;
    }
  var WJ, pG = function Z(Q) {
    var J;
    if (Q === "%AsyncFunction%")
      J = l7("async function () {}");
    else if (Q === "%GeneratorFunction%")
      J = l7("function* () {}");
    else if (Q === "%AsyncGeneratorFunction%")
      J = l7("async function* () {}");
    else if (Q === "%AsyncGenerator%") {
      var X = Z("%AsyncGeneratorFunction%");
      if (X)
        J = X.prototype;
    } else if (Q === "%AsyncIteratorPrototype%") {
      var z = Z("%AsyncGenerator%");
      if (z && E0)
        J = E0(z.prototype);
    }
    return Z5[Q] = J, J;
  }, GJ = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, d5 = _8(), k8 = c7(), aG = d5.call(Function.call, Array.prototype.concat), rG = d5.call(Function.apply, Array.prototype.splice), UJ = d5.call(Function.call, String.prototype.replace), f8 = d5.call(Function.call, String.prototype.slice), nG = d5.call(Function.call, RegExp.prototype.exec), sG = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, tG = /\\(\\)?/g, oG = function Z(Q) {
    var J = f8(Q, 0, 1), X = f8(Q, -1);
    if (J === "%" && X !== "%")
      throw new L5("invalid intrinsic syntax, expected closing `%`");
    else if (X === "%" && J !== "%")
      throw new L5("invalid intrinsic syntax, expected opening `%`");
    var z = [];
    return UJ(Q, sG, function(Y, W, U, V) {
      z[z.length] = U ? UJ(V, tG, "$1") : W || Y;
    }), z;
  }, eG = function Z(Q, J) {
    var X = Q, z;
    if (k8(GJ, X))
      z = GJ[X], X = "%" + z[0] + "%";
    if (k8(Z5, X)) {
      var Y = Z5[X];
      if (Y === C5)
        Y = pG(X);
      if (typeof Y === "undefined" && !J)
        throw new A5("intrinsic " + Q + " exists, but is not available. Please file an issue!");
      return {
        alias: z,
        name: X,
        value: Y
      };
    }
    throw new L5("intrinsic " + Q + " does not exist!");
  };
  KJ.exports = function Z(Q, J) {
    if (typeof Q !== "string" || Q.length === 0)
      throw new A5("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof J !== "boolean")
      throw new A5('"allowMissing" argument must be a boolean');
    if (nG(/^%?[^%]*%?$/, Q) === null)
      throw new L5("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var X = oG(Q), z = X.length > 0 ? X[0] : "", Y = eG("%" + z + "%", J), W = Y.name, U = Y.value, V = !1, M = Y.alias;
    if (M)
      z = M[0], rG(X, aG([0, 1], M));
    for (var q = 1, L = !0;q < X.length; q += 1) {
      var N = X[q], T = f8(N, 0, 1), E = f8(N, -1);
      if ((T === '"' || T === "'" || T === "`" || (E === '"' || E === "'" || E === "`")) && T !== E)
        throw new L5("property names with quotes must have matching quotes");
      if (N === "constructor" || !L)
        V = !0;
      if (z += "." + N, W = "%" + z + "%", k8(Z5, W))
        U = Z5[W];
      else if (U != null) {
        if (!(N in U)) {
          if (!J)
            throw new A5("base intrinsic for " + Q + " exists, but the property is not available.");
          return;
        }
        if (e1 && q + 1 >= X.length) {
          var g = e1(U, N);
          if (L = !!g, L && "get" in g && !("originalValue" in g.get))
            U = g.get;
          else
            U = U[N];
        } else
          L = k8(U, N), U = U[N];
        if (L && !V)
          Z5[W] = U;
      }
    }
    return U;
  };
});

// node_modules/es-define-property/index.js
var m8 = P((st, MJ) => {
  var ZU = N5(), y8 = ZU("%Object.defineProperty%", !0) || !1;
  if (y8)
    try {
      y8({}, "a", { value: 1 });
    } catch (Z) {
      y8 = !1;
    }
  MJ.exports = y8;
});

// node_modules/gopd/index.js
var d7 = P((tt, FJ) => {
  var QU = N5(), u8 = QU("%Object.getOwnPropertyDescriptor%", !0);
  if (u8)
    try {
      u8([], "length");
    } catch (Z) {
      u8 = null;
    }
  FJ.exports = u8;
});

// node_modules/define-data-property/index.js
var BJ = P((ot, OJ) => {
  var RJ = m8(), JU = m7(), P5 = i5(), jJ = d7();
  OJ.exports = function Z(Q, J, X) {
    if (!Q || typeof Q !== "object" && typeof Q !== "function")
      throw new P5("`obj` must be an object or a function`");
    if (typeof J !== "string" && typeof J !== "symbol")
      throw new P5("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null)
      throw new P5("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null)
      throw new P5("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null)
      throw new P5("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] !== "boolean")
      throw new P5("`loose`, if provided, must be a boolean");
    var z = arguments.length > 3 ? arguments[3] : null, Y = arguments.length > 4 ? arguments[4] : null, W = arguments.length > 5 ? arguments[5] : null, U = arguments.length > 6 ? arguments[6] : !1, V = !!jJ && jJ(Q, J);
    if (RJ)
      RJ(Q, J, {
        configurable: W === null && V ? V.configurable : !W,
        enumerable: z === null && V ? V.enumerable : !z,
        value: X,
        writable: Y === null && V ? V.writable : !Y
      });
    else if (U || !z && !Y && !W)
      Q[J] = X;
    else
      throw new JU("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  };
});

// node_modules/has-property-descriptors/index.js
var DJ = P((et, $J) => {
  var p7 = m8(), qJ = function Z() {
    return !!p7;
  };
  qJ.hasArrayLengthDefineBug = function Z() {
    if (!p7)
      return null;
    try {
      return p7([], "length", { value: 1 }).length !== 1;
    } catch (Q) {
      return !0;
    }
  };
  $J.exports = qJ;
});

// node_modules/set-function-length/index.js
var NJ = P((Zo, LJ) => {
  var XU = N5(), IJ = BJ(), zU = DJ()(), CJ = d7(), AJ = i5(), HU = XU("%Math.floor%");
  LJ.exports = function Z(Q, J) {
    if (typeof Q !== "function")
      throw new AJ("`fn` is not a function");
    if (typeof J !== "number" || J < 0 || J > 4294967295 || HU(J) !== J)
      throw new AJ("`length` must be a positive 32-bit integer");
    var X = arguments.length > 2 && !!arguments[2], z = !0, Y = !0;
    if ("length" in Q && CJ) {
      var W = CJ(Q, "length");
      if (W && !W.configurable)
        z = !1;
      if (W && !W.writable)
        Y = !1;
    }
    if (z || Y || !X)
      if (zU)
        IJ(Q, "length", J, !0, !0);
      else
        IJ(Q, "length", J);
    return Q;
  };
});

// node_modules/call-bind/index.js
var bJ = P((Qo, x8) => {
  var a7 = _8(), c8 = N5(), YU = NJ(), WU = i5(), wJ = c8("%Function.prototype.apply%"), TJ = c8("%Function.prototype.call%"), vJ = c8("%Reflect.apply%", !0) || a7.call(TJ, wJ), PJ = m8(), GU = c8("%Math.max%");
  x8.exports = function Z(Q) {
    if (typeof Q !== "function")
      throw new WU("a function is required");
    var J = vJ(a7, TJ, arguments);
    return YU(J, 1 + GU(0, Q.length - (arguments.length - 1)), !0);
  };
  var SJ = function Z() {
    return vJ(a7, wJ, arguments);
  };
  if (PJ)
    PJ(x8.exports, "apply", { value: SJ });
  else
    x8.exports.apply = SJ;
});

// node_modules/call-bind/callBound.js
var _J = P((Jo, hJ) => {
  var EJ = N5(), gJ = bJ(), UU = gJ(EJ("String.prototype.indexOf"));
  hJ.exports = function Z(Q, J) {
    var X = EJ(Q, !!J);
    if (typeof X === "function" && UU(Q, ".prototype.") > -1)
      return gJ(X);
    return X;
  };
});

// node_modules/has-tostringtag/shams.js
var fJ = P((Xo, kJ) => {
  var VU = u7();
  kJ.exports = function Z() {
    return VU() && !!Symbol.toStringTag;
  };
});

// node_modules/is-regex/index.js
var cJ = P((zo, xJ) => {
  var r7 = _J(), yJ = fJ()(), mJ, uJ, n7, s7;
  if (yJ) {
    if (mJ = r7("Object.prototype.hasOwnProperty"), uJ = r7("RegExp.prototype.exec"), n7 = {}, l8 = function() {
      throw n7;
    }, s7 = {
      toString: l8,
      valueOf: l8
    }, typeof Symbol.toPrimitive === "symbol")
      s7[Symbol.toPrimitive] = l8;
  }
  var l8, KU = r7("Object.prototype.toString"), MU = Object.getOwnPropertyDescriptor, FU = "[object RegExp]";
  xJ.exports = yJ ? function Z(Q) {
    if (!Q || typeof Q !== "object")
      return !1;
    var J = MU(Q, "lastIndex"), X = J && mJ(J, "value");
    if (!X)
      return !1;
    try {
      uJ(Q, s7);
    } catch (z) {
      return z === n7;
    }
  } : function Z(Q) {
    if (!Q || typeof Q !== "object" && typeof Q !== "function")
      return !1;
    return KU(Q) === FU;
  };
});

// node_modules/character-parser/index.js
var aJ = P((t0, pJ) => {
  var lJ = function(Z, Q, J) {
    J = J || {}, Q = Q || t0.defaultState();
    var X = J.start || 0, z = J.end || Z.length, Y = X;
    while (Y < z) {
      try {
        o7(Z[Y], Q);
      } catch (W) {
        throw W.index = Y, W;
      }
      Y++;
    }
    return Q;
  }, OU = function(Z, Q, J) {
    J = J || {};
    var X = J.start || 0, z = X, Y = t0.defaultState();
    while (z < Z.length) {
      if ((J.ignoreNesting || !Y.isNesting(J)) && BU(Z, Q, z)) {
        var W = z;
        return {
          start: X,
          end: W,
          src: Z.substring(X, W)
        };
      }
      try {
        o7(Z[z], Y);
      } catch (V) {
        throw V.index = z, V;
      }
      z++;
    }
    var U = new Error("The end of the string was reached with no closing bracket found.");
    throw U.code = "CHARACTER_PARSER:END_OF_STRING_REACHED", U.index = z, U;
  }, o7 = function(Z, Q) {
    if (Z.length !== 1) {
      var J = new Error("Character must be a string of length 1");
      throw J.name = "InvalidArgumentError", J.code = "CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE", J;
    }
    Q = Q || t0.defaultState(), Q.src += Z;
    var X = Q.isComment(), z = Q.history ? Q.history[0] : "";
    if (Q.regexpStart) {
      if (Z === "/" || Z == "*")
        Q.stack.pop();
      Q.regexpStart = !1;
    }
    switch (Q.current()) {
      case g0.LINE_COMMENT:
        if (Z === "\n")
          Q.stack.pop();
        break;
      case g0.BLOCK_COMMENT:
        if (Q.lastChar === "*" && Z === "/")
          Q.stack.pop();
        break;
      case g0.SINGLE_QUOTE:
        if (Z === "\'" && !Q.escaped)
          Q.stack.pop();
        else if (Z === "\\" && !Q.escaped)
          Q.escaped = !0;
        else
          Q.escaped = !1;
        break;
      case g0.DOUBLE_QUOTE:
        if (Z === '"' && !Q.escaped)
          Q.stack.pop();
        else if (Z === "\\" && !Q.escaped)
          Q.escaped = !0;
        else
          Q.escaped = !1;
        break;
      case g0.TEMPLATE_QUOTE:
        if (Z === "`" && !Q.escaped)
          Q.stack.pop(), Q.hasDollar = !1;
        else if (Z === "\\" && !Q.escaped)
          Q.escaped = !0, Q.hasDollar = !1;
        else if (Z === "$" && !Q.escaped)
          Q.hasDollar = !0;
        else if (Z === "{" && Q.hasDollar)
          Q.stack.push(t7[Z]);
        else
          Q.escaped = !1, Q.hasDollar = !1;
        break;
      case g0.REGEXP:
        if (Z === "/" && !Q.escaped)
          Q.stack.pop();
        else if (Z === "\\" && !Q.escaped)
          Q.escaped = !0;
        else
          Q.escaped = !1;
        break;
      default:
        if (Z in t7)
          Q.stack.push(t7[Z]);
        else if (Z in jU) {
          if (Q.current() !== Z) {
            var J = new SyntaxError("Mismatched Bracket: " + Z);
            throw J.code = "CHARACTER_PARSER:MISMATCHED_BRACKET", J;
          }
          Q.stack.pop();
        } else if (z === "/" && Z === "/")
          Q.history = Q.history.substr(1), Q.stack.push(g0.LINE_COMMENT);
        else if (z === "/" && Z === "*")
          Q.history = Q.history.substr(1), Q.stack.push(g0.BLOCK_COMMENT);
        else if (Z === "/" && qU(Q.history))
          Q.stack.push(g0.REGEXP), Q.regexpStart = !0;
        else if (Z === "\'")
          Q.stack.push(g0.SINGLE_QUOTE);
        else if (Z === '"')
          Q.stack.push(g0.DOUBLE_QUOTE);
        else if (Z === "`")
          Q.stack.push(g0.TEMPLATE_QUOTE);
        break;
    }
    if (!Q.isComment() && !X)
      Q.history = Z + Q.history;
    return Q.lastChar = Z, Q;
  }, p5 = function() {
    this.stack = [], this.regexpStart = !1, this.escaped = !1, this.hasDollar = !1, this.src = "", this.history = "", this.lastChar = "";
  }, BU = function(Z, Q, J) {
    if (RU(Q))
      return Q.test(Z.substr(J || 0));
    else
      return Z.substr(J || 0, Q.length) === Q;
  }, iJ = function(Z) {
    if (!Z)
      return !0;
    var Q = Z.charCodeAt(0);
    switch (Q) {
      case 46:
      case 40:
      case 41:
      case 59:
      case 44:
      case 123:
      case 125:
      case 91:
      case 93:
      case 58:
      case 63:
      case 126:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 47:
      case 60:
      case 62:
      case 94:
      case 124:
      case 33:
      case 61:
        return !0;
      default:
        return !1;
    }
  }, dJ = function(Z) {
    return Z === "if" || Z === "in" || Z === "do" || Z === "var" || Z === "for" || Z === "new" || Z === "try" || Z === "let" || Z === "this" || Z === "else" || Z === "case" || Z === "void" || Z === "with" || Z === "enum" || Z === "while" || Z === "break" || Z === "catch" || Z === "throw" || Z === "const" || Z === "yield" || Z === "class" || Z === "super" || Z === "return" || Z === "typeof" || Z === "delete" || Z === "switch" || Z === "export" || Z === "import" || Z === "default" || Z === "finally" || Z === "extends" || Z === "function" || Z === "continue" || Z === "debugger" || Z === "package" || Z === "private" || Z === "interface" || Z === "instanceof" || Z === "implements" || Z === "protected" || Z === "public" || Z === "static";
  }, qU = function(Z) {
    if (Z = Z.replace(/^\s*/, ""), Z[0] === ")")
      return !1;
    if (Z[0] === "}")
      return !0;
    if (iJ(Z[0]))
      return !0;
    if (/^\w+\b/.test(Z) && dJ(/^\w+\b/.exec(Z)[0].split("").reverse().join("")))
      return !0;
    return !1;
  }, RU = cJ();
  t0 = pJ.exports = lJ;
  var g0 = t0.TOKEN_TYPES = {
    LINE_COMMENT: "//",
    BLOCK_COMMENT: "/**/",
    SINGLE_QUOTE: "\'",
    DOUBLE_QUOTE: '"',
    TEMPLATE_QUOTE: "`",
    REGEXP: "//g"
  }, t7 = t0.BRACKETS = {
    "(": ")",
    "{": "}",
    "[": "]"
  }, jU = {
    ")": "(",
    "}": "{",
    "]": "["
  };
  t0.parse = lJ;
  t0.parseUntil = OU;
  t0.parseChar = o7;
  t0.defaultState = function() {
    return new p5;
  };
  p5.prototype.current = function() {
    return this.stack[this.stack.length - 1];
  };
  p5.prototype.isString = function() {
    return this.current() === g0.SINGLE_QUOTE || this.current() === g0.DOUBLE_QUOTE || this.current() === g0.TEMPLATE_QUOTE;
  };
  p5.prototype.isComment = function() {
    return this.current() === g0.LINE_COMMENT || this.current() === g0.BLOCK_COMMENT;
  };
  p5.prototype.isNesting = function(Z) {
    if (Z && Z.ignoreLineComment && this.stack.length === 1 && this.stack[0] === g0.LINE_COMMENT)
      return !1;
    return !!this.stack.length;
  };
  t0.isPunctuator = iJ;
  t0.isKeyword = dJ;
});

// node_modules/pug-error/index.js
var Q5 = P((Ho, rJ) => {
  var $U = function(Z, Q, J) {
    var { line: X, column: z, filename: Y, src: W } = J, U, V = X + (z ? ":" + z : "");
    if (W && X >= 1 && X <= W.split("\n").length) {
      var M = W.split("\n"), q = Math.max(X - 3, 0), L = Math.min(M.length, X + 3), N = M.slice(q, L).map(function(E, g) {
        var n = g + q + 1, x = (n == X ? "  > " : "    ") + n + "| ", d = x + E;
        if (n === X && z > 0)
          d += "\n", d += Array(x.length + z).join("-") + "^";
        return d;
      }).join("\n");
      U = (Y || "Pug") + ":" + V + "\n" + N + "\n\n" + Q;
    } else
      U = (Y || "Pug") + ":" + V + "\n\n" + Q;
    var T = new Error(U);
    return T.code = "PUG:" + Z, T.msg = Q, T.line = X, T.column = z, T.filename = Y, T.src = W, T.toJSON = function() {
      return {
        code: this.code,
        msg: this.msg,
        line: this.line,
        column: this.column,
        filename: this.filename
      };
    }, T;
  };
  rJ.exports = $U;
});

// node_modules/pug-lexer/index.js
var nJ = P((Yo, e7) => {
  var AU = function(Z, Q) {
    var J = new i8(Z, Q);
    return JSON.parse(JSON.stringify(J.getTokens()));
  }, i8 = function(Z, Q) {
    if (Q = Q || {}, typeof Z !== "string")
      throw new Error('Expected source code to be a string but got "' + typeof Z + '"');
    if (typeof Q !== "object")
      throw new Error('Expected "options" to be an object but got "' + typeof Q + '"');
    Z = Z.replace(/^\uFEFF/, ""), this.input = Z.replace(/\r\n|\r/g, "\n"), this.originalInput = this.input, this.filename = Q.filename, this.interpolated = Q.interpolated || !1, this.lineno = Q.startingLine || 1, this.colno = Q.startingColumn || 1, this.plugins = Q.plugins || [], this.indentStack = [0], this.indentRe = null, this.interpolationAllowed = !0, this.whitespaceRe = /[ \n\t]/, this.tokens = [], this.ended = !1;
  }, DU = A0("assert"), IU = fQ(), M1 = aJ(), CU = Q5();
  e7.exports = AU;
  e7.exports.Lexer = i8;
  i8.prototype = {
    constructor: i8,
    error: function(Z, Q) {
      var J = CU(Z, Q, {
        line: this.lineno,
        column: this.colno,
        filename: this.filename,
        src: this.originalInput
      });
      throw J;
    },
    assert: function(Z, Q) {
      if (!Z)
        this.error("ASSERT_FAILED", Q);
    },
    isExpression: function(Z) {
      return IU(Z, {
        throw: !0
      });
    },
    assertExpression: function(Z, Q) {
      try {
        return this.callLexerFunction("isExpression", Z), !0;
      } catch (X) {
        if (Q)
          return !1;
        if (!X.loc)
          throw X;
        this.incrementLine(X.loc.line - 1), this.incrementColumn(X.loc.column);
        var J = "Syntax Error: " + X.message.replace(/ \([0-9]+:[0-9]+\)$/, "");
        this.error("SYNTAX_ERROR", J);
      }
    },
    assertNestingCorrect: function(Z) {
      var Q = M1(Z);
      if (Q.isNesting())
        this.error("INCORRECT_NESTING", "Nesting must match on expression `" + Z + "`");
    },
    tok: function(Z, Q) {
      var J = {
        type: Z,
        loc: {
          start: {
            line: this.lineno,
            column: this.colno
          },
          filename: this.filename
        }
      };
      if (Q !== void 0)
        J.val = Q;
      return J;
    },
    tokEnd: function(Z) {
      return Z.loc.end = {
        line: this.lineno,
        column: this.colno
      }, Z;
    },
    incrementLine: function(Z) {
      if (this.lineno += Z, Z)
        this.colno = 1;
    },
    incrementColumn: function(Z) {
      this.colno += Z;
    },
    consume: function(Z) {
      this.input = this.input.substr(Z);
    },
    scan: function(Z, Q) {
      var J;
      if (J = Z.exec(this.input)) {
        var X = J[0].length, z = J[1], Y = X - (z ? z.length : 0), W = this.tok(Q, z);
        return this.consume(X), this.incrementColumn(Y), W;
      }
    },
    scanEndOfLine: function(Z, Q) {
      var J;
      if (J = Z.exec(this.input)) {
        var X = 0, z, Y;
        if (z = /^([ ]+)([^ ]*)/.exec(J[0]))
          X = z[1].length, this.incrementColumn(X);
        var W = this.input.substr(J[0].length);
        if (W[0] === ":")
          return this.input = W, Y = this.tok(Q, J[1]), this.incrementColumn(J[0].length - X), Y;
        if (/^[ \t]*(\n|$)/.test(W))
          return this.input = W.substr(/^[ \t]*/.exec(W)[0].length), Y = this.tok(Q, J[1]), this.incrementColumn(J[0].length - X), Y;
      }
    },
    bracketExpression: function(Z) {
      Z = Z || 0;
      var Q = this.input[Z];
      DU(Q === "(" || Q === "{" || Q === "[", 'The start character should be "(", "{" or "["');
      var J = M1.BRACKETS[Q], X;
      try {
        X = M1.parseUntil(this.input, J, { start: Z + 1 });
      } catch (V) {
        if (V.index !== void 0) {
          var z = V.index, Y = this.input.substr(Z).indexOf("\n"), W = Y + Z, U = 0;
          while (z > W && Y !== -1)
            this.incrementLine(1), z -= W + 1, U += W + 1, Y = W = this.input.substr(U).indexOf("\n");
          this.incrementColumn(z);
        }
        if (V.code === "CHARACTER_PARSER:END_OF_STRING_REACHED")
          this.error("NO_END_BRACKET", "The end of the string reached with no closing bracket " + J + " found.");
        else if (V.code === "CHARACTER_PARSER:MISMATCHED_BRACKET")
          this.error("BRACKET_MISMATCH", V.message);
        throw V;
      }
      return X;
    },
    scanIndentation: function() {
      var Z, Q;
      if (this.indentRe)
        Z = this.indentRe.exec(this.input);
      else {
        if (Q = /^\n(\t*) */, Z = Q.exec(this.input), Z && !Z[1].length)
          Q = /^\n( *)/, Z = Q.exec(this.input);
        if (Z && Z[1].length)
          this.indentRe = Q;
      }
      return Z;
    },
    eos: function() {
      if (this.input.length)
        return;
      if (this.interpolated)
        this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
      for (var Z = 0;this.indentStack[Z]; Z++)
        this.tokens.push(this.tokEnd(this.tok("outdent")));
      return this.tokens.push(this.tokEnd(this.tok("eos"))), this.ended = !0, !0;
    },
    blank: function() {
      var Z;
      if (Z = /^\n[ \t]*\n/.exec(this.input))
        return this.consume(Z[0].length - 1), this.incrementLine(1), !0;
    },
    comment: function() {
      var Z;
      if (Z = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
        this.consume(Z[0].length);
        var Q = this.tok("comment", Z[2]);
        return Q.buffer = Z[1] != "-", this.interpolationAllowed = Q.buffer, this.tokens.push(Q), this.incrementColumn(Z[0].length), this.tokEnd(Q), this.callLexerFunction("pipelessText"), !0;
      }
    },
    interpolation: function() {
      if (/^#\{/.test(this.input)) {
        var Z = this.bracketExpression(1);
        this.consume(Z.end + 1);
        var Q = this.tok("interpolation", Z.src);
        this.tokens.push(Q), this.incrementColumn(2), this.assertExpression(Z.src);
        var J = Z.src.split("\n"), X = J.length - 1;
        return this.incrementLine(X), this.incrementColumn(J[X].length + 1), this.tokEnd(Q), !0;
      }
    },
    tag: function() {
      var Z;
      if (Z = /^(\w(?:[-:\w]*\w)?)/.exec(this.input)) {
        var Q, J = Z[1], X = Z[0].length;
        return this.consume(X), Q = this.tok("tag", J), this.tokens.push(Q), this.incrementColumn(X), this.tokEnd(Q), !0;
      }
    },
    filter: function(Z) {
      var Q = this.scan(/^:([\w\-]+)/, "filter"), J = Z && Z.inInclude;
      if (Q) {
        if (this.tokens.push(Q), this.incrementColumn(Q.val.length), this.tokEnd(Q), this.callLexerFunction("attrs"), !J)
          this.interpolationAllowed = !1, this.callLexerFunction("pipelessText");
        return !0;
      }
    },
    doctype: function() {
      var Z = this.scanEndOfLine(/^doctype *([^\n]*)/, "doctype");
      if (Z)
        return this.tokens.push(this.tokEnd(Z)), !0;
    },
    id: function() {
      var Z = this.scan(/^#([\w-]+)/, "id");
      if (Z)
        return this.tokens.push(Z), this.incrementColumn(Z.val.length), this.tokEnd(Z), !0;
      if (/^#/.test(this.input))
        this.error("INVALID_ID", '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid ID.');
    },
    className: function() {
      var Z = this.scan(/^\.([_a-z0-9\-]*[_a-z][_a-z0-9\-]*)/i, "class");
      if (Z)
        return this.tokens.push(Z), this.incrementColumn(Z.val.length), this.tokEnd(Z), !0;
      if (/^\.[_a-z0-9\-]+/i.test(this.input))
        this.error("INVALID_CLASS_NAME", "Class names must contain at least one letter or underscore.");
      if (/^\./.test(this.input))
        this.error("INVALID_CLASS_NAME", '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid class name.  Class names can only contain "_", "-", a-z and 0-9, and must contain at least one of "_", or a-z');
    },
    endInterpolation: function() {
      if (this.interpolated && this.input[0] === "]")
        return this.input = this.input.substr(1), this.ended = !0, !0;
    },
    addText: function(Z, Q, J, X) {
      var z;
      if (Q + J === "")
        return;
      J = J || "", X = X || 0;
      var Y = this.interpolated ? Q.indexOf("]") : -1, W = this.interpolationAllowed ? Q.indexOf("#[") : -1, U = this.interpolationAllowed ? Q.indexOf("\\#[") : -1, V = /(\\)?([#!]){((?:.|\n)*)$/.exec(Q), M = this.interpolationAllowed && V ? V.index : Infinity;
      if (Y === -1)
        Y = Infinity;
      if (W === -1)
        W = Infinity;
      if (U === -1)
        U = Infinity;
      if (U !== Infinity && U < Y && U < W && U < M)
        return J = J + Q.substring(0, U) + "#[", this.addText(Z, Q.substring(U + 3), J, X + 1);
      if (W !== Infinity && W < Y && W < U && W < M) {
        z = this.tok(Z, J + Q.substring(0, W)), this.incrementColumn(J.length + W + X), this.tokens.push(this.tokEnd(z)), z = this.tok("start-pug-interpolation"), this.incrementColumn(2), this.tokens.push(this.tokEnd(z));
        var q = new this.constructor(Q.substr(W + 2), {
          filename: this.filename,
          interpolated: !0,
          startingLine: this.lineno,
          startingColumn: this.colno,
          plugins: this.plugins
        }), L;
        try {
          L = q.getTokens();
        } catch (g) {
          if (g.code && /^PUG:/.test(g.code))
            this.colno = g.column, this.error(g.code.substr(4), g.msg);
          throw g;
        }
        this.colno = q.colno, this.tokens = this.tokens.concat(L), z = this.tok("end-pug-interpolation"), this.incrementColumn(1), this.tokens.push(this.tokEnd(z)), this.addText(Z, q.input);
        return;
      }
      if (Y !== Infinity && Y < W && Y < U && Y < M) {
        if (J + Q.substring(0, Y))
          this.addText(Z, Q.substring(0, Y), J);
        this.ended = !0, this.input = Q.substr(Q.indexOf("]") + 1) + this.input;
        return;
      }
      if (M !== Infinity) {
        if (V[1])
          return J = J + Q.substring(0, M) + V[2] + "{", this.addText(Z, Q.substring(M + 3), J, X + 1);
        var N = Q.substr(0, M);
        if (J || N)
          N = J + N, z = this.tok(Z, N), this.incrementColumn(N.length + X), this.tokens.push(this.tokEnd(z));
        var T = V[3], E;
        z = this.tok("interpolated-code"), this.incrementColumn(2);
        try {
          E = M1.parseUntil(T, "}");
        } catch (g) {
          if (g.index !== void 0)
            this.incrementColumn(g.index);
          if (g.code === "CHARACTER_PARSER:END_OF_STRING_REACHED")
            this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
          else if (g.code === "CHARACTER_PARSER:MISMATCHED_BRACKET")
            this.error("BRACKET_MISMATCH", g.message);
          else
            throw g;
        }
        if (z.mustEscape = V[2] === "#", z.buffer = !0, z.val = E.src, this.assertExpression(E.src), E.end + 1 < T.length)
          T = T.substr(E.end + 1), this.incrementColumn(E.end + 1), this.tokens.push(this.tokEnd(z)), this.addText(Z, T);
        else
          this.incrementColumn(T.length), this.tokens.push(this.tokEnd(z));
        return;
      }
      Q = J + Q, z = this.tok(Z, Q), this.incrementColumn(Q.length + X), this.tokens.push(this.tokEnd(z));
    },
    text: function() {
      var Z = this.scan(/^(?:\| ?| )([^\n]+)/, "text") || this.scan(/^( )/, "text") || this.scan(/^\|( ?)/, "text");
      if (Z)
        return this.addText("text", Z.val), !0;
    },
    textHtml: function() {
      var Z = this.scan(/^(<[^\n]*)/, "text-html");
      if (Z)
        return this.addText("text-html", Z.val), !0;
    },
    dot: function() {
      var Z;
      if (Z = this.scanEndOfLine(/^\./, "dot"))
        return this.tokens.push(this.tokEnd(Z)), this.callLexerFunction("pipelessText"), !0;
    },
    extends: function() {
      var Z = this.scan(/^extends?(?= |$|\n)/, "extends");
      if (Z) {
        if (this.tokens.push(this.tokEnd(Z)), !this.callLexerFunction("path"))
          this.error("NO_EXTENDS_PATH", "missing path for extends");
        return !0;
      }
      if (this.scan(/^extends?\b/))
        this.error("MALFORMED_EXTENDS", "malformed extends");
    },
    prepend: function() {
      var Z;
      if (Z = /^(?:block +)?prepend +([^\n]+)/.exec(this.input)) {
        var Q = Z[1].trim(), J = "";
        if (Q.indexOf("//") !== -1)
          J = "//" + Q.split("//").slice(1).join("//"), Q = Q.split("//")[0].trim();
        if (!Q)
          return;
        var X = this.tok("block", Q), z = Z[0].length - J.length;
        while (this.whitespaceRe.test(this.input.charAt(z - 1)))
          z--;
        return this.incrementColumn(z), X.mode = "prepend", this.tokens.push(this.tokEnd(X)), this.consume(Z[0].length - J.length), this.incrementColumn(Z[0].length - J.length - z), !0;
      }
    },
    append: function() {
      var Z;
      if (Z = /^(?:block +)?append +([^\n]+)/.exec(this.input)) {
        var Q = Z[1].trim(), J = "";
        if (Q.indexOf("//") !== -1)
          J = "//" + Q.split("//").slice(1).join("//"), Q = Q.split("//")[0].trim();
        if (!Q)
          return;
        var X = this.tok("block", Q), z = Z[0].length - J.length;
        while (this.whitespaceRe.test(this.input.charAt(z - 1)))
          z--;
        return this.incrementColumn(z), X.mode = "append", this.tokens.push(this.tokEnd(X)), this.consume(Z[0].length - J.length), this.incrementColumn(Z[0].length - J.length - z), !0;
      }
    },
    block: function() {
      var Z;
      if (Z = /^block +([^\n]+)/.exec(this.input)) {
        var Q = Z[1].trim(), J = "";
        if (Q.indexOf("//") !== -1)
          J = "//" + Q.split("//").slice(1).join("//"), Q = Q.split("//")[0].trim();
        if (!Q)
          return;
        var X = this.tok("block", Q), z = Z[0].length - J.length;
        while (this.whitespaceRe.test(this.input.charAt(z - 1)))
          z--;
        return this.incrementColumn(z), X.mode = "replace", this.tokens.push(this.tokEnd(X)), this.consume(Z[0].length - J.length), this.incrementColumn(Z[0].length - J.length - z), !0;
      }
    },
    mixinBlock: function() {
      var Z;
      if (Z = this.scanEndOfLine(/^block/, "mixin-block"))
        return this.tokens.push(this.tokEnd(Z)), !0;
    },
    yield: function() {
      var Z = this.scanEndOfLine(/^yield/, "yield");
      if (Z)
        return this.tokens.push(this.tokEnd(Z)), !0;
    },
    include: function() {
      var Z = this.scan(/^include(?=:| |$|\n)/, "include");
      if (Z) {
        this.tokens.push(this.tokEnd(Z));
        while (this.callLexerFunction("filter", { inInclude: !0 }))
          ;
        if (!this.callLexerFunction("path"))
          if (/^[^ \n]+/.test(this.input))
            this.fail();
          else
            this.error("NO_INCLUDE_PATH", "missing path for include");
        return !0;
      }
      if (this.scan(/^include\b/))
        this.error("MALFORMED_INCLUDE", "malformed include");
    },
    path: function() {
      var Z = this.scanEndOfLine(/^ ([^\n]+)/, "path");
      if (Z && (Z.val = Z.val.trim()))
        return this.tokens.push(this.tokEnd(Z)), !0;
    },
    case: function() {
      var Z = this.scanEndOfLine(/^case +([^\n]+)/, "case");
      if (Z)
        return this.incrementColumn(-Z.val.length), this.assertExpression(Z.val), this.incrementColumn(Z.val.length), this.tokens.push(this.tokEnd(Z)), !0;
      if (this.scan(/^case\b/))
        this.error("NO_CASE_EXPRESSION", "missing expression for case");
    },
    when: function() {
      var Z = this.scanEndOfLine(/^when +([^:\n]+)/, "when");
      if (Z) {
        var Q = M1(Z.val);
        while (Q.isNesting() || Q.isString()) {
          var J = /:([^:\n]+)/.exec(this.input);
          if (!J)
            break;
          Z.val += J[0], this.consume(J[0].length), this.incrementColumn(J[0].length), Q = M1(Z.val);
        }
        return this.incrementColumn(-Z.val.length), this.assertExpression(Z.val), this.incrementColumn(Z.val.length), this.tokens.push(this.tokEnd(Z)), !0;
      }
      if (this.scan(/^when\b/))
        this.error("NO_WHEN_EXPRESSION", "missing expression for when");
    },
    default: function() {
      var Z = this.scanEndOfLine(/^default/, "default");
      if (Z)
        return this.tokens.push(this.tokEnd(Z)), !0;
      if (this.scan(/^default\b/))
        this.error("DEFAULT_WITH_EXPRESSION", "default should not have an expression");
    },
    call: function() {
      var Z, Q, J;
      if (Q = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
        if (Q[3])
          J = Q[0].length, this.consume(J), Z = this.tok("call", Q[3]);
        else {
          var X = this.bracketExpression(2 + Q[1].length);
          J = X.end + 1, this.consume(J), this.assertExpression(X.src), Z = this.tok("call", "#{" + X.src + "}");
        }
        if (this.incrementColumn(J), Z.args = null, Q = /^ *\(/.exec(this.input)) {
          var z = this.bracketExpression(Q[0].length - 1);
          if (!/^\s*[-\w]+ *=/.test(z.src)) {
            this.incrementColumn(1), this.consume(z.end + 1), Z.args = z.src, this.assertExpression("[" + Z.args + "]");
            for (var Y = 0;Y <= Z.args.length; Y++)
              if (Z.args[Y] === "\n")
                this.incrementLine(1);
              else
                this.incrementColumn(1);
          }
        }
        return this.tokens.push(this.tokEnd(Z)), !0;
      }
    },
    mixin: function() {
      var Z;
      if (Z = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
        this.consume(Z[0].length);
        var Q = this.tok("mixin", Z[1]);
        return Q.args = Z[2] || null, this.incrementColumn(Z[0].length), this.tokens.push(this.tokEnd(Q)), !0;
      }
    },
    conditional: function() {
      var Z;
      if (Z = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
        this.consume(Z[0].length);
        var Q = Z[1].replace(/ /g, "-"), J = Z[2] && Z[2].trim(), X = this.tok(Q, J);
        switch (this.incrementColumn(Z[0].length - J.length), Q) {
          case "if":
          case "else-if":
            this.assertExpression(J);
            break;
          case "unless":
            this.assertExpression(J), X.val = "!(" + J + ")", X.type = "if";
            break;
          case "else":
            if (J)
              this.error("ELSE_CONDITION", "`else` cannot have a condition, perhaps you meant `else if`");
            break;
        }
        return this.incrementColumn(J.length), this.tokens.push(this.tokEnd(X)), !0;
      }
    },
    while: function() {
      var Z, Q;
      if (Z = /^while +([^\n]+)/.exec(this.input))
        return this.consume(Z[0].length), this.assertExpression(Z[1]), Q = this.tok("while", Z[1]), this.incrementColumn(Z[0].length), this.tokens.push(this.tokEnd(Q)), !0;
      if (this.scan(/^while\b/))
        this.error("NO_WHILE_EXPRESSION", "missing expression for while");
    },
    each: function() {
      var Z;
      if (Z = /^(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
        this.consume(Z[0].length);
        var Q = this.tok("each", Z[1]);
        return Q.key = Z[2] || null, this.incrementColumn(Z[0].length - Z[3].length), this.assertExpression(Z[3]), Q.code = Z[3], this.incrementColumn(Z[3].length), this.tokens.push(this.tokEnd(Q)), !0;
      }
      const J = /^each\b/.exec(this.input) ? "each" : "for";
      if (this.scan(/^(?:each|for)\b/))
        this.error("MALFORMED_EACH", "This `" + J + "` has a syntax error. `" + J + "` statements should be of the form: `" + J + " VARIABLE_NAME of JS_EXPRESSION`");
      if (Z = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +in +([^\n]+)/.exec(this.input))
        this.error("MALFORMED_EACH", 'Pug each and for should no longer be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
    },
    eachOf: function() {
      var Z;
      if (Z = /^(?:each|for) (.*?) of *([^\n]+)/.exec(this.input)) {
        this.consume(Z[0].length);
        var Q = this.tok("eachOf", Z[1]);
        if (Q.value = Z[1], this.incrementColumn(Z[0].length - Z[2].length), this.assertExpression(Z[2]), Q.code = Z[2], this.incrementColumn(Z[2].length), this.tokens.push(this.tokEnd(Q)), !(/^[a-zA-Z_$][\w$]*$/.test(Q.value.trim()) || /^\[ *[a-zA-Z_$][\w$]* *\, *[a-zA-Z_$][\w$]* *\]$/.test(Q.value.trim())))
          this.error("MALFORMED_EACH_OF_LVAL", "The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).");
        return !0;
      }
      if (Z = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +of +([^\n]+)/.exec(this.input))
        this.error("MALFORMED_EACH", 'Pug each and for should not be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
    },
    code: function() {
      var Z;
      if (Z = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
        var Q = Z[1], J = Z[2], X = 0;
        if (this.interpolated) {
          var z;
          try {
            z = M1.parseUntil(J, "]");
          } catch (U) {
            if (U.index !== void 0)
              this.incrementColumn(Z[0].length - J.length + U.index);
            if (U.code === "CHARACTER_PARSER:END_OF_STRING_REACHED")
              this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
            else if (U.code === "CHARACTER_PARSER:MISMATCHED_BRACKET")
              this.error("BRACKET_MISMATCH", U.message);
            else
              throw U;
          }
          X = J.length - z.end, J = z.src;
        }
        var Y = Z[0].length - X;
        this.consume(Y);
        var W = this.tok("code", J);
        if (W.mustEscape = Q.charAt(0) === "=", W.buffer = Q.charAt(0) === "=" || Q.charAt(1) === "=", this.incrementColumn(Z[0].length - Z[2].length), W.buffer)
          this.assertExpression(J);
        return this.tokens.push(W), this.incrementColumn(J.length), this.tokEnd(W), !0;
      }
    },
    blockCode: function() {
      var Z;
      if (Z = this.scanEndOfLine(/^-/, "blockcode"))
        return this.tokens.push(this.tokEnd(Z)), this.interpolationAllowed = !1, this.callLexerFunction("pipelessText"), !0;
    },
    attribute: function(Z) {
      var Q = "", J = /['"]/, X = "", z;
      for (z = 0;z < Z.length; z++) {
        if (!this.whitespaceRe.test(Z[z]))
          break;
        if (Z[z] === "\n")
          this.incrementLine(1);
        else
          this.incrementColumn(1);
      }
      if (z === Z.length)
        return "";
      var Y = this.tok("attribute");
      if (J.test(Z[z]))
        Q = Z[z], this.incrementColumn(1), z++;
      for (;z < Z.length; z++) {
        if (Q) {
          if (Z[z] === Q) {
            this.incrementColumn(1), z++;
            break;
          }
        } else if (this.whitespaceRe.test(Z[z]) || Z[z] === "!" || Z[z] === "=" || Z[z] === ",")
          break;
        if (X += Z[z], Z[z] === "\n")
          this.incrementLine(1);
        else
          this.incrementColumn(1);
      }
      Y.name = X;
      var W = this.attributeValue(Z.substr(z));
      if (W.val)
        Y.val = W.val, Y.mustEscape = W.mustEscape;
      else
        Y.val = !0, Y.mustEscape = !0;
      Z = W.remainingSource, this.tokens.push(this.tokEnd(Y));
      for (z = 0;z < Z.length; z++) {
        if (!this.whitespaceRe.test(Z[z]))
          break;
        if (Z[z] === "\n")
          this.incrementLine(1);
        else
          this.incrementColumn(1);
      }
      if (Z[z] === ",")
        this.incrementColumn(1), z++;
      return Z.substr(z);
    },
    attributeValue: function(Z) {
      var Q = /['"]/, J = "", X, z, Y, W = !0, U = M1.defaultState(), V = this.colno, M = this.lineno;
      for (z = 0;z < Z.length; z++) {
        if (!this.whitespaceRe.test(Z[z]))
          break;
        if (Z[z] === "\n")
          M++, V = 1;
        else
          V++;
      }
      if (z === Z.length)
        return { remainingSource: Z };
      if (Z[z] === "!") {
        if (W = !1, V++, z++, Z[z] !== "=")
          this.error("INVALID_KEY_CHARACTER", "Unexpected character " + Z[z] + " expected `=`");
      }
      if (Z[z] !== "=")
        if (z === 0 && Z && !this.whitespaceRe.test(Z[0]) && Z[0] !== ",")
          this.error("INVALID_KEY_CHARACTER", "Unexpected character " + Z[0] + " expected `=`");
        else
          return { remainingSource: Z };
      this.lineno = M, this.colno = V + 1, z++;
      for (;z < Z.length; z++) {
        if (!this.whitespaceRe.test(Z[z]))
          break;
        if (Z[z] === "\n")
          this.incrementLine(1);
        else
          this.incrementColumn(1);
      }
      M = this.lineno, V = this.colno;
      for (;z < Z.length; z++) {
        if (!(U.isNesting() || U.isString())) {
          if (this.whitespaceRe.test(Z[z])) {
            X = !1;
            for (Y = z;Y < Z.length; Y++)
              if (!this.whitespaceRe.test(Z[Y])) {
                const q = !M1.isPunctuator(Z[Y]), L = Q.test(Z[Y]), N = Z[Y] === ":", T = Z[Y] + Z[Y + 1] + Z[Y + 2] === "...";
                if ((q || L || N || T) && this.assertExpression(J, !0))
                  X = !0;
                break;
              }
            if (X || Y === Z.length)
              break;
          }
          if (Z[z] === "," && this.assertExpression(J, !0))
            break;
        }
        if (U = M1.parseChar(Z[z], U), J += Z[z], Z[z] === "\n")
          M++, V = 1;
        else
          V++;
      }
      return this.assertExpression(J), this.lineno = M, this.colno = V, { val: J, mustEscape: W, remainingSource: Z.substr(z) };
    },
    attrs: function() {
      var Z;
      if (this.input.charAt(0) == "(") {
        Z = this.tok("start-attributes");
        var Q = this.bracketExpression().end, J = this.input.substr(1, Q - 1);
        this.incrementColumn(1), this.tokens.push(this.tokEnd(Z)), this.assertNestingCorrect(J), this.consume(Q + 1);
        while (J)
          J = this.attribute(J);
        return Z = this.tok("end-attributes"), this.incrementColumn(1), this.tokens.push(this.tokEnd(Z)), !0;
      }
    },
    attributesBlock: function() {
      if (/^&attributes\b/.test(this.input)) {
        var Z = 11;
        this.consume(Z);
        var Q = this.tok("&attributes");
        this.incrementColumn(Z);
        var J = this.bracketExpression();
        return Z = J.end + 1, this.consume(Z), Q.val = J.src, this.incrementColumn(Z), this.tokens.push(this.tokEnd(Q)), !0;
      }
    },
    indent: function() {
      var Z = this.scanIndentation(), Q;
      if (Z) {
        var J = Z[1].length;
        if (this.incrementLine(1), this.consume(J + 1), this.input[0] == " " || this.input[0] == "\t")
          this.error("INVALID_INDENTATION", "Invalid indentation, you can use tabs or spaces but not both");
        if (this.input[0] == "\n")
          return this.interpolationAllowed = !0, this.tokEnd(this.tok("newline"));
        if (J < this.indentStack[0]) {
          var X = 0;
          while (this.indentStack[0] > J) {
            if (this.indentStack[1] < J)
              this.error("INCONSISTENT_INDENTATION", "Inconsistent indentation. Expecting either " + this.indentStack[1] + " or " + this.indentStack[0] + " spaces/tabs.");
            X++, this.indentStack.shift();
          }
          while (X--)
            this.colno = 1, Q = this.tok("outdent"), this.colno = this.indentStack[0] + 1, this.tokens.push(this.tokEnd(Q));
        } else if (J && J != this.indentStack[0])
          Q = this.tok("indent", J), this.colno = 1 + J, this.tokens.push(this.tokEnd(Q)), this.indentStack.unshift(J);
        else
          Q = this.tok("newline"), this.colno = 1 + Math.min(this.indentStack[0] || 0, J), this.tokens.push(this.tokEnd(Q));
        return this.interpolationAllowed = !0, !0;
      }
    },
    pipelessText: function Z(Q) {
      while (this.callLexerFunction("blank"))
        ;
      var J = this.scanIndentation();
      if (Q = Q || J && J[1].length, Q > this.indentStack[0]) {
        this.tokens.push(this.tokEnd(this.tok("start-pipeless-text")));
        var X = [], z = [], Y, W = 0;
        do {
          var U = this.input.substr(W + 1).indexOf("\n");
          if (U == -1)
            U = this.input.length - W - 1;
          var V = this.input.substr(W + 1, U), M = this.indentRe.exec("\n" + V), q = M && M[1].length;
          if (Y = q >= Q, z.push(Y), Y = Y || !V.trim(), Y)
            W += V.length + 1, X.push(V.substr(Q));
          else if (q > this.indentStack[0])
            return this.tokens.pop(), Z.call(this, M[1].length);
        } while (this.input.length - W && Y);
        this.consume(W);
        while (this.input.length === 0 && X[X.length - 1] === "")
          X.pop();
        return X.forEach(function(L, N) {
          var T;
          if (this.incrementLine(1), N !== 0)
            T = this.tok("newline");
          if (z[N])
            this.incrementColumn(Q);
          if (T)
            this.tokens.push(this.tokEnd(T));
          this.addText("text", L);
        }.bind(this)), this.tokens.push(this.tokEnd(this.tok("end-pipeless-text"))), !0;
      }
    },
    slash: function() {
      var Z = this.scan(/^\//, "slash");
      if (Z)
        return this.tokens.push(this.tokEnd(Z)), !0;
    },
    colon: function() {
      var Z = this.scan(/^: +/, ":");
      if (Z)
        return this.tokens.push(this.tokEnd(Z)), !0;
    },
    fail: function() {
      this.error("UNEXPECTED_TEXT", 'unexpected text "' + this.input.substr(0, 5) + '"');
    },
    callLexerFunction: function(Z) {
      var Q = [];
      for (var J = 1;J < arguments.length; J++)
        Q.push(arguments[J]);
      var X = [this].concat(Q);
      for (var J = 0;J < this.plugins.length; J++) {
        var z = this.plugins[J];
        if (z[Z] && z[Z].apply(z, X))
          return !0;
      }
      return this[Z].apply(this, Q);
    },
    advance: function() {
      return this.callLexerFunction("blank") || this.callLexerFunction("eos") || this.callLexerFunction("endInterpolation") || this.callLexerFunction("yield") || this.callLexerFunction("doctype") || this.callLexerFunction("interpolation") || this.callLexerFunction("case") || this.callLexerFunction("when") || this.callLexerFunction("default") || this.callLexerFunction("extends") || this.callLexerFunction("append") || this.callLexerFunction("prepend") || this.callLexerFunction("block") || this.callLexerFunction("mixinBlock") || this.callLexerFunction("include") || this.callLexerFunction("mixin") || this.callLexerFunction("call") || this.callLexerFunction("conditional") || this.callLexerFunction("eachOf") || this.callLexerFunction("each") || this.callLexerFunction("while") || this.callLexerFunction("tag") || this.callLexerFunction("filter") || this.callLexerFunction("blockCode") || this.callLexerFunction("code") || this.callLexerFunction("id") || this.callLexerFunction("dot") || this.callLexerFunction("className") || this.callLexerFunction("attrs") || this.callLexerFunction("attributesBlock") || this.callLexerFunction("indent") || this.callLexerFunction("text") || this.callLexerFunction("textHtml") || this.callLexerFunction("comment") || this.callLexerFunction("slash") || this.callLexerFunction("colon") || this.fail();
    },
    getTokens: function() {
      while (!this.ended)
        this.callLexerFunction("advance");
      return this.tokens;
    }
  };
});

// node_modules/pug-strip-comments/index.js
var tJ = P((Wo, sJ) => {
  var Z6 = function(Z, Q, J, X) {
    var z = "`" + Z + "` encountered when " + Q;
    throw LU("UNEXPECTED_TOKEN", z, { filename: J, line: X });
  }, NU = function(Z, Q) {
    Q = Q || {};
    var J = Q.stripUnbuffered !== !1, X = Q.stripBuffered === !0, z = Q.filename, Y = [], W = !1, U = !1;
    return Z.filter(function(V) {
      switch (V.type) {
        case "comment":
          if (W)
            Z6("comment", "already in a comment", z, V.line);
          else
            return W = V.buffer ? X : J, !W;
        case "start-pipeless-text":
          if (!W)
            return !0;
          if (U)
            Z6("start-pipeless-text", "already in pipeless text mode", z, V.line);
          return U = !0, !1;
        case "end-pipeless-text":
          if (!W)
            return !0;
          if (!U)
            Z6("end-pipeless-text", "not in pipeless text mode", z, V.line);
          return U = !1, W = !1, !1;
        case "text":
          return !W;
        default:
          if (U)
            return !1;
          return W = !1, !0;
      }
    });
  }, LU = Q5();
  sJ.exports = NU;
});

// node_modules/token-stream/index.js
var eJ = P((Go, oJ) => {
  var a5 = function(Z) {
    if (!Array.isArray(Z))
      throw new TypeError("tokens must be passed to TokenStream as an array.");
    this._tokens = Z;
  };
  oJ.exports = a5;
  a5.prototype.lookahead = function(Z) {
    if (this._tokens.length <= Z)
      throw new Error("Cannot read past the end of a stream");
    return this._tokens[Z];
  };
  a5.prototype.peek = function() {
    if (this._tokens.length === 0)
      throw new Error("Cannot read past the end of a stream");
    return this._tokens[0];
  };
  a5.prototype.advance = function() {
    if (this._tokens.length === 0)
      throw new Error("Cannot read past the end of a stream");
    return this._tokens.shift();
  };
  a5.prototype.defer = function(Z) {
    this._tokens.unshift(Z);
  };
});

// node_modules/pug-parser/lib/inline-tags.js
var QX = P((Uo, ZX) => {
  ZX.exports = [
    "a",
    "abbr",
    "acronym",
    "b",
    "br",
    "code",
    "em",
    "font",
    "i",
    "img",
    "ins",
    "kbd",
    "map",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup"
  ];
});

// node_modules/pug-parser/index.js
var JX = P((Vo, Q6) => {
  var vU = function(Z, Q) {
    var J = new d8(Z, Q), X = J.parse();
    return JSON.parse(JSON.stringify(X));
  }, d8 = function(Z, Q) {
    if (Q = Q || {}, !Array.isArray(Z))
      throw new Error('Expected tokens to be an Array but got "' + typeof Z + '"');
    if (typeof Q !== "object")
      throw new Error('Expected "options" to be an object but got "' + typeof Q + '"');
    this.tokens = new SU(Z), this.filename = Q.filename, this.src = Q.src, this.inMixin = 0, this.plugins = Q.plugins || [];
  }, PU = A0("assert"), SU = eJ(), wU = Q5(), TU = QX();
  Q6.exports = vU;
  Q6.exports.Parser = d8;
  d8.prototype = {
    constructor: d8,
    error: function(Z, Q, J) {
      var X = wU(Z, Q, {
        line: J.loc.start.line,
        column: J.loc.start.column,
        filename: this.filename,
        src: this.src
      });
      throw X;
    },
    advance: function() {
      return this.tokens.advance();
    },
    peek: function() {
      return this.tokens.peek();
    },
    lookahead: function(Z) {
      return this.tokens.lookahead(Z);
    },
    parse: function() {
      var Z = this.emptyBlock(0);
      while (this.peek().type != "eos")
        if (this.peek().type == "newline")
          this.advance();
        else if (this.peek().type == "text-html")
          Z.nodes = Z.nodes.concat(this.parseTextHtml());
        else {
          var Q = this.parseExpr();
          if (Q)
            if (Q.type === "Block")
              Z.nodes = Z.nodes.concat(Q.nodes);
            else
              Z.nodes.push(Q);
        }
      return Z;
    },
    expect: function(Z) {
      if (this.peek().type === Z)
        return this.advance();
      else
        this.error("INVALID_TOKEN", 'expected "' + Z + '", but got "' + this.peek().type + '"', this.peek());
    },
    accept: function(Z) {
      if (this.peek().type === Z)
        return this.advance();
    },
    initBlock: function(Z, Q) {
      if ((Z | 0) !== Z)
        throw new Error("`line` is not an integer");
      if (!Array.isArray(Q))
        throw new Error("`nodes` is not an array");
      return {
        type: "Block",
        nodes: Q,
        line: Z,
        filename: this.filename
      };
    },
    emptyBlock: function(Z) {
      return this.initBlock(Z, []);
    },
    runPlugin: function(Z, Q) {
      var J = [this];
      for (var X = 2;X < arguments.length; X++)
        J.push(arguments[X]);
      var z;
      for (var X = 0;X < this.plugins.length; X++) {
        var Y = this.plugins[X];
        if (Y[Z] && Y[Z][Q.type]) {
          if (z)
            throw new Error("Multiple plugin handlers found for context " + JSON.stringify(Z) + ", token type " + JSON.stringify(Q.type));
          z = Y[Z];
        }
      }
      if (z)
        return z[Q.type].apply(z, J);
    },
    parseExpr: function() {
      switch (this.peek().type) {
        case "tag":
          return this.parseTag();
        case "mixin":
          return this.parseMixin();
        case "block":
          return this.parseBlock();
        case "mixin-block":
          return this.parseMixinBlock();
        case "case":
          return this.parseCase();
        case "extends":
          return this.parseExtends();
        case "include":
          return this.parseInclude();
        case "doctype":
          return this.parseDoctype();
        case "filter":
          return this.parseFilter();
        case "comment":
          return this.parseComment();
        case "text":
        case "interpolated-code":
        case "start-pug-interpolation":
          return this.parseText({ block: !0 });
        case "text-html":
          return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());
        case "dot":
          return this.parseDot();
        case "each":
          return this.parseEach();
        case "eachOf":
          return this.parseEachOf();
        case "code":
          return this.parseCode();
        case "blockcode":
          return this.parseBlockCode();
        case "if":
          return this.parseConditional();
        case "while":
          return this.parseWhile();
        case "call":
          return this.parseCall();
        case "interpolation":
          return this.parseInterpolation();
        case "yield":
          return this.parseYield();
        case "id":
        case "class":
          if (!this.peek().loc.start)
            debugger;
          return this.tokens.defer({
            type: "tag",
            val: "div",
            loc: this.peek().loc,
            filename: this.filename
          }), this.parseExpr();
        default:
          var Z = this.runPlugin("expressionTokens", this.peek());
          if (Z)
            return Z;
          this.error("INVALID_TOKEN", 'unexpected token "' + this.peek().type + '"', this.peek());
      }
    },
    parseDot: function() {
      return this.advance(), this.parseTextBlock();
    },
    parseText: function(Z) {
      var Q = [], J = this.peek().loc.start.line, X = this.peek();
      Z:
        while (!0) {
          switch (X.type) {
            case "text":
              var z = this.advance();
              Q.push({
                type: "Text",
                val: z.val,
                line: z.loc.start.line,
                column: z.loc.start.column,
                filename: this.filename
              });
              break;
            case "interpolated-code":
              var z = this.advance();
              Q.push({
                type: "Code",
                val: z.val,
                buffer: z.buffer,
                mustEscape: z.mustEscape !== !1,
                isInline: !0,
                line: z.loc.start.line,
                column: z.loc.start.column,
                filename: this.filename
              });
              break;
            case "newline":
              if (!Z || !Z.block)
                break Z;
              var z = this.advance(), Y = this.peek().type;
              if (Y === "text" || Y === "interpolated-code")
                Q.push({
                  type: "Text",
                  val: "\n",
                  line: z.loc.start.line,
                  column: z.loc.start.column,
                  filename: this.filename
                });
              break;
            case "start-pug-interpolation":
              this.advance(), Q.push(this.parseExpr()), this.expect("end-pug-interpolation");
              break;
            default:
              var W = this.runPlugin("textTokens", X, Q);
              if (W)
                break;
              break Z;
          }
          X = this.peek();
        }
      if (Q.length === 1)
        return Q[0];
      else
        return this.initBlock(J, Q);
    },
    parseTextHtml: function() {
      var Z = [], Q = null;
      Z:
        while (!0)
          switch (this.peek().type) {
            case "text-html":
              var J = this.advance();
              if (!Q)
                Q = {
                  type: "Text",
                  val: J.val,
                  filename: this.filename,
                  line: J.loc.start.line,
                  column: J.loc.start.column,
                  isHtml: !0
                }, Z.push(Q);
              else
                Q.val += "\n" + J.val;
              break;
            case "indent":
              var X = this.block();
              X.nodes.forEach(function(z) {
                if (z.isHtml)
                  if (!Q)
                    Q = z, Z.push(Q);
                  else
                    Q.val += "\n" + z.val;
                else
                  Q = null, Z.push(z);
              });
              break;
            case "code":
              Q = null, Z.push(this.parseCode(!0));
              break;
            case "newline":
              this.advance();
              break;
            default:
              break Z;
          }
      return Z;
    },
    parseBlockExpansion: function() {
      var Z = this.accept(":");
      if (Z) {
        var Q = this.parseExpr();
        return Q.type === "Block" ? Q : this.initBlock(Z.loc.start.line, [Q]);
      } else
        return this.block();
    },
    parseCase: function() {
      var Z = this.expect("case"), Q = {
        type: "Case",
        expr: Z.val,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      }, J = this.emptyBlock(Z.loc.start.line + 1);
      this.expect("indent");
      while (this.peek().type != "outdent")
        switch (this.peek().type) {
          case "comment":
          case "newline":
            this.advance();
            break;
          case "when":
            J.nodes.push(this.parseWhen());
            break;
          case "default":
            J.nodes.push(this.parseDefault());
            break;
          default:
            var X = this.runPlugin("caseTokens", this.peek(), J);
            if (X)
              break;
            this.error("INVALID_TOKEN", 'Unexpected token "' + this.peek().type + '", expected "when", "default" or "newline"', this.peek());
        }
      return this.expect("outdent"), Q.block = J, Q;
    },
    parseWhen: function() {
      var Z = this.expect("when");
      if (this.peek().type !== "newline")
        return {
          type: "When",
          expr: Z.val,
          block: this.parseBlockExpansion(),
          debug: !1,
          line: Z.loc.start.line,
          column: Z.loc.start.column,
          filename: this.filename
        };
      else
        return {
          type: "When",
          expr: Z.val,
          debug: !1,
          line: Z.loc.start.line,
          column: Z.loc.start.column,
          filename: this.filename
        };
    },
    parseDefault: function() {
      var Z = this.expect("default");
      return {
        type: "When",
        expr: "default",
        block: this.parseBlockExpansion(),
        debug: !1,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
    },
    parseCode: function(Z) {
      var Q = this.expect("code");
      PU(typeof Q.mustEscape === "boolean", "Please update to the newest version of pug-lexer.");
      var J = {
        type: "Code",
        val: Q.val,
        buffer: Q.buffer,
        mustEscape: Q.mustEscape !== !1,
        isInline: !!Z,
        line: Q.loc.start.line,
        column: Q.loc.start.column,
        filename: this.filename
      };
      if (J.val.match(/^ *else/))
        J.debug = !1;
      if (Z)
        return J;
      var X = this.peek().type == "indent";
      if (X) {
        if (Q.buffer)
          this.error("BLOCK_IN_BUFFERED_CODE", "Buffered code cannot have a block attached to it", this.peek());
        J.block = this.block();
      }
      return J;
    },
    parseConditional: function() {
      var Z = this.expect("if"), Q = {
        type: "Conditional",
        test: Z.val,
        consequent: this.emptyBlock(Z.loc.start.line),
        alternate: null,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
      if (this.peek().type == "indent")
        Q.consequent = this.block();
      var J = Q;
      while (!0)
        if (this.peek().type === "newline")
          this.expect("newline");
        else if (this.peek().type === "else-if") {
          if (Z = this.expect("else-if"), J = J.alternate = {
            type: "Conditional",
            test: Z.val,
            consequent: this.emptyBlock(Z.loc.start.line),
            alternate: null,
            line: Z.loc.start.line,
            column: Z.loc.start.column,
            filename: this.filename
          }, this.peek().type == "indent")
            J.consequent = this.block();
        } else if (this.peek().type === "else") {
          if (this.expect("else"), this.peek().type === "indent")
            J.alternate = this.block();
          break;
        } else
          break;
      return Q;
    },
    parseWhile: function() {
      var Z = this.expect("while"), Q = {
        type: "While",
        test: Z.val,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
      if (this.peek().type == "indent")
        Q.block = this.block();
      else
        Q.block = this.emptyBlock(Z.loc.start.line);
      return Q;
    },
    parseBlockCode: function() {
      var Z = this.expect("blockcode"), Q = Z.loc.start.line, J = Z.loc.start.column, X = this.peek(), z = "";
      if (X.type === "start-pipeless-text") {
        this.advance();
        while (this.peek().type !== "end-pipeless-text")
          switch (Z = this.advance(), Z.type) {
            case "text":
              z += Z.val;
              break;
            case "newline":
              z += "\n";
              break;
            default:
              var Y = this.runPlugin("blockCodeTokens", Z, Z);
              if (Y) {
                z += Y;
                break;
              }
              this.error("INVALID_TOKEN", "Unexpected token type: " + Z.type, Z);
          }
        this.advance();
      }
      return {
        type: "Code",
        val: z,
        buffer: !1,
        mustEscape: !1,
        isInline: !1,
        line: Q,
        column: J,
        filename: this.filename
      };
    },
    parseComment: function() {
      var Z = this.expect("comment"), Q;
      if (Q = this.parseTextBlock())
        return {
          type: "BlockComment",
          val: Z.val,
          block: Q,
          buffer: Z.buffer,
          line: Z.loc.start.line,
          column: Z.loc.start.column,
          filename: this.filename
        };
      else
        return {
          type: "Comment",
          val: Z.val,
          buffer: Z.buffer,
          line: Z.loc.start.line,
          column: Z.loc.start.column,
          filename: this.filename
        };
    },
    parseDoctype: function() {
      var Z = this.expect("doctype");
      return {
        type: "Doctype",
        val: Z.val,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
    },
    parseIncludeFilter: function() {
      var Z = this.expect("filter"), Q = [];
      if (this.peek().type === "start-attributes")
        Q = this.attrs();
      return {
        type: "IncludeFilter",
        name: Z.val,
        attrs: Q,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
    },
    parseFilter: function() {
      var Z = this.expect("filter"), Q, J = [];
      if (this.peek().type === "start-attributes")
        J = this.attrs();
      if (this.peek().type === "text") {
        var X = this.advance();
        Q = this.initBlock(X.loc.start.line, [
          {
            type: "Text",
            val: X.val,
            line: X.loc.start.line,
            column: X.loc.start.column,
            filename: this.filename
          }
        ]);
      } else if (this.peek().type === "filter")
        Q = this.initBlock(Z.loc.start.line, [this.parseFilter()]);
      else
        Q = this.parseTextBlock() || this.emptyBlock(Z.loc.start.line);
      return {
        type: "Filter",
        name: Z.val,
        block: Q,
        attrs: J,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
    },
    parseEach: function() {
      var Z = this.expect("each"), Q = {
        type: "Each",
        obj: Z.code,
        val: Z.val,
        key: Z.key,
        block: this.block(),
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
      if (this.peek().type == "else")
        this.advance(), Q.alternate = this.block();
      return Q;
    },
    parseEachOf: function() {
      var Z = this.expect("eachOf"), Q = {
        type: "EachOf",
        obj: Z.code,
        val: Z.val,
        block: this.block(),
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
      return Q;
    },
    parseExtends: function() {
      var Z = this.expect("extends"), Q = this.expect("path");
      return {
        type: "Extends",
        file: {
          type: "FileReference",
          path: Q.val.trim(),
          line: Q.loc.start.line,
          column: Q.loc.start.column,
          filename: this.filename
        },
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
    },
    parseBlock: function() {
      var Z = this.expect("block"), Q = this.peek().type == "indent" ? this.block() : this.emptyBlock(Z.loc.start.line);
      return Q.type = "NamedBlock", Q.name = Z.val.trim(), Q.mode = Z.mode, Q.line = Z.loc.start.line, Q.column = Z.loc.start.column, Q;
    },
    parseMixinBlock: function() {
      var Z = this.expect("mixin-block");
      if (!this.inMixin)
        this.error("BLOCK_OUTISDE_MIXIN", "Anonymous blocks are not allowed unless they are part of a mixin.", Z);
      return {
        type: "MixinBlock",
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
    },
    parseYield: function() {
      var Z = this.expect("yield");
      return {
        type: "YieldBlock",
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
    },
    parseInclude: function() {
      var Z = this.expect("include"), Q = {
        type: "Include",
        file: {
          type: "FileReference",
          filename: this.filename
        },
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      }, J = [];
      while (this.peek().type === "filter")
        J.push(this.parseIncludeFilter());
      var X = this.expect("path");
      if (Q.file.path = X.val.trim(), Q.file.line = X.loc.start.line, Q.file.column = X.loc.start.column, (/\.jade$/.test(Q.file.path) || /\.pug$/.test(Q.file.path)) && !J.length) {
        if (Q.block = this.peek().type == "indent" ? this.block() : this.emptyBlock(Z.loc.start.line), /\.jade$/.test(Q.file.path))
          console.warn(this.filename + ", line " + Z.loc.start.line + ':\nThe .jade extension is deprecated, use .pug for "' + Q.file.path + '".');
      } else if (Q.type = "RawInclude", Q.filters = J, this.peek().type === "indent")
        this.error("RAW_INCLUDE_BLOCK", "Raw inclusion cannot contain a block", this.peek());
      return Q;
    },
    parseCall: function() {
      var Z = this.expect("call"), Q = Z.val, J = Z.args, X = {
        type: "Mixin",
        name: Q,
        args: J,
        block: this.emptyBlock(Z.loc.start.line),
        call: !0,
        attrs: [],
        attributeBlocks: [],
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
      if (this.tag(X), X.code)
        X.block.nodes.push(X.code), delete X.code;
      if (X.block.nodes.length === 0)
        X.block = null;
      return X;
    },
    parseMixin: function() {
      var Z = this.expect("mixin"), Q = Z.val, J = Z.args;
      if (this.peek().type == "indent") {
        this.inMixin++;
        var X = {
          type: "Mixin",
          name: Q,
          args: J,
          block: this.block(),
          call: !1,
          line: Z.loc.start.line,
          column: Z.loc.start.column,
          filename: this.filename
        };
        return this.inMixin--, X;
      } else
        this.error("MIXIN_WITHOUT_BODY", "Mixin " + Q + " declared without body", Z);
    },
    parseTextBlock: function() {
      var Z = this.accept("start-pipeless-text");
      if (!Z)
        return;
      var Q = this.emptyBlock(Z.loc.start.line);
      while (this.peek().type !== "end-pipeless-text") {
        var Z = this.advance();
        switch (Z.type) {
          case "text":
            Q.nodes.push({
              type: "Text",
              val: Z.val,
              line: Z.loc.start.line,
              column: Z.loc.start.column,
              filename: this.filename
            });
            break;
          case "newline":
            Q.nodes.push({
              type: "Text",
              val: "\n",
              line: Z.loc.start.line,
              column: Z.loc.start.column,
              filename: this.filename
            });
            break;
          case "start-pug-interpolation":
            Q.nodes.push(this.parseExpr()), this.expect("end-pug-interpolation");
            break;
          case "interpolated-code":
            Q.nodes.push({
              type: "Code",
              val: Z.val,
              buffer: Z.buffer,
              mustEscape: Z.mustEscape !== !1,
              isInline: !0,
              line: Z.loc.start.line,
              column: Z.loc.start.column,
              filename: this.filename
            });
            break;
          default:
            var J = this.runPlugin("textBlockTokens", Z, Q, Z);
            if (J)
              break;
            this.error("INVALID_TOKEN", "Unexpected token type: " + Z.type, Z);
        }
      }
      return this.advance(), Q;
    },
    block: function() {
      var Z = this.expect("indent"), Q = this.emptyBlock(Z.loc.start.line);
      while (this.peek().type != "outdent")
        if (this.peek().type == "newline")
          this.advance();
        else if (this.peek().type == "text-html")
          Q.nodes = Q.nodes.concat(this.parseTextHtml());
        else {
          var J = this.parseExpr();
          if (J.type === "Block")
            Q.nodes = Q.nodes.concat(J.nodes);
          else
            Q.nodes.push(J);
        }
      return this.expect("outdent"), Q;
    },
    parseInterpolation: function() {
      var Z = this.advance(), Q = {
        type: "InterpolatedTag",
        expr: Z.val,
        selfClosing: !1,
        block: this.emptyBlock(Z.loc.start.line),
        attrs: [],
        attributeBlocks: [],
        isInline: !1,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
      return this.tag(Q, { selfClosingAllowed: !0 });
    },
    parseTag: function() {
      var Z = this.advance(), Q = {
        type: "Tag",
        name: Z.val,
        selfClosing: !1,
        block: this.emptyBlock(Z.loc.start.line),
        attrs: [],
        attributeBlocks: [],
        isInline: TU.indexOf(Z.val) !== -1,
        line: Z.loc.start.line,
        column: Z.loc.start.column,
        filename: this.filename
      };
      return this.tag(Q, { selfClosingAllowed: !0 });
    },
    tag: function(Z, Q) {
      var J = !1, X = [], z = Q && Q.selfClosingAllowed;
      Z:
        while (!0)
          switch (this.peek().type) {
            case "id":
            case "class":
              var Y = this.advance();
              if (Y.type === "id") {
                if (X.indexOf("id") !== -1)
                  this.error("DUPLICATE_ID", 'Duplicate attribute "id" is not allowed.', Y);
                X.push("id");
              }
              Z.attrs.push({
                name: Y.type,
                val: "'" + Y.val + "'",
                line: Y.loc.start.line,
                column: Y.loc.start.column,
                filename: this.filename,
                mustEscape: !1
              });
              continue;
            case "start-attributes":
              if (J)
                console.warn(this.filename + ", line " + this.peek().loc.start.line + ":\nYou should not have pug tags with multiple attributes.");
              J = !0, Z.attrs = Z.attrs.concat(this.attrs(X));
              continue;
            case "&attributes":
              var Y = this.advance();
              Z.attributeBlocks.push({
                type: "AttributeBlock",
                val: Y.val,
                line: Y.loc.start.line,
                column: Y.loc.start.column,
                filename: this.filename
              });
              break;
            default:
              var W = this.runPlugin("tagAttributeTokens", this.peek(), Z, X);
              if (W)
                break;
              break Z;
          }
      if (this.peek().type == "dot")
        Z.textOnly = !0, this.advance();
      switch (this.peek().type) {
        case "text":
        case "interpolated-code":
          var U = this.parseText();
          if (U.type === "Block")
            Z.block.nodes.push.apply(Z.block.nodes, U.nodes);
          else
            Z.block.nodes.push(U);
          break;
        case "code":
          Z.block.nodes.push(this.parseCode(!0));
          break;
        case ":":
          this.advance();
          var V = this.parseExpr();
          Z.block = V.type === "Block" ? V : this.initBlock(Z.line, [V]);
          break;
        case "newline":
        case "indent":
        case "outdent":
        case "eos":
        case "start-pipeless-text":
        case "end-pug-interpolation":
          break;
        case "slash":
          if (z) {
            this.advance(), Z.selfClosing = !0;
            break;
          }
        default:
          var W = this.runPlugin("tagTokens", this.peek(), Z, Q);
          if (W)
            break;
          this.error("INVALID_TOKEN", "Unexpected token `" + this.peek().type + "` expected `text`, `interpolated-code`, `code`, `:`" + (z ? ", `slash`" : "") + ", `newline` or `eos`", this.peek());
      }
      while (this.peek().type == "newline")
        this.advance();
      if (Z.textOnly)
        Z.block = this.parseTextBlock() || this.emptyBlock(Z.line);
      else if (this.peek().type == "indent") {
        var M = this.block();
        for (var q = 0, L = M.nodes.length;q < L; ++q)
          Z.block.nodes.push(M.nodes[q]);
      }
      return Z;
    },
    attrs: function(Z) {
      this.expect("start-attributes");
      var Q = [], J = this.advance();
      while (J.type === "attribute") {
        if (J.name !== "class" && Z) {
          if (Z.indexOf(J.name) !== -1)
            this.error("DUPLICATE_ATTRIBUTE", 'Duplicate attribute "' + J.name + '" is not allowed.', J);
          Z.push(J.name);
        }
        Q.push({
          name: J.name,
          val: J.val,
          line: J.loc.start.line,
          column: J.loc.start.column,
          filename: this.filename,
          mustEscape: J.mustEscape !== !1
        }), J = this.advance();
      }
      return this.tokens.defer(J), this.expect("end-attributes"), Q;
    }
  };
});

// node_modules/pug-walk/index.js
var p8 = P((Ko, XX) => {
  var o0 = function(Z, Q, J, X) {
    if (J && typeof J === "object" && typeof X === "undefined")
      X = J, J = null;
    X = X || { includeDependencies: !1 };
    var z = X.parents = X.parents || [], Y = function V(M) {
      if (Array.isArray(M) && !V.arrayAllowed)
        throw new Error("replace() can only be called with an array if the last parent is a Block or NamedBlock");
      Z = M;
    };
    if (Y.arrayAllowed = z[0] && (/^(Named)?Block$/.test(z[0].type) || z[0].type === "RawInclude" && Z.type === "IncludeFilter"), Q) {
      var W = Q(Z, Y);
      if (W === !1)
        return Z;
      else if (Array.isArray(Z))
        return U(Z);
    }
    switch (z.unshift(Z), Z.type) {
      case "NamedBlock":
      case "Block":
        Z.nodes = U(Z.nodes);
        break;
      case "Case":
      case "Filter":
      case "Mixin":
      case "Tag":
      case "InterpolatedTag":
      case "When":
      case "Code":
      case "While":
        if (Z.block)
          Z.block = o0(Z.block, Q, J, X);
        break;
      case "Each":
        if (Z.block)
          Z.block = o0(Z.block, Q, J, X);
        if (Z.alternate)
          Z.alternate = o0(Z.alternate, Q, J, X);
        break;
      case "EachOf":
        if (Z.block)
          Z.block = o0(Z.block, Q, J, X);
        break;
      case "Conditional":
        if (Z.consequent)
          Z.consequent = o0(Z.consequent, Q, J, X);
        if (Z.alternate)
          Z.alternate = o0(Z.alternate, Q, J, X);
        break;
      case "Include":
        o0(Z.block, Q, J, X), o0(Z.file, Q, J, X);
        break;
      case "Extends":
        o0(Z.file, Q, J, X);
        break;
      case "RawInclude":
        Z.filters = U(Z.filters), o0(Z.file, Q, J, X);
        break;
      case "Attrs":
      case "BlockComment":
      case "Comment":
      case "Doctype":
      case "IncludeFilter":
      case "MixinBlock":
      case "YieldBlock":
      case "Text":
        break;
      case "FileReference":
        if (X.includeDependencies && Z.ast)
          o0(Z.ast, Q, J, X);
        break;
      default:
        throw new Error("Unexpected node type " + Z.type);
    }
    return z.shift(), J && J(Z, Y), Z;
    function U(V) {
      return V.reduce(function(M, q) {
        var L = o0(q, Q, J, X);
        if (Array.isArray(L))
          return M.concat(L);
        else
          return M.concat([L]);
      }, []);
    }
  };
  XX.exports = o0;
});

// node_modules/pug-load/index.js
var YX = P((Mo, HX) => {
  var X1 = function(Z, Q) {
    return Q = J6(Q), Z = JSON.parse(JSON.stringify(Z)), EU(Z, function(J) {
      if (J.str === void 0) {
        if (J.type === "Include" || J.type === "RawInclude" || J.type === "Extends") {
          var X = J.file;
          if (X.type !== "FileReference")
            throw new Error('Expected file.type to be "FileReference"');
          var z, Y, W;
          try {
            z = Q.resolve(X.path, X.filename, Q), X.fullPath = z, W = Q.read(z, Q), Y = W.toString("utf8");
          } catch (U) {
            throw U.message += "\n    at " + J.filename + " line " + J.line, U;
          }
          if (X.str = Y, X.raw = W, J.type === "Extends" || J.type === "Include")
            X.ast = X1.string(Y, a8({}, Q, {
              filename: z
            }));
        }
      }
    });
  }, J6 = function(Z) {
    return X1.validateOptions(Z), a8({
      resolve: X1.resolve,
      read: X1.read
    }, Z);
  }, bU = A0("fs"), zX = A0("path"), EU = p8(), a8 = y7();
  HX.exports = X1;
  X1.string = function Z(Q, J) {
    J = a8(J6(J), {
      src: Q
    });
    var X = J.lex(Q, J), z = J.parse(X, J);
    return X1(z, J);
  };
  X1.file = function Z(Q, J) {
    J = a8(J6(J), {
      filename: Q
    });
    var X = J.read(Q).toString("utf8");
    return X1.string(X, J);
  };
  X1.resolve = function Z(Q, J, X) {
    if (Q = Q.trim(), Q[0] !== "/" && !J)
      throw new Error('the "filename" option is required to use includes and extends with "relative" paths');
    if (Q[0] === "/" && !X.basedir)
      throw new Error('the "basedir" option is required to use includes and extends with "absolute" paths');
    return Q = zX.join(Q[0] === "/" ? X.basedir : zX.dirname(J.trim()), Q), Q;
  };
  X1.read = function Z(Q, J) {
    return bU.readFileSync(Q);
  };
  X1.validateOptions = function Z(Q) {
    if (typeof Q !== "object")
      throw new TypeError("options must be an object");
    if (typeof Q.lex !== "function")
      throw new TypeError("options.lex must be a function");
    if (typeof Q.parse !== "function")
      throw new TypeError("options.parse must be a function");
    if (Q.resolve && typeof Q.resolve !== "function")
      throw new TypeError("options.resolve must be a function");
    if (Q.read && typeof Q.read !== "function")
      throw new TypeError("options.read must be a function");
  };
});

// node_modules/asap/raw.js
var z6 = P((Fo, VX) => {
  var GX = function(Z) {
    if (!R1.length)
      UX(), X6 = !0;
    R1[R1.length] = Z;
  }, WX = function() {
    while (F1 < R1.length) {
      var Z = F1;
      if (F1 = F1 + 1, R1[Z].call(), F1 > hU) {
        for (var Q = 0, J = R1.length - F1;Q < J; Q++)
          R1[Q] = R1[Q + F1];
        R1.length -= F1, F1 = 0;
      }
    }
    R1.length = 0, F1 = 0, X6 = !1;
  }, UX = function() {
    var Z = process.domain;
    if (Z) {
      if (!r8)
        r8 = A0("domain");
      r8.active = process.domain = null;
    }
    if (X6 && gU)
      setImmediate(WX);
    else
      process.nextTick(WX);
    if (Z)
      r8.active = process.domain = Z;
  }, r8, gU = typeof setImmediate === "function";
  VX.exports = GX;
  var R1 = [], X6 = !1, F1 = 0, hU = 1024;
  GX.requestFlush = UX;
});

// node_modules/promise/lib/core.js
var J5 = P((Ro, FX) => {
  var s8 = function() {
  }, kU = function(Z) {
    try {
      return Z.then;
    } catch (Q) {
      return w5 = Q, T5;
    }
  }, fU = function(Z, Q) {
    try {
      return Z(Q);
    } catch (J) {
      return w5 = J, T5;
    }
  }, yU = function(Z, Q, J) {
    try {
      Z(Q, J);
    } catch (X) {
      return w5 = X, T5;
    }
  }, e0 = function(Z) {
    if (typeof this !== "object")
      throw new TypeError("Promises must be constructed via new");
    if (typeof Z !== "function")
      throw new TypeError("Promise constructor\'s argument is not a function");
    if (this._40 = 0, this._65 = 0, this._55 = null, this._72 = null, Z === s8)
      return;
    MX(Z, this);
  }, mU = function(Z, Q, J) {
    return new Z.constructor(function(X, z) {
      var Y = new e0(s8);
      Y.then(X, z), n8(Z, new KX(Q, J, Y));
    });
  }, n8 = function(Z, Q) {
    while (Z._65 === 3)
      Z = Z._55;
    if (e0._37)
      e0._37(Z);
    if (Z._65 === 0) {
      if (Z._40 === 0) {
        Z._40 = 1, Z._72 = Q;
        return;
      }
      if (Z._40 === 1) {
        Z._40 = 2, Z._72 = [Z._72, Q];
        return;
      }
      Z._72.push(Q);
      return;
    }
    uU(Z, Q);
  }, uU = function(Z, Q) {
    _U(function() {
      var J = Z._65 === 1 ? Q.onFulfilled : Q.onRejected;
      if (J === null) {
        if (Z._65 === 1)
          H6(Q.promise, Z._55);
        else
          S5(Q.promise, Z._55);
        return;
      }
      var X = fU(J, Z._55);
      if (X === T5)
        S5(Q.promise, w5);
      else
        H6(Q.promise, X);
    });
  }, H6 = function(Z, Q) {
    if (Q === Z)
      return S5(Z, new TypeError("A promise cannot be resolved with itself."));
    if (Q && (typeof Q === "object" || typeof Q === "function")) {
      var J = kU(Q);
      if (J === T5)
        return S5(Z, w5);
      if (J === Z.then && Q instanceof e0) {
        Z._65 = 3, Z._55 = Q, Y6(Z);
        return;
      } else if (typeof J === "function") {
        MX(J.bind(Q), Z);
        return;
      }
    }
    Z._65 = 1, Z._55 = Q, Y6(Z);
  }, S5 = function(Z, Q) {
    if (Z._65 = 2, Z._55 = Q, e0._87)
      e0._87(Z, Q);
    Y6(Z);
  }, Y6 = function(Z) {
    if (Z._40 === 1)
      n8(Z, Z._72), Z._72 = null;
    if (Z._40 === 2) {
      for (var Q = 0;Q < Z._72.length; Q++)
        n8(Z, Z._72[Q]);
      Z._72 = null;
    }
  }, KX = function(Z, Q, J) {
    this.onFulfilled = typeof Z === "function" ? Z : null, this.onRejected = typeof Q === "function" ? Q : null, this.promise = J;
  }, MX = function(Z, Q) {
    var J = !1, X = yU(Z, function(z) {
      if (J)
        return;
      J = !0, H6(Q, z);
    }, function(z) {
      if (J)
        return;
      J = !0, S5(Q, z);
    });
    if (!J && X === T5)
      J = !0, S5(Q, w5);
  }, _U = z6(), w5 = null, T5 = {};
  FX.exports = e0;
  e0._37 = null;
  e0._87 = null;
  e0._61 = s8;
  e0.prototype.then = function(Z, Q) {
    if (this.constructor !== e0)
      return mU(this, Z, Q);
    var J = new e0(s8);
    return n8(this, new KX(Z, Q, J)), J;
  };
});

// node_modules/promise/lib/done.js
var OX = P((jo, jX) => {
  var RX = J5();
  jX.exports = RX;
  RX.prototype.done = function(Z, Q) {
    var J = arguments.length ? this.then.apply(this, arguments) : this;
    J.then(null, function(X) {
      setTimeout(function() {
        throw X;
      }, 0);
    });
  };
});

// node_modules/promise/lib/finally.js
var qX = P((Oo, BX) => {
  var t8 = J5();
  BX.exports = t8;
  t8.prototype.finally = function(Z) {
    return this.then(function(Q) {
      return t8.resolve(Z()).then(function() {
        return Q;
      });
    }, function(Q) {
      return t8.resolve(Z()).then(function() {
        throw Q;
      });
    });
  };
});

// node_modules/promise/lib/es6-extensions.js
var DX = P((Bo, $X) => {
  var X5 = function(Z) {
    var Q = new h0(h0._61);
    return Q._65 = 1, Q._55 = Z, Q;
  }, h0 = J5();
  $X.exports = h0;
  var xU = X5(!0), cU = X5(!1), lU = X5(null), iU = X5(void 0), dU = X5(0), pU = X5("");
  h0.resolve = function(Z) {
    if (Z instanceof h0)
      return Z;
    if (Z === null)
      return lU;
    if (Z === void 0)
      return iU;
    if (Z === !0)
      return xU;
    if (Z === !1)
      return cU;
    if (Z === 0)
      return dU;
    if (Z === "")
      return pU;
    if (typeof Z === "object" || typeof Z === "function")
      try {
        var Q = Z.then;
        if (typeof Q === "function")
          return new h0(Q.bind(Z));
      } catch (J) {
        return new h0(function(X, z) {
          z(J);
        });
      }
    return X5(Z);
  };
  h0.all = function(Z) {
    var Q = Array.prototype.slice.call(Z);
    return new h0(function(J, X) {
      if (Q.length === 0)
        return J([]);
      var z = Q.length;
      function Y(U, V) {
        if (V && (typeof V === "object" || typeof V === "function"))
          if (V instanceof h0 && V.then === h0.prototype.then) {
            while (V._65 === 3)
              V = V._55;
            if (V._65 === 1)
              return Y(U, V._55);
            if (V._65 === 2)
              X(V._55);
            V.then(function(L) {
              Y(U, L);
            }, X);
            return;
          } else {
            var M = V.then;
            if (typeof M === "function") {
              var q = new h0(M.bind(V));
              q.then(function(L) {
                Y(U, L);
              }, X);
              return;
            }
          }
        if (Q[U] = V, --z === 0)
          J(Q);
      }
      for (var W = 0;W < Q.length; W++)
        Y(W, Q[W]);
    });
  };
  h0.reject = function(Z) {
    return new h0(function(Q, J) {
      J(Z);
    });
  };
  h0.race = function(Z) {
    return new h0(function(Q, J) {
      Z.forEach(function(X) {
        h0.resolve(X).then(Q, J);
      });
    });
  };
  h0.prototype.catch = function(Z) {
    return this.then(null, Z);
  };
});

// node_modules/asap/asap.js
var LX = P((qo, AX) => {
  var aU = function(Z) {
    var Q;
    if (W6.length)
      Q = W6.pop();
    else
      Q = new CX;
    Q.task = Z, Q.domain = process.domain, IX(Q);
  }, CX = function() {
    this.task = null, this.domain = null;
  }, IX = z6(), W6 = [];
  AX.exports = aU;
  CX.prototype.call = function() {
    if (this.domain)
      this.domain.enter();
    var Z = !0;
    try {
      if (this.task.call(), Z = !1, this.domain)
        this.domain.exit();
    } finally {
      if (Z)
        IX.requestFlush();
      this.task = null, this.domain = null, W6.push(this);
    }
  };
});

// node_modules/promise/lib/node-extensions.js
var SX = P(($o, PX) => {
  var rU = function(Z, Q) {
    var J = [];
    for (var X = 0;X < Q; X++)
      J.push("a" + X);
    var z = [
      "return function (" + J.join(",") + ") {",
      "var self = this;",
      "return new Promise(function (rs, rj) {",
      "var res = fn.call(",
      ["self"].concat(J).concat([NX]).join(","),
      ");",
      "if (res &&",
      '(typeof res === "object" || typeof res === "function") &&',
      'typeof res.then === "function"',
      ") {rs(res);}",
      "});",
      "};"
    ].join("");
    return Function(["Promise", "fn"], z)(z5, Z);
  }, nU = function(Z) {
    var Q = Math.max(Z.length - 1, 3), J = [];
    for (var X = 0;X < Q; X++)
      J.push("a" + X);
    var z = [
      "return function (" + J.join(",") + ") {",
      "var self = this;",
      "var args;",
      "var argLength = arguments.length;",
      "if (arguments.length > " + Q + ") {",
      "args = new Array(arguments.length + 1);",
      "for (var i = 0; i < arguments.length; i++) {",
      "args[i] = arguments[i];",
      "}",
      "}",
      "return new Promise(function (rs, rj) {",
      "var cb = " + NX + ";",
      "var res;",
      "switch (argLength) {",
      J.concat(["extra"]).map(function(Y, W) {
        return "case " + W + ":res = fn.call(" + ["self"].concat(J.slice(0, W)).concat("cb").join(",") + ");break;";
      }).join(""),
      "default:",
      "args[argLength] = cb;",
      "res = fn.apply(self, args);",
      "}",
      "if (res &&",
      '(typeof res === "object" || typeof res === "function") &&',
      'typeof res.then === "function"',
      ") {rs(res);}",
      "});",
      "};"
    ].join("");
    return Function(["Promise", "fn"], z)(z5, Z);
  }, z5 = J5(), G6 = LX();
  PX.exports = z5;
  z5.denodeify = function(Z, Q) {
    if (typeof Q === "number" && Q !== Infinity)
      return rU(Z, Q);
    else
      return nU(Z);
  };
  var NX = "function (err, res) {if (err) { rj(err); } else { rs(res); }}";
  z5.nodeify = function(Z) {
    return function() {
      var Q = Array.prototype.slice.call(arguments), J = typeof Q[Q.length - 1] === "function" ? Q.pop() : null, X = this;
      try {
        return Z.apply(this, arguments).nodeify(J, X);
      } catch (z) {
        if (J === null || typeof J == "undefined")
          return new z5(function(Y, W) {
            W(z);
          });
        else
          G6(function() {
            J.call(X, z);
          });
      }
    };
  };
  z5.prototype.nodeify = function(Z, Q) {
    if (typeof Z != "function")
      return this;
    this.then(function(J) {
      G6(function() {
        Z.call(Q, null, J);
      });
    }, function(J) {
      G6(function() {
        Z.call(Q, J);
      });
    });
  };
});

// node_modules/promise/lib/synchronous.js
var TX = P((Do, wX) => {
  var l0 = J5();
  wX.exports = l0;
  l0.enableSynchronous = function() {
    l0.prototype.isPending = function() {
      return this.getState() == 0;
    }, l0.prototype.isFulfilled = function() {
      return this.getState() == 1;
    }, l0.prototype.isRejected = function() {
      return this.getState() == 2;
    }, l0.prototype.getValue = function() {
      if (this._65 === 3)
        return this._55.getValue();
      if (!this.isFulfilled())
        throw new Error("Cannot get a value of an unfulfilled promise.");
      return this._55;
    }, l0.prototype.getReason = function() {
      if (this._65 === 3)
        return this._55.getReason();
      if (!this.isRejected())
        throw new Error("Cannot get a rejection reason of a non-rejected promise.");
      return this._55;
    }, l0.prototype.getState = function() {
      if (this._65 === 3)
        return this._55.getState();
      if (this._65 === -1 || this._65 === -2)
        return 0;
      return this._65;
    };
  };
  l0.disableSynchronous = function() {
    l0.prototype.isPending = void 0, l0.prototype.isFulfilled = void 0, l0.prototype.isRejected = void 0, l0.prototype.getValue = void 0, l0.prototype.getReason = void 0, l0.prototype.getState = void 0;
  };
});

// node_modules/promise/lib/index.js
var bX = P((Io, vX) => {
  vX.exports = J5();
  OX();
  qX();
  DX();
  SX();
  TX();
});

// node_modules/is-promise/index.js
var gX = P((Co, U6) => {
  var EX = function(Z) {
    return !!Z && (typeof Z === "object" || typeof Z === "function") && typeof Z.then === "function";
  };
  U6.exports = EX;
  U6.exports.default = EX;
});

// node_modules/jstransformer/index.js
var kX = P((Ao, _X) => {
  var sU = function(Z) {
    if (typeof Z === "function")
      return { fn: Z, dependencies: [] };
    else if (Z && typeof Z === "object" && typeof Z.fn === "function") {
      if ("dependencies" in Z) {
        if (!Array.isArray(Z.dependencies))
          throw new Error("Result should have a dependencies property that is an array");
      } else
        Z.dependencies = [];
      return Z;
    } else
      throw new Error("Invalid result object from transform.");
  }, tU = function(Z, Q) {
    return j1.resolve(Z).then(function(J) {
      if (J && hX(J.fn))
        return J.fn.then(function(X) {
          return J.fn = X, J;
        });
      return J;
    }).then(t.normalizeFn).nodeify(Q);
  }, oU = function(Z) {
    if (typeof Z === "string")
      return { body: Z, dependencies: [] };
    else if (Z && typeof Z === "object" && typeof Z.body === "string") {
      if ("dependencies" in Z) {
        if (!Array.isArray(Z.dependencies))
          throw new Error("Result should have a dependencies property that is an array");
      } else
        Z.dependencies = [];
      return Z;
    } else
      throw new Error("Invalid result object from transform.");
  }, eU = function(Z, Q) {
    return j1.resolve(Z).then(function(J) {
      if (J && hX(J.body))
        return J.body.then(function(X) {
          return J.body = X, J;
        });
      return J;
    }).then(t.normalize).nodeify(Q);
  }, y0 = function(Z) {
    o8(Z, "Transformer must be an object"), o8(typeof Z.name === "string", "Transformer must have a name"), o8(typeof Z.outputFormat === "string", "Transformer must have an output format"), o8([
      "compile",
      "compileAsync",
      "compileFile",
      "compileFileAsync",
      "compileClient",
      "compileClientAsync",
      "compileFileClient",
      "compileFileClientAsync",
      "render",
      "renderAsync",
      "renderFile",
      "renderFileAsync"
    ].some(function(Q) {
      return typeof Z[Q] === "function";
    }), "Transformer must implement at least one of the potential methods."), this._tr = Z, this.name = this._tr.name, this.outputFormat = this._tr.outputFormat, this.inputFormats = this._tr.inputFormats || [this.name];
  }, V6 = A0("fs"), o8 = A0("assert"), j1 = bX(), hX = gX(), t = _X.exports = function(Z) {
    return new y0(Z);
  };
  t.Transformer = y0;
  t.normalizeFn = sU;
  t.normalizeFnAsync = tU;
  t.normalize = oU;
  t.normalizeAsync = eU;
  if (V6.readFile)
    t.readFile = j1.denodeify(V6.readFile), t.readFileSync = V6.readFileSync;
  else
    t.readFile = function() {
      throw new Error("fs.readFile unsupported");
    }, t.readFileSync = function() {
      throw new Error("fs.readFileSync unsupported");
    };
  var ZV = {
    compile: ["compile", "render"],
    compileAsync: ["compileAsync", "compile", "render"],
    compileFile: ["compileFile", "compile", "renderFile", "render"],
    compileFileAsync: [
      "compileFileAsync",
      "compileFile",
      "compileAsync",
      "compile",
      "renderFile",
      "render"
    ],
    compileClient: ["compileClient"],
    compileClientAsync: ["compileClientAsync", "compileClient"],
    compileFileClient: ["compileFileClient", "compileClient"],
    compileFileClientAsync: [
      "compileFileClientAsync",
      "compileFileClient",
      "compileClientAsync",
      "compileClient"
    ],
    render: ["render", "compile"],
    renderAsync: ["renderAsync", "render", "compileAsync", "compile"],
    renderFile: ["renderFile", "render", "compileFile", "compile"],
    renderFileAsync: [
      "renderFileAsync",
      "renderFile",
      "renderAsync",
      "render",
      "compileFileAsync",
      "compileFile",
      "compileAsync",
      "compile"
    ]
  };
  y0.prototype._hasMethod = function(Z) {
    return typeof this._tr[Z] === "function";
  };
  y0.prototype.can = function(Z) {
    return ZV[Z].some(function(Q) {
      return this._hasMethod(Q);
    }.bind(this));
  };
  y0.prototype.compile = function(Z, Q) {
    if (!this._hasMethod("compile")) {
      if (this.can("render")) {
        var J = this;
        return {
          fn: function(X) {
            return t.normalize(J._tr.render(Z, Q, X)).body;
          },
          dependencies: []
        };
      }
      if (this.can("compileAsync"))
        throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
      else if (this.can("compileFileAsync"))
        throw new Error('The Transform "' + this.name + '" does not support compiling plain strings');
      else
        throw new Error('The Transform "' + this.name + '" does not support compilation');
    }
    return t.normalizeFn(this._tr.compile(Z, Q));
  };
  y0.prototype.compileAsync = function(Z, Q, J) {
    if (!this.can("compileAsync"))
      return j1.reject(new Error('The Transform "' + this.name + '" does not support compiling plain strings')).nodeify(J);
    if (this._hasMethod("compileAsync"))
      return t.normalizeFnAsync(this._tr.compileAsync(Z, Q), J);
    else
      return t.normalizeFnAsync(this.compile(Z, Q), J);
  };
  y0.prototype.compileFile = function(Z, Q) {
    if (!this.can("compileFile"))
      throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
    if (this._hasMethod("compileFile"))
      return t.normalizeFn(this._tr.compileFile(Z, Q));
    else if (this._hasMethod("renderFile"))
      return t.normalizeFn(function(J) {
        return t.normalize(this._tr.renderFile(Z, Q, J)).body;
      }.bind(this));
    else {
      if (!Q)
        Q = {};
      if (Q.filename === void 0)
        Q.filename = Z;
      return this.compile(t.readFileSync(Z, "utf8"), Q);
    }
  };
  y0.prototype.compileFileAsync = function(Z, Q, J) {
    if (!this.can("compileFileAsync"))
      return j1.reject(new Error('The Transform "' + this.name + '" does not support compilation'));
    if (this._hasMethod("compileFileAsync"))
      return t.normalizeFnAsync(this._tr.compileFileAsync(Z, Q), J);
    else if (this._hasMethod("compileFile") || this._hasMethod("renderFile"))
      return t.normalizeFnAsync(this.compileFile(Z, Q), J);
    else {
      if (!Q)
        Q = {};
      if (Q.filename === void 0)
        Q.filename = Z;
      return t.normalizeFnAsync(t.readFile(Z, "utf8").then(function(X) {
        if (this._hasMethod("compileAsync"))
          return this._tr.compileAsync(X, Q);
        else
          return this.compile(X, Q);
      }.bind(this)), J);
    }
  };
  y0.prototype.compileClient = function(Z, Q) {
    if (!this.can("compileClient"))
      if (this.can("compileClientAsync"))
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
      else if (this.can("compileFileClientAsync"))
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.');
      else
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
    return t.normalize(this._tr.compileClient(Z, Q));
  };
  y0.prototype.compileClientAsync = function(Z, Q, J) {
    if (!this.can("compileClientAsync"))
      if (this.can("compileFileClientAsync"))
        return j1.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.')).nodeify(J);
      else
        return j1.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(J);
    if (this._hasMethod("compileClientAsync"))
      return t.normalizeAsync(this._tr.compileClientAsync(Z, Q), J);
    else
      return t.normalizeAsync(this._tr.compileClient(Z, Q), J);
  };
  y0.prototype.compileFileClient = function(Z, Q) {
    if (!this.can("compileFileClient"))
      if (this.can("compileFileClientAsync"))
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
      else
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
    if (this._hasMethod("compileFileClient"))
      return t.normalize(this._tr.compileFileClient(Z, Q));
    else {
      if (!Q)
        Q = {};
      if (Q.filename === void 0)
        Q.filename = Z;
      return t.normalize(this._tr.compileClient(t.readFileSync(Z, "utf8"), Q));
    }
  };
  y0.prototype.compileFileClientAsync = function(Z, Q, J) {
    if (!this.can("compileFileClientAsync"))
      return j1.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(J);
    if (this._hasMethod("compileFileClientAsync"))
      return t.normalizeAsync(this._tr.compileFileClientAsync(Z, Q), J);
    else if (this._hasMethod("compileFileClient"))
      return t.normalizeAsync(this._tr.compileFileClient(Z, Q), J);
    else {
      if (!Q)
        Q = {};
      if (Q.filename === void 0)
        Q.filename = Z;
      return t.normalizeAsync(t.readFile(Z, "utf8").then(function(X) {
        if (this._hasMethod("compileClientAsync"))
          return this._tr.compileClientAsync(X, Q);
        else
          return this._tr.compileClient(X, Q);
      }.bind(this)), J);
    }
  };
  y0.prototype.render = function(Z, Q, J) {
    if (!this.can("render"))
      if (this.can("renderAsync"))
        throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
      else if (this.can("renderFileAsync"))
        throw new Error('The Transform "' + this.name + '" does not support rendering from a string.');
      else
        throw new Error('The Transform "' + this.name + '" does not support rendering');
    if (this._hasMethod("render"))
      return t.normalize(this._tr.render(Z, Q, J));
    else {
      var X = t.normalizeFn(this._tr.compile(Z, Q)), z = X.fn(J || Q);
      if (typeof z !== "string")
        throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
      return t.normalize({ body: z, dependencies: X.dependencies });
    }
  };
  y0.prototype.renderAsync = function(Z, Q, J, X) {
    if (typeof J === "function")
      X = J, J = Q;
    if (!this.can("renderAsync"))
      if (this.can("renderFileAsync"))
        return j1.reject(new Error('The Transform "' + this.name + '" does not support rendering from a string.')).nodeify(X);
      else
        return j1.reject(new Error('The Transform "' + this.name + '" does not support rendering')).nodeify(X);
    if (this._hasMethod("renderAsync"))
      return t.normalizeAsync(this._tr.renderAsync(Z, Q, J), X);
    else if (this._hasMethod("render"))
      return t.normalizeAsync(this._tr.render(Z, Q, J), X);
    else
      return t.normalizeAsync(this.compileAsync(Z, Q).then(function(z) {
        return { body: z.fn(J || Q), dependencies: z.dependencies };
      }), X);
  };
  y0.prototype.renderFile = function(Z, Q, J) {
    if (!this.can("renderFile"))
      throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
    if (this._hasMethod("renderFile"))
      return t.normalize(this._tr.renderFile(Z, Q, J));
    else if (this._hasMethod("render")) {
      if (!Q)
        Q = {};
      if (Q.filename === void 0)
        Q.filename = Z;
      return t.normalize(this._tr.render(t.readFileSync(Z, "utf8"), Q, J));
    } else {
      var X = this.compileFile(Z, Q);
      return t.normalize({ body: X.fn(J || Q), dependencies: X.dependencies });
    }
  };
  y0.prototype.renderFileAsync = function(Z, Q, J, X) {
    if (!this.can("renderFileAsync"))
      throw new Error('The Transform "' + this.name + '" does not support rendering.');
    if (typeof J === "function")
      X = J, J = Q;
    if (this._hasMethod("renderFileAsync"))
      return t.normalizeAsync(this._tr.renderFileAsync(Z, Q, J), X);
    else if (this._hasMethod("renderFile"))
      return t.normalizeAsync(this._tr.renderFile(Z, Q, J), X);
    else if (this._hasMethod("compile") || this._hasMethod("compileAsync") || this._hasMethod("compileFile") || this._hasMethod("compileFileAsync"))
      return t.normalizeAsync(this.compileFileAsync(Z, Q).then(function(z) {
        return { body: z.fn(J || Q), dependencies: z.dependencies };
      }), X);
    else {
      if (!Q)
        Q = {};
      if (Q.filename === void 0)
        Q.filename = Z;
      return t.normalizeAsync(t.readFile(Z, "utf8").then(function(z) {
        return this.renderAsync(z, Q, J);
      }.bind(this)), X);
    }
  };
});

// node_modules/resolve/lib/homedir.js
var K6 = P((Lo, fX) => {
  var QV = A0("os");
  fX.exports = QV.homedir || function Z() {
    var Q = process.env.HOME, J = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    if (process.platform === "win32")
      return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || Q || null;
    if (process.platform === "darwin")
      return Q || (J ? "/Users/" + J : null);
    if (process.platform === "linux")
      return Q || (process.getuid() === 0 ? "/root" : J ? "/home/" + J : null);
    return Q || null;
  };
});

// node_modules/resolve/lib/caller.js
var M6 = P((No, yX) => {
  yX.exports = function() {
    var Z = Error.prepareStackTrace;
    Error.prepareStackTrace = function(J, X) {
      return X;
    };
    var Q = new Error().stack;
    return Error.prepareStackTrace = Z, Q[2].getFileName();
  };
});

// node_modules/path-parse/index.js
var mX = P((Po, r5) => {
  var zV = function(Z) {
    return XV.exec(Z).slice(1);
  }, YV = function(Z) {
    return HV.exec(Z).slice(1);
  }, JV = process.platform === "win32", XV = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/, F6 = {};
  F6.parse = function(Z) {
    if (typeof Z !== "string")
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof Z);
    var Q = zV(Z);
    if (!Q || Q.length !== 5)
      throw new TypeError("Invalid path '" + Z + "'");
    return {
      root: Q[1],
      dir: Q[0] === Q[1] ? Q[0] : Q[0].slice(0, -1),
      base: Q[2],
      ext: Q[4],
      name: Q[3]
    };
  };
  var HV = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/, R6 = {};
  R6.parse = function(Z) {
    if (typeof Z !== "string")
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof Z);
    var Q = YV(Z);
    if (!Q || Q.length !== 5)
      throw new TypeError("Invalid path '" + Z + "'");
    return {
      root: Q[1],
      dir: Q[0].slice(0, -1),
      base: Q[2],
      ext: Q[4],
      name: Q[3]
    };
  };
  if (JV)
    r5.exports = F6.parse;
  else
    r5.exports = R6.parse;
  r5.exports.posix = R6.parse;
  r5.exports.win32 = F6.parse;
});

// node_modules/resolve/lib/node-modules-paths.js
var j6 = P((So, lX) => {
  var cX = A0("path"), uX = cX.parse || mX(), xX = function Z(Q, J) {
    var X = "/";
    if (/^([A-Za-z]:)/.test(Q))
      X = "";
    else if (/^\\\\/.test(Q))
      X = "\\\\";
    var z = [Q], Y = uX(Q);
    while (Y.dir !== z[z.length - 1])
      z.push(Y.dir), Y = uX(Y.dir);
    return z.reduce(function(W, U) {
      return W.concat(J.map(function(V) {
        return cX.resolve(X, U, V);
      }));
    }, []);
  };
  lX.exports = function Z(Q, J, X) {
    var z = J && J.moduleDirectory ? [].concat(J.moduleDirectory) : ["node_modules"];
    if (J && typeof J.paths === "function")
      return J.paths(X, Q, function() {
        return xX(Q, z);
      }, J);
    var Y = xX(Q, z);
    return J && J.paths ? Y.concat(J.paths) : Y;
  };
});

// node_modules/resolve/lib/normalize-options.js
var O6 = P((wo, iX) => {
  iX.exports = function(Z, Q) {
    return Q || {};
  };
});

// node_modules/is-core-module/core.json
var dX = P((To, WV) => {
  WV.exports = {
    assert: !0,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: !0,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: !0,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: !0,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: !0,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: !0,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: !0,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: !0,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: !0,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: !0,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: !0,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: !0,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: !0,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: !0,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: !0,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: !0,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: !0,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: !0,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: !0,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: !0,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: !0,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: !0,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: !0,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: !0,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: !0,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: !0,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: !0,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// node_modules/is-core-module/index.js
var n5 = P((vo, rX) => {
  var UV = function(Z, Q) {
    var J = Z.split("."), X = Q.split(" "), z = X.length > 1 ? X[0] : "=", Y = (X.length > 1 ? X[1] : X[0]).split(".");
    for (var W = 0;W < 3; ++W) {
      var U = parseInt(J[W] || 0, 10), V = parseInt(Y[W] || 0, 10);
      if (U === V)
        continue;
      if (z === "<")
        return U < V;
      if (z === ">=")
        return U >= V;
      return !1;
    }
    return z === ">=";
  }, pX = function(Z, Q) {
    var J = Q.split(/ ?&& ?/);
    if (J.length === 0)
      return !1;
    for (var X = 0;X < J.length; ++X)
      if (!UV(Z, J[X]))
        return !1;
    return !0;
  }, VV = function(Z, Q) {
    if (typeof Q === "boolean")
      return Q;
    var J = typeof Z === "undefined" ? process.versions && process.versions.node : Z;
    if (typeof J !== "string")
      throw new TypeError(typeof Z === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    if (Q && typeof Q === "object") {
      for (var X = 0;X < Q.length; ++X)
        if (pX(J, Q[X]))
          return !0;
      return !1;
    }
    return pX(J, Q);
  }, GV = c7(), aX = dX();
  rX.exports = function Z(Q, J) {
    return GV(aX, Q) && VV(J, aX[Q]);
  };
});

// node_modules/resolve/lib/async.js
var tX = P((bo, sX) => {
  var H5 = A0("fs"), KV = K6(), w0 = A0("path"), MV = M6(), FV = j6(), RV = O6(), jV = n5(), OV = process.platform !== "win32" && H5.realpath && typeof H5.realpath.native === "function" ? H5.realpath.native : H5.realpath, nX = KV(), BV = function() {
    return [
      w0.join(nX, ".node_modules"),
      w0.join(nX, ".node_libraries")
    ];
  }, qV = function Z(Q, J) {
    H5.stat(Q, function(X, z) {
      if (!X)
        return J(null, z.isFile() || z.isFIFO());
      if (X.code === "ENOENT" || X.code === "ENOTDIR")
        return J(null, !1);
      return J(X);
    });
  }, $V = function Z(Q, J) {
    H5.stat(Q, function(X, z) {
      if (!X)
        return J(null, z.isDirectory());
      if (X.code === "ENOENT" || X.code === "ENOTDIR")
        return J(null, !1);
      return J(X);
    });
  }, DV = function Z(Q, J) {
    OV(Q, function(X, z) {
      if (X && X.code !== "ENOENT")
        J(X);
      else
        J(null, X ? Q : z);
    });
  }, s5 = function Z(Q, J, X, z) {
    if (X && X.preserveSymlinks === !1)
      Q(J, z);
    else
      z(null, J);
  }, IV = function Z(Q, J, X) {
    Q(J, function(z, Y) {
      if (z)
        X(z);
      else
        try {
          var W = JSON.parse(Y);
          X(null, W);
        } catch (U) {
          X(null);
        }
    });
  }, CV = function Z(Q, J, X) {
    var z = FV(J, X, Q);
    for (var Y = 0;Y < z.length; Y++)
      z[Y] = w0.join(z[Y], Q);
    return z;
  };
  sX.exports = function Z(Q, J, X) {
    var z = X, Y = J;
    if (typeof J === "function")
      z = Y, Y = {};
    if (typeof Q !== "string") {
      var W = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        z(W);
      });
    }
    Y = RV(Q, Y);
    var U = Y.isFile || qV, V = Y.isDirectory || $V, M = Y.readFile || H5.readFile, q = Y.realpath || DV, L = Y.readPackage || IV;
    if (Y.readFile && Y.readPackage) {
      var N = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        z(N);
      });
    }
    var T = Y.packageIterator, E = Y.extensions || [".js"], g = Y.includeCoreModules !== !1, n = Y.basedir || w0.dirname(MV()), x = Y.filename || n;
    Y.paths = Y.paths || BV();
    var d = w0.resolve(n);
    s5(q, d, Y, function(p, Q0) {
      if (p)
        z(p);
      else
        R(Q0);
    });
    var y;
    function R(p) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(Q)) {
        if (y = w0.resolve(p, Q), Q === "." || Q === ".." || Q.slice(-1) === "/")
          y += "/";
        if (/\/$/.test(Q) && y === p)
          q0(y, Y.package, L0);
        else
          B0(y, Y.package, L0);
      } else if (g && jV(Q))
        return z(null, Q);
      else
        s0(Q, p, function(Q0, $0, H0) {
          if (Q0)
            z(Q0);
          else if ($0)
            return s5(q, $0, Y, function(v0, O0) {
              if (v0)
                z(v0);
              else
                z(null, O0, H0);
            });
          else {
            var R0 = new Error("Cannot find module '" + Q + "' from '" + x + "'");
            R0.code = "MODULE_NOT_FOUND", z(R0);
          }
        });
    }
    function L0(p, Q0, $0) {
      if (p)
        z(p);
      else if (Q0)
        z(null, Q0, $0);
      else
        q0(y, function(H0, R0, v0) {
          if (H0)
            z(H0);
          else if (R0)
            s5(q, R0, Y, function(D0, b0) {
              if (D0)
                z(D0);
              else
                z(null, b0, v0);
            });
          else {
            var O0 = new Error("Cannot find module '" + Q + "' from '" + x + "'");
            O0.code = "MODULE_NOT_FOUND", z(O0);
          }
        });
    }
    function B0(p, Q0, $0) {
      var H0 = Q0, R0 = $0;
      if (typeof H0 === "function")
        R0 = H0, H0 = void 0;
      var v0 = [""].concat(E);
      O0(v0, p, H0);
      function O0(D0, b0, Y1) {
        if (D0.length === 0)
          return R0(null, void 0, Y1);
        var $1 = b0 + D0[0], k0 = Y1;
        if (k0)
          N0(null, k0);
        else
          e(w0.dirname($1), N0);
        function N0(W1, D1, Q1) {
          if (k0 = D1, W1)
            return R0(W1);
          if (Q1 && k0 && Y.pathFilter) {
            var n1 = w0.relative(Q1, $1), s1 = n1.slice(0, n1.length - D0[0].length), f1 = Y.pathFilter(k0, b0, s1);
            if (f1)
              return O0([""].concat(E.slice()), w0.resolve(Q1, f1), k0);
          }
          U($1, k1);
        }
        function k1(W1, D1) {
          if (W1)
            return R0(W1);
          if (D1)
            return R0(null, $1, k0);
          O0(D0.slice(1), b0, k0);
        }
      }
    }
    function e(p, Q0) {
      if (p === "" || p === "/")
        return Q0(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(p))
        return Q0(null);
      if (/[/\\]node_modules[/\\]*$/.test(p))
        return Q0(null);
      s5(q, p, Y, function($0, H0) {
        if ($0)
          return e(w0.dirname(p), Q0);
        var R0 = w0.join(H0, "package.json");
        U(R0, function(v0, O0) {
          if (!O0)
            return e(w0.dirname(p), Q0);
          L(M, R0, function(D0, b0) {
            if (D0)
              Q0(D0);
            var Y1 = b0;
            if (Y1 && Y.packageFilter)
              Y1 = Y.packageFilter(Y1, R0);
            Q0(null, Y1, p);
          });
        });
      });
    }
    function q0(p, Q0, $0) {
      var H0 = $0, R0 = Q0;
      if (typeof R0 === "function")
        H0 = R0, R0 = Y.package;
      s5(q, p, Y, function(v0, O0) {
        if (v0)
          return H0(v0);
        var D0 = w0.join(O0, "package.json");
        U(D0, function(b0, Y1) {
          if (b0)
            return H0(b0);
          if (!Y1)
            return B0(w0.join(p, "index"), R0, H0);
          L(M, D0, function($1, k0) {
            if ($1)
              return H0($1);
            var N0 = k0;
            if (N0 && Y.packageFilter)
              N0 = Y.packageFilter(N0, D0);
            if (N0 && N0.main) {
              if (typeof N0.main !== "string") {
                var k1 = new TypeError("package \u201C" + N0.name + "\u201D `main` must be a string");
                return k1.code = "INVALID_PACKAGE_MAIN", H0(k1);
              }
              if (N0.main === "." || N0.main === "./")
                N0.main = "index";
              B0(w0.resolve(p, N0.main), N0, function(W1, D1, Q1) {
                if (W1)
                  return H0(W1);
                if (D1)
                  return H0(null, D1, Q1);
                if (!Q1)
                  return B0(w0.join(p, "index"), Q1, H0);
                var n1 = w0.resolve(p, Q1.main);
                q0(n1, Q1, function(s1, f1, B5) {
                  if (s1)
                    return H0(s1);
                  if (f1)
                    return H0(null, f1, B5);
                  B0(w0.join(p, "index"), B5, H0);
                });
              });
              return;
            }
            B0(w0.join(p, "/index"), N0, H0);
          });
        });
      });
    }
    function Z0(p, Q0) {
      if (Q0.length === 0)
        return p(null, void 0);
      var $0 = Q0[0];
      V(w0.dirname($0), H0);
      function H0(O0, D0) {
        if (O0)
          return p(O0);
        if (!D0)
          return Z0(p, Q0.slice(1));
        B0($0, Y.package, R0);
      }
      function R0(O0, D0, b0) {
        if (O0)
          return p(O0);
        if (D0)
          return p(null, D0, b0);
        q0($0, Y.package, v0);
      }
      function v0(O0, D0, b0) {
        if (O0)
          return p(O0);
        if (D0)
          return p(null, D0, b0);
        Z0(p, Q0.slice(1));
      }
    }
    function s0(p, Q0, $0) {
      var H0 = function() {
        return CV(p, Q0, Y);
      };
      Z0($0, T ? T(p, Q0, H0, Y) : H0());
    }
  };
});

// node_modules/resolve/lib/core.json
var oX = P((Eo, AV) => {
  AV.exports = {
    assert: !0,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: !0,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: !0,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: !0,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: !0,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: !0,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: !0,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: !0,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: !0,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: !0,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: !0,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: !0,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: !0,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: !0,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: !0,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: !0,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: !0,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: !0,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: !0,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: !0,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: !0,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: !0,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: !0,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: !0,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: !0,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: !0,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: !0,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// node_modules/resolve/lib/core.js
var Jz = P((go, Qz) => {
  var LV = n5(), eX = oX(), Zz = {};
  for (e8 in eX)
    if (Object.prototype.hasOwnProperty.call(eX, e8))
      Zz[e8] = LV(e8);
  var e8;
  Qz.exports = Zz;
});

// node_modules/resolve/lib/is-core.js
var zz = P((ho, Xz) => {
  var NV = n5();
  Xz.exports = function Z(Q) {
    return NV(Q);
  };
});

// node_modules/resolve/lib/sync.js
var Wz = P((_o, Yz) => {
  var PV = n5(), Y5 = A0("fs"), m0 = A0("path"), SV = K6(), wV = M6(), TV = j6(), vV = O6(), bV = process.platform !== "win32" && Y5.realpathSync && typeof Y5.realpathSync.native === "function" ? Y5.realpathSync.native : Y5.realpathSync, Hz = SV(), EV = function() {
    return [
      m0.join(Hz, ".node_modules"),
      m0.join(Hz, ".node_libraries")
    ];
  }, gV = function Z(Q) {
    try {
      var J = Y5.statSync(Q, { throwIfNoEntry: !1 });
    } catch (X) {
      if (X && (X.code === "ENOENT" || X.code === "ENOTDIR"))
        return !1;
      throw X;
    }
    return !!J && (J.isFile() || J.isFIFO());
  }, hV = function Z(Q) {
    try {
      var J = Y5.statSync(Q, { throwIfNoEntry: !1 });
    } catch (X) {
      if (X && (X.code === "ENOENT" || X.code === "ENOTDIR"))
        return !1;
      throw X;
    }
    return !!J && J.isDirectory();
  }, _V = function Z(Q) {
    try {
      return bV(Q);
    } catch (J) {
      if (J.code !== "ENOENT")
        throw J;
    }
    return Q;
  }, t5 = function Z(Q, J, X) {
    if (X && X.preserveSymlinks === !1)
      return Q(J);
    return J;
  }, kV = function Z(Q, J) {
    var X = Q(J);
    try {
      var z = JSON.parse(X);
      return z;
    } catch (Y) {
    }
  }, fV = function Z(Q, J, X) {
    var z = TV(J, X, Q);
    for (var Y = 0;Y < z.length; Y++)
      z[Y] = m0.join(z[Y], Q);
    return z;
  };
  Yz.exports = function Z(Q, J) {
    if (typeof Q !== "string")
      throw new TypeError("Path must be a string.");
    var X = vV(Q, J), z = X.isFile || gV, Y = X.readFileSync || Y5.readFileSync, W = X.isDirectory || hV, U = X.realpathSync || _V, V = X.readPackageSync || kV;
    if (X.readFileSync && X.readPackageSync)
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    var M = X.packageIterator, q = X.extensions || [".js"], L = X.includeCoreModules !== !1, N = X.basedir || m0.dirname(wV()), T = X.filename || N;
    X.paths = X.paths || EV();
    var E = t5(U, m0.resolve(N), X);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(Q)) {
      var g = m0.resolve(E, Q);
      if (Q === "." || Q === ".." || Q.slice(-1) === "/")
        g += "/";
      var n = y(g) || L0(g);
      if (n)
        return t5(U, n, X);
    } else if (L && PV(Q))
      return Q;
    else {
      var x = B0(Q, E);
      if (x)
        return t5(U, x, X);
    }
    var d = new Error("Cannot find module '" + Q + "' from '" + T + "'");
    throw d.code = "MODULE_NOT_FOUND", d;
    function y(e) {
      var q0 = R(m0.dirname(e));
      if (q0 && q0.dir && q0.pkg && X.pathFilter) {
        var Z0 = m0.relative(q0.dir, e), s0 = X.pathFilter(q0.pkg, e, Z0);
        if (s0)
          e = m0.resolve(q0.dir, s0);
      }
      if (z(e))
        return e;
      for (var p = 0;p < q.length; p++) {
        var Q0 = e + q[p];
        if (z(Q0))
          return Q0;
      }
    }
    function R(e) {
      if (e === "" || e === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(e))
        return;
      if (/[/\\]node_modules[/\\]*$/.test(e))
        return;
      var q0 = m0.join(t5(U, e, X), "package.json");
      if (!z(q0))
        return R(m0.dirname(e));
      var Z0 = V(Y, q0);
      if (Z0 && X.packageFilter)
        Z0 = X.packageFilter(Z0, e);
      return { pkg: Z0, dir: e };
    }
    function L0(e) {
      var q0 = m0.join(t5(U, e, X), "/package.json");
      if (z(q0)) {
        try {
          var Z0 = V(Y, q0);
        } catch ($0) {
        }
        if (Z0 && X.packageFilter)
          Z0 = X.packageFilter(Z0, e);
        if (Z0 && Z0.main) {
          if (typeof Z0.main !== "string") {
            var s0 = new TypeError("package \u201C" + Z0.name + "\u201D `main` must be a string");
            throw s0.code = "INVALID_PACKAGE_MAIN", s0;
          }
          if (Z0.main === "." || Z0.main === "./")
            Z0.main = "index";
          try {
            var p = y(m0.resolve(e, Z0.main));
            if (p)
              return p;
            var Q0 = L0(m0.resolve(e, Z0.main));
            if (Q0)
              return Q0;
          } catch ($0) {
          }
        }
      }
      return y(m0.join(e, "/index"));
    }
    function B0(e, q0) {
      var Z0 = function() {
        return fV(e, q0, X);
      }, s0 = M ? M(e, q0, Z0, X) : Z0();
      for (var p = 0;p < s0.length; p++) {
        var Q0 = s0[p];
        if (W(m0.dirname(Q0))) {
          var $0 = y(Q0);
          if ($0)
            return $0;
          var H0 = L0(Q0);
          if (H0)
            return H0;
        }
      }
    }
  };
});

// node_modules/resolve/index.js
var Uz = P((ko, Gz) => {
  var Z7 = tX();
  Z7.core = Jz();
  Z7.isCore = zz();
  Z7.sync = Wz();
  Gz.exports = Z7;
});

// node_modules/pug-filters/lib/run-filter.js
var B6 = P((fo, Kz) => {
  var uV = function(Z) {
    switch (Z) {
      case "js":
        return "uglify-js";
      case "css":
        return "clean-css";
    }
  }, Vz = function(Z, Q, J, X, z) {
    z = z || "render";
    var Y;
    try {
      try {
        Y = mV.sync("jstransformer-" + Z, {
          basedir: X || process.cwd()
        });
      } catch (q) {
        Y = A0.resolve("jstransformer-" + Z);
      }
    } catch (q) {
      var W = new Error('unknown filter ":' + Z + '"');
      throw W.code = "UNKNOWN_FILTER", W;
    }
    var U = yV(A0(Y)), V = U[z](Q, J, J).body;
    if (J && J.minify) {
      var M = uV(U.outputFormat);
      if (M)
        try {
          V = Vz(M, V, null, X);
        } catch (q) {
        }
    }
    return V;
  }, yV = kX(), mV = Uz();
  Kz.exports = Vz;
});

// node_modules/@babel/parser/lib/index.js
var u6 = P((W4) => {
  var wz = function(Z, Q) {
    if (Z == null)
      return {};
    var J = {}, X = Object.keys(Z), z, Y;
    for (Y = 0;Y < X.length; Y++) {
      if (z = X[Y], Q.indexOf(z) >= 0)
        continue;
      J[z] = Z[z];
    }
    return J;
  }, d0 = function(Z, Q) {
    const {
      line: J,
      column: X,
      index: z
    } = Z;
    return new T1(J, X + Q, z + Q);
  }, Rz = function(Z, Q, J) {
    Object.defineProperty(Z, Q, {
      enumerable: !1,
      configurable: !0,
      value: J
    });
  }, rV = function(Z) {
    let {
      toMessage: Q
    } = Z, J = wz(Z, pV);
    return function X(z, Y) {
      const W = new SyntaxError;
      if (Object.assign(W, J, {
        loc: z,
        pos: z.index
      }), "missingPlugin" in Y)
        Object.assign(W, {
          missingPlugin: Y.missingPlugin
        });
      return Rz(W, "clone", function U(V = {}) {
        var M;
        const {
          line: q,
          column: L,
          index: N
        } = (M = V.loc) != null ? M : z;
        return X(new T1(q, L, N), Object.assign({}, Y, V.details));
      }), Rz(W, "details", Y), Object.defineProperty(W, "message", {
        configurable: !0,
        get() {
          const U = `${Q(Y)} (${z.line}:${z.column})`;
          return this.message = U, U;
        },
        set(U) {
          Object.defineProperty(this, "message", {
            value: U,
            writable: !0
          });
        }
      }), W;
    };
  }, w1 = function(Z, Q) {
    if (Array.isArray(Z))
      return (X) => w1(X, Z[0]);
    const J = {};
    for (let X of Object.keys(Z)) {
      const z = Z[X], Y = typeof z === "string" ? {
        message: () => z
      } : typeof z === "function" ? {
        message: z
      } : z, {
        message: W
      } = Y, U = wz(Y, aV), V = typeof W === "string" ? () => W : W;
      J[X] = rV(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: X,
        toMessage: V
      }, Q ? {
        syntaxPlugin: Q
      } : {}, U));
    }
    return J;
  }, o5 = function(Z) {
    return Z.loc.start && jz(Z.loc.start, "index"), Z.loc.end && jz(Z.loc.end, "index"), Z;
  }, U0 = function(Z, Q = {}) {
    Q.keyword = Z;
    const J = c(Z, Q);
    return S6.set(Z, J), J;
  }, i0 = function(Z, Q) {
    return c(Z, {
      beforeExpr: z0,
      binop: Q
    });
  }, c = function(Z, Q = {}) {
    var J, X, z, Y;
    return ++X8, w6.push(Z), T6.push((J = Q.binop) != null ? J : -1), v6.push((X = Q.beforeExpr) != null ? X : !1), b6.push((z = Q.startsExpr) != null ? z : !1), E6.push((Y = Q.prefix) != null ? Y : !1), P1.push(new P6(Z, Q)), X8;
  }, X0 = function(Z, Q = {}) {
    var J, X, z, Y;
    return ++X8, S6.set(Z, X8), w6.push(Z), T6.push((J = Q.binop) != null ? J : -1), v6.push((X = Q.beforeExpr) != null ? X : !1), b6.push((z = Q.startsExpr) != null ? z : !1), E6.push((Y = Q.prefix) != null ? Y : !1), P1.push(new P6("name", Q)), X8;
  }, K0 = function(Z) {
    return Z >= 93 && Z <= 132;
  }, eV = function(Z) {
    return Z <= 92;
  }, G1 = function(Z) {
    return Z >= 58 && Z <= 132;
  }, Tz = function(Z) {
    return Z >= 58 && Z <= 136;
  }, ZK = function(Z) {
    return v6[Z];
  }, A6 = function(Z) {
    return b6[Z];
  }, QK = function(Z) {
    return Z >= 29 && Z <= 33;
  }, Oz = function(Z) {
    return Z >= 129 && Z <= 131;
  }, JK = function(Z) {
    return Z >= 90 && Z <= 92;
  }, g6 = function(Z) {
    return Z >= 58 && Z <= 92;
  }, XK = function(Z) {
    return Z >= 39 && Z <= 59;
  }, zK = function(Z) {
    return Z === 34;
  }, HK = function(Z) {
    return E6[Z];
  }, YK = function(Z) {
    return Z >= 121 && Z <= 123;
  }, WK = function(Z) {
    return Z >= 124 && Z <= 130;
  }, c1 = function(Z) {
    return w6[Z];
  }, z7 = function(Z) {
    return T6[Z];
  }, GK = function(Z) {
    return Z === 57;
  }, W7 = function(Z) {
    return Z >= 24 && Z <= 25;
  }, L1 = function(Z) {
    return P1[Z];
  }, L6 = function(Z, Q) {
    let J = 65536;
    for (let X = 0, z = Q.length;X < z; X += 2) {
      if (J += Q[X], J > Z)
        return !1;
      if (J += Q[X + 1], J >= Z)
        return !0;
    }
    return !1;
  }, S1 = function(Z) {
    if (Z < 65)
      return Z === 36;
    if (Z <= 90)
      return !0;
    if (Z < 97)
      return Z === 95;
    if (Z <= 122)
      return !0;
    if (Z <= 65535)
      return Z >= 170 && UK.test(String.fromCharCode(Z));
    return L6(Z, bz);
  }, E5 = function(Z) {
    if (Z < 48)
      return Z === 36;
    if (Z < 58)
      return !0;
    if (Z < 65)
      return !1;
    if (Z <= 90)
      return !0;
    if (Z < 97)
      return Z === 95;
    if (Z <= 122)
      return !0;
    if (Z <= 65535)
      return Z >= 170 && VK.test(String.fromCharCode(Z));
    return L6(Z, bz) || L6(Z, KK);
  }, Ez = function(Z, Q) {
    return Q && Z === "await" || Z === "enum";
  }, gz = function(Z, Q) {
    return Ez(Z, Q) || FK.has(Z);
  }, hz = function(Z) {
    return RK.has(Z);
  }, _z = function(Z, Q) {
    return gz(Z, Q) || hz(Z);
  }, jK = function(Z) {
    return MK.has(Z);
  }, OK = function(Z, Q, J) {
    return Z === 64 && Q === 64 && S1(J);
  }, qK = function(Z) {
    return BK.has(Z);
  }, mz = function(Z, Q) {
    if (Z.trailingComments === void 0)
      Z.trailingComments = Q;
    else
      Z.trailingComments.unshift(...Q);
  }, $K = function(Z, Q) {
    if (Z.leadingComments === void 0)
      Z.leadingComments = Q;
    else
      Z.leadingComments.unshift(...Q);
  }, W8 = function(Z, Q) {
    if (Z.innerComments === void 0)
      Z.innerComments = Q;
    else
      Z.innerComments.unshift(...Q);
  }, Z8 = function(Z, Q, J) {
    let X = null, z = Q.length;
    while (X === null && z > 0)
      X = Q[--z];
    if (X === null || X.start > J.start)
      W8(Z, J.comments);
    else
      mz(X, J.comments);
  }, z8 = function(Z) {
    switch (Z) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }, DK = function(Z) {
    switch (Z) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }, $z = function(Z, Q, J, X, z, Y) {
    const W = J, U = X, V = z;
    let M = "", q = null, L = J;
    const {
      length: N
    } = Q;
    for (;; ) {
      if (J >= N) {
        Y.unterminated(W, U, V), M += Q.slice(L, J);
        break;
      }
      const T = Q.charCodeAt(J);
      if (CK(Z, T, Q, J)) {
        M += Q.slice(L, J);
        break;
      }
      if (T === 92) {
        M += Q.slice(L, J);
        const E = AK(Q, J, X, z, Z === "template", Y);
        if (E.ch === null && !q)
          q = {
            pos: J,
            lineStart: X,
            curLine: z
          };
        else
          M += E.ch;
        ({
          pos: J,
          lineStart: X,
          curLine: z
        } = E), L = J;
      } else if (T === 8232 || T === 8233)
        ++J, ++z, X = J;
      else if (T === 10 || T === 13)
        if (Z === "template") {
          if (M += Q.slice(L, J) + "\n", ++J, T === 13 && Q.charCodeAt(J) === 10)
            ++J;
          ++z, L = X = J;
        } else
          Y.unterminated(W, U, V);
      else
        ++J;
    }
    return {
      pos: J,
      str: M,
      firstInvalidLoc: q,
      lineStart: X,
      curLine: z,
      containsInvalid: !!q
    };
  }, CK = function(Z, Q, J, X) {
    if (Z === "template")
      return Q === 96 || Q === 36 && J.charCodeAt(X + 1) === 123;
    return Q === (Z === "double" ? 34 : 39);
  }, AK = function(Z, Q, J, X, z, Y) {
    const W = !z;
    Q++;
    const U = (M) => ({
      pos: Q,
      ch: M,
      lineStart: J,
      curLine: X
    }), V = Z.charCodeAt(Q++);
    switch (V) {
      case 110:
        return U("\n");
      case 114:
        return U("\r");
      case 120: {
        let M;
        return {
          code: M,
          pos: Q
        } = N6(Z, Q, J, X, 2, !1, W, Y), U(M === null ? null : String.fromCharCode(M));
      }
      case 117: {
        let M;
        return {
          code: M,
          pos: Q
        } = lz(Z, Q, J, X, W, Y), U(M === null ? null : String.fromCodePoint(M));
      }
      case 116:
        return U("\t");
      case 98:
        return U("\b");
      case 118:
        return U("\v");
      case 102:
        return U("\f");
      case 13:
        if (Z.charCodeAt(Q) === 10)
          ++Q;
      case 10:
        J = Q, ++X;
      case 8232:
      case 8233:
        return U("");
      case 56:
      case 57:
        if (z)
          return U(null);
        else
          Y.strictNumericEscape(Q - 1, J, X);
      default:
        if (V >= 48 && V <= 55) {
          const M = Q - 1;
          let L = Z.slice(M, Q + 2).match(/^[0-7]+/)[0], N = parseInt(L, 8);
          if (N > 255)
            L = L.slice(0, -1), N = parseInt(L, 8);
          Q += L.length - 1;
          const T = Z.charCodeAt(Q);
          if (L !== "0" || T === 56 || T === 57)
            if (z)
              return U(null);
            else
              Y.strictNumericEscape(M, J, X);
          return U(String.fromCharCode(N));
        }
        return U(String.fromCharCode(V));
    }
  }, N6 = function(Z, Q, J, X, z, Y, W, U) {
    const V = Q;
    let M;
    if ({
      n: M,
      pos: Q
    } = cz(Z, Q, J, X, 16, z, Y, !1, U, !W), M === null)
      if (W)
        U.invalidEscapeSequence(V, J, X);
      else
        Q = V - 1;
    return {
      code: M,
      pos: Q
    };
  }, cz = function(Z, Q, J, X, z, Y, W, U, V, M) {
    const q = Q, L = z === 16 ? qz.hex : qz.decBinOct, N = z === 16 ? J7.hex : z === 10 ? J7.dec : z === 8 ? J7.oct : J7.bin;
    let T = !1, E = 0;
    for (let g = 0, n = Y == null ? Infinity : Y;g < n; ++g) {
      const x = Z.charCodeAt(Q);
      let d;
      if (x === 95 && U !== "bail") {
        const y = Z.charCodeAt(Q - 1), R = Z.charCodeAt(Q + 1);
        if (!U) {
          if (M)
            return {
              n: null,
              pos: Q
            };
          V.numericSeparatorInEscapeSequence(Q, J, X);
        } else if (Number.isNaN(R) || !N(R) || L.has(y) || L.has(R)) {
          if (M)
            return {
              n: null,
              pos: Q
            };
          V.unexpectedNumericSeparator(Q, J, X);
        }
        ++Q;
        continue;
      }
      if (x >= 97)
        d = x - 97 + 10;
      else if (x >= 65)
        d = x - 65 + 10;
      else if (IK(x))
        d = x - 48;
      else
        d = Infinity;
      if (d >= z)
        if (d <= 9 && M)
          return {
            n: null,
            pos: Q
          };
        else if (d <= 9 && V.invalidDigit(Q, J, X, z))
          d = 0;
        else if (W)
          d = 0, T = !0;
        else
          break;
      ++Q, E = E * z + d;
    }
    if (Q === q || Y != null && Q - q !== Y || T)
      return {
        n: null,
        pos: Q
      };
    return {
      n: E,
      pos: Q
    };
  }, lz = function(Z, Q, J, X, z, Y) {
    const W = Z.charCodeAt(Q);
    let U;
    if (W === 123) {
      if (++Q, {
        code: U,
        pos: Q
      } = N6(Z, Q, J, X, Z.indexOf("}", Q) - Q, !0, z, Y), ++Q, U !== null && U > 1114111)
        if (z)
          Y.invalidCodePoint(Q, J, X);
        else
          return {
            code: null,
            pos: Q
          };
    } else
      ({
        code: U,
        pos: Q
      } = N6(Z, Q, J, X, 4, !1, z, Y));
    return {
      code: U,
      pos: Q
    };
  }, Q8 = function(Z, Q, J) {
    return new T1(J, Z - Q, Z);
  }, NK = function() {
    return new U8(3);
  }, PK = function() {
    return new f6(1);
  }, SK = function() {
    return new f6(2);
  }, rz = function() {
    return new U8;
  }, Y7 = function(Z, Q) {
    return (Z ? 2 : 0) | (Q ? 1 : 0);
  }, wK = function(Z) {
    return v1(Z);
  }, v1 = function(Z) {
    const {
      type: Q,
      start: J,
      end: X,
      loc: z,
      range: Y,
      extra: W,
      name: U
    } = Z, V = Object.create(y6);
    if (V.type = Q, V.start = J, V.end = X, V.loc = z, V.range = Y, V.extra = W, V.name = U, Q === "Placeholder")
      V.expectedNode = Z.expectedNode;
    return V;
  }, TK = function(Z) {
    const {
      type: Q,
      start: J,
      end: X,
      loc: z,
      range: Y,
      extra: W
    } = Z;
    if (Q === "Placeholder")
      return wK(Z);
    const U = Object.create(y6);
    if (U.type = Q, U.start = J, U.end = X, U.loc = z, U.range = Y, Z.raw !== void 0)
      U.raw = Z.raw;
    else
      U.extra = W;
    return U.value = Z.value, U;
  }, bK = function(Z) {
    return Z.type === "DeclareExportAllDeclaration" || Z.type === "DeclareExportDeclaration" && (!Z.declaration || Z.declaration.type !== "TypeAlias" && Z.declaration.type !== "InterfaceDeclaration");
  }, Dz = function(Z) {
    return Z.importKind === "type" || Z.importKind === "typeof";
  }, gK = function(Z, Q) {
    const J = [], X = [];
    for (let z = 0;z < Z.length; z++)
      (Q(Z[z], z, Z) ? J : X).push(Z[z]);
    return [J, X];
  }, u1 = function(Z) {
    return Z ? Z.type === "JSXOpeningFragment" || Z.type === "JSXClosingFragment" : !1;
  }, b5 = function(Z) {
    if (Z.type === "JSXIdentifier")
      return Z.name;
    if (Z.type === "JSXNamespacedName")
      return Z.namespace.name + ":" + Z.name.name;
    if (Z.type === "JSXMemberExpression")
      return b5(Z.object) + "." + b5(Z.property);
    throw new Error("Node had unexpected type: " + Z.type);
  }, uK = function(Z) {
    if (Z == null)
      throw new Error(`Unexpected ${Z} value.`);
    return Z;
  }, Iz = function(Z) {
    if (!Z)
      throw new Error("Assert fail");
  }, xK = function(Z) {
    switch (Z) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }, Cz = function(Z) {
    return Z === "private" || Z === "public" || Z === "protected";
  }, cK = function(Z) {
    return Z === "in" || Z === "out";
  }, iK = function(Z) {
    if (Z.type !== "MemberExpression")
      return !1;
    const {
      computed: Q,
      property: J
    } = Z;
    if (Q && J.type !== "StringLiteral" && (J.type !== "TemplateLiteral" || J.expressions.length > 0))
      return !1;
    return X4(Z.object);
  }, dK = function(Z, Q) {
    var J;
    const {
      type: X
    } = Z;
    if ((J = Z.extra) != null && J.parenthesized)
      return !1;
    if (Q) {
      if (X === "Literal") {
        const {
          value: z
        } = Z;
        if (typeof z === "string" || typeof z === "boolean")
          return !0;
      }
    } else if (X === "StringLiteral" || X === "BooleanLiteral")
      return !0;
    if (J4(Z, Q) || pK(Z, Q))
      return !0;
    if (X === "TemplateLiteral" && Z.expressions.length === 0)
      return !0;
    if (iK(Z))
      return !0;
    return !1;
  }, J4 = function(Z, Q) {
    if (Q)
      return Z.type === "Literal" && (typeof Z.value === "number" || ("bigint" in Z));
    return Z.type === "NumericLiteral" || Z.type === "BigIntLiteral";
  }, pK = function(Z, Q) {
    if (Z.type === "UnaryExpression") {
      const {
        operator: J,
        argument: X
      } = Z;
      if (J === "-" && J4(X, Q))
        return !0;
    }
    return !1;
  }, X4 = function(Z) {
    if (Z.type === "Identifier")
      return !0;
    if (Z.type !== "MemberExpression" || Z.computed)
      return !1;
    return X4(Z.object);
  }, T0 = function(Z, Q) {
    const [J, X] = typeof Q === "string" ? [Q, {}] : Q, z = Object.keys(X), Y = z.length === 0;
    return Z.some((W) => {
      if (typeof W === "string")
        return Y && W === J;
      else {
        const [U, V] = W;
        if (U !== J)
          return !1;
        for (let M of z)
          if (V[M] !== X[M])
            return !1;
        return !0;
      }
    });
  }, x1 = function(Z, Q, J) {
    const X = Z.find((z) => {
      if (Array.isArray(z))
        return z[0] === Q;
      else
        return z === Q;
    });
    if (X && Array.isArray(X) && X.length > 1)
      return X[1][J];
    return null;
  }, nK = function(Z) {
    if (T0(Z, "decorators")) {
      if (T0(Z, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const Q = x1(Z, "decorators", "decoratorsBeforeExport");
      if (Q != null && typeof Q !== "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      const J = x1(Z, "decorators", "allowCallParenthesized");
      if (J != null && typeof J !== "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (T0(Z, "flow") && T0(Z, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (T0(Z, "placeholders") && T0(Z, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (T0(Z, "pipelineOperator")) {
      const Q = x1(Z, "pipelineOperator", "proposal");
      if (!Lz.includes(Q)) {
        const X = Lz.map((z) => `"${z}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${X}.`);
      }
      const J = T0(Z, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (Q === "hack") {
        if (T0(Z, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (T0(Z, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const X = x1(Z, "pipelineOperator", "topicToken");
        if (!Nz.includes(X)) {
          const z = Nz.map((Y) => `"${Y}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${z}.`);
        }
        if (X === "#" && J)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (Q === "smart" && J)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (T0(Z, "moduleAttributes")) {
      if (T0(Z, "importAssertions") || T0(Z, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (x1(Z, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (T0(Z, "importAssertions") && T0(Z, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (T0(Z, "recordAndTuple") && x1(Z, "recordAndTuple", "syntaxType") != null && !Pz.includes(x1(Z, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Pz.map((Q) => `'${Q}'`).join(", "));
    if (T0(Z, "asyncDoExpressions") && !T0(Z, "doExpressions")) {
      const Q = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw Q.missingPlugins = "doExpressions", Q;
    }
    if (T0(Z, "optionalChainingAssign") && x1(Z, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }, tK = function(Z) {
    if (Z == null)
      return Object.assign({}, D6);
    if (Z.annexB != null && Z.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    const Q = {};
    for (let X of Object.keys(D6)) {
      var J;
      Q[X] = (J = Z[X]) != null ? J : D6[X];
    }
    return Q;
  }, Z3 = function(Z, Q) {
    for (let J = 0;J < Z.length; J++) {
      const X = Z[J], {
        type: z
      } = X;
      if (typeof z === "number") {
        {
          if (z === 138) {
            const {
              loc: Y,
              start: W,
              value: U,
              end: V
            } = X, M = W + 1, q = d0(Y.start, 1);
            Z.splice(J, 1, new N1({
              type: L1(27),
              value: "#",
              start: W,
              end: M,
              startLoc: Y.start,
              endLoc: q
            }), new N1({
              type: L1(132),
              value: U,
              start: M,
              end: V,
              startLoc: q,
              endLoc: Y.end
            })), J++;
            continue;
          }
          if (W7(z)) {
            const {
              loc: Y,
              start: W,
              value: U,
              end: V
            } = X, M = W + 1, q = d0(Y.start, 1);
            let L;
            if (Q.charCodeAt(W) === 96)
              L = new N1({
                type: L1(22),
                value: "`",
                start: W,
                end: M,
                startLoc: Y.start,
                endLoc: q
              });
            else
              L = new N1({
                type: L1(8),
                value: "}",
                start: W,
                end: M,
                startLoc: Y.start,
                endLoc: q
              });
            let N, T, E, g;
            if (z === 24)
              T = V - 1, E = d0(Y.end, -1), N = U === null ? null : U.slice(1, -1), g = new N1({
                type: L1(22),
                value: "`",
                start: T,
                end: V,
                startLoc: E,
                endLoc: Y.end
              });
            else
              T = V - 2, E = d0(Y.end, -2), N = U === null ? null : U.slice(1, -2), g = new N1({
                type: L1(23),
                value: "${",
                start: T,
                end: V,
                startLoc: E,
                endLoc: Y.end
              });
            Z.splice(J, 1, L, new N1({
              type: L1(20),
              value: N,
              start: M,
              end: T,
              startLoc: q,
              endLoc: E
            }), g), J += 2;
            continue;
          }
        }
        X.type = L1(z);
      }
    }
    return Z;
  }, Q3 = function(Z) {
    const Q = new Map;
    for (let J of Z) {
      const [X, z] = Array.isArray(J) ? J : [J, {}];
      if (!Q.has(X))
        Q.set(X, z || {});
    }
    return Q;
  }, J3 = function(Z, Q) {
    var J;
    if (((J = Q) == null ? void 0 : J.sourceType) === "unambiguous") {
      Q = Object.assign({}, Q);
      try {
        Q.sourceType = "module";
        const X = J8(Q, Z), z = X.parse();
        if (X.sawUnambiguousESM)
          return z;
        if (X.ambiguousScriptDifferentAst)
          try {
            return Q.sourceType = "script", J8(Q, Z).parse();
          } catch (Y) {
          }
        else
          z.program.sourceType = "script";
        return z;
      } catch (X) {
        try {
          return Q.sourceType = "script", J8(Q, Z).parse();
        } catch (z) {
        }
        throw X;
      }
    } else
      return J8(Q, Z).parse();
  }, X3 = function(Z, Q) {
    const J = J8(Q, Z);
    if (J.options.strictMode)
      J.state.strict = !0;
    return J.getExpression();
  }, z3 = function(Z) {
    const Q = {};
    for (let J of Object.keys(Z))
      Q[J] = L1(Z[J]);
    return Q;
  }, J8 = function(Z, Q) {
    let J = m6;
    if (Z != null && Z.plugins)
      nK(Z.plugins), J = Y3(Z.plugins);
    return new J(Z, Q);
  }, Y3 = function(Z) {
    const Q = sK.filter((z) => T0(Z, z)), J = Q.join("/");
    let X = Sz[J];
    if (!X) {
      X = m6;
      for (let z of Q)
        X = z4[z](X);
      Sz[J] = X;
    }
    return X;
  };
  Object.defineProperty(W4, "__esModule", {
    value: !0
  });

  class T1 {
    constructor(Z, Q, J) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = Z, this.column = Q, this.index = J;
    }
  }

  class Y8 {
    constructor(Z, Q) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = Z, this.end = Q;
    }
  }
  var Mz = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", xV = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: Mz
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: Mz
    }
  }, Fz = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, X7 = ({
    type: Z,
    prefix: Q
  }) => Z === "UpdateExpression" ? Fz.UpdateExpression[String(Q)] : Fz[Z], cV = {
    AccessorIsGenerator: ({
      kind: Z
    }) => `A ${Z}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind: Z
    }) => `Missing initializer in ${Z} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName: Z
    }) => `\`${Z}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: ({
      phase: Z
    }) => `'import.${Z}(...)' can only be parsed when using the 'createImportExpressions' option.`,
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName: Z,
      exportName: Q
    }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${Z}' as '${Q}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type: Z
    }) => `'${Z === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type: Z
    }) => `Unsyntactic ${Z === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: ({
      importName: Z
    }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${Z}" as foo }\`?`,
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: ({
      maxArgumentCount: Z
    }) => `\`import()\` requires exactly ${Z === 1 ? "one argument" : "one or two arguments"}.`,
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix: Z
    }) => `Expected number in radix ${Z}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord: Z
    }) => `Escape sequence in keyword ${Z}.`,
    InvalidIdentifier: ({
      identifierName: Z
    }) => `Invalid identifier ${Z}.`,
    InvalidLhs: ({
      ancestor: Z
    }) => `Invalid left-hand side in ${X7(Z)}.`,
    InvalidLhsBinding: ({
      ancestor: Z
    }) => `Binding invalid left-hand side in ${X7(Z)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor: Z
    }) => `Invalid optional chaining in the left-hand side of ${X7(Z)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected: Z
    }) => `Unexpected character '${Z}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName: Z
    }) => `Private name #${Z} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName: Z
    }) => `Label '${Z}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin: Z
    }) => `This experimental syntax requires enabling the parser plugin: ${Z.map((Q) => JSON.stringify(Q)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin: Z
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${Z.map((Q) => JSON.stringify(Q)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key: Z
    }) => `Duplicate key "${Z}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode: Z
    }) => `An export name cannot include a lone surrogate, found '\\u${Z.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName: Z
    }) => `Export '${Z}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName: Z
    }) => `Private names are only allowed in property accesses (\`obj.#${Z}\`) or in \`in\` expressions (\`#${Z} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName: Z
    }) => `Duplicate private name #${Z}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword: Z
    }) => `Unexpected keyword '${Z}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord: Z
    }) => `Unexpected reserved word '${Z}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected: Z,
      unexpected: Q
    }) => `Unexpected token${Q ? ` '${Q}'.` : ""}${Z ? `, expected "${Z}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target: Z,
      onlyValidPropertyName: Q
    }) => `The only valid meta property for ${Z} is ${Z}.${Q}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName: Z
    }) => `Identifier '${Z}' has already been declared.`,
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, lV = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName: Z
    }) => `Assigning to '${Z}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName: Z
    }) => `Binding '${Z}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, iV = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), dV = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token: Z
    }) => `Invalid topic token ${Z}. In order to use ${Z} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${Z}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type: Z
    }) => `Hack-style pipe body cannot be an unparenthesized ${X7({
      type: Z
    })}; please wrap it in parentheses.`,
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  }, pV = ["toMessage"], aV = ["message"], C = Object.assign({}, w1(xV), w1(cV), w1(lV), w1`pipelineOperator`(dV)), {
    defineProperty: nV
  } = Object, jz = (Z, Q) => nV(Z, Q, {
    enumerable: !1,
    value: Z[Q]
  }), sV = (Z) => class Q extends Z {
    parse() {
      const J = o5(super.parse());
      if (this.options.tokens)
        J.tokens = J.tokens.map(o5);
      return J;
    }
    parseRegExpLiteral({
      pattern: J,
      flags: X
    }) {
      let z = null;
      try {
        z = new RegExp(J, X);
      } catch (W) {
      }
      const Y = this.estreeParseLiteral(z);
      return Y.regex = {
        pattern: J,
        flags: X
      }, Y;
    }
    parseBigIntLiteral(J) {
      let X;
      try {
        X = BigInt(J);
      } catch (Y) {
        X = null;
      }
      const z = this.estreeParseLiteral(X);
      return z.bigint = String(z.value || J), z;
    }
    parseDecimalLiteral(J) {
      const z = this.estreeParseLiteral(null);
      return z.decimal = String(z.value || J), z;
    }
    estreeParseLiteral(J) {
      return this.parseLiteral(J, "Literal");
    }
    parseStringLiteral(J) {
      return this.estreeParseLiteral(J);
    }
    parseNumericLiteral(J) {
      return this.estreeParseLiteral(J);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(J) {
      return this.estreeParseLiteral(J);
    }
    directiveToStmt(J) {
      const X = J.value;
      delete J.value, X.type = "Literal", X.raw = X.extra.raw, X.value = X.extra.expressionValue;
      const z = J;
      return z.type = "ExpressionStatement", z.expression = X, z.directive = X.extra.rawValue, delete X.extra, z;
    }
    initFunction(J, X) {
      super.initFunction(J, X), J.expression = !1;
    }
    checkDeclaration(J) {
      if (J != null && this.isObjectProperty(J))
        this.checkDeclaration(J.value);
      else
        super.checkDeclaration(J);
    }
    getObjectOrClassMethodParams(J) {
      return J.value.params;
    }
    isValidDirective(J) {
      var X;
      return J.type === "ExpressionStatement" && J.expression.type === "Literal" && typeof J.expression.value === "string" && !((X = J.expression.extra) != null && X.parenthesized);
    }
    parseBlockBody(J, X, z, Y, W) {
      super.parseBlockBody(J, X, z, Y, W);
      const U = J.directives.map((V) => this.directiveToStmt(V));
      J.body = U.concat(J.body), delete J.directives;
    }
    pushClassMethod(J, X, z, Y, W, U) {
      if (this.parseMethod(X, z, Y, W, U, "ClassMethod", !0), X.typeParameters)
        X.value.typeParameters = X.typeParameters, delete X.typeParameters;
      J.body.push(X);
    }
    parsePrivateName() {
      const J = super.parsePrivateName();
      if (!this.getPluginOption("estree", "classFeatures"))
        return J;
      return this.convertPrivateNameToPrivateIdentifier(J);
    }
    convertPrivateNameToPrivateIdentifier(J) {
      const X = super.getPrivateNameSV(J);
      return J = J, delete J.id, J.name = X, J.type = "PrivateIdentifier", J;
    }
    isPrivateName(J) {
      if (!this.getPluginOption("estree", "classFeatures"))
        return super.isPrivateName(J);
      return J.type === "PrivateIdentifier";
    }
    getPrivateNameSV(J) {
      if (!this.getPluginOption("estree", "classFeatures"))
        return super.getPrivateNameSV(J);
      return J.name;
    }
    parseLiteral(J, X) {
      const z = super.parseLiteral(J, X);
      return z.raw = z.extra.raw, delete z.extra, z;
    }
    parseFunctionBody(J, X, z = !1) {
      super.parseFunctionBody(J, X, z), J.expression = J.body.type !== "BlockStatement";
    }
    parseMethod(J, X, z, Y, W, U, V = !1) {
      let M = this.startNode();
      if (M.kind = J.kind, M = super.parseMethod(M, X, z, Y, W, U, V), M.type = "FunctionExpression", delete M.kind, J.value = M, U === "ClassPrivateMethod")
        J.computed = !1;
      return this.finishNode(J, "MethodDefinition");
    }
    parseClassProperty(...J) {
      const X = super.parseClassProperty(...J);
      if (!this.getPluginOption("estree", "classFeatures"))
        return X;
      return X.type = "PropertyDefinition", X;
    }
    parseClassPrivateProperty(...J) {
      const X = super.parseClassPrivateProperty(...J);
      if (!this.getPluginOption("estree", "classFeatures"))
        return X;
      return X.type = "PropertyDefinition", X.computed = !1, X;
    }
    parseObjectMethod(J, X, z, Y, W) {
      const U = super.parseObjectMethod(J, X, z, Y, W);
      if (U) {
        if (U.type = "Property", U.kind === "method")
          U.kind = "init";
        U.shorthand = !1;
      }
      return U;
    }
    parseObjectProperty(J, X, z, Y) {
      const W = super.parseObjectProperty(J, X, z, Y);
      if (W)
        W.kind = "init", W.type = "Property";
      return W;
    }
    isValidLVal(J, X, z) {
      return J === "Property" ? "value" : super.isValidLVal(J, X, z);
    }
    isAssignable(J, X) {
      if (J != null && this.isObjectProperty(J))
        return this.isAssignable(J.value, X);
      return super.isAssignable(J, X);
    }
    toAssignable(J, X = !1) {
      if (J != null && this.isObjectProperty(J)) {
        const {
          key: z,
          value: Y
        } = J;
        if (this.isPrivateName(z))
          this.classScope.usePrivateName(this.getPrivateNameSV(z), z.loc.start);
        this.toAssignable(Y, X);
      } else
        super.toAssignable(J, X);
    }
    toAssignableObjectExpressionProp(J, X, z) {
      if (J.kind === "get" || J.kind === "set")
        this.raise(C.PatternHasAccessor, J.key);
      else if (J.method)
        this.raise(C.PatternHasMethod, J.key);
      else
        super.toAssignableObjectExpressionProp(J, X, z);
    }
    finishCallExpression(J, X) {
      const z = super.finishCallExpression(J, X);
      if (z.callee.type === "Import") {
        if (z.type = "ImportExpression", z.source = z.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var Y, W;
          z.options = (Y = z.arguments[1]) != null ? Y : null, z.attributes = (W = z.arguments[1]) != null ? W : null;
        }
        delete z.arguments, delete z.callee;
      }
      return z;
    }
    toReferencedArguments(J) {
      if (J.type === "ImportExpression")
        return;
      super.toReferencedArguments(J);
    }
    parseExport(J, X) {
      const z = this.state.lastTokStartLoc, Y = super.parseExport(J, X);
      switch (Y.type) {
        case "ExportAllDeclaration":
          Y.exported = null;
          break;
        case "ExportNamedDeclaration":
          if (Y.specifiers.length === 1 && Y.specifiers[0].type === "ExportNamespaceSpecifier")
            Y.type = "ExportAllDeclaration", Y.exported = Y.specifiers[0].exported, delete Y.specifiers;
        case "ExportDefaultDeclaration":
          {
            var W;
            const {
              declaration: U
            } = Y;
            if ((U == null ? void 0 : U.type) === "ClassDeclaration" && ((W = U.decorators) == null ? void 0 : W.length) > 0 && U.start === Y.start)
              this.resetStartLocation(Y, z);
          }
          break;
      }
      return Y;
    }
    parseSubscript(J, X, z, Y) {
      const W = super.parseSubscript(J, X, z, Y);
      if (Y.optionalChainMember) {
        if (W.type === "OptionalMemberExpression" || W.type === "OptionalCallExpression")
          W.type = W.type.substring(8);
        if (Y.stop) {
          const U = this.startNodeAtNode(W);
          return U.expression = W, this.finishNode(U, "ChainExpression");
        }
      } else if (W.type === "MemberExpression" || W.type === "CallExpression")
        W.optional = !1;
      return W;
    }
    isOptionalMemberExpression(J) {
      if (J.type === "ChainExpression")
        return J.expression.type === "MemberExpression";
      return super.isOptionalMemberExpression(J);
    }
    hasPropertyAsPrivateName(J) {
      if (J.type === "ChainExpression")
        J = J.expression;
      return super.hasPropertyAsPrivateName(J);
    }
    isObjectProperty(J) {
      return J.type === "Property" && J.kind === "init" && !J.method;
    }
    isObjectMethod(J) {
      return J.method || J.kind === "get" || J.kind === "set";
    }
    finishNodeAt(J, X, z) {
      return o5(super.finishNodeAt(J, X, z));
    }
    resetStartLocation(J, X) {
      super.resetStartLocation(J, X), o5(J);
    }
    resetEndLocation(J, X = this.state.lastTokEndLoc) {
      super.resetEndLocation(J, X), o5(J);
    }
  };

  class v5 {
    constructor(Z, Q) {
      this.token = void 0, this.preserveSpace = void 0, this.token = Z, this.preserveSpace = !!Q;
    }
  }
  var j0 = {
    brace: new v5("{"),
    j_oTag: new v5("<tag"),
    j_cTag: new v5("</tag"),
    j_expr: new v5("<tag>...</tag>", !0)
  };
  j0.template = new v5("`", !0);
  var z0 = !0, k = !0, q6 = !0, e5 = !0, m1 = !0, tV = !0;

  class P6 {
    constructor(Z, Q = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = Z, this.keyword = Q.keyword, this.beforeExpr = !!Q.beforeExpr, this.startsExpr = !!Q.startsExpr, this.rightAssociative = !!Q.rightAssociative, this.isLoop = !!Q.isLoop, this.isAssign = !!Q.isAssign, this.prefix = !!Q.prefix, this.postfix = !!Q.postfix, this.binop = Q.binop != null ? Q.binop : null, this.updateContext = null;
    }
  }
  var S6 = new Map, X8 = -1, P1 = [], w6 = [], T6 = [], v6 = [], b6 = [], E6 = [], oV = {
    bracketL: c("[", {
      beforeExpr: z0,
      startsExpr: k
    }),
    bracketHashL: c("#[", {
      beforeExpr: z0,
      startsExpr: k
    }),
    bracketBarL: c("[|", {
      beforeExpr: z0,
      startsExpr: k
    }),
    bracketR: c("]"),
    bracketBarR: c("|]"),
    braceL: c("{", {
      beforeExpr: z0,
      startsExpr: k
    }),
    braceBarL: c("{|", {
      beforeExpr: z0,
      startsExpr: k
    }),
    braceHashL: c("#{", {
      beforeExpr: z0,
      startsExpr: k
    }),
    braceR: c("}"),
    braceBarR: c("|}"),
    parenL: c("(", {
      beforeExpr: z0,
      startsExpr: k
    }),
    parenR: c(")"),
    comma: c(",", {
      beforeExpr: z0
    }),
    semi: c(";", {
      beforeExpr: z0
    }),
    colon: c(":", {
      beforeExpr: z0
    }),
    doubleColon: c("::", {
      beforeExpr: z0
    }),
    dot: c("."),
    question: c("?", {
      beforeExpr: z0
    }),
    questionDot: c("?."),
    arrow: c("=>", {
      beforeExpr: z0
    }),
    template: c("template"),
    ellipsis: c("...", {
      beforeExpr: z0
    }),
    backQuote: c("`", {
      startsExpr: k
    }),
    dollarBraceL: c("${", {
      beforeExpr: z0,
      startsExpr: k
    }),
    templateTail: c("...`", {
      startsExpr: k
    }),
    templateNonTail: c("...${", {
      beforeExpr: z0,
      startsExpr: k
    }),
    at: c("@"),
    hash: c("#", {
      startsExpr: k
    }),
    interpreterDirective: c("#!..."),
    eq: c("=", {
      beforeExpr: z0,
      isAssign: e5
    }),
    assign: c("_=", {
      beforeExpr: z0,
      isAssign: e5
    }),
    slashAssign: c("_=", {
      beforeExpr: z0,
      isAssign: e5
    }),
    xorAssign: c("_=", {
      beforeExpr: z0,
      isAssign: e5
    }),
    moduloAssign: c("_=", {
      beforeExpr: z0,
      isAssign: e5
    }),
    incDec: c("++/--", {
      prefix: m1,
      postfix: tV,
      startsExpr: k
    }),
    bang: c("!", {
      beforeExpr: z0,
      prefix: m1,
      startsExpr: k
    }),
    tilde: c("~", {
      beforeExpr: z0,
      prefix: m1,
      startsExpr: k
    }),
    doubleCaret: c("^^", {
      startsExpr: k
    }),
    doubleAt: c("@@", {
      startsExpr: k
    }),
    pipeline: i0("|>", 0),
    nullishCoalescing: i0("??", 1),
    logicalOR: i0("||", 1),
    logicalAND: i0("&&", 2),
    bitwiseOR: i0("|", 3),
    bitwiseXOR: i0("^", 4),
    bitwiseAND: i0("&", 5),
    equality: i0("==/!=/===/!==", 6),
    lt: i0("</>/<=/>=", 7),
    gt: i0("</>/<=/>=", 7),
    relational: i0("</>/<=/>=", 7),
    bitShift: i0("<</>>/>>>", 8),
    bitShiftL: i0("<</>>/>>>", 8),
    bitShiftR: i0("<</>>/>>>", 8),
    plusMin: c("+/-", {
      beforeExpr: z0,
      binop: 9,
      prefix: m1,
      startsExpr: k
    }),
    modulo: c("%", {
      binop: 10,
      startsExpr: k
    }),
    star: c("*", {
      binop: 10
    }),
    slash: i0("/", 10),
    exponent: c("**", {
      beforeExpr: z0,
      binop: 11,
      rightAssociative: !0
    }),
    _in: U0("in", {
      beforeExpr: z0,
      binop: 7
    }),
    _instanceof: U0("instanceof", {
      beforeExpr: z0,
      binop: 7
    }),
    _break: U0("break"),
    _case: U0("case", {
      beforeExpr: z0
    }),
    _catch: U0("catch"),
    _continue: U0("continue"),
    _debugger: U0("debugger"),
    _default: U0("default", {
      beforeExpr: z0
    }),
    _else: U0("else", {
      beforeExpr: z0
    }),
    _finally: U0("finally"),
    _function: U0("function", {
      startsExpr: k
    }),
    _if: U0("if"),
    _return: U0("return", {
      beforeExpr: z0
    }),
    _switch: U0("switch"),
    _throw: U0("throw", {
      beforeExpr: z0,
      prefix: m1,
      startsExpr: k
    }),
    _try: U0("try"),
    _var: U0("var"),
    _const: U0("const"),
    _with: U0("with"),
    _new: U0("new", {
      beforeExpr: z0,
      startsExpr: k
    }),
    _this: U0("this", {
      startsExpr: k
    }),
    _super: U0("super", {
      startsExpr: k
    }),
    _class: U0("class", {
      startsExpr: k
    }),
    _extends: U0("extends", {
      beforeExpr: z0
    }),
    _export: U0("export"),
    _import: U0("import", {
      startsExpr: k
    }),
    _null: U0("null", {
      startsExpr: k
    }),
    _true: U0("true", {
      startsExpr: k
    }),
    _false: U0("false", {
      startsExpr: k
    }),
    _typeof: U0("typeof", {
      beforeExpr: z0,
      prefix: m1,
      startsExpr: k
    }),
    _void: U0("void", {
      beforeExpr: z0,
      prefix: m1,
      startsExpr: k
    }),
    _delete: U0("delete", {
      beforeExpr: z0,
      prefix: m1,
      startsExpr: k
    }),
    _do: U0("do", {
      isLoop: q6,
      beforeExpr: z0
    }),
    _for: U0("for", {
      isLoop: q6
    }),
    _while: U0("while", {
      isLoop: q6
    }),
    _as: X0("as", {
      startsExpr: k
    }),
    _assert: X0("assert", {
      startsExpr: k
    }),
    _async: X0("async", {
      startsExpr: k
    }),
    _await: X0("await", {
      startsExpr: k
    }),
    _defer: X0("defer", {
      startsExpr: k
    }),
    _from: X0("from", {
      startsExpr: k
    }),
    _get: X0("get", {
      startsExpr: k
    }),
    _let: X0("let", {
      startsExpr: k
    }),
    _meta: X0("meta", {
      startsExpr: k
    }),
    _of: X0("of", {
      startsExpr: k
    }),
    _sent: X0("sent", {
      startsExpr: k
    }),
    _set: X0("set", {
      startsExpr: k
    }),
    _source: X0("source", {
      startsExpr: k
    }),
    _static: X0("static", {
      startsExpr: k
    }),
    _using: X0("using", {
      startsExpr: k
    }),
    _yield: X0("yield", {
      startsExpr: k
    }),
    _asserts: X0("asserts", {
      startsExpr: k
    }),
    _checks: X0("checks", {
      startsExpr: k
    }),
    _exports: X0("exports", {
      startsExpr: k
    }),
    _global: X0("global", {
      startsExpr: k
    }),
    _implements: X0("implements", {
      startsExpr: k
    }),
    _intrinsic: X0("intrinsic", {
      startsExpr: k
    }),
    _infer: X0("infer", {
      startsExpr: k
    }),
    _is: X0("is", {
      startsExpr: k
    }),
    _mixins: X0("mixins", {
      startsExpr: k
    }),
    _proto: X0("proto", {
      startsExpr: k
    }),
    _require: X0("require", {
      startsExpr: k
    }),
    _satisfies: X0("satisfies", {
      startsExpr: k
    }),
    _keyof: X0("keyof", {
      startsExpr: k
    }),
    _readonly: X0("readonly", {
      startsExpr: k
    }),
    _unique: X0("unique", {
      startsExpr: k
    }),
    _abstract: X0("abstract", {
      startsExpr: k
    }),
    _declare: X0("declare", {
      startsExpr: k
    }),
    _enum: X0("enum", {
      startsExpr: k
    }),
    _module: X0("module", {
      startsExpr: k
    }),
    _namespace: X0("namespace", {
      startsExpr: k
    }),
    _interface: X0("interface", {
      startsExpr: k
    }),
    _type: X0("type", {
      startsExpr: k
    }),
    _opaque: X0("opaque", {
      startsExpr: k
    }),
    name: c("name", {
      startsExpr: k
    }),
    string: c("string", {
      startsExpr: k
    }),
    num: c("num", {
      startsExpr: k
    }),
    bigint: c("bigint", {
      startsExpr: k
    }),
    decimal: c("decimal", {
      startsExpr: k
    }),
    regexp: c("regexp", {
      startsExpr: k
    }),
    privateName: c("#name", {
      startsExpr: k
    }),
    eof: c("eof"),
    jsxName: c("jsxName"),
    jsxText: c("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: c("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: c("jsxTagEnd"),
    placeholder: c("%%", {
      startsExpr: !0
    })
  };
  P1[8].updateContext = (Z) => {
    Z.pop();
  }, P1[5].updateContext = P1[7].updateContext = P1[23].updateContext = (Z) => {
    Z.push(j0.brace);
  }, P1[22].updateContext = (Z) => {
    if (Z[Z.length - 1] === j0.template)
      Z.pop();
    else
      Z.push(j0.template);
  }, P1[142].updateContext = (Z) => {
    Z.push(j0.j_expr, j0.j_oTag);
  };
  var h6 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", vz = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", UK = new RegExp("[" + h6 + "]"), VK = new RegExp("[" + h6 + vz + "]");
  h6 = vz = null;
  var bz = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], KK = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], _6 = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, MK = new Set(_6.keyword), FK = new Set(_6.strict), RK = new Set(_6.strictBind), BK = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);

  class G7 {
    constructor(Z) {
      this.flags = 0, this.names = new Map, this.firstLexicalName = "", this.flags = Z;
    }
  }

  class U7 {
    constructor(Z, Q) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = new Map, this.parser = Z, this.inModule = Q;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const Z = this.currentThisScopeFlags();
      return (Z & 64) > 0 && (Z & 2) === 0;
    }
    get inStaticBlock() {
      for (let Z = this.scopeStack.length - 1;; Z--) {
        const {
          flags: Q
        } = this.scopeStack[Z];
        if (Q & 128)
          return !0;
        if (Q & (387 | 64))
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(Z) {
      return new G7(Z);
    }
    enter(Z) {
      this.scopeStack.push(this.createScope(Z));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(Z) {
      return !!(Z.flags & (2 | 128) || !this.parser.inModule && Z.flags & 1);
    }
    declareName(Z, Q, J) {
      let X = this.currentScope();
      if (Q & 8 || Q & 16) {
        this.checkRedeclarationInScope(X, Z, Q, J);
        let z = X.names.get(Z) || 0;
        if (Q & 16)
          z = z | 4;
        else {
          if (!X.firstLexicalName)
            X.firstLexicalName = Z;
          z = z | 2;
        }
        if (X.names.set(Z, z), Q & 8)
          this.maybeExportDefined(X, Z);
      } else if (Q & 4) {
        for (let z = this.scopeStack.length - 1;z >= 0; --z)
          if (X = this.scopeStack[z], this.checkRedeclarationInScope(X, Z, Q, J), X.names.set(Z, (X.names.get(Z) || 0) | 1), this.maybeExportDefined(X, Z), X.flags & 387)
            break;
      }
      if (this.parser.inModule && X.flags & 1)
        this.undefinedExports.delete(Z);
    }
    maybeExportDefined(Z, Q) {
      if (this.parser.inModule && Z.flags & 1)
        this.undefinedExports.delete(Q);
    }
    checkRedeclarationInScope(Z, Q, J, X) {
      if (this.isRedeclaredInScope(Z, Q, J))
        this.parser.raise(C.VarRedeclaration, X, {
          identifierName: Q
        });
    }
    isRedeclaredInScope(Z, Q, J) {
      if (!(J & 1))
        return !1;
      if (J & 8)
        return Z.names.has(Q);
      const X = Z.names.get(Q);
      if (J & 16)
        return (X & 2) > 0 || !this.treatFunctionsAsVarInScope(Z) && (X & 1) > 0;
      return (X & 2) > 0 && !(Z.flags & 8 && Z.firstLexicalName === Q) || !this.treatFunctionsAsVarInScope(Z) && (X & 4) > 0;
    }
    checkLocalExport(Z) {
      const {
        name: Q
      } = Z;
      if (!this.scopeStack[0].names.has(Q))
        this.undefinedExports.set(Q, Z.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let Z = this.scopeStack.length - 1;; Z--) {
        const {
          flags: Q
        } = this.scopeStack[Z];
        if (Q & 387)
          return Q;
      }
    }
    currentThisScopeFlags() {
      for (let Z = this.scopeStack.length - 1;; Z--) {
        const {
          flags: Q
        } = this.scopeStack[Z];
        if (Q & (387 | 64) && !(Q & 4))
          return Q;
      }
    }
  }

  class kz extends G7 {
    constructor(...Z) {
      super(...Z);
      this.declareFunctions = new Set;
    }
  }

  class fz extends U7 {
    createScope(Z) {
      return new kz(Z);
    }
    declareName(Z, Q, J) {
      const X = this.currentScope();
      if (Q & 2048) {
        this.checkRedeclarationInScope(X, Z, Q, J), this.maybeExportDefined(X, Z), X.declareFunctions.add(Z);
        return;
      }
      super.declareName(Z, Q, J);
    }
    isRedeclaredInScope(Z, Q, J) {
      if (super.isRedeclaredInScope(Z, Q, J))
        return !0;
      if (J & 2048 && !Z.declareFunctions.has(Q)) {
        const X = Z.names.get(Q);
        return (X & 4) > 0 || (X & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(Z) {
      if (!this.scopeStack[0].declareFunctions.has(Z.name))
        super.checkLocalExport(Z);
    }
  }

  class yz {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(Z) {
      if (typeof Z === "string")
        return this.plugins.has(Z);
      else {
        const [Q, J] = Z;
        if (!this.hasPlugin(Q))
          return !1;
        const X = this.plugins.get(Q);
        for (let z of Object.keys(J))
          if ((X == null ? void 0 : X[z]) !== J[z])
            return !1;
        return !0;
      }
    }
    getPluginOption(Z, Q) {
      var J;
      return (J = this.plugins.get(Z)) == null ? void 0 : J[Q];
    }
  }

  class uz extends yz {
    addComment(Z) {
      if (this.filename)
        Z.loc.filename = this.filename;
      const {
        commentsLen: Q
      } = this.state;
      if (this.comments.length != Q)
        this.comments.length = Q;
      this.comments.push(Z), this.state.commentsLen++;
    }
    processComment(Z) {
      const {
        commentStack: Q
      } = this.state, J = Q.length;
      if (J === 0)
        return;
      let X = J - 1;
      const z = Q[X];
      if (z.start === Z.end)
        z.leadingNode = Z, X--;
      const {
        start: Y
      } = Z;
      for (;X >= 0; X--) {
        const W = Q[X], U = W.end;
        if (U > Y)
          W.containingNode = Z, this.finalizeComment(W), Q.splice(X, 1);
        else {
          if (U === Y)
            W.trailingNode = Z;
          break;
        }
      }
    }
    finalizeComment(Z) {
      const {
        comments: Q
      } = Z;
      if (Z.leadingNode !== null || Z.trailingNode !== null) {
        if (Z.leadingNode !== null)
          mz(Z.leadingNode, Q);
        if (Z.trailingNode !== null)
          $K(Z.trailingNode, Q);
      } else {
        const {
          containingNode: J,
          start: X
        } = Z;
        if (this.input.charCodeAt(X - 1) === 44)
          switch (J.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Z8(J, J.properties, Z);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Z8(J, J.arguments, Z);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Z8(J, J.params, Z);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Z8(J, J.elements, Z);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Z8(J, J.specifiers, Z);
              break;
            default:
              W8(J, Q);
          }
        else
          W8(J, Q);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack: Z
      } = this.state;
      for (let Q = Z.length - 1;Q >= 0; Q--)
        this.finalizeComment(Z[Q]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(Z) {
      const {
        commentStack: Q
      } = this.state, {
        length: J
      } = Q;
      if (J === 0)
        return;
      const X = Q[J - 1];
      if (X.leadingNode === Z)
        X.leadingNode = null;
    }
    resetPreviousIdentifierLeadingComments(Z) {
      const {
        commentStack: Q
      } = this.state, {
        length: J
      } = Q;
      if (J === 0)
        return;
      if (Q[J - 1].trailingNode === Z)
        Q[J - 1].trailingNode = null;
      else if (J >= 2 && Q[J - 2].trailingNode === Z)
        Q[J - 2].trailingNode = null;
    }
    takeSurroundingComments(Z, Q, J) {
      const {
        commentStack: X
      } = this.state, z = X.length;
      if (z === 0)
        return;
      let Y = z - 1;
      for (;Y >= 0; Y--) {
        const W = X[Y], U = W.end;
        if (W.start === J)
          W.leadingNode = Z;
        else if (U === Q)
          W.trailingNode = Z;
        else if (U < Q)
          break;
      }
    }
  }
  var xz = /\r\n?|[\n\u2028\u2029]/, Q7 = new RegExp(xz.source, "g"), $6 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, H7 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Bz = new RegExp("(?=(" + H7.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");

  class k6 {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [j0.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = new Map, this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(Z) {
      if (Z)
        this.flags |= 1;
      else
        this.flags &= ~1;
    }
    init({
      strictMode: Z,
      sourceType: Q,
      startLine: J,
      startColumn: X
    }) {
      this.strict = Z === !1 ? !1 : Z === !0 ? !0 : Q === "module", this.curLine = J, this.lineStart = -X, this.startLoc = this.endLoc = new T1(J, X, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(Z) {
      if (Z)
        this.flags |= 2;
      else
        this.flags &= ~2;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(Z) {
      if (Z)
        this.flags |= 4;
      else
        this.flags &= ~4;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(Z) {
      if (Z)
        this.flags |= 8;
      else
        this.flags &= ~8;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(Z) {
      if (Z)
        this.flags |= 16;
      else
        this.flags &= ~16;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(Z) {
      if (Z)
        this.flags |= 32;
      else
        this.flags &= ~32;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(Z) {
      if (Z)
        this.flags |= 64;
      else
        this.flags &= ~64;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(Z) {
      if (Z)
        this.flags |= 128;
      else
        this.flags &= ~128;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(Z) {
      if (Z)
        this.flags |= 256;
      else
        this.flags &= ~256;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(Z) {
      if (Z)
        this.flags |= 512;
      else
        this.flags &= ~512;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(Z) {
      if (Z)
        this.flags |= 1024;
      else
        this.flags &= ~1024;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(Z) {
      if (Z)
        this.flags |= 2048;
      else
        this.flags &= ~2048;
    }
    curPosition() {
      return new T1(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      const Z = new k6;
      return Z.flags = this.flags, Z.curLine = this.curLine, Z.lineStart = this.lineStart, Z.startLoc = this.startLoc, Z.endLoc = this.endLoc, Z.errors = this.errors.slice(), Z.potentialArrowAt = this.potentialArrowAt, Z.noArrowAt = this.noArrowAt.slice(), Z.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), Z.topicContext = this.topicContext, Z.labels = this.labels.slice(), Z.commentsLen = this.commentsLen, Z.commentStack = this.commentStack.slice(), Z.pos = this.pos, Z.type = this.type, Z.value = this.value, Z.start = this.start, Z.end = this.end, Z.lastTokEndLoc = this.lastTokEndLoc, Z.lastTokStartLoc = this.lastTokStartLoc, Z.context = this.context.slice(), Z.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, Z.strictErrors = this.strictErrors, Z.tokensLength = this.tokensLength, Z;
    }
  }
  var IK = function Z(Q) {
    return Q >= 48 && Q <= 57;
  }, qz = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  }, J7 = {
    bin: (Z) => Z === 48 || Z === 49,
    oct: (Z) => Z >= 48 && Z <= 55,
    dec: (Z) => Z >= 48 && Z <= 57,
    hex: (Z) => Z >= 48 && Z <= 57 || Z >= 65 && Z <= 70 || Z >= 97 && Z <= 102
  }, LK = new Set([103, 109, 115, 105, 121, 117, 100, 118]);

  class N1 {
    constructor(Z) {
      this.type = Z.type, this.value = Z.value, this.start = Z.start, this.end = Z.end, this.loc = new Y8(Z.startLoc, Z.endLoc);
    }
  }

  class iz extends uz {
    constructor(Z, Q) {
      super();
      this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: (J, X, z, Y) => {
          if (!this.options.errorRecovery)
            return !1;
          return this.raise(C.InvalidDigit, Q8(J, X, z), {
            radix: Y
          }), !0;
        },
        numericSeparatorInEscapeSequence: this.errorBuilder(C.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(C.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(C.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(C.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (J, X, z) => {
          this.recordStrictModeErrors(C.StrictNumericEscape, Q8(J, X, z));
        },
        unterminated: (J, X, z) => {
          throw this.raise(C.UnterminatedString, Q8(J - 1, X, z));
        }
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(C.StrictNumericEscape),
        unterminated: (J, X, z) => {
          throw this.raise(C.UnterminatedTemplate, Q8(J, X, z));
        }
      }), this.state = new k6, this.state.init(Z), this.input = Q, this.length = Q.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(Z) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(Z), ++this.state.tokensLength;
    }
    next() {
      if (this.checkKeywordEscapes(), this.options.tokens)
        this.pushToken(new N1(this.state));
      this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(Z) {
      if (this.match(Z))
        return this.next(), !0;
      else
        return !1;
    }
    match(Z) {
      return this.state.type === Z;
    }
    createLookaheadState(Z) {
      return {
        pos: Z.pos,
        value: null,
        type: Z.type,
        start: Z.start,
        end: Z.end,
        context: [this.curContext()],
        inType: Z.inType,
        startLoc: Z.startLoc,
        lastTokEndLoc: Z.lastTokEndLoc,
        curLine: Z.curLine,
        lineStart: Z.lineStart,
        curPosition: Z.curPosition
      };
    }
    lookahead() {
      const Z = this.state;
      this.state = this.createLookaheadState(Z), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      const Q = this.state;
      return this.state = Z, Q;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(Z) {
      return $6.lastIndex = Z, $6.test(this.input) ? $6.lastIndex : Z;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(Z) {
      return H7.lastIndex = Z, H7.test(this.input) ? H7.lastIndex : Z;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(Z) {
      let Q = this.input.charCodeAt(Z);
      if ((Q & 64512) === 55296 && ++Z < this.input.length) {
        const J = this.input.charCodeAt(Z);
        if ((J & 64512) === 56320)
          Q = 65536 + ((Q & 1023) << 10) + (J & 1023);
      }
      return Q;
    }
    setStrict(Z) {
      if (this.state.strict = Z, Z)
        this.state.strictErrors.forEach(([Q, J]) => this.raise(Q, J)), this.state.strictErrors.clear();
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, !this.isLookahead)
        this.state.startLoc = this.state.curPosition();
      if (this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(Z) {
      let Q;
      if (!this.isLookahead)
        Q = this.state.curPosition();
      const J = this.state.pos, X = this.input.indexOf(Z, J + 2);
      if (X === -1)
        throw this.raise(C.UnterminatedComment, this.state.curPosition());
      this.state.pos = X + Z.length, Q7.lastIndex = J + 2;
      while (Q7.test(this.input) && Q7.lastIndex <= X)
        ++this.state.curLine, this.state.lineStart = Q7.lastIndex;
      if (this.isLookahead)
        return;
      const z = {
        type: "CommentBlock",
        value: this.input.slice(J + 2, X),
        start: J,
        end: X + Z.length,
        loc: new Y8(Q, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(z);
      return z;
    }
    skipLineComment(Z) {
      const Q = this.state.pos;
      let J;
      if (!this.isLookahead)
        J = this.state.curPosition();
      let X = this.input.charCodeAt(this.state.pos += Z);
      if (this.state.pos < this.length)
        while (!z8(X) && ++this.state.pos < this.length)
          X = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      const z = this.state.pos, W = {
        type: "CommentLine",
        value: this.input.slice(Q + Z, z),
        start: Q,
        end: z,
        loc: new Y8(J, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(W);
      return W;
    }
    skipSpace() {
      const Z = this.state.pos, Q = [];
      Z:
        while (this.state.pos < this.length) {
          const J = this.input.charCodeAt(this.state.pos);
          switch (J) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10)
                ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const X = this.skipBlockComment("*/");
                  if (X !== void 0) {
                    if (this.addComment(X), this.options.attachComment)
                      Q.push(X);
                  }
                  break;
                }
                case 47: {
                  const X = this.skipLineComment(2);
                  if (X !== void 0) {
                    if (this.addComment(X), this.options.attachComment)
                      Q.push(X);
                  }
                  break;
                }
                default:
                  break Z;
              }
              break;
            default:
              if (DK(J))
                ++this.state.pos;
              else if (J === 45 && !this.inModule && this.options.annexB) {
                const X = this.state.pos;
                if (this.input.charCodeAt(X + 1) === 45 && this.input.charCodeAt(X + 2) === 62 && (Z === 0 || this.state.lineStart > Z)) {
                  const z = this.skipLineComment(3);
                  if (z !== void 0) {
                    if (this.addComment(z), this.options.attachComment)
                      Q.push(z);
                  }
                } else
                  break Z;
              } else if (J === 60 && !this.inModule && this.options.annexB) {
                const X = this.state.pos;
                if (this.input.charCodeAt(X + 1) === 33 && this.input.charCodeAt(X + 2) === 45 && this.input.charCodeAt(X + 3) === 45) {
                  const z = this.skipLineComment(4);
                  if (z !== void 0) {
                    if (this.addComment(z), this.options.attachComment)
                      Q.push(z);
                  }
                } else
                  break Z;
              } else
                break Z;
          }
        }
      if (Q.length > 0) {
        const J = this.state.pos, X = {
          start: Z,
          end: J,
          comments: Q,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(X);
      }
    }
    finishToken(Z, Q) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const J = this.state.type;
      if (this.state.type = Z, this.state.value = Q, !this.isLookahead)
        this.updateContext(J);
    }
    replaceToken(Z) {
      this.state.type = Z, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const Z = this.state.pos + 1, Q = this.codePointAtPos(Z);
      if (Q >= 48 && Q <= 57)
        throw this.raise(C.UnexpectedDigitAfterHash, this.state.curPosition());
      if (Q === 123 || Q === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(Q === 123 ? C.RecordExpressionHashIncorrectStartSyntaxType : C.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        if (this.state.pos += 2, Q === 123)
          this.finishToken(7);
        else
          this.finishToken(1);
      } else if (S1(Q))
        ++this.state.pos, this.finishToken(138, this.readWord1(Q));
      else if (Q === 92)
        ++this.state.pos, this.finishToken(138, this.readWord1());
      else
        this.finishOp(27, 1);
    }
    readToken_dot() {
      const Z = this.input.charCodeAt(this.state.pos + 1);
      if (Z >= 48 && Z <= 57) {
        this.readNumber(!0);
        return;
      }
      if (Z === 46 && this.input.charCodeAt(this.state.pos + 2) === 46)
        this.state.pos += 3, this.finishToken(21);
      else
        ++this.state.pos, this.finishToken(16);
    }
    readToken_slash() {
      if (this.input.charCodeAt(this.state.pos + 1) === 61)
        this.finishOp(31, 2);
      else
        this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return !1;
      let Z = this.input.charCodeAt(this.state.pos + 1);
      if (Z !== 33)
        return !1;
      const Q = this.state.pos;
      this.state.pos += 1;
      while (!z8(Z) && ++this.state.pos < this.length)
        Z = this.input.charCodeAt(this.state.pos);
      const J = this.input.slice(Q + 2, this.state.pos);
      return this.finishToken(28, J), !0;
    }
    readToken_mult_modulo(Z) {
      let Q = Z === 42 ? 55 : 54, J = 1, X = this.input.charCodeAt(this.state.pos + 1);
      if (Z === 42 && X === 42)
        J++, X = this.input.charCodeAt(this.state.pos + 2), Q = 57;
      if (X === 61 && !this.state.inType)
        J++, Q = Z === 37 ? 33 : 30;
      this.finishOp(Q, J);
    }
    readToken_pipe_amp(Z) {
      const Q = this.input.charCodeAt(this.state.pos + 1);
      if (Q === Z) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61)
          this.finishOp(30, 3);
        else
          this.finishOp(Z === 124 ? 41 : 42, 2);
        return;
      }
      if (Z === 124) {
        if (Q === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && Q === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(C.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && Q === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(C.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (Q === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(Z === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const Z = this.input.charCodeAt(this.state.pos + 1);
      if (Z === 61 && !this.state.inType)
        this.finishOp(32, 2);
      else if (Z === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
          this.unexpected();
      } else
        this.finishOp(44, 1);
    }
    readToken_atSign() {
      if (this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]))
        this.finishOp(38, 2);
      else
        this.finishOp(26, 1);
    }
    readToken_plus_min(Z) {
      const Q = this.input.charCodeAt(this.state.pos + 1);
      if (Q === Z) {
        this.finishOp(34, 2);
        return;
      }
      if (Q === 61)
        this.finishOp(30, 2);
      else
        this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: Z
      } = this.state, Q = this.input.charCodeAt(Z + 1);
      if (Q === 60) {
        if (this.input.charCodeAt(Z + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (Q === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: Z
      } = this.state, Q = this.input.charCodeAt(Z + 1);
      if (Q === 62) {
        const J = this.input.charCodeAt(Z + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(Z + J) === 61) {
          this.finishOp(30, J + 1);
          return;
        }
        this.finishOp(52, J);
        return;
      }
      if (Q === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(Z) {
      const Q = this.input.charCodeAt(this.state.pos + 1);
      if (Q === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (Z === 61 && Q === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(Z === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const Z = this.input.charCodeAt(this.state.pos + 1), Q = this.input.charCodeAt(this.state.pos + 2);
      if (Z === 63)
        if (Q === 61)
          this.finishOp(30, 3);
        else
          this.finishOp(40, 2);
      else if (Z === 46 && !(Q >= 48 && Q <= 57))
        this.state.pos += 2, this.finishToken(18);
      else
        ++this.state.pos, this.finishToken(17);
    }
    getTokenFromCode(Z) {
      switch (Z) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(C.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(C.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58)
            this.finishOp(15, 2);
          else
            ++this.state.pos, this.finishToken(14);
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const Q = this.input.charCodeAt(this.state.pos + 1);
          if (Q === 120 || Q === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (Q === 111 || Q === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (Q === 98 || Q === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(Z);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(Z);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(Z);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(Z);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(Z);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (S1(Z)) {
            this.readWord(Z);
            return;
          }
      }
      throw this.raise(C.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(Z)
      });
    }
    finishOp(Z, Q) {
      const J = this.input.slice(this.state.pos, this.state.pos + Q);
      this.state.pos += Q, this.finishToken(Z, J);
    }
    readRegexp() {
      const Z = this.state.startLoc, Q = this.state.start + 1;
      let J, X, {
        pos: z
      } = this.state;
      for (;; ++z) {
        if (z >= this.length)
          throw this.raise(C.UnterminatedRegExp, d0(Z, 1));
        const V = this.input.charCodeAt(z);
        if (z8(V))
          throw this.raise(C.UnterminatedRegExp, d0(Z, 1));
        if (J)
          J = !1;
        else {
          if (V === 91)
            X = !0;
          else if (V === 93 && X)
            X = !1;
          else if (V === 47 && !X)
            break;
          J = V === 92;
        }
      }
      const Y = this.input.slice(Q, z);
      ++z;
      let W = "";
      const U = () => d0(Z, z + 2 - Q);
      while (z < this.length) {
        const V = this.codePointAtPos(z), M = String.fromCharCode(V);
        if (LK.has(V)) {
          if (V === 118) {
            if (W.includes("u"))
              this.raise(C.IncompatibleRegExpUVFlags, U());
          } else if (V === 117) {
            if (W.includes("v"))
              this.raise(C.IncompatibleRegExpUVFlags, U());
          }
          if (W.includes(M))
            this.raise(C.DuplicateRegExpFlags, U());
        } else if (E5(V) || V === 92)
          this.raise(C.MalformedRegExpFlags, U());
        else
          break;
        ++z, W += M;
      }
      this.state.pos = z, this.finishToken(137, {
        pattern: Y,
        flags: W
      });
    }
    readInt(Z, Q, J = !1, X = !0) {
      const {
        n: z,
        pos: Y
      } = cz(this.input, this.state.pos, this.state.lineStart, this.state.curLine, Z, Q, J, X, this.errorHandlers_readInt, !1);
      return this.state.pos = Y, z;
    }
    readRadixNumber(Z) {
      const Q = this.state.curPosition();
      let J = !1;
      this.state.pos += 2;
      const X = this.readInt(Z);
      if (X == null)
        this.raise(C.InvalidDigit, d0(Q, 2), {
          radix: Z
        });
      const z = this.input.charCodeAt(this.state.pos);
      if (z === 110)
        ++this.state.pos, J = !0;
      else if (z === 109)
        throw this.raise(C.InvalidDecimal, Q);
      if (S1(this.codePointAtPos(this.state.pos)))
        throw this.raise(C.NumberIdentifier, this.state.curPosition());
      if (J) {
        const Y = this.input.slice(Q.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, Y);
        return;
      }
      this.finishToken(134, X);
    }
    readNumber(Z) {
      const Q = this.state.pos, J = this.state.curPosition();
      let X = !1, z = !1, Y = !1, W = !1, U = !1;
      if (!Z && this.readInt(10) === null)
        this.raise(C.InvalidNumber, this.state.curPosition());
      const V = this.state.pos - Q >= 2 && this.input.charCodeAt(Q) === 48;
      if (V) {
        const N = this.input.slice(Q, this.state.pos);
        if (this.recordStrictModeErrors(C.StrictOctalLiteral, J), !this.state.strict) {
          const T = N.indexOf("_");
          if (T > 0)
            this.raise(C.ZeroDigitNumericSeparator, d0(J, T));
        }
        U = V && !/[89]/.test(N);
      }
      let M = this.input.charCodeAt(this.state.pos);
      if (M === 46 && !U)
        ++this.state.pos, this.readInt(10), X = !0, M = this.input.charCodeAt(this.state.pos);
      if ((M === 69 || M === 101) && !U) {
        if (M = this.input.charCodeAt(++this.state.pos), M === 43 || M === 45)
          ++this.state.pos;
        if (this.readInt(10) === null)
          this.raise(C.InvalidOrMissingExponent, J);
        X = !0, W = !0, M = this.input.charCodeAt(this.state.pos);
      }
      if (M === 110) {
        if (X || V)
          this.raise(C.InvalidBigIntLiteral, J);
        ++this.state.pos, z = !0;
      }
      if (M === 109) {
        if (this.expectPlugin("decimal", this.state.curPosition()), W || V)
          this.raise(C.InvalidDecimal, J);
        ++this.state.pos, Y = !0;
      }
      if (S1(this.codePointAtPos(this.state.pos)))
        throw this.raise(C.NumberIdentifier, this.state.curPosition());
      const q = this.input.slice(Q, this.state.pos).replace(/[_mn]/g, "");
      if (z) {
        this.finishToken(135, q);
        return;
      }
      if (Y) {
        this.finishToken(136, q);
        return;
      }
      const L = U ? parseInt(q, 8) : parseFloat(q);
      this.finishToken(134, L);
    }
    readCodePoint(Z) {
      const {
        code: Q,
        pos: J
      } = lz(this.input, this.state.pos, this.state.lineStart, this.state.curLine, Z, this.errorHandlers_readCodePoint);
      return this.state.pos = J, Q;
    }
    readString(Z) {
      const {
        str: Q,
        pos: J,
        curLine: X,
        lineStart: z
      } = $z(Z === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = J + 1, this.state.lineStart = z, this.state.curLine = X, this.finishToken(133, Q);
    }
    readTemplateContinuation() {
      if (!this.match(8))
        this.unexpected(null, 8);
      this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const Z = this.input[this.state.pos], {
        str: Q,
        firstInvalidLoc: J,
        pos: X,
        curLine: z,
        lineStart: Y
      } = $z("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      if (this.state.pos = X + 1, this.state.lineStart = Y, this.state.curLine = z, J)
        this.state.firstInvalidTemplateEscapePos = new T1(J.curLine, J.pos - J.lineStart, J.pos);
      if (this.input.codePointAt(X) === 96)
        this.finishToken(24, J ? null : Z + Q + "`");
      else
        this.state.pos++, this.finishToken(25, J ? null : Z + Q + "${");
    }
    recordStrictModeErrors(Z, Q) {
      const J = Q.index;
      if (this.state.strict && !this.state.strictErrors.has(J))
        this.raise(Z, Q);
      else
        this.state.strictErrors.set(J, [Z, Q]);
    }
    readWord1(Z) {
      this.state.containsEsc = !1;
      let Q = "";
      const J = this.state.pos;
      let X = this.state.pos;
      if (Z !== void 0)
        this.state.pos += Z <= 65535 ? 1 : 2;
      while (this.state.pos < this.length) {
        const z = this.codePointAtPos(this.state.pos);
        if (E5(z))
          this.state.pos += z <= 65535 ? 1 : 2;
        else if (z === 92) {
          this.state.containsEsc = !0, Q += this.input.slice(X, this.state.pos);
          const Y = this.state.curPosition(), W = this.state.pos === J ? S1 : E5;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(C.MissingUnicodeEscape, this.state.curPosition()), X = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const U = this.readCodePoint(!0);
          if (U !== null) {
            if (!W(U))
              this.raise(C.EscapedCharNotAnIdentifier, Y);
            Q += String.fromCodePoint(U);
          }
          X = this.state.pos;
        } else
          break;
      }
      return Q + this.input.slice(X, this.state.pos);
    }
    readWord(Z) {
      const Q = this.readWord1(Z), J = S6.get(Q);
      if (J !== void 0)
        this.finishToken(J, c1(J));
      else
        this.finishToken(132, Q);
    }
    checkKeywordEscapes() {
      const {
        type: Z
      } = this.state;
      if (g6(Z) && this.state.containsEsc)
        this.raise(C.InvalidEscapedReservedWord, this.state.startLoc, {
          reservedWord: c1(Z)
        });
    }
    raise(Z, Q, J = {}) {
      const X = Q instanceof T1 ? Q : Q.loc.start, z = Z(X, J);
      if (!this.options.errorRecovery)
        throw z;
      if (!this.isLookahead)
        this.state.errors.push(z);
      return z;
    }
    raiseOverwrite(Z, Q, J = {}) {
      const X = Q instanceof T1 ? Q : Q.loc.start, z = X.index, Y = this.state.errors;
      for (let W = Y.length - 1;W >= 0; W--) {
        const U = Y[W];
        if (U.loc.index === z)
          return Y[W] = Z(X, J);
        if (U.loc.index < z)
          break;
      }
      return this.raise(Z, Q, J);
    }
    updateContext(Z) {
    }
    unexpected(Z, Q) {
      throw this.raise(C.UnexpectedToken, Z != null ? Z : this.state.startLoc, {
        expected: Q ? c1(Q) : null
      });
    }
    expectPlugin(Z, Q) {
      if (this.hasPlugin(Z))
        return !0;
      throw this.raise(C.MissingPlugin, Q != null ? Q : this.state.startLoc, {
        missingPlugin: [Z]
      });
    }
    expectOnePlugin(Z) {
      if (!Z.some((Q) => this.hasPlugin(Q)))
        throw this.raise(C.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: Z
        });
    }
    errorBuilder(Z) {
      return (Q, J, X) => {
        this.raise(Z, Q8(Q, J, X));
      };
    }
  }

  class dz {
    constructor() {
      this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map;
    }
  }

  class pz {
    constructor(Z) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = new Map, this.parser = Z;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new dz);
    }
    exit() {
      const Z = this.stack.pop(), Q = this.current();
      for (let [J, X] of Array.from(Z.undefinedPrivateNames))
        if (Q) {
          if (!Q.undefinedPrivateNames.has(J))
            Q.undefinedPrivateNames.set(J, X);
        } else
          this.parser.raise(C.InvalidPrivateFieldResolution, X, {
            identifierName: J
          });
    }
    declarePrivateName(Z, Q, J) {
      const {
        privateNames: X,
        loneAccessors: z,
        undefinedPrivateNames: Y
      } = this.current();
      let W = X.has(Z);
      if (Q & 3) {
        const U = W && z.get(Z);
        if (U) {
          const V = U & 4, M = Q & 4, q = U & 3, L = Q & 3;
          if (W = q === L || V !== M, !W)
            z.delete(Z);
        } else if (!W)
          z.set(Z, Q);
      }
      if (W)
        this.parser.raise(C.PrivateNameRedeclaration, J, {
          identifierName: Z
        });
      X.add(Z), Y.delete(Z);
    }
    usePrivateName(Z, Q) {
      let J;
      for (J of this.stack)
        if (J.privateNames.has(Z))
          return;
      if (J)
        J.undefinedPrivateNames.set(Z, Q);
      else
        this.parser.raise(C.InvalidPrivateFieldResolution, Q, {
          identifierName: Z
        });
    }
  }

  class U8 {
    constructor(Z = 0) {
      this.type = Z;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }

  class f6 extends U8 {
    constructor(Z) {
      super(Z);
      this.declarationErrors = new Map;
    }
    recordDeclarationError(Z, Q) {
      const J = Q.index;
      this.declarationErrors.set(J, [Z, Q]);
    }
    clearDeclarationError(Z) {
      this.declarationErrors.delete(Z);
    }
    iterateErrors(Z) {
      this.declarationErrors.forEach(Z);
    }
  }

  class az {
    constructor(Z) {
      this.parser = void 0, this.stack = [new U8], this.parser = Z;
    }
    enter(Z) {
      this.stack.push(Z);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(Z, Q) {
      const J = Q.loc.start, {
        stack: X
      } = this;
      let z = X.length - 1, Y = X[z];
      while (!Y.isCertainlyParameterDeclaration()) {
        if (Y.canBeArrowParameterDeclaration())
          Y.recordDeclarationError(Z, J);
        else
          return;
        Y = X[--z];
      }
      this.parser.raise(Z, J);
    }
    recordArrowParameterBindingError(Z, Q) {
      const {
        stack: J
      } = this, X = J[J.length - 1], z = Q.loc.start;
      if (X.isCertainlyParameterDeclaration())
        this.parser.raise(Z, z);
      else if (X.canBeArrowParameterDeclaration())
        X.recordDeclarationError(Z, z);
      else
        return;
    }
    recordAsyncArrowParametersError(Z) {
      const {
        stack: Q
      } = this;
      let J = Q.length - 1, X = Q[J];
      while (X.canBeArrowParameterDeclaration()) {
        if (X.type === 2)
          X.recordDeclarationError(C.AwaitBindingIdentifier, Z);
        X = Q[--J];
      }
    }
    validateAsPattern() {
      const {
        stack: Z
      } = this, Q = Z[Z.length - 1];
      if (!Q.canBeArrowParameterDeclaration())
        return;
      Q.iterateErrors(([J, X]) => {
        this.parser.raise(J, X);
        let z = Z.length - 2, Y = Z[z];
        while (Y.canBeArrowParameterDeclaration())
          Y.clearDeclarationError(X.index), Y = Z[--z];
      });
    }
  }

  class nz {
    constructor() {
      this.stacks = [];
    }
    enter(Z) {
      this.stacks.push(Z);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }

  class sz extends iz {
    addExtra(Z, Q, J, X = !0) {
      if (!Z)
        return;
      const z = Z.extra = Z.extra || {};
      if (X)
        z[Q] = J;
      else
        Object.defineProperty(z, Q, {
          enumerable: X,
          value: J
        });
    }
    isContextual(Z) {
      return this.state.type === Z && !this.state.containsEsc;
    }
    isUnparsedContextual(Z, Q) {
      const J = Z + Q.length;
      if (this.input.slice(Z, J) === Q) {
        const X = this.input.charCodeAt(J);
        return !(E5(X) || (X & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(Z) {
      const Q = this.nextTokenStart();
      return this.isUnparsedContextual(Q, Z);
    }
    eatContextual(Z) {
      if (this.isContextual(Z))
        return this.next(), !0;
      return !1;
    }
    expectContextual(Z, Q) {
      if (!this.eatContextual(Z)) {
        if (Q != null)
          throw this.raise(Q, this.state.startLoc);
        this.unexpected(null, Z);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return xz.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return Bz.lastIndex = this.state.end, Bz.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(Z = !0) {
      if (Z ? this.isLineTerminator() : this.eat(13))
        return;
      this.raise(C.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(Z, Q) {
      this.eat(Z) || this.unexpected(Q, Z);
    }
    tryParse(Z, Q = this.state.clone()) {
      const J = {
        node: null
      };
      try {
        const X = Z((z = null) => {
          throw J.node = z, J;
        });
        if (this.state.errors.length > Q.errors.length) {
          const z = this.state;
          return this.state = Q, this.state.tokensLength = z.tokensLength, {
            node: X,
            error: z.errors[Q.errors.length],
            thrown: !1,
            aborted: !1,
            failState: z
          };
        }
        return {
          node: X,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (X) {
        const z = this.state;
        if (this.state = Q, X instanceof SyntaxError)
          return {
            node: null,
            error: X,
            thrown: !0,
            aborted: !1,
            failState: z
          };
        if (X === J)
          return {
            node: J.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: z
          };
        throw X;
      }
    }
    checkExpressionErrors(Z, Q) {
      if (!Z)
        return !1;
      const {
        shorthandAssignLoc: J,
        doubleProtoLoc: X,
        privateKeyLoc: z,
        optionalParametersLoc: Y
      } = Z, W = !!J || !!X || !!Y || !!z;
      if (!Q)
        return W;
      if (J != null)
        this.raise(C.InvalidCoverInitializedName, J);
      if (X != null)
        this.raise(C.DuplicateProto, X);
      if (z != null)
        this.raise(C.UnexpectedPrivateField, z);
      if (Y != null)
        this.unexpected(Y);
    }
    isLiteralPropertyName() {
      return Tz(this.state.type);
    }
    isPrivateName(Z) {
      return Z.type === "PrivateName";
    }
    getPrivateNameSV(Z) {
      return Z.id.name;
    }
    hasPropertyAsPrivateName(Z) {
      return (Z.type === "MemberExpression" || Z.type === "OptionalMemberExpression") && this.isPrivateName(Z.property);
    }
    isObjectProperty(Z) {
      return Z.type === "ObjectProperty";
    }
    isObjectMethod(Z) {
      return Z.type === "ObjectMethod";
    }
    initializeScopes(Z = this.options.sourceType === "module") {
      const Q = this.state.labels;
      this.state.labels = [];
      const J = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set;
      const X = this.inModule;
      this.inModule = Z;
      const z = this.scope, Y = this.getScopeHandler();
      this.scope = new Y(this, Z);
      const W = this.prodParam;
      this.prodParam = new nz;
      const U = this.classScope;
      this.classScope = new pz(this);
      const V = this.expressionScope;
      return this.expressionScope = new az(this), () => {
        this.state.labels = Q, this.exportedIdentifiers = J, this.inModule = X, this.scope = z, this.prodParam = W, this.classScope = U, this.expressionScope = V;
      };
    }
    enterInitialScopes() {
      let Z = 0;
      if (this.inModule)
        Z |= 2;
      this.scope.enter(1), this.prodParam.enter(Z);
    }
    checkDestructuringPrivate(Z) {
      const {
        privateKeyLoc: Q
      } = Z;
      if (Q !== null)
        this.expectPlugin("destructuringPrivate", Q);
    }
  }

  class H8 {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }

  class G8 {
    constructor(Z, Q, J) {
      if (this.type = "", this.start = Q, this.end = 0, this.loc = new Y8(J), Z != null && Z.options.ranges)
        this.range = [Q, 0];
      if (Z != null && Z.filename)
        this.loc.filename = Z.filename;
    }
  }
  var y6 = G8.prototype;
  y6.__clone = function() {
    const Z = new G8(void 0, this.start, this.loc.start), Q = Object.keys(this);
    for (let J = 0, X = Q.length;J < X; J++) {
      const z = Q[J];
      if (z !== "leadingComments" && z !== "trailingComments" && z !== "innerComments")
        Z[z] = this[z];
    }
    return Z;
  };

  class tz extends sz {
    startNode() {
      const Z = this.state.startLoc;
      return new G8(this, Z.index, Z);
    }
    startNodeAt(Z) {
      return new G8(this, Z.index, Z);
    }
    startNodeAtNode(Z) {
      return this.startNodeAt(Z.loc.start);
    }
    finishNode(Z, Q) {
      return this.finishNodeAt(Z, Q, this.state.lastTokEndLoc);
    }
    finishNodeAt(Z, Q, J) {
      if (Z.type = Q, Z.end = J.index, Z.loc.end = J, this.options.ranges)
        Z.range[1] = J.index;
      if (this.options.attachComment)
        this.processComment(Z);
      return Z;
    }
    resetStartLocation(Z, Q) {
      if (Z.start = Q.index, Z.loc.start = Q, this.options.ranges)
        Z.range[0] = Q.index;
    }
    resetEndLocation(Z, Q = this.state.lastTokEndLoc) {
      if (Z.end = Q.index, Z.loc.end = Q, this.options.ranges)
        Z.range[1] = Q.index;
    }
    resetStartLocationFromNode(Z, Q) {
      this.resetStartLocation(Z, Q.loc.start);
    }
  }
  var vK = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), i = w1`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType: Z
    }) => `Cannot overwrite reserved type ${Z}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName: Z,
      enumName: Q
    }) => `Boolean enum members need to be initialized. Use either \`${Z} = true,\` or \`${Z} = false,\` in enum \`${Q}\`.`,
    EnumDuplicateMemberName: ({
      memberName: Z,
      enumName: Q
    }) => `Enum member names need to be unique, but the name \`${Z}\` has already been used before in enum \`${Q}\`.`,
    EnumInconsistentMemberValues: ({
      enumName: Z
    }) => `Enum \`${Z}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType: Z,
      enumName: Q
    }) => `Enum type \`${Z}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${Q}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName: Z
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${Z}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName: Z,
      memberName: Q,
      explicitType: J
    }) => `Enum \`${Z}\` has type \`${J}\`, so the initializer of \`${Q}\` needs to be a ${J} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName: Z,
      memberName: Q
    }) => `Symbol enum members cannot be initialized. Use \`${Q},\` in enum \`${Z}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName: Z,
      memberName: Q
    }) => `The enum member initializer for \`${Q}\` needs to be a literal (either a boolean, number, or string) in enum \`${Z}\`.`,
    EnumInvalidMemberName: ({
      enumName: Z,
      memberName: Q,
      suggestion: J
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${Q}\`, consider using \`${J}\`, in enum \`${Z}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName: Z,
      memberName: Q
    }) => `Number enum members need to be initialized, e.g. \`${Q} = 1\` in enum \`${Z}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName: Z
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${Z}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType: Z
    }) => `Unexpected reserved type ${Z}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind: Z,
      suggestion: Q
    }) => `\`declare export ${Z}\` is not supported. Use \`${Q}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  }), EK = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  }, hK = /\*?\s*@((?:no)?flow)\b/, _K = (Z) => class Q extends Z {
    constructor(...J) {
      super(...J);
      this.flowPragma = void 0;
    }
    getScopeHandler() {
      return fz;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(J, X) {
      if (J !== 133 && J !== 13 && J !== 28) {
        if (this.flowPragma === void 0)
          this.flowPragma = null;
      }
      super.finishToken(J, X);
    }
    addComment(J) {
      if (this.flowPragma === void 0) {
        const X = hK.exec(J.value);
        if (!X)
          ;
        else if (X[1] === "flow")
          this.flowPragma = "flow";
        else if (X[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(J);
    }
    flowParseTypeInitialiser(J) {
      const X = this.state.inType;
      this.state.inType = !0, this.expect(J || 14);
      const z = this.flowParseType();
      return this.state.inType = X, z;
    }
    flowParsePredicate() {
      const J = this.startNode(), X = this.state.startLoc;
      if (this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > X.index + 1)
        this.raise(i.UnexpectedSpaceBetweenModuloChecks, X);
      if (this.eat(10))
        return J.value = super.parseExpression(), this.expect(11), this.finishNode(J, "DeclaredPredicate");
      else
        return this.finishNode(J, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const J = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let X = null, z = null;
      if (this.match(54))
        this.state.inType = J, z = this.flowParsePredicate();
      else if (X = this.flowParseType(), this.state.inType = J, this.match(54))
        z = this.flowParsePredicate();
      return [X, z];
    }
    flowParseDeclareClass(J) {
      return this.next(), this.flowParseInterfaceish(J, !0), this.finishNode(J, "DeclareClass");
    }
    flowParseDeclareFunction(J) {
      this.next();
      const X = J.id = this.parseIdentifier(), z = this.startNode(), Y = this.startNode();
      if (this.match(47))
        z.typeParameters = this.flowParseTypeParameterDeclaration();
      else
        z.typeParameters = null;
      this.expect(10);
      const W = this.flowParseFunctionTypeParams();
      return z.params = W.params, z.rest = W.rest, z.this = W._this, this.expect(11), [z.returnType, J.predicate] = this.flowParseTypeAndPredicateInitialiser(), Y.typeAnnotation = this.finishNode(z, "FunctionTypeAnnotation"), X.typeAnnotation = this.finishNode(Y, "TypeAnnotation"), this.resetEndLocation(X), this.semicolon(), this.scope.declareName(J.id.name, 2048, J.id.loc.start), this.finishNode(J, "DeclareFunction");
    }
    flowParseDeclare(J, X) {
      if (this.match(80))
        return this.flowParseDeclareClass(J);
      else if (this.match(68))
        return this.flowParseDeclareFunction(J);
      else if (this.match(74))
        return this.flowParseDeclareVariable(J);
      else if (this.eatContextual(127))
        if (this.match(16))
          return this.flowParseDeclareModuleExports(J);
        else {
          if (X)
            this.raise(i.NestedDeclareModule, this.state.lastTokStartLoc);
          return this.flowParseDeclareModule(J);
        }
      else if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(J);
      else if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(J);
      else if (this.isContextual(129))
        return this.flowParseDeclareInterface(J);
      else if (this.match(82))
        return this.flowParseDeclareExportDeclaration(J, X);
      else
        this.unexpected();
    }
    flowParseDeclareVariable(J) {
      return this.next(), J.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(J.id.name, 5, J.id.loc.start), this.semicolon(), this.finishNode(J, "DeclareVariable");
    }
    flowParseDeclareModule(J) {
      if (this.scope.enter(0), this.match(133))
        J.id = super.parseExprAtom();
      else
        J.id = this.parseIdentifier();
      const X = J.body = this.startNode(), z = X.body = [];
      this.expect(5);
      while (!this.match(8)) {
        let U = this.startNode();
        if (this.match(83)) {
          if (this.next(), !this.isContextual(130) && !this.match(87))
            this.raise(i.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
          super.parseImport(U);
        } else
          this.expectContextual(125, i.UnsupportedStatementInDeclareModule), U = this.flowParseDeclare(U, !0);
        z.push(U);
      }
      this.scope.exit(), this.expect(8), this.finishNode(X, "BlockStatement");
      let Y = null, W = !1;
      return z.forEach((U) => {
        if (bK(U)) {
          if (Y === "CommonJS")
            this.raise(i.AmbiguousDeclareModuleKind, U);
          Y = "ES";
        } else if (U.type === "DeclareModuleExports") {
          if (W)
            this.raise(i.DuplicateDeclareModuleExports, U);
          if (Y === "ES")
            this.raise(i.AmbiguousDeclareModuleKind, U);
          Y = "CommonJS", W = !0;
        }
      }), J.kind = Y || "CommonJS", this.finishNode(J, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(J, X) {
      if (this.expect(82), this.eat(65)) {
        if (this.match(68) || this.match(80))
          J.declaration = this.flowParseDeclare(this.startNode());
        else
          J.declaration = this.flowParseType(), this.semicolon();
        return J.default = !0, this.finishNode(J, "DeclareExportDeclaration");
      } else {
        if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !X) {
          const z = this.state.value;
          throw this.raise(i.UnsupportedDeclareExportKind, this.state.startLoc, {
            unsupportedExportKind: z,
            suggestion: EK[z]
          });
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
          return J.declaration = this.flowParseDeclare(this.startNode()), J.default = !1, this.finishNode(J, "DeclareExportDeclaration");
        else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
          if (J = this.parseExport(J, null), J.type === "ExportNamedDeclaration")
            J.type = "ExportDeclaration", J.default = !1, delete J.exportKind;
          return J.type = "Declare" + J.type, J;
        }
      }
      this.unexpected();
    }
    flowParseDeclareModuleExports(J) {
      return this.next(), this.expectContextual(111), J.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(J, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(J) {
      this.next();
      const X = this.flowParseTypeAlias(J);
      return X.type = "DeclareTypeAlias", X;
    }
    flowParseDeclareOpaqueType(J) {
      this.next();
      const X = this.flowParseOpaqueType(J, !0);
      return X.type = "DeclareOpaqueType", X;
    }
    flowParseDeclareInterface(J) {
      return this.next(), this.flowParseInterfaceish(J, !1), this.finishNode(J, "DeclareInterface");
    }
    flowParseInterfaceish(J, X) {
      if (J.id = this.flowParseRestrictedIdentifier(!X, !0), this.scope.declareName(J.id.name, X ? 17 : 8201, J.id.loc.start), this.match(47))
        J.typeParameters = this.flowParseTypeParameterDeclaration();
      else
        J.typeParameters = null;
      if (J.extends = [], this.eat(81))
        do
          J.extends.push(this.flowParseInterfaceExtends());
        while (!X && this.eat(12));
      if (X) {
        if (J.implements = [], J.mixins = [], this.eatContextual(117))
          do
            J.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            J.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      J.body = this.flowParseObjectType({
        allowStatic: X,
        allowExact: !1,
        allowSpread: !1,
        allowProto: X,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      const J = this.startNode();
      if (J.id = this.flowParseQualifiedTypeIdentifier(), this.match(47))
        J.typeParameters = this.flowParseTypeParameterInstantiation();
      else
        J.typeParameters = null;
      return this.finishNode(J, "InterfaceExtends");
    }
    flowParseInterface(J) {
      return this.flowParseInterfaceish(J, !1), this.finishNode(J, "InterfaceDeclaration");
    }
    checkNotUnderscore(J) {
      if (J === "_")
        this.raise(i.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(J, X, z) {
      if (!vK.has(J))
        return;
      this.raise(z ? i.AssignReservedType : i.UnexpectedReservedType, X, {
        reservedType: J
      });
    }
    flowParseRestrictedIdentifier(J, X) {
      return this.checkReservedType(this.state.value, this.state.startLoc, X), this.parseIdentifier(J);
    }
    flowParseTypeAlias(J) {
      if (J.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(J.id.name, 8201, J.id.loc.start), this.match(47))
        J.typeParameters = this.flowParseTypeParameterDeclaration();
      else
        J.typeParameters = null;
      return J.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(J, "TypeAlias");
    }
    flowParseOpaqueType(J, X) {
      if (this.expectContextual(130), J.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(J.id.name, 8201, J.id.loc.start), this.match(47))
        J.typeParameters = this.flowParseTypeParameterDeclaration();
      else
        J.typeParameters = null;
      if (J.supertype = null, this.match(14))
        J.supertype = this.flowParseTypeInitialiser(14);
      if (J.impltype = null, !X)
        J.impltype = this.flowParseTypeInitialiser(29);
      return this.semicolon(), this.finishNode(J, "OpaqueType");
    }
    flowParseTypeParameter(J = !1) {
      const X = this.state.startLoc, z = this.startNode(), Y = this.flowParseVariance(), W = this.flowParseTypeAnnotatableIdentifier();
      if (z.name = W.name, z.variance = Y, z.bound = W.typeAnnotation, this.match(29))
        this.eat(29), z.default = this.flowParseType();
      else if (J)
        this.raise(i.MissingTypeParamDefault, X);
      return this.finishNode(z, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const J = this.state.inType, X = this.startNode();
      if (X.params = [], this.state.inType = !0, this.match(47) || this.match(142))
        this.next();
      else
        this.unexpected();
      let z = !1;
      do {
        const Y = this.flowParseTypeParameter(z);
        if (X.params.push(Y), Y.default)
          z = !0;
        if (!this.match(48))
          this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = J, this.finishNode(X, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const J = this.startNode(), X = this.state.inType;
      J.params = [], this.state.inType = !0, this.expect(47);
      const z = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = !1;
      while (!this.match(48))
        if (J.params.push(this.flowParseType()), !this.match(48))
          this.expect(12);
      return this.state.noAnonFunctionType = z, this.expect(48), this.state.inType = X, this.finishNode(J, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const J = this.startNode(), X = this.state.inType;
      J.params = [], this.state.inType = !0, this.expect(47);
      while (!this.match(48))
        if (J.params.push(this.flowParseTypeOrImplicitInstantiation()), !this.match(48))
          this.expect(12);
      return this.expect(48), this.state.inType = X, this.finishNode(J, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const J = this.startNode();
      if (this.expectContextual(129), J.extends = [], this.eat(81))
        do
          J.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return J.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(J, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(J, X, z) {
      if (J.static = X, this.lookahead().type === 14)
        J.id = this.flowParseObjectPropertyKey(), J.key = this.flowParseTypeInitialiser();
      else
        J.id = null, J.key = this.flowParseType();
      return this.expect(3), J.value = this.flowParseTypeInitialiser(), J.variance = z, this.finishNode(J, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(J, X) {
      if (J.static = X, J.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10))
        J.method = !0, J.optional = !1, J.value = this.flowParseObjectTypeMethodish(this.startNodeAt(J.loc.start));
      else {
        if (J.method = !1, this.eat(17))
          J.optional = !0;
        J.value = this.flowParseTypeInitialiser();
      }
      return this.finishNode(J, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(J) {
      if (J.params = [], J.rest = null, J.typeParameters = null, J.this = null, this.match(47))
        J.typeParameters = this.flowParseTypeParameterDeclaration();
      if (this.expect(10), this.match(78)) {
        if (J.this = this.flowParseFunctionTypeParam(!0), J.this.name = null, !this.match(11))
          this.expect(12);
      }
      while (!this.match(11) && !this.match(21))
        if (J.params.push(this.flowParseFunctionTypeParam(!1)), !this.match(11))
          this.expect(12);
      if (this.eat(21))
        J.rest = this.flowParseFunctionTypeParam(!1);
      return this.expect(11), J.returnType = this.flowParseTypeInitialiser(), this.finishNode(J, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(J, X) {
      const z = this.startNode();
      return J.static = X, J.value = this.flowParseObjectTypeMethodish(z), this.finishNode(J, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: J,
      allowExact: X,
      allowSpread: z,
      allowProto: Y,
      allowInexact: W
    }) {
      const U = this.state.inType;
      this.state.inType = !0;
      const V = this.startNode();
      V.callProperties = [], V.properties = [], V.indexers = [], V.internalSlots = [];
      let M, q, L = !1;
      if (X && this.match(6))
        this.expect(6), M = 9, q = !0;
      else
        this.expect(5), M = 8, q = !1;
      V.exact = q;
      while (!this.match(M)) {
        let T = !1, E = null, g = null;
        const n = this.startNode();
        if (Y && this.isContextual(118)) {
          const d = this.lookahead();
          if (d.type !== 14 && d.type !== 17)
            this.next(), E = this.state.startLoc, J = !1;
        }
        if (J && this.isContextual(106)) {
          const d = this.lookahead();
          if (d.type !== 14 && d.type !== 17)
            this.next(), T = !0;
        }
        const x = this.flowParseVariance();
        if (this.eat(0)) {
          if (E != null)
            this.unexpected(E);
          if (this.eat(0)) {
            if (x)
              this.unexpected(x.loc.start);
            V.internalSlots.push(this.flowParseObjectTypeInternalSlot(n, T));
          } else
            V.indexers.push(this.flowParseObjectTypeIndexer(n, T, x));
        } else if (this.match(10) || this.match(47)) {
          if (E != null)
            this.unexpected(E);
          if (x)
            this.unexpected(x.loc.start);
          V.callProperties.push(this.flowParseObjectTypeCallProperty(n, T));
        } else {
          let d = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const R = this.lookahead();
            if (Tz(R.type))
              d = this.state.value, this.next();
          }
          const y = this.flowParseObjectTypeProperty(n, T, E, x, d, z, W != null ? W : !q);
          if (y === null)
            L = !0, g = this.state.lastTokStartLoc;
          else
            V.properties.push(y);
        }
        if (this.flowObjectTypeSemicolon(), g && !this.match(8) && !this.match(9))
          this.raise(i.UnexpectedExplicitInexactInObject, g);
      }
      if (this.expect(M), z)
        V.inexact = L;
      const N = this.finishNode(V, "ObjectTypeAnnotation");
      return this.state.inType = U, N;
    }
    flowParseObjectTypeProperty(J, X, z, Y, W, U, V) {
      if (this.eat(21)) {
        if (this.match(12) || this.match(13) || this.match(8) || this.match(9)) {
          if (!U)
            this.raise(i.InexactInsideNonObject, this.state.lastTokStartLoc);
          else if (!V)
            this.raise(i.InexactInsideExact, this.state.lastTokStartLoc);
          if (Y)
            this.raise(i.InexactVariance, Y);
          return null;
        }
        if (!U)
          this.raise(i.UnexpectedSpreadType, this.state.lastTokStartLoc);
        if (z != null)
          this.unexpected(z);
        if (Y)
          this.raise(i.SpreadVariance, Y);
        return J.argument = this.flowParseType(), this.finishNode(J, "ObjectTypeSpreadProperty");
      } else {
        J.key = this.flowParseObjectPropertyKey(), J.static = X, J.proto = z != null, J.kind = W;
        let M = !1;
        if (this.match(47) || this.match(10)) {
          if (J.method = !0, z != null)
            this.unexpected(z);
          if (Y)
            this.unexpected(Y.loc.start);
          if (J.value = this.flowParseObjectTypeMethodish(this.startNodeAt(J.loc.start)), W === "get" || W === "set")
            this.flowCheckGetterSetterParams(J);
          if (!U && J.key.name === "constructor" && J.value.this)
            this.raise(i.ThisParamBannedInConstructor, J.value.this);
        } else {
          if (W !== "init")
            this.unexpected();
          if (J.method = !1, this.eat(17))
            M = !0;
          J.value = this.flowParseTypeInitialiser(), J.variance = Y;
        }
        return J.optional = M, this.finishNode(J, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(J) {
      const X = J.kind === "get" ? 0 : 1, z = J.value.params.length + (J.value.rest ? 1 : 0);
      if (J.value.this)
        this.raise(J.kind === "get" ? i.GetterMayNotHaveThisParam : i.SetterMayNotHaveThisParam, J.value.this);
      if (z !== X)
        this.raise(J.kind === "get" ? C.BadGetterArity : C.BadSetterArity, J);
      if (J.kind === "set" && J.value.rest)
        this.raise(C.BadSetterRestParameter, J);
    }
    flowObjectTypeSemicolon() {
      if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9))
        this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(J, X) {
      var z;
      (z = J) != null || (J = this.state.startLoc);
      let Y = X || this.flowParseRestrictedIdentifier(!0);
      while (this.eat(16)) {
        const W = this.startNodeAt(J);
        W.qualification = Y, W.id = this.flowParseRestrictedIdentifier(!0), Y = this.finishNode(W, "QualifiedTypeIdentifier");
      }
      return Y;
    }
    flowParseGenericType(J, X) {
      const z = this.startNodeAt(J);
      if (z.typeParameters = null, z.id = this.flowParseQualifiedTypeIdentifier(J, X), this.match(47))
        z.typeParameters = this.flowParseTypeParameterInstantiation();
      return this.finishNode(z, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const J = this.startNode();
      return this.expect(87), J.argument = this.flowParsePrimaryType(), this.finishNode(J, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const J = this.startNode();
      J.types = [], this.expect(0);
      while (this.state.pos < this.length && !this.match(3)) {
        if (J.types.push(this.flowParseType()), this.match(3))
          break;
        this.expect(12);
      }
      return this.expect(3), this.finishNode(J, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(J) {
      let X = null, z = !1, Y = null;
      const W = this.startNode(), U = this.lookahead(), V = this.state.type === 78;
      if (U.type === 14 || U.type === 17) {
        if (V && !J)
          this.raise(i.ThisParamMustBeFirst, W);
        if (X = this.parseIdentifier(V), this.eat(17)) {
          if (z = !0, V)
            this.raise(i.ThisParamMayNotBeOptional, W);
        }
        Y = this.flowParseTypeInitialiser();
      } else
        Y = this.flowParseType();
      return W.name = X, W.optional = z, W.typeAnnotation = Y, this.finishNode(W, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(J) {
      const X = this.startNodeAt(J.loc.start);
      return X.name = null, X.optional = !1, X.typeAnnotation = J, this.finishNode(X, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(J = []) {
      let X = null, z = null;
      if (this.match(78)) {
        if (z = this.flowParseFunctionTypeParam(!0), z.name = null, !this.match(11))
          this.expect(12);
      }
      while (!this.match(11) && !this.match(21))
        if (J.push(this.flowParseFunctionTypeParam(!1)), !this.match(11))
          this.expect(12);
      if (this.eat(21))
        X = this.flowParseFunctionTypeParam(!1);
      return {
        params: J,
        rest: X,
        _this: z
      };
    }
    flowIdentToTypeAnnotation(J, X, z) {
      switch (z.name) {
        case "any":
          return this.finishNode(X, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(X, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(X, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(X, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(X, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(X, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(X, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(z.name), this.flowParseGenericType(J, z);
      }
    }
    flowParsePrimaryType() {
      const J = this.state.startLoc, X = this.startNode();
      let z, Y, W = !1;
      const U = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, Y = this.flowParseTupleType(), this.state.noAnonFunctionType = U, Y;
        case 47:
          return X.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), z = this.flowParseFunctionTypeParams(), X.params = z.params, X.rest = z.rest, X.this = z._this, this.expect(11), this.expect(19), X.returnType = this.flowParseType(), this.finishNode(X, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (K0(this.state.type) || this.match(78)) {
              const V = this.lookahead().type;
              W = V !== 17 && V !== 14;
            } else
              W = !0;
          if (W)
            if (this.state.noAnonFunctionType = !1, Y = this.flowParseType(), this.state.noAnonFunctionType = U, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), Y;
            else
              this.eat(12);
          if (Y)
            z = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(Y)]);
          else
            z = this.flowParseFunctionTypeParams();
          return X.params = z.params, X.rest = z.rest, X.this = z._this, this.expect(11), this.expect(19), X.returnType = this.flowParseType(), X.typeParameters = null, this.finishNode(X, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return X.value = this.match(85), this.next(), this.finishNode(X, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", X);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", X);
            throw this.raise(i.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(X, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(X, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(X, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(X, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (g6(this.state.type)) {
            const V = c1(this.state.type);
            return this.next(), super.createIdentifier(X, V);
          } else if (K0(this.state.type)) {
            if (this.isContextual(129))
              return this.flowParseInterfaceType();
            return this.flowIdentToTypeAnnotation(J, X, this.parseIdentifier());
          }
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const J = this.state.startLoc;
      let X = this.flowParsePrimaryType(), z = !1;
      while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
        const Y = this.startNodeAt(J), W = this.eat(18);
        if (z = z || W, this.expect(0), !W && this.match(3))
          Y.elementType = X, this.next(), X = this.finishNode(Y, "ArrayTypeAnnotation");
        else if (Y.objectType = X, Y.indexType = this.flowParseType(), this.expect(3), z)
          Y.optional = W, X = this.finishNode(Y, "OptionalIndexedAccessType");
        else
          X = this.finishNode(Y, "IndexedAccessType");
      }
      return X;
    }
    flowParsePrefixType() {
      const J = this.startNode();
      if (this.eat(17))
        return J.typeAnnotation = this.flowParsePrefixType(), this.finishNode(J, "NullableTypeAnnotation");
      else
        return this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const J = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const X = this.startNodeAt(J.loc.start);
        return X.params = [this.reinterpretTypeAsFunctionTypeParam(J)], X.rest = null, X.this = null, X.returnType = this.flowParseType(), X.typeParameters = null, this.finishNode(X, "FunctionTypeAnnotation");
      }
      return J;
    }
    flowParseIntersectionType() {
      const J = this.startNode();
      this.eat(45);
      const X = this.flowParseAnonFunctionWithoutParens();
      J.types = [X];
      while (this.eat(45))
        J.types.push(this.flowParseAnonFunctionWithoutParens());
      return J.types.length === 1 ? X : this.finishNode(J, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const J = this.startNode();
      this.eat(43);
      const X = this.flowParseIntersectionType();
      J.types = [X];
      while (this.eat(43))
        J.types.push(this.flowParseIntersectionType());
      return J.types.length === 1 ? X : this.finishNode(J, "UnionTypeAnnotation");
    }
    flowParseType() {
      const J = this.state.inType;
      this.state.inType = !0;
      const X = this.flowParseUnionType();
      return this.state.inType = J, X;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const J = this.state.startLoc, X = this.parseIdentifier();
        return this.flowParseGenericType(J, X);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const J = this.startNode();
      return J.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(J, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(J) {
      const X = J ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      if (this.match(14))
        X.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(X);
      return X;
    }
    typeCastToParameter(J) {
      return J.expression.typeAnnotation = J.typeAnnotation, this.resetEndLocation(J.expression, J.typeAnnotation.loc.end), J.expression;
    }
    flowParseVariance() {
      let J = null;
      if (this.match(53)) {
        if (J = this.startNode(), this.state.value === "+")
          J.kind = "plus";
        else
          J.kind = "minus";
        return this.next(), this.finishNode(J, "Variance");
      }
      return J;
    }
    parseFunctionBody(J, X, z = !1) {
      if (X) {
        this.forwardNoArrowParamsConversionAt(J, () => super.parseFunctionBody(J, !0, z));
        return;
      }
      super.parseFunctionBody(J, !1, z);
    }
    parseFunctionBodyAndFinish(J, X, z = !1) {
      if (this.match(14)) {
        const Y = this.startNode();
        [Y.typeAnnotation, J.predicate] = this.flowParseTypeAndPredicateInitialiser(), J.returnType = Y.typeAnnotation ? this.finishNode(Y, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(J, X, z);
    }
    parseStatementLike(J) {
      if (this.state.strict && this.isContextual(129)) {
        const z = this.lookahead();
        if (G1(z.type)) {
          const Y = this.startNode();
          return this.next(), this.flowParseInterface(Y);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        const z = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(z);
      }
      const X = super.parseStatementLike(J);
      if (this.flowPragma === void 0 && !this.isValidDirective(X))
        this.flowPragma = null;
      return X;
    }
    parseExpressionStatement(J, X, z) {
      if (X.type === "Identifier") {
        if (X.name === "declare") {
          if (this.match(80) || K0(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(J);
        } else if (K0(this.state.type)) {
          if (X.name === "interface")
            return this.flowParseInterface(J);
          else if (X.name === "type")
            return this.flowParseTypeAlias(J);
          else if (X.name === "opaque")
            return this.flowParseOpaqueType(J, !1);
        }
      }
      return super.parseExpressionStatement(J, X, z);
    }
    shouldParseExportDeclaration() {
      const {
        type: J
      } = this.state;
      if (Oz(J) || this.shouldParseEnums() && J === 126)
        return !this.state.containsEsc;
      return super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: J
      } = this.state;
      if (Oz(J) || this.shouldParseEnums() && J === 126)
        return this.state.containsEsc;
      return super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        const J = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(J);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(J, X, z) {
      if (!this.match(17))
        return J;
      if (this.state.maybeInArrowParameters) {
        const N = this.lookaheadCharCode();
        if (N === 44 || N === 61 || N === 58 || N === 41)
          return this.setOptionalParametersError(z), J;
      }
      this.expect(17);
      const Y = this.state.clone(), W = this.state.noArrowAt, U = this.startNodeAt(X);
      let {
        consequent: V,
        failed: M
      } = this.tryParseConditionalConsequent(), [q, L] = this.getArrowLikeExpressions(V);
      if (M || L.length > 0) {
        const N = [...W];
        if (L.length > 0) {
          this.state = Y, this.state.noArrowAt = N;
          for (let T = 0;T < L.length; T++)
            N.push(L[T].start);
          ({
            consequent: V,
            failed: M
          } = this.tryParseConditionalConsequent()), [q, L] = this.getArrowLikeExpressions(V);
        }
        if (M && q.length > 1)
          this.raise(i.AmbiguousConditionalArrow, Y.startLoc);
        if (M && q.length === 1)
          this.state = Y, N.push(q[0].start), this.state.noArrowAt = N, {
            consequent: V,
            failed: M
          } = this.tryParseConditionalConsequent();
      }
      return this.getArrowLikeExpressions(V, !0), this.state.noArrowAt = W, this.expect(14), U.test = J, U.consequent = V, U.alternate = this.forwardNoArrowParamsConversionAt(U, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(U, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const J = this.parseMaybeAssignAllowIn(), X = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: J,
        failed: X
      };
    }
    getArrowLikeExpressions(J, X) {
      const z = [J], Y = [];
      while (z.length !== 0) {
        const W = z.pop();
        if (W.type === "ArrowFunctionExpression") {
          if (W.typeParameters || !W.returnType)
            this.finishArrowValidation(W);
          else
            Y.push(W);
          z.push(W.body);
        } else if (W.type === "ConditionalExpression")
          z.push(W.consequent), z.push(W.alternate);
      }
      if (X)
        return Y.forEach((W) => this.finishArrowValidation(W)), [Y, []];
      return gK(Y, (W) => W.params.every((U) => this.isAssignable(U, !0)));
    }
    finishArrowValidation(J) {
      var X;
      this.toAssignableList(J.params, (X = J.extra) == null ? void 0 : X.trailingCommaLoc, !1), this.scope.enter(2 | 4), super.checkParams(J, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(J, X) {
      let z;
      if (this.state.noArrowParamsConversionAt.indexOf(J.start) !== -1)
        this.state.noArrowParamsConversionAt.push(this.state.start), z = X(), this.state.noArrowParamsConversionAt.pop();
      else
        z = X();
      return z;
    }
    parseParenItem(J, X) {
      if (J = super.parseParenItem(J, X), this.eat(17))
        J.optional = !0, this.resetEndLocation(J);
      if (this.match(14)) {
        const z = this.startNodeAt(X);
        return z.expression = J, z.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(z, "TypeCastExpression");
      }
      return J;
    }
    assertModuleNodeAllowed(J) {
      if (J.type === "ImportDeclaration" && (J.importKind === "type" || J.importKind === "typeof") || J.type === "ExportNamedDeclaration" && J.exportKind === "type" || J.type === "ExportAllDeclaration" && J.exportKind === "type")
        return;
      super.assertModuleNodeAllowed(J);
    }
    parseExportDeclaration(J) {
      if (this.isContextual(130)) {
        J.exportKind = "type";
        const X = this.startNode();
        if (this.next(), this.match(5))
          return J.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(J), null;
        else
          return this.flowParseTypeAlias(X);
      } else if (this.isContextual(131)) {
        J.exportKind = "type";
        const X = this.startNode();
        return this.next(), this.flowParseOpaqueType(X, !1);
      } else if (this.isContextual(129)) {
        J.exportKind = "type";
        const X = this.startNode();
        return this.next(), this.flowParseInterface(X);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        J.exportKind = "value";
        const X = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(X);
      } else
        return super.parseExportDeclaration(J);
    }
    eatExportStar(J) {
      if (super.eatExportStar(J))
        return !0;
      if (this.isContextual(130) && this.lookahead().type === 55)
        return J.exportKind = "type", this.next(), this.next(), !0;
      return !1;
    }
    maybeParseExportNamespaceSpecifier(J) {
      const {
        startLoc: X
      } = this.state, z = super.maybeParseExportNamespaceSpecifier(J);
      if (z && J.exportKind === "type")
        this.unexpected(X);
      return z;
    }
    parseClassId(J, X, z) {
      if (super.parseClassId(J, X, z), this.match(47))
        J.typeParameters = this.flowParseTypeParameterDeclaration();
    }
    parseClassMember(J, X, z) {
      const {
        startLoc: Y
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(J, X))
          return;
        X.declare = !0;
      }
      if (super.parseClassMember(J, X, z), X.declare) {
        if (X.type !== "ClassProperty" && X.type !== "ClassPrivateProperty" && X.type !== "PropertyDefinition")
          this.raise(i.DeclareClassElement, Y);
        else if (X.value)
          this.raise(i.DeclareClassFieldInitializer, X.value);
      }
    }
    isIterator(J) {
      return J === "iterator" || J === "asyncIterator";
    }
    readIterator() {
      const J = super.readWord1(), X = "@@" + J;
      if (!this.isIterator(J) || !this.state.inType)
        this.raise(C.InvalidIdentifier, this.state.curPosition(), {
          identifierName: X
        });
      this.finishToken(132, X);
    }
    getTokenFromCode(J) {
      const X = this.input.charCodeAt(this.state.pos + 1);
      if (J === 123 && X === 124)
        this.finishOp(6, 2);
      else if (this.state.inType && (J === 62 || J === 60))
        this.finishOp(J === 62 ? 48 : 47, 1);
      else if (this.state.inType && J === 63)
        if (X === 46)
          this.finishOp(18, 2);
        else
          this.finishOp(17, 1);
      else if (OK(J, X, this.input.charCodeAt(this.state.pos + 2)))
        this.state.pos += 2, this.readIterator();
      else
        super.getTokenFromCode(J);
    }
    isAssignable(J, X) {
      if (J.type === "TypeCastExpression")
        return this.isAssignable(J.expression, X);
      else
        return super.isAssignable(J, X);
    }
    toAssignable(J, X = !1) {
      if (!X && J.type === "AssignmentExpression" && J.left.type === "TypeCastExpression")
        J.left = this.typeCastToParameter(J.left);
      super.toAssignable(J, X);
    }
    toAssignableList(J, X, z) {
      for (let Y = 0;Y < J.length; Y++) {
        const W = J[Y];
        if ((W == null ? void 0 : W.type) === "TypeCastExpression")
          J[Y] = this.typeCastToParameter(W);
      }
      super.toAssignableList(J, X, z);
    }
    toReferencedList(J, X) {
      for (let Y = 0;Y < J.length; Y++) {
        var z;
        const W = J[Y];
        if (W && W.type === "TypeCastExpression" && !((z = W.extra) != null && z.parenthesized) && (J.length > 1 || !X))
          this.raise(i.TypeCastInPattern, W.typeAnnotation);
      }
      return J;
    }
    parseArrayLike(J, X, z, Y) {
      const W = super.parseArrayLike(J, X, z, Y);
      if (X && !this.state.maybeInArrowParameters)
        this.toReferencedList(W.elements);
      return W;
    }
    isValidLVal(J, X, z) {
      return J === "TypeCastExpression" || super.isValidLVal(J, X, z);
    }
    parseClassProperty(J) {
      if (this.match(14))
        J.typeAnnotation = this.flowParseTypeAnnotation();
      return super.parseClassProperty(J);
    }
    parseClassPrivateProperty(J) {
      if (this.match(14))
        J.typeAnnotation = this.flowParseTypeAnnotation();
      return super.parseClassPrivateProperty(J);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(J) {
      return !this.match(14) && super.isNonstaticConstructor(J);
    }
    pushClassMethod(J, X, z, Y, W, U) {
      if (X.variance)
        this.unexpected(X.variance.loc.start);
      if (delete X.variance, this.match(47))
        X.typeParameters = this.flowParseTypeParameterDeclaration();
      if (super.pushClassMethod(J, X, z, Y, W, U), X.params && W) {
        const V = X.params;
        if (V.length > 0 && this.isThisParam(V[0]))
          this.raise(i.ThisParamBannedInConstructor, X);
      } else if (X.type === "MethodDefinition" && W && X.value.params) {
        const V = X.value.params;
        if (V.length > 0 && this.isThisParam(V[0]))
          this.raise(i.ThisParamBannedInConstructor, X);
      }
    }
    pushClassPrivateMethod(J, X, z, Y) {
      if (X.variance)
        this.unexpected(X.variance.loc.start);
      if (delete X.variance, this.match(47))
        X.typeParameters = this.flowParseTypeParameterDeclaration();
      super.pushClassPrivateMethod(J, X, z, Y);
    }
    parseClassSuper(J) {
      if (super.parseClassSuper(J), J.superClass && this.match(47))
        J.superTypeParameters = this.flowParseTypeParameterInstantiation();
      if (this.isContextual(113)) {
        this.next();
        const X = J.implements = [];
        do {
          const z = this.startNode();
          if (z.id = this.flowParseRestrictedIdentifier(!0), this.match(47))
            z.typeParameters = this.flowParseTypeParameterInstantiation();
          else
            z.typeParameters = null;
          X.push(this.finishNode(z, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(J) {
      super.checkGetterSetterParams(J);
      const X = this.getObjectOrClassMethodParams(J);
      if (X.length > 0) {
        const z = X[0];
        if (this.isThisParam(z) && J.kind === "get")
          this.raise(i.GetterMayNotHaveThisParam, z);
        else if (this.isThisParam(z))
          this.raise(i.SetterMayNotHaveThisParam, z);
      }
    }
    parsePropertyNamePrefixOperator(J) {
      J.variance = this.flowParseVariance();
    }
    parseObjPropValue(J, X, z, Y, W, U, V) {
      if (J.variance)
        this.unexpected(J.variance.loc.start);
      delete J.variance;
      let M;
      if (this.match(47) && !U) {
        if (M = this.flowParseTypeParameterDeclaration(), !this.match(10))
          this.unexpected();
      }
      const q = super.parseObjPropValue(J, X, z, Y, W, U, V);
      if (M)
        (q.value || q).typeParameters = M;
      return q;
    }
    parseAssignableListItemTypes(J) {
      if (this.eat(17)) {
        if (J.type !== "Identifier")
          this.raise(i.PatternIsOptional, J);
        if (this.isThisParam(J))
          this.raise(i.ThisParamMayNotBeOptional, J);
        J.optional = !0;
      }
      if (this.match(14))
        J.typeAnnotation = this.flowParseTypeAnnotation();
      else if (this.isThisParam(J))
        this.raise(i.ThisParamAnnotationRequired, J);
      if (this.match(29) && this.isThisParam(J))
        this.raise(i.ThisParamNoDefault, J);
      return this.resetEndLocation(J), J;
    }
    parseMaybeDefault(J, X) {
      const z = super.parseMaybeDefault(J, X);
      if (z.type === "AssignmentPattern" && z.typeAnnotation && z.right.start < z.typeAnnotation.start)
        this.raise(i.TypeBeforeInitializer, z.typeAnnotation);
      return z;
    }
    checkImportReflection(J) {
      if (super.checkImportReflection(J), J.module && J.importKind !== "value")
        this.raise(i.ImportReflectionHasImportType, J.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(J, X, z) {
      X.local = Dz(J) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), J.specifiers.push(this.finishImportSpecifier(X, z));
    }
    isPotentialImportPhase(J) {
      if (super.isPotentialImportPhase(J))
        return !0;
      if (this.isContextual(130)) {
        if (!J)
          return !0;
        const X = this.lookaheadCharCode();
        return X === 123 || X === 42;
      }
      return !J && this.isContextual(87);
    }
    applyImportPhase(J, X, z, Y) {
      if (super.applyImportPhase(J, X, z, Y), X) {
        if (!z && this.match(65))
          return;
        J.exportKind = z === "type" ? z : "value";
      } else {
        if (z === "type" && this.match(55))
          this.unexpected();
        J.importKind = z === "type" || z === "typeof" ? z : "value";
      }
    }
    parseImportSpecifier(J, X, z, Y, W) {
      const U = J.imported;
      let V = null;
      if (U.type === "Identifier") {
        if (U.name === "type")
          V = "type";
        else if (U.name === "typeof")
          V = "typeof";
      }
      let M = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const L = this.parseIdentifier(!0);
        if (V !== null && !G1(this.state.type))
          J.imported = L, J.importKind = V, J.local = v1(L);
        else
          J.imported = U, J.importKind = null, J.local = this.parseIdentifier();
      } else {
        if (V !== null && G1(this.state.type))
          J.imported = this.parseIdentifier(!0), J.importKind = V;
        else {
          if (X)
            throw this.raise(C.ImportBindingIsString, J, {
              importName: U.value
            });
          J.imported = U, J.importKind = null;
        }
        if (this.eatContextual(93))
          J.local = this.parseIdentifier();
        else
          M = !0, J.local = v1(J.imported);
      }
      const q = Dz(J);
      if (z && q)
        this.raise(i.ImportTypeShorthandOnlyInPureImport, J);
      if (z || q)
        this.checkReservedType(J.local.name, J.local.loc.start, !0);
      if (M && !z && !q)
        this.checkReservedWord(J.local.name, J.loc.start, !0, !0);
      return this.finishImportSpecifier(J, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(J, X) {
      const z = J.kind;
      if (z !== "get" && z !== "set" && this.match(47))
        J.typeParameters = this.flowParseTypeParameterDeclaration();
      super.parseFunctionParams(J, X);
    }
    parseVarId(J, X) {
      if (super.parseVarId(J, X), this.match(14))
        J.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(J.id);
    }
    parseAsyncArrowFromCallExpression(J, X) {
      if (this.match(14)) {
        const z = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, J.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = z;
      }
      return super.parseAsyncArrowFromCallExpression(J, X);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(J, X) {
      var z;
      let Y = null, W;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (Y = this.state.clone(), W = this.tryParse(() => super.parseMaybeAssign(J, X), Y), !W.error)
          return W.node;
        const {
          context: M
        } = this.state, q = M[M.length - 1];
        if (q === j0.j_oTag || q === j0.j_expr)
          M.pop();
      }
      if ((z = W) != null && z.error || this.match(47)) {
        var U, V;
        Y = Y || this.state.clone();
        let M;
        const q = this.tryParse((N) => {
          var T;
          M = this.flowParseTypeParameterDeclaration();
          const E = this.forwardNoArrowParamsConversionAt(M, () => {
            const n = super.parseMaybeAssign(J, X);
            return this.resetStartLocationFromNode(n, M), n;
          });
          if ((T = E.extra) != null && T.parenthesized)
            N();
          const g = this.maybeUnwrapTypeCastExpression(E);
          if (g.type !== "ArrowFunctionExpression")
            N();
          return g.typeParameters = M, this.resetStartLocationFromNode(g, M), E;
        }, Y);
        let L = null;
        if (q.node && this.maybeUnwrapTypeCastExpression(q.node).type === "ArrowFunctionExpression") {
          if (!q.error && !q.aborted) {
            if (q.node.async)
              this.raise(i.UnexpectedTypeParameterBeforeAsyncArrowFunction, M);
            return q.node;
          }
          L = q.node;
        }
        if ((U = W) != null && U.node)
          return this.state = W.failState, W.node;
        if (L)
          return this.state = q.failState, L;
        if ((V = W) != null && V.thrown)
          throw W.error;
        if (q.thrown)
          throw q.error;
        throw this.raise(i.UnexpectedTokenAfterTypeParameter, M);
      }
      return super.parseMaybeAssign(J, X);
    }
    parseArrow(J) {
      if (this.match(14)) {
        const X = this.tryParse(() => {
          const z = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          const Y = this.startNode();
          if ([Y.typeAnnotation, J.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = z, this.canInsertSemicolon())
            this.unexpected();
          if (!this.match(19))
            this.unexpected();
          return Y;
        });
        if (X.thrown)
          return null;
        if (X.error)
          this.state = X.failState;
        J.returnType = X.node.typeAnnotation ? this.finishNode(X.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(J);
    }
    shouldParseArrow(J) {
      return this.match(14) || super.shouldParseArrow(J);
    }
    setArrowFunctionParameters(J, X) {
      if (this.state.noArrowParamsConversionAt.indexOf(J.start) !== -1)
        J.params = X;
      else
        super.setArrowFunctionParameters(J, X);
    }
    checkParams(J, X, z, Y = !0) {
      if (z && this.state.noArrowParamsConversionAt.indexOf(J.start) !== -1)
        return;
      for (let W = 0;W < J.params.length; W++)
        if (this.isThisParam(J.params[W]) && W > 0)
          this.raise(i.ThisParamMustBeFirst, J.params[W]);
      super.checkParams(J, X, z, Y);
    }
    parseParenAndDistinguishExpression(J) {
      return super.parseParenAndDistinguishExpression(J && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(J, X, z) {
      if (J.type === "Identifier" && J.name === "async" && this.state.noArrowAt.indexOf(X.index) !== -1) {
        this.next();
        const Y = this.startNodeAt(X);
        Y.callee = J, Y.arguments = super.parseCallExpressionArguments(11, !1), J = this.finishNode(Y, "CallExpression");
      } else if (J.type === "Identifier" && J.name === "async" && this.match(47)) {
        const Y = this.state.clone(), W = this.tryParse((V) => this.parseAsyncArrowWithTypeParameters(X) || V(), Y);
        if (!W.error && !W.aborted)
          return W.node;
        const U = this.tryParse(() => super.parseSubscripts(J, X, z), Y);
        if (U.node && !U.error)
          return U.node;
        if (W.node)
          return this.state = W.failState, W.node;
        if (U.node)
          return this.state = U.failState, U.node;
        throw W.error || U.error;
      }
      return super.parseSubscripts(J, X, z);
    }
    parseSubscript(J, X, z, Y) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (Y.optionalChainMember = !0, z)
          return Y.stop = !0, J;
        this.next();
        const W = this.startNodeAt(X);
        return W.callee = J, W.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), W.arguments = this.parseCallExpressionArguments(11, !1), W.optional = !0, this.finishCallExpression(W, !0);
      } else if (!z && this.shouldParseTypes() && this.match(47)) {
        const W = this.startNodeAt(X);
        W.callee = J;
        const U = this.tryParse(() => {
          if (W.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), W.arguments = super.parseCallExpressionArguments(11, !1), Y.optionalChainMember)
            W.optional = !1;
          return this.finishCallExpression(W, Y.optionalChainMember);
        });
        if (U.node) {
          if (U.error)
            this.state = U.failState;
          return U.node;
        }
      }
      return super.parseSubscript(J, X, z, Y);
    }
    parseNewCallee(J) {
      super.parseNewCallee(J);
      let X = null;
      if (this.shouldParseTypes() && this.match(47))
        X = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
      J.typeArguments = X;
    }
    parseAsyncArrowWithTypeParameters(J) {
      const X = this.startNodeAt(J);
      if (this.parseFunctionParams(X, !1), !this.parseArrow(X))
        return;
      return super.parseArrowExpression(X, void 0, !0);
    }
    readToken_mult_modulo(J) {
      const X = this.input.charCodeAt(this.state.pos + 1);
      if (J === 42 && X === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(J);
    }
    readToken_pipe_amp(J) {
      const X = this.input.charCodeAt(this.state.pos + 1);
      if (J === 124 && X === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(J);
    }
    parseTopLevel(J, X) {
      const z = super.parseTopLevel(J, X);
      if (this.state.hasFlowComment)
        this.raise(i.UnterminatedFlowComment, this.state.curPosition());
      return z;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(i.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const J = this.skipFlowComment();
        if (J)
          this.state.pos += J, this.state.hasFlowComment = !0;
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos: J
      } = this.state;
      let X = 2;
      while ([32, 9].includes(this.input.charCodeAt(J + X)))
        X++;
      const z = this.input.charCodeAt(X + J), Y = this.input.charCodeAt(X + J + 1);
      if (z === 58 && Y === 58)
        return X + 2;
      if (this.input.slice(X + J, X + J + 12) === "flow-include")
        return X + 12;
      if (z === 58 && Y !== 58)
        return X;
      return !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(C.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(J, {
      enumName: X,
      memberName: z
    }) {
      this.raise(i.EnumBooleanMemberNotInitialized, J, {
        memberName: z,
        enumName: X
      });
    }
    flowEnumErrorInvalidMemberInitializer(J, X) {
      return this.raise(!X.explicitType ? i.EnumInvalidMemberInitializerUnknownType : X.explicitType === "symbol" ? i.EnumInvalidMemberInitializerSymbolType : i.EnumInvalidMemberInitializerPrimaryType, J, X);
    }
    flowEnumErrorNumberMemberNotInitialized(J, X) {
      this.raise(i.EnumNumberMemberNotInitialized, J, X);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(J, X) {
      this.raise(i.EnumStringMemberInconsistentlyInitialized, J, X);
    }
    flowEnumMemberInit() {
      const J = this.state.startLoc, X = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          const z = this.parseNumericLiteral(this.state.value);
          if (X())
            return {
              type: "number",
              loc: z.loc.start,
              value: z
            };
          return {
            type: "invalid",
            loc: J
          };
        }
        case 133: {
          const z = this.parseStringLiteral(this.state.value);
          if (X())
            return {
              type: "string",
              loc: z.loc.start,
              value: z
            };
          return {
            type: "invalid",
            loc: J
          };
        }
        case 85:
        case 86: {
          const z = this.parseBooleanLiteral(this.match(85));
          if (X())
            return {
              type: "boolean",
              loc: z.loc.start,
              value: z
            };
          return {
            type: "invalid",
            loc: J
          };
        }
        default:
          return {
            type: "invalid",
            loc: J
          };
      }
    }
    flowEnumMemberRaw() {
      const J = this.state.startLoc, X = this.parseIdentifier(!0), z = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: J
      };
      return {
        id: X,
        init: z
      };
    }
    flowEnumCheckExplicitTypeMismatch(J, X, z) {
      const {
        explicitType: Y
      } = X;
      if (Y === null)
        return;
      if (Y !== z)
        this.flowEnumErrorInvalidMemberInitializer(J, X);
    }
    flowEnumMembers({
      enumName: J,
      explicitType: X
    }) {
      const z = new Set, Y = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let W = !1;
      while (!this.match(8)) {
        if (this.eat(21)) {
          W = !0;
          break;
        }
        const U = this.startNode(), {
          id: V,
          init: M
        } = this.flowEnumMemberRaw(), q = V.name;
        if (q === "")
          continue;
        if (/^[a-z]/.test(q))
          this.raise(i.EnumInvalidMemberName, V, {
            memberName: q,
            suggestion: q[0].toUpperCase() + q.slice(1),
            enumName: J
          });
        if (z.has(q))
          this.raise(i.EnumDuplicateMemberName, V, {
            memberName: q,
            enumName: J
          });
        z.add(q);
        const L = {
          enumName: J,
          explicitType: X,
          memberName: q
        };
        switch (U.id = V, M.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(M.loc, L, "boolean"), U.init = M.value, Y.booleanMembers.push(this.finishNode(U, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(M.loc, L, "number"), U.init = M.value, Y.numberMembers.push(this.finishNode(U, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(M.loc, L, "string"), U.init = M.value, Y.stringMembers.push(this.finishNode(U, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(M.loc, L);
          case "none":
            switch (X) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(M.loc, L);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(M.loc, L);
                break;
              default:
                Y.defaultedMembers.push(this.finishNode(U, "EnumDefaultedMember"));
            }
        }
        if (!this.match(8))
          this.expect(12);
      }
      return {
        members: Y,
        hasUnknownMembers: W
      };
    }
    flowEnumStringMembers(J, X, {
      enumName: z
    }) {
      if (J.length === 0)
        return X;
      else if (X.length === 0)
        return J;
      else if (X.length > J.length) {
        for (let Y of J)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(Y, {
            enumName: z
          });
        return X;
      } else {
        for (let Y of X)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(Y, {
            enumName: z
          });
        return J;
      }
    }
    flowEnumParseExplicitType({
      enumName: J
    }) {
      if (!this.eatContextual(102))
        return null;
      if (!K0(this.state.type))
        throw this.raise(i.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: J
        });
      const {
        value: X
      } = this.state;
      if (this.next(), X !== "boolean" && X !== "number" && X !== "string" && X !== "symbol")
        this.raise(i.EnumInvalidExplicitType, this.state.startLoc, {
          enumName: J,
          invalidEnumType: X
        });
      return X;
    }
    flowEnumBody(J, X) {
      const z = X.name, Y = X.loc.start, W = this.flowEnumParseExplicitType({
        enumName: z
      });
      this.expect(5);
      const {
        members: U,
        hasUnknownMembers: V
      } = this.flowEnumMembers({
        enumName: z,
        explicitType: W
      });
      switch (J.hasUnknownMembers = V, W) {
        case "boolean":
          return J.explicitType = !0, J.members = U.booleanMembers, this.expect(8), this.finishNode(J, "EnumBooleanBody");
        case "number":
          return J.explicitType = !0, J.members = U.numberMembers, this.expect(8), this.finishNode(J, "EnumNumberBody");
        case "string":
          return J.explicitType = !0, J.members = this.flowEnumStringMembers(U.stringMembers, U.defaultedMembers, {
            enumName: z
          }), this.expect(8), this.finishNode(J, "EnumStringBody");
        case "symbol":
          return J.members = U.defaultedMembers, this.expect(8), this.finishNode(J, "EnumSymbolBody");
        default: {
          const M = () => {
            return J.members = [], this.expect(8), this.finishNode(J, "EnumStringBody");
          };
          J.explicitType = !1;
          const q = U.booleanMembers.length, L = U.numberMembers.length, N = U.stringMembers.length, T = U.defaultedMembers.length;
          if (!q && !L && !N && !T)
            return M();
          else if (!q && !L)
            return J.members = this.flowEnumStringMembers(U.stringMembers, U.defaultedMembers, {
              enumName: z
            }), this.expect(8), this.finishNode(J, "EnumStringBody");
          else if (!L && !N && q >= T) {
            for (let E of U.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(E.loc.start, {
                enumName: z,
                memberName: E.id.name
              });
            return J.members = U.booleanMembers, this.expect(8), this.finishNode(J, "EnumBooleanBody");
          } else if (!q && !N && L >= T) {
            for (let E of U.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(E.loc.start, {
                enumName: z,
                memberName: E.id.name
              });
            return J.members = U.numberMembers, this.expect(8), this.finishNode(J, "EnumNumberBody");
          } else
            return this.raise(i.EnumInconsistentMemberValues, Y, {
              enumName: z
            }), M();
        }
      }
    }
    flowParseEnumDeclaration(J) {
      const X = this.parseIdentifier();
      return J.id = X, J.body = this.flowEnumBody(this.startNode(), X), this.finishNode(J, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const J = this.nextTokenStart();
      if (this.input.charCodeAt(J) === 60) {
        const X = this.input.charCodeAt(J + 1);
        return X !== 60 && X !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(J) {
      return J.type === "TypeCastExpression" ? J.expression : J;
    }
  }, kK = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, W5 = w1`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName: Z
    }) => `Expected corresponding JSX closing tag for <${Z}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected: Z,
      HTMLEntity: Q
    }) => `Unexpected token \`${Z}\`. Did you mean \`${Q}\` or \`{'${Z}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  }), fK = (Z) => class Q extends Z {
    jsxReadToken() {
      let J = "", X = this.state.pos;
      for (;; ) {
        if (this.state.pos >= this.length)
          throw this.raise(W5.UnterminatedJsxContent, this.state.startLoc);
        const z = this.input.charCodeAt(this.state.pos);
        switch (z) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (z === 60 && this.state.canStartJSXElement)
                ++this.state.pos, this.finishToken(142);
              else
                super.getTokenFromCode(z);
              return;
            }
            J += this.input.slice(X, this.state.pos), this.finishToken(141, J);
            return;
          case 38:
            J += this.input.slice(X, this.state.pos), J += this.jsxReadEntity(), X = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            if (z8(z))
              J += this.input.slice(X, this.state.pos), J += this.jsxReadNewLine(!0), X = this.state.pos;
            else
              ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(J) {
      const X = this.input.charCodeAt(this.state.pos);
      let z;
      if (++this.state.pos, X === 13 && this.input.charCodeAt(this.state.pos) === 10)
        ++this.state.pos, z = J ? "\n" : "\r\n";
      else
        z = String.fromCharCode(X);
      return ++this.state.curLine, this.state.lineStart = this.state.pos, z;
    }
    jsxReadString(J) {
      let X = "", z = ++this.state.pos;
      for (;; ) {
        if (this.state.pos >= this.length)
          throw this.raise(C.UnterminatedString, this.state.startLoc);
        const Y = this.input.charCodeAt(this.state.pos);
        if (Y === J)
          break;
        if (Y === 38)
          X += this.input.slice(z, this.state.pos), X += this.jsxReadEntity(), z = this.state.pos;
        else if (z8(Y))
          X += this.input.slice(z, this.state.pos), X += this.jsxReadNewLine(!1), z = this.state.pos;
        else
          ++this.state.pos;
      }
      X += this.input.slice(z, this.state.pos++), this.finishToken(133, X);
    }
    jsxReadEntity() {
      const J = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let X = 10;
        if (this.codePointAtPos(this.state.pos) === 120)
          X = 16, ++this.state.pos;
        const z = this.readInt(X, void 0, !1, "bail");
        if (z !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(z);
      } else {
        let X = 0, z = !1;
        while (X++ < 10 && this.state.pos < this.length && !(z = this.codePointAtPos(this.state.pos) == 59))
          ++this.state.pos;
        if (z) {
          const Y = this.input.slice(J, this.state.pos), W = kK[Y];
          if (++this.state.pos, W)
            return W;
        }
      }
      return this.state.pos = J, "&";
    }
    jsxReadWord() {
      let J;
      const X = this.state.pos;
      do
        J = this.input.charCodeAt(++this.state.pos);
      while (E5(J) || J === 45);
      this.finishToken(140, this.input.slice(X, this.state.pos));
    }
    jsxParseIdentifier() {
      const J = this.startNode();
      if (this.match(140))
        J.name = this.state.value;
      else if (g6(this.state.type))
        J.name = c1(this.state.type);
      else
        this.unexpected();
      return this.next(), this.finishNode(J, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const J = this.state.startLoc, X = this.jsxParseIdentifier();
      if (!this.eat(14))
        return X;
      const z = this.startNodeAt(J);
      return z.namespace = X, z.name = this.jsxParseIdentifier(), this.finishNode(z, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const J = this.state.startLoc;
      let X = this.jsxParseNamespacedName();
      if (X.type === "JSXNamespacedName")
        return X;
      while (this.eat(16)) {
        const z = this.startNodeAt(J);
        z.object = X, z.property = this.jsxParseIdentifier(), X = this.finishNode(z, "JSXMemberExpression");
      }
      return X;
    }
    jsxParseAttributeValue() {
      let J;
      switch (this.state.type) {
        case 5:
          if (J = this.startNode(), this.setContext(j0.brace), this.next(), J = this.jsxParseExpressionContainer(J, j0.j_oTag), J.expression.type === "JSXEmptyExpression")
            this.raise(W5.AttributeIsEmpty, J);
          return J;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(W5.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const J = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(J, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(J) {
      return this.next(), J.expression = this.parseExpression(), this.setContext(j0.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(J, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(J, X) {
      if (this.match(8))
        J.expression = this.jsxParseEmptyExpression();
      else {
        const z = this.parseExpression();
        J.expression = z;
      }
      return this.setContext(X), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(J, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const J = this.startNode();
      if (this.match(5))
        return this.setContext(j0.brace), this.next(), this.expect(21), J.argument = this.parseMaybeAssignAllowIn(), this.setContext(j0.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(J, "JSXSpreadAttribute");
      return J.name = this.jsxParseNamespacedName(), J.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(J, "JSXAttribute");
    }
    jsxParseOpeningElementAt(J) {
      const X = this.startNodeAt(J);
      if (this.eat(143))
        return this.finishNode(X, "JSXOpeningFragment");
      return X.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(X);
    }
    jsxParseOpeningElementAfterName(J) {
      const X = [];
      while (!this.match(56) && !this.match(143))
        X.push(this.jsxParseAttribute());
      return J.attributes = X, J.selfClosing = this.eat(56), this.expect(143), this.finishNode(J, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(J) {
      const X = this.startNodeAt(J);
      if (this.eat(143))
        return this.finishNode(X, "JSXClosingFragment");
      return X.name = this.jsxParseElementName(), this.expect(143), this.finishNode(X, "JSXClosingElement");
    }
    jsxParseElementAt(J) {
      const X = this.startNodeAt(J), z = [], Y = this.jsxParseOpeningElementAt(J);
      let W = null;
      if (!Y.selfClosing) {
        Z:
          for (;; )
            switch (this.state.type) {
              case 142:
                if (J = this.state.startLoc, this.next(), this.eat(56)) {
                  W = this.jsxParseClosingElementAt(J);
                  break Z;
                }
                z.push(this.jsxParseElementAt(J));
                break;
              case 141:
                z.push(this.parseExprAtom());
                break;
              case 5: {
                const U = this.startNode();
                if (this.setContext(j0.brace), this.next(), this.match(21))
                  z.push(this.jsxParseSpreadChild(U));
                else
                  z.push(this.jsxParseExpressionContainer(U, j0.j_expr));
                break;
              }
              default:
                this.unexpected();
            }
        if (u1(Y) && !u1(W) && W !== null)
          this.raise(W5.MissingClosingTagFragment, W);
        else if (!u1(Y) && u1(W))
          this.raise(W5.MissingClosingTagElement, W, {
            openingTagName: b5(Y.name)
          });
        else if (!u1(Y) && !u1(W)) {
          if (b5(W.name) !== b5(Y.name))
            this.raise(W5.MissingClosingTagElement, W, {
              openingTagName: b5(Y.name)
            });
        }
      }
      if (u1(Y))
        X.openingFragment = Y, X.closingFragment = W;
      else
        X.openingElement = Y, X.closingElement = W;
      if (X.children = z, this.match(47))
        throw this.raise(W5.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return u1(Y) ? this.finishNode(X, "JSXFragment") : this.finishNode(X, "JSXElement");
    }
    jsxParseElement() {
      const J = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(J);
    }
    setContext(J) {
      const {
        context: X
      } = this.state;
      X[X.length - 1] = J;
    }
    parseExprAtom(J) {
      if (this.match(141))
        return this.parseLiteral(this.state.value, "JSXText");
      else if (this.match(142))
        return this.jsxParseElement();
      else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33)
        return this.replaceToken(142), this.jsxParseElement();
      else
        return super.parseExprAtom(J);
    }
    skipSpace() {
      if (!this.curContext().preserveSpace)
        super.skipSpace();
    }
    getTokenFromCode(J) {
      const X = this.curContext();
      if (X === j0.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (X === j0.j_oTag || X === j0.j_cTag) {
        if (S1(J)) {
          this.jsxReadWord();
          return;
        }
        if (J === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((J === 34 || J === 39) && X === j0.j_oTag) {
          this.jsxReadString(J);
          return;
        }
      }
      if (J === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(J);
    }
    updateContext(J) {
      const {
        context: X,
        type: z
      } = this.state;
      if (z === 56 && J === 142)
        X.splice(-2, 2, j0.j_cTag), this.state.canStartJSXElement = !1;
      else if (z === 142)
        X.push(j0.j_oTag);
      else if (z === 143) {
        const Y = X[X.length - 1];
        if (Y === j0.j_oTag && J === 56 || Y === j0.j_cTag)
          X.pop(), this.state.canStartJSXElement = X[X.length - 1] === j0.j_expr;
        else
          this.setContext(j0.j_expr), this.state.canStartJSXElement = !0;
      } else
        this.state.canStartJSXElement = ZK(z);
    }
  };

  class oz extends G7 {
    constructor(...Z) {
      super(...Z);
      this.tsNames = new Map;
    }
  }

  class ez extends U7 {
    constructor(...Z) {
      super(...Z);
      this.importsStack = [];
    }
    createScope(Z) {
      return this.importsStack.push(new Set), new oz(Z);
    }
    enter(Z) {
      if (Z == 256)
        this.importsStack.push(new Set);
      super.enter(Z);
    }
    exit() {
      const Z = super.exit();
      if (Z == 256)
        this.importsStack.pop();
      return Z;
    }
    hasImport(Z, Q) {
      const J = this.importsStack.length;
      if (this.importsStack[J - 1].has(Z))
        return !0;
      if (!Q && J > 1) {
        for (let X = 0;X < J - 1; X++)
          if (this.importsStack[X].has(Z))
            return !0;
      }
      return !1;
    }
    declareName(Z, Q, J) {
      if (Q & 4096) {
        if (this.hasImport(Z, !0))
          this.parser.raise(C.VarRedeclaration, J, {
            identifierName: Z
          });
        this.importsStack[this.importsStack.length - 1].add(Z);
        return;
      }
      const X = this.currentScope();
      let z = X.tsNames.get(Z) || 0;
      if (Q & 1024) {
        this.maybeExportDefined(X, Z), X.tsNames.set(Z, z | 16);
        return;
      }
      if (super.declareName(Z, Q, J), Q & 2) {
        if (!(Q & 1))
          this.checkRedeclarationInScope(X, Z, Q, J), this.maybeExportDefined(X, Z);
        z = z | 1;
      }
      if (Q & 256)
        z = z | 2;
      if (Q & 512)
        z = z | 4;
      if (Q & 128)
        z = z | 8;
      if (z)
        X.tsNames.set(Z, z);
    }
    isRedeclaredInScope(Z, Q, J) {
      const X = Z.tsNames.get(Q);
      if ((X & 2) > 0) {
        if (J & 256) {
          const z = !!(J & 512), Y = (X & 4) > 0;
          return z !== Y;
        }
        return !0;
      }
      if (J & 128 && (X & 8) > 0)
        if (Z.names.get(Q) & 2)
          return !!(J & 1);
        else
          return !1;
      if (J & 2 && (X & 1) > 0)
        return !0;
      return super.isRedeclaredInScope(Z, Q, J);
    }
    checkLocalExport(Z) {
      const {
        name: Q
      } = Z;
      if (this.hasImport(Q))
        return;
      const J = this.scopeStack.length;
      for (let X = J - 1;X >= 0; X--) {
        const Y = this.scopeStack[X].tsNames.get(Q);
        if ((Y & 1) > 0 || (Y & 16) > 0)
          return;
      }
      super.checkLocalExport(Z);
    }
  }
  var yK = (Z, Q) => Object.hasOwnProperty.call(Z, Q) && Z[Q], Z4 = (Z) => {
    return Z.type === "ParenthesizedExpression" ? Z4(Z.expression) : Z;
  };

  class Q4 extends tz {
    toAssignable(Z, Q = !1) {
      var J, X;
      let z = void 0;
      if (Z.type === "ParenthesizedExpression" || (J = Z.extra) != null && J.parenthesized)
        if (z = Z4(Z), Q) {
          if (z.type === "Identifier")
            this.expressionScope.recordArrowParameterBindingError(C.InvalidParenthesizedAssignment, Z);
          else if (z.type !== "MemberExpression" && !this.isOptionalMemberExpression(z))
            this.raise(C.InvalidParenthesizedAssignment, Z);
        } else
          this.raise(C.InvalidParenthesizedAssignment, Z);
      switch (Z.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          Z.type = "ObjectPattern";
          for (let W = 0, U = Z.properties.length, V = U - 1;W < U; W++) {
            var Y;
            const M = Z.properties[W], q = W === V;
            if (this.toAssignableObjectExpressionProp(M, q, Q), q && M.type === "RestElement" && (Y = Z.extra) != null && Y.trailingCommaLoc)
              this.raise(C.RestTrailingComma, Z.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const {
            key: W,
            value: U
          } = Z;
          if (this.isPrivateName(W))
            this.classScope.usePrivateName(this.getPrivateNameSV(W), W.loc.start);
          this.toAssignable(U, Q);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          Z.type = "ArrayPattern", this.toAssignableList(Z.elements, (X = Z.extra) == null ? void 0 : X.trailingCommaLoc, Q);
          break;
        case "AssignmentExpression":
          if (Z.operator !== "=")
            this.raise(C.MissingEqInAssignment, Z.left.loc.end);
          Z.type = "AssignmentPattern", delete Z.operator, this.toAssignable(Z.left, Q);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(z, Q);
          break;
      }
    }
    toAssignableObjectExpressionProp(Z, Q, J) {
      if (Z.type === "ObjectMethod")
        this.raise(Z.kind === "get" || Z.kind === "set" ? C.PatternHasAccessor : C.PatternHasMethod, Z.key);
      else if (Z.type === "SpreadElement") {
        Z.type = "RestElement";
        const X = Z.argument;
        if (this.checkToRestConversion(X, !1), this.toAssignable(X, J), !Q)
          this.raise(C.RestTrailingComma, Z);
      } else
        this.toAssignable(Z, J);
    }
    toAssignableList(Z, Q, J) {
      const X = Z.length - 1;
      for (let z = 0;z <= X; z++) {
        const Y = Z[z];
        if (!Y)
          continue;
        if (Y.type === "SpreadElement") {
          Y.type = "RestElement";
          const W = Y.argument;
          this.checkToRestConversion(W, !0), this.toAssignable(W, J);
        } else
          this.toAssignable(Y, J);
        if (Y.type === "RestElement") {
          if (z < X)
            this.raise(C.RestTrailingComma, Y);
          else if (Q)
            this.raise(C.RestTrailingComma, Q);
        }
      }
    }
    isAssignable(Z, Q) {
      switch (Z.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          const J = Z.properties.length - 1;
          return Z.properties.every((X, z) => {
            return X.type !== "ObjectMethod" && (z === J || X.type !== "SpreadElement") && this.isAssignable(X);
          });
        }
        case "ObjectProperty":
          return this.isAssignable(Z.value);
        case "SpreadElement":
          return this.isAssignable(Z.argument);
        case "ArrayExpression":
          return Z.elements.every((J) => J === null || this.isAssignable(J));
        case "AssignmentExpression":
          return Z.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(Z.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !Q;
        default:
          return !1;
      }
    }
    toReferencedList(Z, Q) {
      return Z;
    }
    toReferencedListDeep(Z, Q) {
      this.toReferencedList(Z, Q);
      for (let J of Z)
        if ((J == null ? void 0 : J.type) === "ArrayExpression")
          this.toReferencedListDeep(J.elements);
    }
    parseSpread(Z) {
      const Q = this.startNode();
      return this.next(), Q.argument = this.parseMaybeAssignAllowIn(Z, void 0), this.finishNode(Q, "SpreadElement");
    }
    parseRestBinding() {
      const Z = this.startNode();
      return this.next(), Z.argument = this.parseBindingAtom(), this.finishNode(Z, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const Z = this.startNode();
          return this.next(), Z.elements = this.parseBindingList(3, 93, 1), this.finishNode(Z, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(Z, Q, J) {
      const X = J & 1, z = [];
      let Y = !0;
      while (!this.eat(Z)) {
        if (Y)
          Y = !1;
        else
          this.expect(12);
        if (X && this.match(12))
          z.push(null);
        else if (this.eat(Z))
          break;
        else if (this.match(21)) {
          if (z.push(this.parseAssignableListItemTypes(this.parseRestBinding(), J)), !this.checkCommaAfterRest(Q)) {
            this.expect(Z);
            break;
          }
        } else {
          const W = [];
          if (this.match(26) && this.hasPlugin("decorators"))
            this.raise(C.UnsupportedParameterDecorator, this.state.startLoc);
          while (this.match(26))
            W.push(this.parseDecorator());
          z.push(this.parseAssignableListItem(J, W));
        }
      }
      return z;
    }
    parseBindingRestProperty(Z) {
      return this.next(), Z.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(Z, "RestElement");
    }
    parseBindingProperty() {
      const Z = this.startNode(), {
        type: Q,
        startLoc: J
      } = this.state;
      if (Q === 21)
        return this.parseBindingRestProperty(Z);
      else if (Q === 138)
        this.expectPlugin("destructuringPrivate", J), this.classScope.usePrivateName(this.state.value, J), Z.key = this.parsePrivateName();
      else
        this.parsePropertyName(Z);
      return Z.method = !1, this.parseObjPropValue(Z, J, !1, !1, !0, !1);
    }
    parseAssignableListItem(Z, Q) {
      const J = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(J, Z);
      const X = this.parseMaybeDefault(J.loc.start, J);
      if (Q.length)
        J.decorators = Q;
      return X;
    }
    parseAssignableListItemTypes(Z, Q) {
      return Z;
    }
    parseMaybeDefault(Z, Q) {
      var J, X;
      if ((J = Z) != null || (Z = this.state.startLoc), Q = (X = Q) != null ? X : this.parseBindingAtom(), !this.eat(29))
        return Q;
      const z = this.startNodeAt(Z);
      return z.left = Q, z.right = this.parseMaybeAssignAllowIn(), this.finishNode(z, "AssignmentPattern");
    }
    isValidLVal(Z, Q, J) {
      return yK({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, Z);
    }
    isOptionalMemberExpression(Z) {
      return Z.type === "OptionalMemberExpression";
    }
    checkLVal(Z, {
      in: Q,
      binding: J = 64,
      checkClashes: X = !1,
      strictModeChanged: z = !1,
      hasParenthesizedAncestor: Y = !1
    }) {
      var W;
      const U = Z.type;
      if (this.isObjectMethod(Z))
        return;
      const V = this.isOptionalMemberExpression(Z);
      if (V || U === "MemberExpression") {
        if (V) {
          if (this.expectPlugin("optionalChainingAssign", Z.loc.start), Q.type !== "AssignmentExpression")
            this.raise(C.InvalidLhsOptionalChaining, Z, {
              ancestor: Q
            });
        }
        if (J !== 64)
          this.raise(C.InvalidPropertyBindingPattern, Z);
        return;
      }
      if (U === "Identifier") {
        this.checkIdentifier(Z, J, z);
        const {
          name: T
        } = Z;
        if (X)
          if (X.has(T))
            this.raise(C.ParamDupe, Z);
          else
            X.add(T);
        return;
      }
      const M = this.isValidLVal(U, !(Y || (W = Z.extra) != null && W.parenthesized) && Q.type === "AssignmentExpression", J);
      if (M === !0)
        return;
      if (M === !1) {
        const T = J === 64 ? C.InvalidLhs : C.InvalidLhsBinding;
        this.raise(T, Z, {
          ancestor: Q
        });
        return;
      }
      const [q, L] = Array.isArray(M) ? M : [M, U === "ParenthesizedExpression"], N = U === "ArrayPattern" || U === "ObjectPattern" ? {
        type: U
      } : Q;
      for (let T of [].concat(Z[q]))
        if (T)
          this.checkLVal(T, {
            in: N,
            binding: J,
            checkClashes: X,
            strictModeChanged: z,
            hasParenthesizedAncestor: L
          });
    }
    checkIdentifier(Z, Q, J = !1) {
      if (this.state.strict && (J ? _z(Z.name, this.inModule) : hz(Z.name)))
        if (Q === 64)
          this.raise(C.StrictEvalArguments, Z, {
            referenceName: Z.name
          });
        else
          this.raise(C.StrictEvalArgumentsBinding, Z, {
            bindingName: Z.name
          });
      if (Q & 8192 && Z.name === "let")
        this.raise(C.LetInLexicalBinding, Z);
      if (!(Q & 64))
        this.declareNameFromIdentifier(Z, Q);
    }
    declareNameFromIdentifier(Z, Q) {
      this.scope.declareName(Z.name, Q, Z.loc.start);
    }
    checkToRestConversion(Z, Q) {
      switch (Z.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(Z.expression, Q);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (Q)
            break;
        default:
          this.raise(C.InvalidRestAssignmentPattern, Z);
      }
    }
    checkCommaAfterRest(Z) {
      if (!this.match(12))
        return !1;
      return this.raise(this.lookaheadCharCode() === Z ? C.RestTrailingComma : C.ElementAfterRest, this.state.startLoc), !0;
    }
  }
  var mK = (Z, Q) => Object.hasOwnProperty.call(Z, Q) && Z[Q], m = w1`typescript`({
    AbstractMethodHasImplementation: ({
      methodName: Z
    }) => `Method '${Z}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName: Z
    }) => `Property '${Z}' cannot have an initializer because it is marked abstract.`,
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind: Z
    }) => `'declare' is not allowed in ${Z}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier: Z
    }) => "Accessibility modifier already seen.",
    DuplicateModifier: ({
      modifier: Z
    }) => `Duplicate modifier: '${Z}'.`,
    EmptyHeritageClauseType: ({
      token: Z
    }) => `'${Z}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers: Z
    }) => `'${Z[0]}' modifier cannot be used with '${Z[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier: Z
    }) => `Index signatures cannot have an accessibility modifier ('${Z}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: ({
      modifier: Z
    }) => `'${Z}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier: Z
    }) => `'${Z}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier: Z
    }) => `'${Z}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifiersOrder: ({
      orderedModifiers: Z
    }) => `'${Z[0]}' modifier must precede '${Z[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier: Z
    }) => `Private elements cannot have an accessibility modifier ('${Z}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName: Z
    }) => `Single type parameter ${Z} should have a trailing comma. Example usage: <${Z},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type: Z
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${Z}.`
  }), lK = (Z) => class Q extends Z {
    constructor(...J) {
      super(...J);
      this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: m.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: m.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: m.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return ez;
    }
    tsIsIdentifier() {
      return K0(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(J, X) {
      if (!K0(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      const z = this.state.value;
      if (J.indexOf(z) !== -1) {
        if (X && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return z;
      }
      return;
    }
    tsParseModifiers({
      allowedModifiers: J,
      disallowedModifiers: X,
      stopOnStartOfClassStaticBlock: z,
      errorTemplate: Y = m.InvalidModifierOnTypeMember
    }, W) {
      const U = (M, q, L, N) => {
        if (q === L && W[N])
          this.raise(m.InvalidModifiersOrder, M, {
            orderedModifiers: [L, N]
          });
      }, V = (M, q, L, N) => {
        if (W[L] && q === N || W[N] && q === L)
          this.raise(m.IncompatibleModifiers, M, {
            modifiers: [L, N]
          });
      };
      for (;; ) {
        const {
          startLoc: M
        } = this.state, q = this.tsParseModifier(J.concat(X != null ? X : []), z);
        if (!q)
          break;
        if (Cz(q))
          if (W.accessibility)
            this.raise(m.DuplicateAccessibilityModifier, M, {
              modifier: q
            });
          else
            U(M, q, q, "override"), U(M, q, q, "static"), U(M, q, q, "readonly"), W.accessibility = q;
        else if (cK(q)) {
          if (W[q])
            this.raise(m.DuplicateModifier, M, {
              modifier: q
            });
          W[q] = !0, U(M, q, "in", "out");
        } else {
          if (Object.hasOwnProperty.call(W, q))
            this.raise(m.DuplicateModifier, M, {
              modifier: q
            });
          else
            U(M, q, "static", "readonly"), U(M, q, "static", "override"), U(M, q, "override", "readonly"), U(M, q, "abstract", "override"), V(M, q, "declare", "override"), V(M, q, "static", "abstract");
          W[q] = !0;
        }
        if (X != null && X.includes(q))
          this.raise(Y, M, {
            modifier: q
          });
      }
    }
    tsIsListTerminator(J) {
      switch (J) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(J, X) {
      const z = [];
      while (!this.tsIsListTerminator(J))
        z.push(X());
      return z;
    }
    tsParseDelimitedList(J, X, z) {
      return uK(this.tsParseDelimitedListWorker(J, X, !0, z));
    }
    tsParseDelimitedListWorker(J, X, z, Y) {
      const W = [];
      let U = -1;
      for (;; ) {
        if (this.tsIsListTerminator(J))
          break;
        U = -1;
        const V = X();
        if (V == null)
          return;
        if (W.push(V), this.eat(12)) {
          U = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(J))
          break;
        if (z)
          this.expect(12);
        return;
      }
      if (Y)
        Y.value = U;
      return W;
    }
    tsParseBracketedList(J, X, z, Y, W) {
      if (!Y)
        if (z)
          this.expect(0);
        else
          this.expect(47);
      const U = this.tsParseDelimitedList(J, X, W);
      if (z)
        this.expect(3);
      else
        this.expect(48);
      return U;
    }
    tsParseImportType() {
      const J = this.startNode();
      if (this.expect(83), this.expect(10), !this.match(133))
        this.raise(m.UnsupportedImportTypeArgument, this.state.startLoc);
      if (J.argument = super.parseExprAtom(), this.expect(11), this.eat(16))
        J.qualifier = this.tsParseEntityName();
      if (this.match(47))
        J.typeParameters = this.tsParseTypeArguments();
      return this.finishNode(J, "TSImportType");
    }
    tsParseEntityName(J = !0) {
      let X = this.parseIdentifier(J);
      while (this.eat(16)) {
        const z = this.startNodeAtNode(X);
        z.left = X, z.right = this.parseIdentifier(J), X = this.finishNode(z, "TSQualifiedName");
      }
      return X;
    }
    tsParseTypeReference() {
      const J = this.startNode();
      if (J.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47))
        J.typeParameters = this.tsParseTypeArguments();
      return this.finishNode(J, "TSTypeReference");
    }
    tsParseThisTypePredicate(J) {
      this.next();
      const X = this.startNodeAtNode(J);
      return X.parameterName = J, X.typeAnnotation = this.tsParseTypeAnnotation(!1), X.asserts = !1, this.finishNode(X, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const J = this.startNode();
      return this.next(), this.finishNode(J, "TSThisType");
    }
    tsParseTypeQuery() {
      const J = this.startNode();
      if (this.expect(87), this.match(83))
        J.exprName = this.tsParseImportType();
      else
        J.exprName = this.tsParseEntityName();
      if (!this.hasPrecedingLineBreak() && this.match(47))
        J.typeParameters = this.tsParseTypeArguments();
      return this.finishNode(J, "TSTypeQuery");
    }
    tsParseTypeParameter(J) {
      const X = this.startNode();
      return J(X), X.name = this.tsParseTypeParameterName(), X.constraint = this.tsEatThenParseType(81), X.default = this.tsEatThenParseType(29), this.finishNode(X, "TSTypeParameter");
    }
    tsTryParseTypeParameters(J) {
      if (this.match(47))
        return this.tsParseTypeParameters(J);
    }
    tsParseTypeParameters(J) {
      const X = this.startNode();
      if (this.match(47) || this.match(142))
        this.next();
      else
        this.unexpected();
      const z = {
        value: -1
      };
      if (X.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, J), !1, !0, z), X.params.length === 0)
        this.raise(m.EmptyTypeParameters, X);
      if (z.value !== -1)
        this.addExtra(X, "trailingComma", z.value);
      return this.finishNode(X, "TSTypeParameterDeclaration");
    }
    tsFillSignature(J, X) {
      const z = J === 19;
      if (X.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), X["parameters"] = this.tsParseBindingListForSignature(), z)
        X["typeAnnotation"] = this.tsParseTypeOrTypePredicateAnnotation(J);
      else if (this.match(J))
        X["typeAnnotation"] = this.tsParseTypeOrTypePredicateAnnotation(J);
    }
    tsParseBindingListForSignature() {
      const J = super.parseBindingList(11, 41, 2);
      for (let X of J) {
        const {
          type: z
        } = X;
        if (z === "AssignmentPattern" || z === "TSParameterProperty")
          this.raise(m.UnsupportedSignatureParameterKind, X, {
            type: z
          });
      }
      return J;
    }
    tsParseTypeMemberSemicolon() {
      if (!this.eat(12) && !this.isLineTerminator())
        this.expect(13);
    }
    tsParseSignatureMember(J, X) {
      return this.tsFillSignature(14, X), this.tsParseTypeMemberSemicolon(), this.finishNode(X, J);
    }
    tsIsUnambiguouslyIndexSignature() {
      if (this.next(), K0(this.state.type))
        return this.next(), this.match(14);
      return !1;
    }
    tsTryParseIndexSignature(J) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const X = this.parseIdentifier();
      X.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(X), this.expect(3), J.parameters = [X];
      const z = this.tsTryParseTypeAnnotation();
      if (z)
        J.typeAnnotation = z;
      return this.tsParseTypeMemberSemicolon(), this.finishNode(J, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(J, X) {
      if (this.eat(17))
        J.optional = !0;
      const z = J;
      if (this.match(10) || this.match(47)) {
        if (X)
          this.raise(m.ReadonlyForMethodSignature, J);
        const Y = z;
        if (Y.kind && this.match(47))
          this.raise(m.AccesorCannotHaveTypeParameters, this.state.curPosition());
        this.tsFillSignature(14, Y), this.tsParseTypeMemberSemicolon();
        const W = "parameters", U = "typeAnnotation";
        if (Y.kind === "get") {
          if (Y[W].length > 0) {
            if (this.raise(C.BadGetterArity, this.state.curPosition()), this.isThisParam(Y[W][0]))
              this.raise(m.AccesorCannotDeclareThisParameter, this.state.curPosition());
          }
        } else if (Y.kind === "set") {
          if (Y[W].length !== 1)
            this.raise(C.BadSetterArity, this.state.curPosition());
          else {
            const V = Y[W][0];
            if (this.isThisParam(V))
              this.raise(m.AccesorCannotDeclareThisParameter, this.state.curPosition());
            if (V.type === "Identifier" && V.optional)
              this.raise(m.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());
            if (V.type === "RestElement")
              this.raise(m.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          if (Y[U])
            this.raise(m.SetAccesorCannotHaveReturnType, Y[U]);
        } else
          Y.kind = "method";
        return this.finishNode(Y, "TSMethodSignature");
      } else {
        const Y = z;
        if (X)
          Y.readonly = !0;
        const W = this.tsTryParseTypeAnnotation();
        if (W)
          Y.typeAnnotation = W;
        return this.tsParseTypeMemberSemicolon(), this.finishNode(Y, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const J = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", J);
      if (this.match(77)) {
        const z = this.startNode();
        if (this.next(), this.match(10) || this.match(47))
          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", J);
        else
          return J.key = this.createIdentifier(z, "new"), this.tsParsePropertyOrMethodSignature(J, !1);
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, J);
      const X = this.tsTryParseIndexSignature(J);
      if (X)
        return X;
      if (super.parsePropertyName(J), !J.computed && J.key.type === "Identifier" && (J.key.name === "get" || J.key.name === "set") && this.tsTokenCanFollowModifier())
        J.kind = J.key.name, super.parsePropertyName(J);
      return this.tsParsePropertyOrMethodSignature(J, !!J.readonly);
    }
    tsParseTypeLiteral() {
      const J = this.startNode();
      return J.members = this.tsParseObjectTypeMembers(), this.finishNode(J, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const J = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), J;
    }
    tsIsStartOfMappedType() {
      if (this.next(), this.eat(53))
        return this.isContextual(122);
      if (this.isContextual(122))
        this.next();
      if (!this.match(0))
        return !1;
      if (this.next(), !this.tsIsIdentifier())
        return !1;
      return this.next(), this.match(58);
    }
    tsParseMappedTypeParameter() {
      const J = this.startNode();
      return J.name = this.tsParseTypeParameterName(), J.constraint = this.tsExpectThenParseType(58), this.finishNode(J, "TSTypeParameter");
    }
    tsParseMappedType() {
      const J = this.startNode();
      if (this.expect(5), this.match(53))
        J.readonly = this.state.value, this.next(), this.expectContextual(122);
      else if (this.eatContextual(122))
        J.readonly = !0;
      if (this.expect(0), J.typeParameter = this.tsParseMappedTypeParameter(), J.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53))
        J.optional = this.state.value, this.next(), this.expect(17);
      else if (this.eat(17))
        J.optional = !0;
      return J.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(J, "TSMappedType");
    }
    tsParseTupleType() {
      const J = this.startNode();
      J.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let X = !1;
      return J.elementTypes.forEach((z) => {
        const {
          type: Y
        } = z;
        if (X && Y !== "TSRestType" && Y !== "TSOptionalType" && !(Y === "TSNamedTupleMember" && z.optional))
          this.raise(m.OptionalTypeBeforeRequired, z);
        X || (X = Y === "TSNamedTupleMember" && z.optional || Y === "TSOptionalType");
      }), this.finishNode(J, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        startLoc: J
      } = this.state, X = this.eat(21);
      let z, Y, W, U;
      const M = G1(this.state.type) ? this.lookaheadCharCode() : null;
      if (M === 58)
        z = !0, W = !1, Y = this.parseIdentifier(!0), this.expect(14), U = this.tsParseType();
      else if (M === 63) {
        W = !0;
        const q = this.state.startLoc, L = this.state.value, N = this.tsParseNonArrayType();
        if (this.lookaheadCharCode() === 58)
          z = !0, Y = this.createIdentifier(this.startNodeAt(q), L), this.expect(17), this.expect(14), U = this.tsParseType();
        else
          z = !1, U = N, this.expect(17);
      } else
        U = this.tsParseType(), W = this.eat(17), z = this.eat(14);
      if (z) {
        let q;
        if (Y) {
          if (q = this.startNodeAtNode(Y), q.optional = W, q.label = Y, q.elementType = U, this.eat(17))
            q.optional = !0, this.raise(m.TupleOptionalAfterType, this.state.lastTokStartLoc);
        } else
          q = this.startNodeAtNode(U), q.optional = W, this.raise(m.InvalidTupleMemberLabel, U), q.label = U, q.elementType = this.tsParseType();
        U = this.finishNode(q, "TSNamedTupleMember");
      } else if (W) {
        const q = this.startNodeAtNode(U);
        q.typeAnnotation = U, U = this.finishNode(q, "TSOptionalType");
      }
      if (X) {
        const q = this.startNodeAt(J);
        q.typeAnnotation = U, U = this.finishNode(q, "TSRestType");
      }
      return U;
    }
    tsParseParenthesizedType() {
      const J = this.startNode();
      return this.expect(10), J.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(J, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(J, X) {
      const z = this.startNode();
      if (J === "TSConstructorType") {
        if (z.abstract = !!X, X)
          this.next();
        this.next();
      }
      return this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, z)), this.finishNode(z, J);
    }
    tsParseLiteralTypeNode() {
      const J = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          J.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(J, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const J = this.startNode();
      return J.literal = super.parseTemplate(!1), this.finishNode(J, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      if (this.state.inType)
        return this.tsParseType();
      return super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const J = this.tsParseThisTypeNode();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.tsParseThisTypePredicate(J);
      else
        return J;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const J = this.startNode(), X = this.lookahead();
            if (X.type !== 134 && X.type !== 135)
              this.unexpected();
            return J.literal = this.parseMaybeUnary(), this.finishNode(J, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: J
          } = this.state;
          if (K0(J) || J === 88 || J === 84) {
            const X = J === 88 ? "TSVoidKeyword" : J === 84 ? "TSNullKeyword" : xK(this.state.value);
            if (X !== void 0 && this.lookaheadCharCode() !== 46) {
              const z = this.startNode();
              return this.next(), this.finishNode(z, X);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let J = this.tsParseNonArrayType();
      while (!this.hasPrecedingLineBreak() && this.eat(0))
        if (this.match(3)) {
          const X = this.startNodeAtNode(J);
          X.elementType = J, this.expect(3), J = this.finishNode(X, "TSArrayType");
        } else {
          const X = this.startNodeAtNode(J);
          X.objectType = J, X.indexType = this.tsParseType(), this.expect(3), J = this.finishNode(X, "TSIndexedAccessType");
        }
      return J;
    }
    tsParseTypeOperator() {
      const J = this.startNode(), X = this.state.value;
      if (this.next(), J.operator = X, J.typeAnnotation = this.tsParseTypeOperatorOrHigher(), X === "readonly")
        this.tsCheckTypeAnnotationForReadOnly(J);
      return this.finishNode(J, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(J) {
      switch (J.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(m.UnexpectedReadonly, J);
      }
    }
    tsParseInferType() {
      const J = this.startNode();
      this.expectContextual(115);
      const X = this.startNode();
      return X.name = this.tsParseTypeParameterName(), X.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), J.typeParameter = this.finishNode(X, "TSTypeParameter"), this.finishNode(J, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const J = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return J;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return YK(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(J, X, z) {
      const Y = this.startNode(), W = this.eat(z), U = [];
      do
        U.push(X());
      while (this.eat(z));
      if (U.length === 1 && !W)
        return U[0];
      return Y.types = U, this.finishNode(Y, J);
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      if (this.match(47))
        return !0;
      return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (K0(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        const {
          errors: J
        } = this.state, X = J.length;
        try {
          return this.parseObjectLike(8, !0), J.length === X;
        } catch (z) {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: J
        } = this.state, X = J.length;
        try {
          return super.parseBindingList(3, 93, 1), J.length === X;
        } catch (z) {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      if (this.next(), this.match(11) || this.match(21))
        return !0;
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29))
          return !0;
        if (this.match(11)) {
          if (this.next(), this.match(19))
            return !0;
        }
      }
      return !1;
    }
    tsParseTypeOrTypePredicateAnnotation(J) {
      return this.tsInType(() => {
        const X = this.startNode();
        this.expect(J);
        const z = this.startNode(), Y = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (Y && this.match(78)) {
          let V = this.tsParseThisTypeOrThisTypePredicate();
          if (V.type === "TSThisType")
            z.parameterName = V, z.asserts = !0, z.typeAnnotation = null, V = this.finishNode(z, "TSTypePredicate");
          else
            this.resetStartLocationFromNode(V, z), V.asserts = !0;
          return X.typeAnnotation = V, this.finishNode(X, "TSTypeAnnotation");
        }
        const W = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!W) {
          if (!Y)
            return this.tsParseTypeAnnotation(!1, X);
          return z.parameterName = this.parseIdentifier(), z.asserts = Y, z.typeAnnotation = null, X.typeAnnotation = this.finishNode(z, "TSTypePredicate"), this.finishNode(X, "TSTypeAnnotation");
        }
        const U = this.tsParseTypeAnnotation(!1);
        return z.parameterName = W, z.typeAnnotation = U, z.asserts = Y, X.typeAnnotation = this.finishNode(z, "TSTypePredicate"), this.finishNode(X, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const J = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), J;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      const J = this.state.containsEsc;
      if (this.next(), !K0(this.state.type) && !this.match(78))
        return !1;
      if (J)
        this.raise(C.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
          reservedWord: "asserts"
        });
      return !0;
    }
    tsParseTypeAnnotation(J = !0, X = this.startNode()) {
      return this.tsInType(() => {
        if (J)
          this.expect(14);
        X.typeAnnotation = this.tsParseType();
      }), this.finishNode(X, "TSTypeAnnotation");
    }
    tsParseType() {
      Iz(this.state.inType);
      const J = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return J;
      const X = this.startNodeAtNode(J);
      return X.checkType = J, X.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), X.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), X.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(X, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType())
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      if (this.match(77))
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      else if (this.isAbstractConstructorSignature())
        return this.tsParseFunctionOrConstructorType("TSConstructorType", !0);
      return this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike"))
        this.raise(m.ReservedTypeAssertion, this.state.startLoc);
      const J = this.startNode();
      return J.typeAnnotation = this.tsInType(() => {
        return this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
      }), this.expect(48), J.expression = this.parseMaybeUnary(), this.finishNode(J, "TSTypeAssertion");
    }
    tsParseHeritageClause(J) {
      const X = this.state.startLoc, z = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const Y = this.startNode();
        if (Y.expression = this.tsParseEntityName(), this.match(47))
          Y.typeParameters = this.tsParseTypeArguments();
        return this.finishNode(Y, "TSExpressionWithTypeArguments");
      });
      if (!z.length)
        this.raise(m.EmptyHeritageClauseType, X, {
          token: J
        });
      return z;
    }
    tsParseInterfaceDeclaration(J, X = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      if (this.expectContextual(129), X.declare)
        J.declare = !0;
      if (K0(this.state.type))
        J.id = this.parseIdentifier(), this.checkIdentifier(J.id, 130);
      else
        J.id = null, this.raise(m.MissingInterfaceName, this.state.startLoc);
      if (J.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81))
        J.extends = this.tsParseHeritageClause("extends");
      const z = this.startNode();
      return z.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), J.body = this.finishNode(z, "TSInterfaceBody"), this.finishNode(J, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(J) {
      return J.id = this.parseIdentifier(), this.checkIdentifier(J.id, 2), J.typeAnnotation = this.tsInType(() => {
        if (J.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          const X = this.startNode();
          return this.next(), this.finishNode(X, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(J, "TSTypeAliasDeclaration");
    }
    tsInNoContext(J) {
      const X = this.state.context;
      this.state.context = [X[0]];
      try {
        return J();
      } finally {
        this.state.context = X;
      }
    }
    tsInType(J) {
      const X = this.state.inType;
      this.state.inType = !0;
      try {
        return J();
      } finally {
        this.state.inType = X;
      }
    }
    tsInDisallowConditionalTypesContext(J) {
      const X = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return J();
      } finally {
        this.state.inDisallowConditionalTypesContext = X;
      }
    }
    tsInAllowConditionalTypesContext(J) {
      const X = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return J();
      } finally {
        this.state.inDisallowConditionalTypesContext = X;
      }
    }
    tsEatThenParseType(J) {
      if (this.match(J))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(J) {
      return this.tsInType(() => {
        return this.expect(J), this.tsParseType();
      });
    }
    tsNextThenParseType() {
      return this.tsInType(() => {
        return this.next(), this.tsParseType();
      });
    }
    tsParseEnumMember() {
      const J = this.startNode();
      if (J.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29))
        J.initializer = super.parseMaybeAssignAllowIn();
      return this.finishNode(J, "TSEnumMember");
    }
    tsParseEnumDeclaration(J, X = {}) {
      if (X.const)
        J.const = !0;
      if (X.declare)
        J.declare = !0;
      return this.expectContextual(126), J.id = this.parseIdentifier(), this.checkIdentifier(J.id, J.const ? 8971 : 8459), this.expect(5), J.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(J, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const J = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(J.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(J, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(J, X = !1) {
      if (J.id = this.parseIdentifier(), !X)
        this.checkIdentifier(J.id, 1024);
      if (this.eat(16)) {
        const z = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(z, !0), J.body = z;
      } else
        this.scope.enter(256), this.prodParam.enter(0), J.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(J, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(J) {
      if (this.isContextual(112))
        J.global = !0, J.id = this.parseIdentifier();
      else if (this.match(133))
        J.id = super.parseStringLiteral(this.state.value);
      else
        this.unexpected();
      if (this.match(5))
        this.scope.enter(256), this.prodParam.enter(0), J.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      else
        this.semicolon();
      return this.finishNode(J, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(J, X, z) {
      J.isExport = z || !1, J.id = X || this.parseIdentifier(), this.checkIdentifier(J.id, 4096), this.expect(29);
      const Y = this.tsParseModuleReference();
      if (J.importKind === "type" && Y.type !== "TSExternalModuleReference")
        this.raise(m.ImportAliasHasImportType, Y);
      return J.moduleReference = Y, this.semicolon(), this.finishNode(J, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      const J = this.startNode();
      if (this.expectContextual(119), this.expect(10), !this.match(133))
        this.unexpected();
      return J.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(J, "TSExternalModuleReference");
    }
    tsLookAhead(J) {
      const X = this.state.clone(), z = J();
      return this.state = X, z;
    }
    tsTryParseAndCatch(J) {
      const X = this.tryParse((z) => J() || z());
      if (X.aborted || !X.node)
        return;
      if (X.error)
        this.state = X.failState;
      return X.node;
    }
    tsTryParse(J) {
      const X = this.state.clone(), z = J();
      if (z !== void 0 && z !== !1)
        return z;
      this.state = X;
    }
    tsTryParseDeclare(J) {
      if (this.isLineTerminator())
        return;
      let X = this.state.type, z;
      if (this.isContextual(100))
        X = 74, z = "let";
      return this.tsInAmbientContext(() => {
        switch (X) {
          case 68:
            return J.declare = !0, super.parseFunctionStatement(J, !1, !1);
          case 80:
            return J.declare = !0, this.parseClass(J, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(J, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(J);
          case 75:
          case 74:
            if (!this.match(75) || !this.isLookaheadContextual("enum"))
              return J.declare = !0, this.parseVarStatement(J, z || this.state.value, !0);
            return this.expect(75), this.tsParseEnumDeclaration(J, {
              const: !0,
              declare: !0
            });
          case 129: {
            const Y = this.tsParseInterfaceDeclaration(J, {
              declare: !0
            });
            if (Y)
              return Y;
          }
          default:
            if (K0(X))
              return this.tsParseDeclaration(J, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(J, X, z) {
      switch (X.name) {
        case "declare": {
          const Y = this.tsTryParseDeclare(J);
          if (Y)
            Y.declare = !0;
          return Y;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const Y = J;
            return Y.global = !0, Y.id = X, Y.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(Y, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(J, X.name, !1, z);
      }
    }
    tsParseDeclaration(J, X, z, Y) {
      switch (X) {
        case "abstract":
          if (this.tsCheckLineTerminator(z) && (this.match(80) || K0(this.state.type)))
            return this.tsParseAbstractDeclaration(J, Y);
          break;
        case "module":
          if (this.tsCheckLineTerminator(z)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(J);
            else if (K0(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(J);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(z) && K0(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(J);
          break;
        case "type":
          if (this.tsCheckLineTerminator(z) && K0(this.state.type))
            return this.tsParseTypeAliasDeclaration(J);
          break;
      }
    }
    tsCheckLineTerminator(J) {
      if (J) {
        if (this.hasFollowingLineBreak())
          return !1;
        return this.next(), !0;
      }
      return !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(J) {
      if (!this.match(47))
        return;
      const X = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      const z = this.tsTryParseAndCatch(() => {
        const Y = this.startNodeAt(J);
        return Y.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(Y), Y.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), Y;
      });
      if (this.state.maybeInArrowParameters = X, !z)
        return;
      return super.parseArrowExpression(z, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() !== 47)
        return;
      return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const J = this.startNode();
      if (J.params = this.tsInType(() => this.tsInNoContext(() => {
        return this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
      })), J.params.length === 0)
        this.raise(m.EmptyTypeArguments, J);
      else if (!this.state.inType && this.curContext() === j0.brace)
        this.reScan_lt_gt();
      return this.expect(48), this.finishNode(J, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return WK(this.state.type);
    }
    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart())
        return !1;
      return super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(J, X) {
      const z = this.state.startLoc, Y = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, Y);
      const { accessibility: W, override: U, readonly: V } = Y;
      if (!(J & 4) && (W || V || U))
        this.raise(m.UnexpectedParameterModifier, z);
      const M = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(M, J);
      const q = this.parseMaybeDefault(M.loc.start, M);
      if (W || V || U) {
        const L = this.startNodeAt(z);
        if (X.length)
          L.decorators = X;
        if (W)
          L.accessibility = W;
        if (V)
          L.readonly = V;
        if (U)
          L.override = U;
        if (q.type !== "Identifier" && q.type !== "AssignmentPattern")
          this.raise(m.UnsupportedParameterPropertyKind, L);
        return L.parameter = q, this.finishNode(L, "TSParameterProperty");
      }
      if (X.length)
        M.decorators = X;
      return q;
    }
    isSimpleParameter(J) {
      return J.type === "TSParameterProperty" && super.isSimpleParameter(J.parameter) || super.isSimpleParameter(J);
    }
    tsDisallowOptionalPattern(J) {
      for (let X of J.params)
        if (X.type !== "Identifier" && X.optional && !this.state.isAmbientContext)
          this.raise(m.PatternIsOptional, X);
    }
    setArrowFunctionParameters(J, X, z) {
      super.setArrowFunctionParameters(J, X, z), this.tsDisallowOptionalPattern(J);
    }
    parseFunctionBodyAndFinish(J, X, z = !1) {
      if (this.match(14))
        J.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
      const Y = X === "FunctionDeclaration" ? "TSDeclareFunction" : X === "ClassMethod" || X === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      if (Y && !this.match(5) && this.isLineTerminator())
        return this.finishNode(J, Y);
      if (Y === "TSDeclareFunction" && this.state.isAmbientContext) {
        if (this.raise(m.DeclareFunctionHasImplementation, J), J.declare)
          return super.parseFunctionBodyAndFinish(J, Y, z);
      }
      return this.tsDisallowOptionalPattern(J), super.parseFunctionBodyAndFinish(J, X, z);
    }
    registerFunctionStatementId(J) {
      if (!J.body && J.id)
        this.checkIdentifier(J.id, 1024);
      else
        super.registerFunctionStatementId(J);
    }
    tsCheckForInvalidTypeCasts(J) {
      J.forEach((X) => {
        if ((X == null ? void 0 : X.type) === "TSTypeCastExpression")
          this.raise(m.UnexpectedTypeAnnotation, X.typeAnnotation);
      });
    }
    toReferencedList(J, X) {
      return this.tsCheckForInvalidTypeCasts(J), J;
    }
    parseArrayLike(J, X, z, Y) {
      const W = super.parseArrayLike(J, X, z, Y);
      if (W.type === "ArrayExpression")
        this.tsCheckForInvalidTypeCasts(W.elements);
      return W;
    }
    parseSubscript(J, X, z, Y) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        const U = this.startNodeAt(X);
        return U.expression = J, this.finishNode(U, "TSNonNullExpression");
      }
      let W = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (z)
          return Y.stop = !0, J;
        Y.optionalChainMember = W = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let U;
        const V = this.tsTryParseAndCatch(() => {
          if (!z && this.atPossibleAsyncArrow(J)) {
            const N = this.tsTryParseGenericAsyncArrowFunction(X);
            if (N)
              return N;
          }
          const M = this.tsParseTypeArgumentsInExpression();
          if (!M)
            return;
          if (W && !this.match(10)) {
            U = this.state.curPosition();
            return;
          }
          if (W7(this.state.type)) {
            const N = super.parseTaggedTemplateExpression(J, X, Y);
            return N.typeParameters = M, N;
          }
          if (!z && this.eat(10)) {
            const N = this.startNodeAt(X);
            if (N.callee = J, N.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(N.arguments), N.typeParameters = M, Y.optionalChainMember)
              N.optional = W;
            return this.finishCallExpression(N, Y.optionalChainMember);
          }
          const q = this.state.type;
          if (q === 48 || q === 52 || q !== 10 && A6(q) && !this.hasPrecedingLineBreak())
            return;
          const L = this.startNodeAt(X);
          return L.expression = J, L.typeParameters = M, this.finishNode(L, "TSInstantiationExpression");
        });
        if (U)
          this.unexpected(U, 10);
        if (V) {
          if (V.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40))
            this.raise(m.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
          return V;
        }
      }
      return super.parseSubscript(J, X, z, Y);
    }
    parseNewCallee(J) {
      var X;
      super.parseNewCallee(J);
      const {
        callee: z
      } = J;
      if (z.type === "TSInstantiationExpression" && !((X = z.extra) != null && X.parenthesized))
        J.typeParameters = z.typeParameters, J.callee = z.expression;
    }
    parseExprOp(J, X, z) {
      let Y;
      if (z7(58) > z && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (Y = this.isContextual(120)))) {
        const W = this.startNodeAt(X);
        return W.expression = J, W.typeAnnotation = this.tsInType(() => {
          if (this.next(), this.match(75)) {
            if (Y)
              this.raise(C.UnexpectedKeyword, this.state.startLoc, {
                keyword: "const"
              });
            return this.tsParseTypeReference();
          }
          return this.tsParseType();
        }), this.finishNode(W, Y ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(W, X, z);
      }
      return super.parseExprOp(J, X, z);
    }
    checkReservedWord(J, X, z, Y) {
      if (!this.state.isAmbientContext)
        super.checkReservedWord(J, X, z, Y);
    }
    checkImportReflection(J) {
      if (super.checkImportReflection(J), J.module && J.importKind !== "value")
        this.raise(m.ImportReflectionHasImportType, J.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(J) {
      if (super.isPotentialImportPhase(J))
        return !0;
      if (this.isContextual(130)) {
        const X = this.lookaheadCharCode();
        return J ? X === 123 || X === 42 : X !== 61;
      }
      return !J && this.isContextual(87);
    }
    applyImportPhase(J, X, z, Y) {
      if (super.applyImportPhase(J, X, z, Y), X)
        J.exportKind = z === "type" ? "type" : "value";
      else
        J.importKind = z === "type" || z === "typeof" ? z : "value";
    }
    parseImport(J) {
      if (this.match(133))
        return J.importKind = "value", super.parseImport(J);
      let X;
      if (K0(this.state.type) && this.lookaheadCharCode() === 61)
        return J.importKind = "value", this.tsParseImportEqualsDeclaration(J);
      else if (this.isContextual(130)) {
        const z = this.parseMaybeImportPhase(J, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(J, z);
        else
          X = super.parseImportSpecifiersAndAfter(J, z);
      } else
        X = super.parseImport(J);
      if (X.importKind === "type" && X.specifiers.length > 1 && X.specifiers[0].type === "ImportDefaultSpecifier")
        this.raise(m.TypeImportCannotSpecifyDefaultAndNamed, X);
      return X;
    }
    parseExport(J, X) {
      if (this.match(83)) {
        this.next();
        let z = null;
        if (this.isContextual(130) && this.isPotentialImportPhase(!1))
          z = this.parseMaybeImportPhase(J, !1);
        else
          J.importKind = "value";
        return this.tsParseImportEqualsDeclaration(J, z, !0);
      } else if (this.eat(29)) {
        const z = J;
        return z.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(z, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const z = J;
        return this.expectContextual(128), z.id = this.parseIdentifier(), this.semicolon(), this.finishNode(z, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(J, X);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const J = this.startNode();
        return this.next(), J.abstract = !0, this.parseClass(J, !0, !0);
      }
      if (this.match(129)) {
        const J = this.tsParseInterfaceDeclaration(this.startNode());
        if (J)
          return J;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(J, X, z = !1) {
      const {
        isAmbientContext: Y
      } = this.state, W = super.parseVarStatement(J, X, z || Y);
      if (!Y)
        return W;
      for (let {
        id: U,
        init: V
      } of W.declarations) {
        if (!V)
          continue;
        if (X !== "const" || !!U.typeAnnotation)
          this.raise(m.InitializerNotAllowedInAmbientContext, V);
        else if (!dK(V, this.hasPlugin("estree")))
          this.raise(m.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, V);
      }
      return W;
    }
    parseStatementContent(J, X) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const z = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(z, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const z = this.tsParseInterfaceDeclaration(this.startNode());
        if (z)
          return z;
      }
      return super.parseStatementContent(J, X);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(J, X) {
      return X.some((z) => {
        if (Cz(z))
          return J.accessibility === z;
        return !!J[z];
      });
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(J, X, z) {
      const Y = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: Y,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: m.InvalidModifierOnTypeParameterPositions
      }, X);
      const W = () => {
        if (this.tsIsStartOfStaticBlocks()) {
          if (this.next(), this.next(), this.tsHasSomeModifiers(X, Y))
            this.raise(m.StaticBlockCannotHaveModifier, this.state.curPosition());
          super.parseClassStaticBlock(J, X);
        } else
          this.parseClassMemberWithIsStatic(J, X, z, !!X.static);
      };
      if (X.declare)
        this.tsInAmbientContext(W);
      else
        W();
    }
    parseClassMemberWithIsStatic(J, X, z, Y) {
      const W = this.tsTryParseIndexSignature(X);
      if (W) {
        if (J.body.push(W), X.abstract)
          this.raise(m.IndexSignatureHasAbstract, X);
        if (X.accessibility)
          this.raise(m.IndexSignatureHasAccessibility, X, {
            modifier: X.accessibility
          });
        if (X.declare)
          this.raise(m.IndexSignatureHasDeclare, X);
        if (X.override)
          this.raise(m.IndexSignatureHasOverride, X);
        return;
      }
      if (!this.state.inAbstractClass && X.abstract)
        this.raise(m.NonAbstractClassHasAbstractMethod, X);
      if (X.override) {
        if (!z.hadSuperClass)
          this.raise(m.OverrideNotInSubClass, X);
      }
      super.parseClassMemberWithIsStatic(J, X, z, Y);
    }
    parsePostMemberNameModifiers(J) {
      if (this.eat(17))
        J.optional = !0;
      if (J.readonly && this.match(10))
        this.raise(m.ClassMethodHasReadonly, J);
      if (J.declare && this.match(10))
        this.raise(m.ClassMethodHasDeclare, J);
    }
    parseExpressionStatement(J, X, z) {
      return (X.type === "Identifier" ? this.tsParseExpressionStatement(J, X, z) : void 0) || super.parseExpressionStatement(J, X, z);
    }
    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart())
        return !0;
      return super.shouldParseExportDeclaration();
    }
    parseConditional(J, X, z) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(J, X, z);
      const Y = this.tryParse(() => super.parseConditional(J, X));
      if (!Y.node) {
        if (Y.error)
          super.setOptionalParametersError(z, Y.error);
        return J;
      }
      if (Y.error)
        this.state = Y.failState;
      return Y.node;
    }
    parseParenItem(J, X) {
      if (J = super.parseParenItem(J, X), this.eat(17))
        J.optional = !0, this.resetEndLocation(J);
      if (this.match(14)) {
        const z = this.startNodeAt(X);
        return z.expression = J, z.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(z, "TSTypeCastExpression");
      }
      return J;
    }
    parseExportDeclaration(J) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(J));
      const X = this.state.startLoc, z = this.eatContextual(125);
      if (z && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(m.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const W = K0(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(J);
      if (!W)
        return null;
      if (W.type === "TSInterfaceDeclaration" || W.type === "TSTypeAliasDeclaration" || z)
        J.exportKind = "type";
      if (z)
        this.resetStartLocation(W, X), W.declare = !0;
      return W;
    }
    parseClassId(J, X, z, Y) {
      if ((!X || z) && this.isContextual(113))
        return;
      super.parseClassId(J, X, z, J.declare ? 1024 : 8331);
      const W = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      if (W)
        J.typeParameters = W;
    }
    parseClassPropertyAnnotation(J) {
      if (!J.optional) {
        if (this.eat(35))
          J.definite = !0;
        else if (this.eat(17))
          J.optional = !0;
      }
      const X = this.tsTryParseTypeAnnotation();
      if (X)
        J.typeAnnotation = X;
    }
    parseClassProperty(J) {
      if (this.parseClassPropertyAnnotation(J), this.state.isAmbientContext && !(J.readonly && !J.typeAnnotation) && this.match(29))
        this.raise(m.DeclareClassFieldHasInitializer, this.state.startLoc);
      if (J.abstract && this.match(29)) {
        const {
          key: X
        } = J;
        this.raise(m.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: X.type === "Identifier" && !J.computed ? X.name : `[${this.input.slice(X.start, X.end)}]`
        });
      }
      return super.parseClassProperty(J);
    }
    parseClassPrivateProperty(J) {
      if (J.abstract)
        this.raise(m.PrivateElementHasAbstract, J);
      if (J.accessibility)
        this.raise(m.PrivateElementHasAccessibility, J, {
          modifier: J.accessibility
        });
      return this.parseClassPropertyAnnotation(J), super.parseClassPrivateProperty(J);
    }
    parseClassAccessorProperty(J) {
      if (this.parseClassPropertyAnnotation(J), J.optional)
        this.raise(m.AccessorCannotBeOptional, J);
      return super.parseClassAccessorProperty(J);
    }
    pushClassMethod(J, X, z, Y, W, U) {
      const V = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (V && W)
        this.raise(m.ConstructorHasTypeParameters, V);
      const {
        declare: M = !1,
        kind: q
      } = X;
      if (M && (q === "get" || q === "set"))
        this.raise(m.DeclareAccessor, X, {
          kind: q
        });
      if (V)
        X.typeParameters = V;
      super.pushClassMethod(J, X, z, Y, W, U);
    }
    pushClassPrivateMethod(J, X, z, Y) {
      const W = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (W)
        X.typeParameters = W;
      super.pushClassPrivateMethod(J, X, z, Y);
    }
    declareClassPrivateMethodInScope(J, X) {
      if (J.type === "TSDeclareMethod")
        return;
      if (J.type === "MethodDefinition" && !J.value.body)
        return;
      super.declareClassPrivateMethodInScope(J, X);
    }
    parseClassSuper(J) {
      if (super.parseClassSuper(J), J.superClass && (this.match(47) || this.match(51)))
        J.superTypeParameters = this.tsParseTypeArgumentsInExpression();
      if (this.eatContextual(113))
        J.implements = this.tsParseHeritageClause("implements");
    }
    parseObjPropValue(J, X, z, Y, W, U, V) {
      const M = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (M)
        J.typeParameters = M;
      return super.parseObjPropValue(J, X, z, Y, W, U, V);
    }
    parseFunctionParams(J, X) {
      const z = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (z)
        J.typeParameters = z;
      super.parseFunctionParams(J, X);
    }
    parseVarId(J, X) {
      if (super.parseVarId(J, X), J.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35))
        J.definite = !0;
      const z = this.tsTryParseTypeAnnotation();
      if (z)
        J.id.typeAnnotation = z, this.resetEndLocation(J.id);
    }
    parseAsyncArrowFromCallExpression(J, X) {
      if (this.match(14))
        J.returnType = this.tsParseTypeAnnotation();
      return super.parseAsyncArrowFromCallExpression(J, X);
    }
    parseMaybeAssign(J, X) {
      var z, Y, W, U, V;
      let M, q, L;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (M = this.state.clone(), q = this.tryParse(() => super.parseMaybeAssign(J, X), M), !q.error)
          return q.node;
        const {
          context: E
        } = this.state, g = E[E.length - 1];
        if (g === j0.j_oTag || g === j0.j_expr)
          E.pop();
      }
      if (!((z = q) != null && z.error) && !this.match(47))
        return super.parseMaybeAssign(J, X);
      if (!M || M === this.state)
        M = this.state.clone();
      let N;
      const T = this.tryParse((E) => {
        var g, n;
        N = this.tsParseTypeParameters(this.tsParseConstModifier);
        const x = super.parseMaybeAssign(J, X);
        if (x.type !== "ArrowFunctionExpression" || (g = x.extra) != null && g.parenthesized)
          E();
        if (((n = N) == null ? void 0 : n.params.length) !== 0)
          this.resetStartLocationFromNode(x, N);
        return x.typeParameters = N, x;
      }, M);
      if (!T.error && !T.aborted) {
        if (N)
          this.reportReservedArrowTypeParam(N);
        return T.node;
      }
      if (!q) {
        if (Iz(!this.hasPlugin("jsx")), L = this.tryParse(() => super.parseMaybeAssign(J, X), M), !L.error)
          return L.node;
      }
      if ((Y = q) != null && Y.node)
        return this.state = q.failState, q.node;
      if (T.node) {
        if (this.state = T.failState, N)
          this.reportReservedArrowTypeParam(N);
        return T.node;
      }
      if ((W = L) != null && W.node)
        return this.state = L.failState, L.node;
      throw ((U = q) == null ? void 0 : U.error) || T.error || ((V = L) == null ? void 0 : V.error);
    }
    reportReservedArrowTypeParam(J) {
      var X;
      if (J.params.length === 1 && !J.params[0].constraint && !((X = J.extra) != null && X.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike"))
        this.raise(m.ReservedArrowTypeParam, J);
    }
    parseMaybeUnary(J, X) {
      if (!this.hasPlugin("jsx") && this.match(47))
        return this.tsParseTypeAssertion();
      return super.parseMaybeUnary(J, X);
    }
    parseArrow(J) {
      if (this.match(14)) {
        const X = this.tryParse((z) => {
          const Y = this.tsParseTypeOrTypePredicateAnnotation(14);
          if (this.canInsertSemicolon() || !this.match(19))
            z();
          return Y;
        });
        if (X.aborted)
          return;
        if (!X.thrown) {
          if (X.error)
            this.state = X.failState;
          J.returnType = X.node;
        }
      }
      return super.parseArrow(J);
    }
    parseAssignableListItemTypes(J, X) {
      if (!(X & 2))
        return J;
      if (this.eat(17))
        J.optional = !0;
      const z = this.tsTryParseTypeAnnotation();
      if (z)
        J.typeAnnotation = z;
      return this.resetEndLocation(J), J;
    }
    isAssignable(J, X) {
      switch (J.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(J.expression, X);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(J, X);
      }
    }
    toAssignable(J, X = !1) {
      switch (J.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(J, X);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          if (X)
            this.expressionScope.recordArrowParameterBindingError(m.UnexpectedTypeCastInParameter, J);
          else
            this.raise(m.UnexpectedTypeCastInParameter, J);
          this.toAssignable(J.expression, X);
          break;
        case "AssignmentExpression":
          if (!X && J.left.type === "TSTypeCastExpression")
            J.left = this.typeCastToParameter(J.left);
        default:
          super.toAssignable(J, X);
      }
    }
    toAssignableParenthesizedExpression(J, X) {
      switch (J.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(J.expression, X);
          break;
        default:
          super.toAssignable(J, X);
      }
    }
    checkToRestConversion(J, X) {
      switch (J.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(J.expression, !1);
          break;
        default:
          super.checkToRestConversion(J, X);
      }
    }
    isValidLVal(J, X, z) {
      return mK({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (z !== 64 || !X) && ["expression", !0],
        TSSatisfiesExpression: (z !== 64 || !X) && ["expression", !0],
        TSTypeAssertion: (z !== 64 || !X) && ["expression", !0]
      }, J) || super.isValidLVal(J, X, z);
    }
    parseBindingAtom() {
      if (this.state.type === 78)
        return this.parseIdentifier(!0);
      return super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(J) {
      if (this.match(47) || this.match(51)) {
        const X = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const z = super.parseMaybeDecoratorArguments(J);
          return z.typeParameters = X, z;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(J);
    }
    checkCommaAfterRest(J) {
      if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === J)
        return this.next(), !1;
      return super.checkCommaAfterRest(J);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(J, X) {
      const z = super.parseMaybeDefault(J, X);
      if (z.type === "AssignmentPattern" && z.typeAnnotation && z.right.start < z.typeAnnotation.start)
        this.raise(m.TypeAnnotationAfterAssign, z.typeAnnotation);
      return z;
    }
    getTokenFromCode(J) {
      if (this.state.inType) {
        if (J === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (J === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(J);
    }
    reScan_lt_gt() {
      const {
        type: J
      } = this.state;
      if (J === 47)
        this.state.pos -= 1, this.readToken_lt();
      else if (J === 48)
        this.state.pos -= 1, this.readToken_gt();
    }
    reScan_lt() {
      const {
        type: J
      } = this.state;
      if (J === 51)
        return this.state.pos -= 2, this.finishOp(47, 1), 47;
      return J;
    }
    toAssignableList(J, X, z) {
      for (let Y = 0;Y < J.length; Y++) {
        const W = J[Y];
        if ((W == null ? void 0 : W.type) === "TSTypeCastExpression")
          J[Y] = this.typeCastToParameter(W);
      }
      super.toAssignableList(J, X, z);
    }
    typeCastToParameter(J) {
      return J.expression.typeAnnotation = J.typeAnnotation, this.resetEndLocation(J.expression, J.typeAnnotation.loc.end), J.expression;
    }
    shouldParseArrow(J) {
      if (this.match(14))
        return J.every((X) => this.isAssignable(X, !0));
      return super.shouldParseArrow(J);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(J) {
      if (this.match(47) || this.match(51)) {
        const X = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        if (X)
          J.typeParameters = X;
      }
      return super.jsxParseOpeningElementAfterName(J);
    }
    getGetterSetterExpectedParamCount(J) {
      const X = super.getGetterSetterExpectedParamCount(J), Y = this.getObjectOrClassMethodParams(J)[0];
      return Y && this.isThisParam(Y) ? X + 1 : X;
    }
    parseCatchClauseParam() {
      const J = super.parseCatchClauseParam(), X = this.tsTryParseTypeAnnotation();
      if (X)
        J.typeAnnotation = X, this.resetEndLocation(J);
      return J;
    }
    tsInAmbientContext(J) {
      const X = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return J();
      } finally {
        this.state.isAmbientContext = X;
      }
    }
    parseClass(J, X, z) {
      const Y = this.state.inAbstractClass;
      this.state.inAbstractClass = !!J.abstract;
      try {
        return super.parseClass(J, X, z);
      } finally {
        this.state.inAbstractClass = Y;
      }
    }
    tsParseAbstractDeclaration(J, X) {
      if (this.match(80))
        return J.abstract = !0, this.maybeTakeDecorators(X, this.parseClass(J, !0, !1));
      else if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return J.abstract = !0, this.raise(m.NonClassMethodPropertyHasAbstractModifer, J), this.tsParseInterfaceDeclaration(J);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(J, X, z, Y, W, U, V) {
      const M = super.parseMethod(J, X, z, Y, W, U, V);
      if (M.abstract) {
        if (this.hasPlugin("estree") ? !!M.value.body : !!M.body) {
          const {
            key: L
          } = M;
          this.raise(m.AbstractMethodHasImplementation, M, {
            methodName: L.type === "Identifier" && !M.computed ? L.name : `[${this.input.slice(L.start, L.end)}]`
          });
        }
      }
      return M;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      if (this.shouldParseAsAmbientContext())
        this.state.isAmbientContext = !0;
      return super.parse();
    }
    getExpression() {
      if (this.shouldParseAsAmbientContext())
        this.state.isAmbientContext = !0;
      return super.getExpression();
    }
    parseExportSpecifier(J, X, z, Y) {
      if (!X && Y)
        return this.parseTypeOnlyImportExportSpecifier(J, !1, z), this.finishNode(J, "ExportSpecifier");
      return J.exportKind = "value", super.parseExportSpecifier(J, X, z, Y);
    }
    parseImportSpecifier(J, X, z, Y, W) {
      if (!X && Y)
        return this.parseTypeOnlyImportExportSpecifier(J, !0, z), this.finishNode(J, "ImportSpecifier");
      return J.importKind = "value", super.parseImportSpecifier(J, X, z, Y, z ? 4098 : 4096);
    }
    parseTypeOnlyImportExportSpecifier(J, X, z) {
      const Y = X ? "imported" : "local", W = X ? "local" : "exported";
      let U = J[Y], V, M = !1, q = !0;
      const L = U.loc.start;
      if (this.isContextual(93)) {
        const T = this.parseIdentifier();
        if (this.isContextual(93)) {
          const E = this.parseIdentifier();
          if (G1(this.state.type))
            M = !0, U = T, V = X ? this.parseIdentifier() : this.parseModuleExportName(), q = !1;
          else
            V = E, q = !1;
        } else if (G1(this.state.type))
          q = !1, V = X ? this.parseIdentifier() : this.parseModuleExportName();
        else
          M = !0, U = T;
      } else if (G1(this.state.type))
        if (M = !0, X) {
          if (U = this.parseIdentifier(!0), !this.isContextual(93))
            this.checkReservedWord(U.name, U.loc.start, !0, !0);
        } else
          U = this.parseModuleExportName();
      if (M && z)
        this.raise(X ? m.TypeModifierIsUsedInTypeImports : m.TypeModifierIsUsedInTypeExports, L);
      J[Y] = U, J[W] = V;
      const N = X ? "importKind" : "exportKind";
      if (J[N] = M ? "type" : "value", q && this.eatContextual(93))
        J[W] = X ? this.parseIdentifier() : this.parseModuleExportName();
      if (!J[W])
        J[W] = v1(J[Y]);
      if (X)
        this.checkIdentifier(J[W], M ? 4098 : 4096);
    }
  }, Az = w1`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), aK = (Z) => class Q extends Z {
    parsePlaceholder(J) {
      if (this.match(144)) {
        const X = this.startNode();
        return this.next(), this.assertNoSpace(), X.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(X, J);
      }
    }
    finishPlaceholder(J, X) {
      const z = !!(J.expectedNode && J.type === "Placeholder");
      return J.expectedNode = X, z ? J : this.finishNode(J, "Placeholder");
    }
    getTokenFromCode(J) {
      if (J === 37 && this.input.charCodeAt(this.state.pos + 1) === 37)
        this.finishOp(144, 2);
      else
        super.getTokenFromCode(J);
    }
    parseExprAtom(J) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(J);
    }
    parseIdentifier(J) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(J);
    }
    checkReservedWord(J, X, z, Y) {
      if (J !== void 0)
        super.checkReservedWord(J, X, z, Y);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(J, X, z) {
      return J === "Placeholder" || super.isValidLVal(J, X, z);
    }
    toAssignable(J, X) {
      if (J && J.type === "Placeholder" && J.expectedNode === "Expression")
        J.expectedNode = "Pattern";
      else
        super.toAssignable(J, X);
    }
    chStartsBindingIdentifier(J, X) {
      if (super.chStartsBindingIdentifier(J, X))
        return !0;
      if (this.lookahead().type === 144)
        return !0;
      return !1;
    }
    verifyBreakContinue(J, X) {
      if (J.label && J.label.type === "Placeholder")
        return;
      super.verifyBreakContinue(J, X);
    }
    parseExpressionStatement(J, X) {
      var z;
      if (X.type !== "Placeholder" || (z = X.extra) != null && z.parenthesized)
        return super.parseExpressionStatement(J, X);
      if (this.match(14)) {
        const Y = J;
        return Y.label = this.finishPlaceholder(X, "Identifier"), this.next(), Y.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(Y, "LabeledStatement");
      }
      return this.semicolon(), J.name = X.name, this.finishPlaceholder(J, "Statement");
    }
    parseBlock(J, X, z) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(J, X, z);
    }
    parseFunctionId(J) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(J);
    }
    parseClass(J, X, z) {
      const Y = X ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const W = this.state.strict, U = this.parsePlaceholder("Identifier");
      if (U)
        if (this.match(81) || this.match(144) || this.match(5))
          J.id = U;
        else if (z || !X)
          return J.id = null, J.body = this.finishPlaceholder(U, "ClassBody"), this.finishNode(J, Y);
        else
          throw this.raise(Az.ClassNameIsRequired, this.state.startLoc);
      else
        this.parseClassId(J, X, z);
      return super.parseClassSuper(J), J.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!J.superClass, W), this.finishNode(J, Y);
    }
    parseExport(J, X) {
      const z = this.parsePlaceholder("Identifier");
      if (!z)
        return super.parseExport(J, X);
      if (!this.isContextual(98) && !this.match(12))
        return J.specifiers = [], J.source = null, J.declaration = this.finishPlaceholder(z, "Declaration"), this.finishNode(J, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const Y = this.startNode();
      return Y.exported = z, J.specifiers = [this.finishNode(Y, "ExportDefaultSpecifier")], super.parseExport(J, X);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const J = this.nextTokenStart();
        if (this.isUnparsedContextual(J, "from")) {
          if (this.input.startsWith(c1(144), this.nextTokenStartSince(J + 4)))
            return !0;
        }
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(J, X) {
      var z;
      if ((z = J.specifiers) != null && z.length)
        return !0;
      return super.maybeParseExportDefaultSpecifier(J, X);
    }
    checkExport(J) {
      const {
        specifiers: X
      } = J;
      if (X != null && X.length)
        J.specifiers = X.filter((z) => z.exported.type === "Placeholder");
      super.checkExport(J), J.specifiers = X;
    }
    parseImport(J) {
      const X = this.parsePlaceholder("Identifier");
      if (!X)
        return super.parseImport(J);
      if (J.specifiers = [], !this.isContextual(98) && !this.match(12))
        return J.source = this.finishPlaceholder(X, "StringLiteral"), this.semicolon(), this.finishNode(J, "ImportDeclaration");
      const z = this.startNodeAtNode(X);
      if (z.local = X, J.specifiers.push(this.finishNode(z, "ImportDefaultSpecifier")), this.eat(12)) {
        if (!this.maybeParseStarImportSpecifier(J))
          this.parseNamedImportSpecifiers(J);
      }
      return this.expectContextual(98), J.source = this.parseImportSource(), this.semicolon(), this.finishNode(J, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      if (this.state.start > this.state.lastTokEndLoc.index)
        this.raise(Az.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, rK = (Z) => class Q extends Z {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const J = this.state.startLoc, X = this.startNode();
        if (this.next(), K0(this.state.type)) {
          const z = this.parseIdentifierName(), Y = this.createIdentifier(X, z);
          if (Y.type = "V8IntrinsicIdentifier", this.match(10))
            return Y;
        }
        this.unexpected(J);
      }
    }
    parseExprAtom(J) {
      return this.parseV8Intrinsic() || super.parseExprAtom(J);
    }
  }, Lz = ["minimal", "fsharp", "hack", "smart"], Nz = ["^^", "@@", "^", "%", "#"], Pz = ["hash", "bar"], z4 = {
    estree: sV,
    jsx: fK,
    flow: _K,
    typescript: lK,
    v8intrinsic: rK,
    placeholders: aK
  }, sK = Object.keys(z4), D6 = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };

  class H4 extends Q4 {
    checkProto(Z, Q, J, X) {
      if (Z.type === "SpreadElement" || this.isObjectMethod(Z) || Z.computed || Z.shorthand)
        return;
      const z = Z.key;
      if ((z.type === "Identifier" ? z.name : z.value) === "__proto__") {
        if (Q) {
          this.raise(C.RecordNoProto, z);
          return;
        }
        if (J.used)
          if (X) {
            if (X.doubleProtoLoc === null)
              X.doubleProtoLoc = z.loc.start;
          } else
            this.raise(C.DuplicateProto, z);
        J.used = !0;
      }
    }
    shouldExitDescending(Z, Q) {
      return Z.type === "ArrowFunctionExpression" && Z.start === Q;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const Z = this.parseExpression();
      if (!this.match(139))
        this.unexpected();
      if (this.finalizeRemainingComments(), Z.comments = this.comments, Z.errors = this.state.errors, this.options.tokens)
        Z.tokens = this.tokens;
      return Z;
    }
    parseExpression(Z, Q) {
      if (Z)
        return this.disallowInAnd(() => this.parseExpressionBase(Q));
      return this.allowInAnd(() => this.parseExpressionBase(Q));
    }
    parseExpressionBase(Z) {
      const Q = this.state.startLoc, J = this.parseMaybeAssign(Z);
      if (this.match(12)) {
        const X = this.startNodeAt(Q);
        X.expressions = [J];
        while (this.eat(12))
          X.expressions.push(this.parseMaybeAssign(Z));
        return this.toReferencedList(X.expressions), this.finishNode(X, "SequenceExpression");
      }
      return J;
    }
    parseMaybeAssignDisallowIn(Z, Q) {
      return this.disallowInAnd(() => this.parseMaybeAssign(Z, Q));
    }
    parseMaybeAssignAllowIn(Z, Q) {
      return this.allowInAnd(() => this.parseMaybeAssign(Z, Q));
    }
    setOptionalParametersError(Z, Q) {
      var J;
      Z.optionalParametersLoc = (J = Q == null ? void 0 : Q.loc) != null ? J : this.state.startLoc;
    }
    parseMaybeAssign(Z, Q) {
      const J = this.state.startLoc;
      if (this.isContextual(108)) {
        if (this.prodParam.hasYield) {
          let W = this.parseYield();
          if (Q)
            W = Q.call(this, W, J);
          return W;
        }
      }
      let X;
      if (Z)
        X = !1;
      else
        Z = new H8, X = !0;
      const {
        type: z
      } = this.state;
      if (z === 10 || K0(z))
        this.state.potentialArrowAt = this.state.start;
      let Y = this.parseMaybeConditional(Z);
      if (Q)
        Y = Q.call(this, Y, J);
      if (QK(this.state.type)) {
        const W = this.startNodeAt(J), U = this.state.value;
        if (W.operator = U, this.match(29)) {
          this.toAssignable(Y, !0), W.left = Y;
          const V = J.index;
          if (Z.doubleProtoLoc != null && Z.doubleProtoLoc.index >= V)
            Z.doubleProtoLoc = null;
          if (Z.shorthandAssignLoc != null && Z.shorthandAssignLoc.index >= V)
            Z.shorthandAssignLoc = null;
          if (Z.privateKeyLoc != null && Z.privateKeyLoc.index >= V)
            this.checkDestructuringPrivate(Z), Z.privateKeyLoc = null;
        } else
          W.left = Y;
        return this.next(), W.right = this.parseMaybeAssign(), this.checkLVal(Y, {
          in: this.finishNode(W, "AssignmentExpression")
        }), W;
      } else if (X)
        this.checkExpressionErrors(Z, !0);
      return Y;
    }
    parseMaybeConditional(Z) {
      const Q = this.state.startLoc, J = this.state.potentialArrowAt, X = this.parseExprOps(Z);
      if (this.shouldExitDescending(X, J))
        return X;
      return this.parseConditional(X, Q, Z);
    }
    parseConditional(Z, Q, J) {
      if (this.eat(17)) {
        const X = this.startNodeAt(Q);
        return X.test = Z, X.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), X.alternate = this.parseMaybeAssign(), this.finishNode(X, "ConditionalExpression");
      }
      return Z;
    }
    parseMaybeUnaryOrPrivate(Z) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(Z);
    }
    parseExprOps(Z) {
      const Q = this.state.startLoc, J = this.state.potentialArrowAt, X = this.parseMaybeUnaryOrPrivate(Z);
      if (this.shouldExitDescending(X, J))
        return X;
      return this.parseExprOp(X, Q, -1);
    }
    parseExprOp(Z, Q, J) {
      if (this.isPrivateName(Z)) {
        const z = this.getPrivateNameSV(Z);
        if (J >= z7(58) || !this.prodParam.hasIn || !this.match(58))
          this.raise(C.PrivateInExpectedIn, Z, {
            identifierName: z
          });
        this.classScope.usePrivateName(z, Z.loc.start);
      }
      const X = this.state.type;
      if (XK(X) && (this.prodParam.hasIn || !this.match(58))) {
        let z = z7(X);
        if (z > J) {
          if (X === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return Z;
            this.checkPipelineAtInfixOperator(Z, Q);
          }
          const Y = this.startNodeAt(Q);
          Y.left = Z, Y.operator = this.state.value;
          const W = X === 41 || X === 42, U = X === 40;
          if (U)
            z = z7(42);
          if (this.next(), X === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }])) {
            if (this.state.type === 96 && this.prodParam.hasAwait)
              throw this.raise(C.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          }
          Y.right = this.parseExprOpRightExpr(X, z);
          const V = this.finishNode(Y, W || U ? "LogicalExpression" : "BinaryExpression"), M = this.state.type;
          if (U && (M === 41 || M === 42) || W && M === 40)
            throw this.raise(C.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(V, Q, J);
        }
      }
      return Z;
    }
    parseExprOpRightExpr(Z, Q) {
      const J = this.state.startLoc;
      switch (Z) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => {
                return this.parseHackPipeBody();
              });
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(C.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(Z, Q), J);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(Q);
              });
          }
        default:
          return this.parseExprOpBaseRightExpr(Z, Q);
      }
    }
    parseExprOpBaseRightExpr(Z, Q) {
      const J = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), J, GK(Z) ? Q - 1 : Q);
    }
    parseHackPipeBody() {
      var Z;
      const {
        startLoc: Q
      } = this.state, J = this.parseMaybeAssign();
      if (iV.has(J.type) && !((Z = J.extra) != null && Z.parenthesized))
        this.raise(C.PipeUnparenthesizedBody, Q, {
          type: J.type
        });
      if (!this.topicReferenceWasUsedInCurrentContext())
        this.raise(C.PipeTopicUnused, Q);
      return J;
    }
    checkExponentialAfterUnary(Z) {
      if (this.match(57))
        this.raise(C.UnexpectedTokenUnaryExponentiation, Z.argument);
    }
    parseMaybeUnary(Z, Q) {
      const J = this.state.startLoc, X = this.isContextual(96);
      if (X && this.isAwaitAllowed()) {
        this.next();
        const U = this.parseAwait(J);
        if (!Q)
          this.checkExponentialAfterUnary(U);
        return U;
      }
      const z = this.match(34), Y = this.startNode();
      if (HK(this.state.type)) {
        if (Y.operator = this.state.value, Y.prefix = !0, this.match(72))
          this.expectPlugin("throwExpressions");
        const U = this.match(89);
        if (this.next(), Y.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(Z, !0), this.state.strict && U) {
          const V = Y.argument;
          if (V.type === "Identifier")
            this.raise(C.StrictDelete, Y);
          else if (this.hasPropertyAsPrivateName(V))
            this.raise(C.DeletePrivateField, Y);
        }
        if (!z) {
          if (!Q)
            this.checkExponentialAfterUnary(Y);
          return this.finishNode(Y, "UnaryExpression");
        }
      }
      const W = this.parseUpdate(Y, z, Z);
      if (X) {
        const {
          type: U
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? A6(U) : A6(U) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(C.AwaitNotInAsyncContext, J), this.parseAwait(J);
      }
      return W;
    }
    parseUpdate(Z, Q, J) {
      if (Q) {
        const Y = Z;
        return this.checkLVal(Y.argument, {
          in: this.finishNode(Y, "UpdateExpression")
        }), Z;
      }
      const X = this.state.startLoc;
      let z = this.parseExprSubscripts(J);
      if (this.checkExpressionErrors(J, !1))
        return z;
      while (zK(this.state.type) && !this.canInsertSemicolon()) {
        const Y = this.startNodeAt(X);
        Y.operator = this.state.value, Y.prefix = !1, Y.argument = z, this.next(), this.checkLVal(z, {
          in: z = this.finishNode(Y, "UpdateExpression")
        });
      }
      return z;
    }
    parseExprSubscripts(Z) {
      const Q = this.state.startLoc, J = this.state.potentialArrowAt, X = this.parseExprAtom(Z);
      if (this.shouldExitDescending(X, J))
        return X;
      return this.parseSubscripts(X, Q);
    }
    parseSubscripts(Z, Q, J) {
      const X = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(Z),
        stop: !1
      };
      do
        Z = this.parseSubscript(Z, Q, J, X), X.maybeAsyncArrow = !1;
      while (!X.stop);
      return Z;
    }
    parseSubscript(Z, Q, J, X) {
      const {
        type: z
      } = this.state;
      if (!J && z === 15)
        return this.parseBind(Z, Q, J, X);
      else if (W7(z))
        return this.parseTaggedTemplateExpression(Z, Q, X);
      let Y = !1;
      if (z === 18) {
        if (J) {
          if (this.raise(C.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)
            return X.stop = !0, Z;
        }
        X.optionalChainMember = Y = !0, this.next();
      }
      if (!J && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(Z, Q, X, Y);
      else {
        const W = this.eat(0);
        if (W || Y || this.eat(16))
          return this.parseMember(Z, Q, X, W, Y);
        else
          return X.stop = !0, Z;
      }
    }
    parseMember(Z, Q, J, X, z) {
      const Y = this.startNodeAt(Q);
      if (Y.object = Z, Y.computed = X, X)
        Y.property = this.parseExpression(), this.expect(3);
      else if (this.match(138)) {
        if (Z.type === "Super")
          this.raise(C.SuperPrivateField, Q);
        this.classScope.usePrivateName(this.state.value, this.state.startLoc), Y.property = this.parsePrivateName();
      } else
        Y.property = this.parseIdentifier(!0);
      if (J.optionalChainMember)
        return Y.optional = z, this.finishNode(Y, "OptionalMemberExpression");
      else
        return this.finishNode(Y, "MemberExpression");
    }
    parseBind(Z, Q, J, X) {
      const z = this.startNodeAt(Q);
      return z.object = Z, this.next(), z.callee = this.parseNoCallExpr(), X.stop = !0, this.parseSubscripts(this.finishNode(z, "BindExpression"), Q, J);
    }
    parseCoverCallAndAsyncArrowHead(Z, Q, J, X) {
      const z = this.state.maybeInArrowParameters;
      let Y = null;
      this.state.maybeInArrowParameters = !0, this.next();
      const W = this.startNodeAt(Q);
      W.callee = Z;
      const {
        maybeAsyncArrow: U,
        optionalChainMember: V
      } = J;
      if (U)
        this.expressionScope.enter(SK()), Y = new H8;
      if (V)
        W.optional = X;
      if (X)
        W.arguments = this.parseCallExpressionArguments(11);
      else
        W.arguments = this.parseCallExpressionArguments(11, Z.type === "Import", Z.type !== "Super", W, Y);
      let M = this.finishCallExpression(W, V);
      if (U && this.shouldParseAsyncArrow() && !X)
        J.stop = !0, this.checkDestructuringPrivate(Y), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), M = this.parseAsyncArrowFromCallExpression(this.startNodeAt(Q), M);
      else {
        if (U)
          this.checkExpressionErrors(Y, !0), this.expressionScope.exit();
        this.toReferencedArguments(M);
      }
      return this.state.maybeInArrowParameters = z, M;
    }
    toReferencedArguments(Z, Q) {
      this.toReferencedListDeep(Z.arguments, Q);
    }
    parseTaggedTemplateExpression(Z, Q, J) {
      const X = this.startNodeAt(Q);
      if (X.tag = Z, X.quasi = this.parseTemplate(!0), J.optionalChainMember)
        this.raise(C.OptionalChainingNoTemplate, Q);
      return this.finishNode(X, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(Z) {
      return Z.type === "Identifier" && Z.name === "async" && this.state.lastTokEndLoc.index === Z.end && !this.canInsertSemicolon() && Z.end - Z.start === 5 && Z.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      if (!this.hasPlugin("importAssertions"))
        this.expectPlugin("importAttributes");
    }
    finishCallExpression(Z, Q) {
      if (Z.callee.type === "Import") {
        if (Z.arguments.length === 2) {
          if (!this.hasPlugin("moduleAttributes"))
            this.expectImportAttributesPlugin();
        }
        if (Z.arguments.length === 0 || Z.arguments.length > 2)
          this.raise(C.ImportCallArity, Z, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        else
          for (let J of Z.arguments)
            if (J.type === "SpreadElement")
              this.raise(C.ImportCallSpreadArgument, J);
      }
      return this.finishNode(Z, Q ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(Z, Q, J, X, z) {
      const Y = [];
      let W = !0;
      const U = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      while (!this.eat(Z)) {
        if (W)
          W = !1;
        else if (this.expect(12), this.match(Z)) {
          if (Q && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes"))
            this.raise(C.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);
          if (X)
            this.addTrailingCommaExtraToNode(X);
          this.next();
          break;
        }
        Y.push(this.parseExprListItem(!1, z, J));
      }
      return this.state.inFSharpPipelineDirectBody = U, Y;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(Z, Q) {
      var J;
      if (this.resetPreviousNodeTrailingComments(Q), this.expect(19), this.parseArrowExpression(Z, Q.arguments, !0, (J = Q.extra) == null ? void 0 : J.trailingCommaLoc), Q.innerComments)
        W8(Z, Q.innerComments);
      if (Q.callee.trailingComments)
        W8(Z, Q.callee.trailingComments);
      return Z;
    }
    parseNoCallExpr() {
      const Z = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), Z, !0);
    }
    parseExprAtom(Z) {
      let Q, J = null;
      const {
        type: X
      } = this.state;
      switch (X) {
        case 79:
          return this.parseSuper();
        case 83:
          if (Q = this.startNode(), this.next(), this.match(16))
            return this.parseImportMetaProperty(Q);
          if (this.match(10))
            if (this.options.createImportExpressions)
              return this.parseImportCall(Q);
            else
              return this.finishNode(Q, "Import");
          else
            return this.raise(C.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(Q, "Import");
        case 78:
          return Q = this.startNode(), this.next(), this.finishNode(Q, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          const z = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(z);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, Z);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, Z);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          J = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(J, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          Q = this.startNode(), this.next(), Q.object = null;
          const z = Q.callee = this.parseNoCallExpr();
          if (z.type === "MemberExpression")
            return this.finishNode(Q, "BindExpression");
          else
            throw this.raise(C.UnsupportedBind, z);
        }
        case 138:
          return this.raise(C.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const z = this.getPluginOption("pipelineOperator", "proposal");
          if (z)
            return this.parseTopicReference(z);
          this.unexpected();
          break;
        }
        case 47: {
          const z = this.input.codePointAt(this.nextTokenStart());
          if (S1(z) || z === 62)
            this.expectOnePlugin(["jsx", "flow", "typescript"]);
          else
            this.unexpected();
          break;
        }
        default:
          if (K0(X)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            const z = this.state.potentialArrowAt === this.state.start, Y = this.state.containsEsc, W = this.parseIdentifier();
            if (!Y && W.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: U
              } = this.state;
              if (U === 68)
                return this.resetPreviousNodeTrailingComments(W), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(W));
              else if (K0(U))
                if (this.lookaheadCharCode() === 61)
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(W));
                else
                  return W;
              else if (U === 90)
                return this.resetPreviousNodeTrailingComments(W), this.parseDo(this.startNodeAtNode(W), !0);
            }
            if (z && this.match(19) && !this.canInsertSemicolon())
              return this.next(), this.parseArrowExpression(this.startNodeAtNode(W), [W], !1);
            return W;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(Z, Q) {
      const J = this.getPluginOption("pipelineOperator", "proposal");
      if (J)
        return this.state.type = Z, this.state.value = Q, this.state.pos--, this.state.end--, this.state.endLoc = d0(this.state.endLoc, -1), this.parseTopicReference(J);
      else
        this.unexpected();
    }
    parseTopicReference(Z) {
      const Q = this.startNode(), J = this.state.startLoc, X = this.state.type;
      return this.next(), this.finishTopicReference(Q, J, Z, X);
    }
    finishTopicReference(Z, Q, J, X) {
      if (this.testTopicReferenceConfiguration(J, Q, X)) {
        const z = J === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        if (!this.topicReferenceIsAllowedInCurrentContext())
          this.raise(J === "smart" ? C.PrimaryTopicNotAllowed : C.PipeTopicUnbound, Q);
        return this.registerTopicReference(), this.finishNode(Z, z);
      } else
        throw this.raise(C.PipeTopicUnconfiguredToken, Q, {
          token: c1(X)
        });
    }
    testTopicReferenceConfiguration(Z, Q, J) {
      switch (Z) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: c1(J)
          }]);
        case "smart":
          return J === 27;
        default:
          throw this.raise(C.PipeTopicRequiresHackPipes, Q);
      }
    }
    parseAsyncArrowUnaryFunction(Z) {
      this.prodParam.enter(Y7(!0, this.prodParam.hasYield));
      const Q = [this.parseIdentifier()];
      if (this.prodParam.exit(), this.hasPrecedingLineBreak())
        this.raise(C.LineTerminatorBeforeArrow, this.state.curPosition());
      return this.expect(19), this.parseArrowExpression(Z, Q, !0);
    }
    parseDo(Z, Q) {
      if (this.expectPlugin("doExpressions"), Q)
        this.expectPlugin("asyncDoExpressions");
      Z.async = Q, this.next();
      const J = this.state.labels;
      if (this.state.labels = [], Q)
        this.prodParam.enter(2), Z.body = this.parseBlock(), this.prodParam.exit();
      else
        Z.body = this.parseBlock();
      return this.state.labels = J, this.finishNode(Z, "DoExpression");
    }
    parseSuper() {
      const Z = this.startNode();
      if (this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod)
        this.raise(C.SuperNotAllowed, Z);
      else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod)
        this.raise(C.UnexpectedSuper, Z);
      if (!this.match(10) && !this.match(0) && !this.match(16))
        this.raise(C.UnsupportedSuper, Z);
      return this.finishNode(Z, "Super");
    }
    parsePrivateName() {
      const Z = this.startNode(), Q = this.startNodeAt(d0(this.state.startLoc, 1)), J = this.state.value;
      return this.next(), Z.id = this.createIdentifier(Q, J), this.finishNode(Z, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const Z = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const Q = this.createIdentifier(this.startNodeAtNode(Z), "function");
        if (this.next(), this.match(103))
          this.expectPlugin("functionSent");
        else if (!this.hasPlugin("functionSent"))
          this.unexpected();
        return this.parseMetaProperty(Z, Q, "sent");
      }
      return this.parseFunction(Z);
    }
    parseMetaProperty(Z, Q, J) {
      Z.meta = Q;
      const X = this.state.containsEsc;
      if (Z.property = this.parseIdentifier(!0), Z.property.name !== J || X)
        this.raise(C.UnsupportedMetaProperty, Z.property, {
          target: Q.name,
          onlyValidPropertyName: J
        });
      return this.finishNode(Z, "MetaProperty");
    }
    parseImportMetaProperty(Z) {
      const Q = this.createIdentifier(this.startNodeAtNode(Z), "import");
      if (this.next(), this.isContextual(101)) {
        if (!this.inModule)
          this.raise(C.ImportMetaOutsideModule, Q);
        this.sawUnambiguousESM = !0;
      } else if (this.isContextual(105) || this.isContextual(97)) {
        const J = this.isContextual(105);
        if (!J)
          this.unexpected();
        if (this.expectPlugin(J ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(C.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), Z.phase = J ? "source" : "defer", this.parseImportCall(Z);
      }
      return this.parseMetaProperty(Z, Q, "meta");
    }
    parseLiteralAtNode(Z, Q, J) {
      return this.addExtra(J, "rawValue", Z), this.addExtra(J, "raw", this.input.slice(J.start, this.state.end)), J.value = Z, this.next(), this.finishNode(J, Q);
    }
    parseLiteral(Z, Q) {
      const J = this.startNode();
      return this.parseLiteralAtNode(Z, Q, J);
    }
    parseStringLiteral(Z) {
      return this.parseLiteral(Z, "StringLiteral");
    }
    parseNumericLiteral(Z) {
      return this.parseLiteral(Z, "NumericLiteral");
    }
    parseBigIntLiteral(Z) {
      return this.parseLiteral(Z, "BigIntLiteral");
    }
    parseDecimalLiteral(Z) {
      return this.parseLiteral(Z, "DecimalLiteral");
    }
    parseRegExpLiteral(Z) {
      const Q = this.parseLiteral(Z.value, "RegExpLiteral");
      return Q.pattern = Z.pattern, Q.flags = Z.flags, Q;
    }
    parseBooleanLiteral(Z) {
      const Q = this.startNode();
      return Q.value = Z, this.next(), this.finishNode(Q, "BooleanLiteral");
    }
    parseNullLiteral() {
      const Z = this.startNode();
      return this.next(), this.finishNode(Z, "NullLiteral");
    }
    parseParenAndDistinguishExpression(Z) {
      const Q = this.state.startLoc;
      let J;
      this.next(), this.expressionScope.enter(PK());
      const X = this.state.maybeInArrowParameters, z = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      const Y = this.state.startLoc, W = [], U = new H8;
      let V = !0, M, q;
      while (!this.match(11)) {
        if (V)
          V = !1;
        else if (this.expect(12, U.optionalParametersLoc === null ? null : U.optionalParametersLoc), this.match(11)) {
          q = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const T = this.state.startLoc;
          if (M = this.state.startLoc, W.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          W.push(this.parseMaybeAssignAllowIn(U, this.parseParenItem));
      }
      const L = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = X, this.state.inFSharpPipelineDirectBody = z;
      let N = this.startNodeAt(Q);
      if (Z && this.shouldParseArrow(W) && (N = this.parseArrow(N)))
        return this.checkDestructuringPrivate(U), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(N, W, !1), N;
      if (this.expressionScope.exit(), !W.length)
        this.unexpected(this.state.lastTokStartLoc);
      if (q)
        this.unexpected(q);
      if (M)
        this.unexpected(M);
      if (this.checkExpressionErrors(U, !0), this.toReferencedListDeep(W, !0), W.length > 1)
        J = this.startNodeAt(Y), J.expressions = W, this.finishNode(J, "SequenceExpression"), this.resetEndLocation(J, L);
      else
        J = W[0];
      return this.wrapParenthesis(Q, J);
    }
    wrapParenthesis(Z, Q) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(Q, "parenthesized", !0), this.addExtra(Q, "parenStart", Z.index), this.takeSurroundingComments(Q, Z.index, this.state.lastTokEndLoc.index), Q;
      const J = this.startNodeAt(Z);
      return J.expression = Q, this.finishNode(J, "ParenthesizedExpression");
    }
    shouldParseArrow(Z) {
      return !this.canInsertSemicolon();
    }
    parseArrow(Z) {
      if (this.eat(19))
        return Z;
    }
    parseParenItem(Z, Q) {
      return Z;
    }
    parseNewOrNewTarget() {
      const Z = this.startNode();
      if (this.next(), this.match(16)) {
        const Q = this.createIdentifier(this.startNodeAtNode(Z), "new");
        this.next();
        const J = this.parseMetaProperty(Z, Q, "target");
        if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction)
          this.raise(C.UnexpectedNewTarget, J);
        return J;
      }
      return this.parseNew(Z);
    }
    parseNew(Z) {
      if (this.parseNewCallee(Z), this.eat(10)) {
        const Q = this.parseExprList(11);
        this.toReferencedList(Q), Z.arguments = Q;
      } else
        Z.arguments = [];
      return this.finishNode(Z, "NewExpression");
    }
    parseNewCallee(Z) {
      const Q = this.match(83), J = this.parseNoCallExpr();
      if (Z.callee = J, Q && (J.type === "Import" || J.type === "ImportExpression"))
        this.raise(C.ImportCallNotNewExpression, J);
    }
    parseTemplateElement(Z) {
      const {
        start: Q,
        startLoc: J,
        end: X,
        value: z
      } = this.state, Y = Q + 1, W = this.startNodeAt(d0(J, 1));
      if (z === null) {
        if (!Z)
          this.raise(C.InvalidEscapeSequenceTemplate, d0(this.state.firstInvalidTemplateEscapePos, 1));
      }
      const U = this.match(24), V = U ? -1 : -2, M = X + V;
      W.value = {
        raw: this.input.slice(Y, M).replace(/\r\n?/g, "\n"),
        cooked: z === null ? null : z.slice(1, V)
      }, W.tail = U, this.next();
      const q = this.finishNode(W, "TemplateElement");
      return this.resetEndLocation(q, d0(this.state.lastTokEndLoc, V)), q;
    }
    parseTemplate(Z) {
      const Q = this.startNode();
      Q.expressions = [];
      let J = this.parseTemplateElement(Z);
      Q.quasis = [J];
      while (!J.tail)
        Q.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), Q.quasis.push(J = this.parseTemplateElement(Z));
      return this.finishNode(Q, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(Z, Q, J, X) {
      if (J)
        this.expectPlugin("recordAndTuple");
      const z = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const Y = Object.create(null);
      let W = !0;
      const U = this.startNode();
      U.properties = [], this.next();
      while (!this.match(Z)) {
        if (W)
          W = !1;
        else if (this.expect(12), this.match(Z)) {
          this.addTrailingCommaExtraToNode(U);
          break;
        }
        let M;
        if (Q)
          M = this.parseBindingProperty();
        else
          M = this.parsePropertyDefinition(X), this.checkProto(M, J, Y, X);
        if (J && !this.isObjectProperty(M) && M.type !== "SpreadElement")
          this.raise(C.InvalidRecordProperty, M);
        if (M.shorthand)
          this.addExtra(M, "shorthand", !0);
        U.properties.push(M);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = z;
      let V = "ObjectExpression";
      if (Q)
        V = "ObjectPattern";
      else if (J)
        V = "RecordExpression";
      return this.finishNode(U, V);
    }
    addTrailingCommaExtraToNode(Z) {
      this.addExtra(Z, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(Z, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(Z) {
      return !Z.computed && Z.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(Z) {
      let Q = [];
      if (this.match(26)) {
        if (this.hasPlugin("decorators"))
          this.raise(C.UnsupportedPropertyDecorator, this.state.startLoc);
        while (this.match(26))
          Q.push(this.parseDecorator());
      }
      const J = this.startNode();
      let X = !1, z = !1, Y;
      if (this.match(21)) {
        if (Q.length)
          this.unexpected();
        return this.parseSpread();
      }
      if (Q.length)
        J.decorators = Q, Q = [];
      if (J.method = !1, Z)
        Y = this.state.startLoc;
      let W = this.eat(55);
      this.parsePropertyNamePrefixOperator(J);
      const U = this.state.containsEsc, V = this.parsePropertyName(J, Z);
      if (!W && !U && this.maybeAsyncOrAccessorProp(J)) {
        const M = V.name;
        if (M === "async" && !this.hasPrecedingLineBreak())
          X = !0, this.resetPreviousNodeTrailingComments(V), W = this.eat(55), this.parsePropertyName(J);
        if (M === "get" || M === "set") {
          if (z = !0, this.resetPreviousNodeTrailingComments(V), J.kind = M, this.match(55))
            W = !0, this.raise(C.AccessorIsGenerator, this.state.curPosition(), {
              kind: M
            }), this.next();
          this.parsePropertyName(J);
        }
      }
      return this.parseObjPropValue(J, Y, W, X, !1, z, Z);
    }
    getGetterSetterExpectedParamCount(Z) {
      return Z.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(Z) {
      return Z.params;
    }
    checkGetterSetterParams(Z) {
      var Q;
      const J = this.getGetterSetterExpectedParamCount(Z), X = this.getObjectOrClassMethodParams(Z);
      if (X.length !== J)
        this.raise(Z.kind === "get" ? C.BadGetterArity : C.BadSetterArity, Z);
      if (Z.kind === "set" && ((Q = X[X.length - 1]) == null ? void 0 : Q.type) === "RestElement")
        this.raise(C.BadSetterRestParameter, Z);
    }
    parseObjectMethod(Z, Q, J, X, z) {
      if (z) {
        const Y = this.parseMethod(Z, Q, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(Y), Y;
      }
      if (J || Q || this.match(10)) {
        if (X)
          this.unexpected();
        return Z.kind = "method", Z.method = !0, this.parseMethod(Z, Q, J, !1, !1, "ObjectMethod");
      }
    }
    parseObjectProperty(Z, Q, J, X) {
      if (Z.shorthand = !1, this.eat(14))
        return Z.value = J ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(X), this.finishNode(Z, "ObjectProperty");
      if (!Z.computed && Z.key.type === "Identifier") {
        if (this.checkReservedWord(Z.key.name, Z.key.loc.start, !0, !1), J)
          Z.value = this.parseMaybeDefault(Q, v1(Z.key));
        else if (this.match(29)) {
          const z = this.state.startLoc;
          if (X != null) {
            if (X.shorthandAssignLoc === null)
              X.shorthandAssignLoc = z;
          } else
            this.raise(C.InvalidCoverInitializedName, z);
          Z.value = this.parseMaybeDefault(Q, v1(Z.key));
        } else
          Z.value = v1(Z.key);
        return Z.shorthand = !0, this.finishNode(Z, "ObjectProperty");
      }
    }
    parseObjPropValue(Z, Q, J, X, z, Y, W) {
      const U = this.parseObjectMethod(Z, J, X, z, Y) || this.parseObjectProperty(Z, Q, z, W);
      if (!U)
        this.unexpected();
      return U;
    }
    parsePropertyName(Z, Q) {
      if (this.eat(0))
        Z.computed = !0, Z.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: J,
          value: X
        } = this.state;
        let z;
        if (G1(J))
          z = this.parseIdentifier(!0);
        else
          switch (J) {
            case 134:
              z = this.parseNumericLiteral(X);
              break;
            case 133:
              z = this.parseStringLiteral(X);
              break;
            case 135:
              z = this.parseBigIntLiteral(X);
              break;
            case 136:
              z = this.parseDecimalLiteral(X);
              break;
            case 138: {
              const Y = this.state.startLoc;
              if (Q != null) {
                if (Q.privateKeyLoc === null)
                  Q.privateKeyLoc = Y;
              } else
                this.raise(C.UnexpectedPrivateField, Y);
              z = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        if (Z.key = z, J !== 138)
          Z.computed = !1;
      }
      return Z.key;
    }
    initFunction(Z, Q) {
      Z.id = null, Z.generator = !1, Z.async = Q;
    }
    parseMethod(Z, Q, J, X, z, Y, W = !1) {
      this.initFunction(Z, J), Z.generator = Q, this.scope.enter(2 | 16 | (W ? 64 : 0) | (z ? 32 : 0)), this.prodParam.enter(Y7(J, Z.generator)), this.parseFunctionParams(Z, X);
      const U = this.parseFunctionBodyAndFinish(Z, Y, !0);
      return this.prodParam.exit(), this.scope.exit(), U;
    }
    parseArrayLike(Z, Q, J, X) {
      if (J)
        this.expectPlugin("recordAndTuple");
      const z = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const Y = this.startNode();
      return this.next(), Y.elements = this.parseExprList(Z, !J, X, Y), this.state.inFSharpPipelineDirectBody = z, this.finishNode(Y, J ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(Z, Q, J, X) {
      this.scope.enter(2 | 4);
      let z = Y7(J, !1);
      if (!this.match(5) && this.prodParam.hasIn)
        z |= 8;
      this.prodParam.enter(z), this.initFunction(Z, J);
      const Y = this.state.maybeInArrowParameters;
      if (Q)
        this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(Z, Q, X);
      return this.state.maybeInArrowParameters = !1, this.parseFunctionBody(Z, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = Y, this.finishNode(Z, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(Z, Q, J) {
      this.toAssignableList(Q, J, !1), Z.params = Q;
    }
    parseFunctionBodyAndFinish(Z, Q, J = !1) {
      return this.parseFunctionBody(Z, !1, J), this.finishNode(Z, Q);
    }
    parseFunctionBody(Z, Q, J = !1) {
      const X = Q && !this.match(5);
      if (this.expressionScope.enter(rz()), X)
        Z.body = this.parseMaybeAssign(), this.checkParams(Z, !1, Q, !1);
      else {
        const z = this.state.strict, Y = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), Z.body = this.parseBlock(!0, !1, (W) => {
          const U = !this.isSimpleParamList(Z.params);
          if (W && U)
            this.raise(C.IllegalLanguageModeDirective, (Z.kind === "method" || Z.kind === "constructor") && !!Z.key ? Z.key.loc.end : Z);
          const V = !z && this.state.strict;
          if (this.checkParams(Z, !this.state.strict && !Q && !J && !U, Q, V), this.state.strict && Z.id)
            this.checkIdentifier(Z.id, 65, V);
        }), this.prodParam.exit(), this.state.labels = Y;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(Z) {
      return Z.type === "Identifier";
    }
    isSimpleParamList(Z) {
      for (let Q = 0, J = Z.length;Q < J; Q++)
        if (!this.isSimpleParameter(Z[Q]))
          return !1;
      return !0;
    }
    checkParams(Z, Q, J, X = !0) {
      const z = !Q && new Set, Y = {
        type: "FormalParameters"
      };
      for (let W of Z.params)
        this.checkLVal(W, {
          in: Y,
          binding: 5,
          checkClashes: z,
          strictModeChanged: X
        });
    }
    parseExprList(Z, Q, J, X) {
      const z = [];
      let Y = !0;
      while (!this.eat(Z)) {
        if (Y)
          Y = !1;
        else if (this.expect(12), this.match(Z)) {
          if (X)
            this.addTrailingCommaExtraToNode(X);
          this.next();
          break;
        }
        z.push(this.parseExprListItem(Q, J));
      }
      return z;
    }
    parseExprListItem(Z, Q, J) {
      let X;
      if (this.match(12)) {
        if (!Z)
          this.raise(C.UnexpectedToken, this.state.curPosition(), {
            unexpected: ","
          });
        X = null;
      } else if (this.match(21)) {
        const z = this.state.startLoc;
        X = this.parseParenItem(this.parseSpread(Q), z);
      } else if (this.match(17)) {
        if (this.expectPlugin("partialApplication"), !J)
          this.raise(C.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const z = this.startNode();
        this.next(), X = this.finishNode(z, "ArgumentPlaceholder");
      } else
        X = this.parseMaybeAssignAllowIn(Q, this.parseParenItem);
      return X;
    }
    parseIdentifier(Z) {
      const Q = this.startNode(), J = this.parseIdentifierName(Z);
      return this.createIdentifier(Q, J);
    }
    createIdentifier(Z, Q) {
      return Z.name = Q, Z.loc.identifierName = Q, this.finishNode(Z, "Identifier");
    }
    parseIdentifierName(Z) {
      let Q;
      const {
        startLoc: J,
        type: X
      } = this.state;
      if (G1(X))
        Q = this.state.value;
      else
        this.unexpected();
      const z = eV(X);
      if (Z) {
        if (z)
          this.replaceToken(132);
      } else
        this.checkReservedWord(Q, J, z, !1);
      return this.next(), Q;
    }
    checkReservedWord(Z, Q, J, X) {
      if (Z.length > 10)
        return;
      if (!qK(Z))
        return;
      if (J && jK(Z)) {
        this.raise(C.UnexpectedKeyword, Q, {
          keyword: Z
        });
        return;
      }
      if ((!this.state.strict ? Ez : X ? _z : gz)(Z, this.inModule)) {
        this.raise(C.UnexpectedReservedWord, Q, {
          reservedWord: Z
        });
        return;
      } else if (Z === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(C.YieldBindingIdentifier, Q);
          return;
        }
      } else if (Z === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(C.AwaitBindingIdentifier, Q);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(C.AwaitBindingIdentifierInStaticBlock, Q);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(Q);
      } else if (Z === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(C.ArgumentsInClass, Q);
          return;
        }
      }
    }
    isAwaitAllowed() {
      if (this.prodParam.hasAwait)
        return !0;
      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction)
        return !0;
      return !1;
    }
    parseAwait(Z) {
      const Q = this.startNodeAt(Z);
      if (this.expressionScope.recordParameterInitializerError(C.AwaitExpressionFormalParameter, Q), this.eat(55))
        this.raise(C.ObsoleteAwaitStar, Q);
      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction)
        if (this.isAmbiguousAwait())
          this.ambiguousScriptDifferentAst = !0;
        else
          this.sawUnambiguousESM = !0;
      if (!this.state.soloAwait)
        Q.argument = this.parseMaybeUnary(null, !0);
      return this.finishNode(Q, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return !0;
      const {
        type: Z
      } = this.state;
      return Z === 53 || Z === 10 || Z === 0 || W7(Z) || Z === 102 && !this.state.containsEsc || Z === 137 || Z === 56 || this.hasPlugin("v8intrinsic") && Z === 54;
    }
    parseYield() {
      const Z = this.startNode();
      this.expressionScope.recordParameterInitializerError(C.YieldInParameter, Z), this.next();
      let Q = !1, J = null;
      if (!this.hasPrecedingLineBreak())
        switch (Q = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!Q)
              break;
          default:
            J = this.parseMaybeAssign();
        }
      return Z.delegate = Q, Z.argument = J, this.finishNode(Z, "YieldExpression");
    }
    parseImportCall(Z) {
      if (this.next(), Z.source = this.parseMaybeAssignAllowIn(), this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        Z.options = null;
      if (this.eat(12)) {
        if (this.expectImportAttributesPlugin(), !this.match(11))
          Z.options = this.parseMaybeAssignAllowIn(), this.eat(12);
      }
      return this.expect(11), this.finishNode(Z, "ImportExpression");
    }
    checkPipelineAtInfixOperator(Z, Q) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        if (Z.type === "SequenceExpression")
          this.raise(C.PipelineHeadSequenceExpression, Q);
      }
    }
    parseSmartPipelineBodyInStyle(Z, Q) {
      if (this.isSimpleReference(Z)) {
        const J = this.startNodeAt(Q);
        return J.callee = Z, this.finishNode(J, "PipelineBareFunction");
      } else {
        const J = this.startNodeAt(Q);
        return this.checkSmartPipeTopicBodyEarlyErrors(Q), J.expression = Z, this.finishNode(J, "PipelineTopicExpression");
      }
    }
    isSimpleReference(Z) {
      switch (Z.type) {
        case "MemberExpression":
          return !Z.computed && this.isSimpleReference(Z.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(Z) {
      if (this.match(19))
        throw this.raise(C.PipelineBodyNoArrow, this.state.startLoc);
      if (!this.topicReferenceWasUsedInCurrentContext())
        this.raise(C.PipelineTopicUnused, Z);
    }
    withTopicBindingContext(Z) {
      const Q = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return Z();
      } finally {
        this.state.topicContext = Q;
      }
    }
    withSmartMixTopicForbiddingContext(Z) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const Q = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return Z();
        } finally {
          this.state.topicContext = Q;
        }
      } else
        return Z();
    }
    withSoloAwaitPermittingContext(Z) {
      const Q = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return Z();
      } finally {
        this.state.soloAwait = Q;
      }
    }
    allowInAnd(Z) {
      const Q = this.prodParam.currentFlags();
      if (8 & ~Q) {
        this.prodParam.enter(Q | 8);
        try {
          return Z();
        } finally {
          this.prodParam.exit();
        }
      }
      return Z();
    }
    disallowInAnd(Z) {
      const Q = this.prodParam.currentFlags();
      if (8 & Q) {
        this.prodParam.enter(Q & ~8);
        try {
          return Z();
        } finally {
          this.prodParam.exit();
        }
      }
      return Z();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(Z) {
      const Q = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const J = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      const X = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), Q, Z);
      return this.state.inFSharpPipelineDirectBody = J, X;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const Z = this.startNode();
      if (this.next(), !this.match(5))
        this.unexpected(null, 5);
      const Q = this.startNodeAt(this.state.endLoc);
      this.next();
      const J = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        Z.body = this.parseProgram(Q, 8, "module");
      } finally {
        J();
      }
      return this.finishNode(Z, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(Z) {
    }
  }
  var I6 = {
    kind: 1
  }, oK = {
    kind: 2
  }, eK = /[\uD800-\uDFFF]/u, C6 = /in(?:stanceof)?/y;

  class Y4 extends H4 {
    parseTopLevel(Z, Q) {
      if (Z.program = this.parseProgram(Q), Z.comments = this.comments, this.options.tokens)
        Z.tokens = Z3(this.tokens, this.input);
      return this.finishNode(Z, "File");
    }
    parseProgram(Z, Q = 139, J = this.options.sourceType) {
      if (Z.sourceType = J, Z.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(Z, !0, !0, Q), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [z, Y] of Array.from(this.scope.undefinedExports))
          this.raise(C.ModuleExportUndefined, Y, {
            localName: z
          });
      let X;
      if (Q === 139)
        X = this.finishNode(Z, "Program");
      else
        X = this.finishNodeAt(Z, "Program", d0(this.state.startLoc, -1));
      return X;
    }
    stmtToDirective(Z) {
      const Q = Z;
      Q.type = "Directive", Q.value = Q.expression, delete Q.expression;
      const J = Q.value, X = J.value, z = this.input.slice(J.start, J.end), Y = J.value = z.slice(1, -1);
      return this.addExtra(J, "raw", z), this.addExtra(J, "rawValue", Y), this.addExtra(J, "expressionValue", X), J.type = "DirectiveLiteral", Q;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const Z = this.startNode();
      return Z.value = this.state.value, this.next(), this.finishNode(Z, "InterpreterDirective");
    }
    isLet() {
      if (!this.isContextual(100))
        return !1;
      return this.hasFollowingBindingAtom();
    }
    chStartsBindingIdentifier(Z, Q) {
      if (S1(Z)) {
        if (C6.lastIndex = Q, C6.test(this.input)) {
          const J = this.codePointAtPos(C6.lastIndex);
          if (!E5(J) && J !== 92)
            return !1;
        }
        return !0;
      } else if (Z === 92)
        return !0;
      else
        return !1;
    }
    chStartsBindingPattern(Z) {
      return Z === 91 || Z === 123;
    }
    hasFollowingBindingAtom() {
      const Z = this.nextTokenStart(), Q = this.codePointAtPos(Z);
      return this.chStartsBindingPattern(Q) || this.chStartsBindingIdentifier(Q, Z);
    }
    hasInLineFollowingBindingIdentifier() {
      const Z = this.nextTokenInLineStart(), Q = this.codePointAtPos(Z);
      return this.chStartsBindingIdentifier(Q, Z);
    }
    startsUsingForOf() {
      const {
        type: Z,
        containsEsc: Q
      } = this.lookahead();
      if (Z === 102 && !Q)
        return !1;
      else if (K0(Z) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let Z = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(Z, "using")) {
        Z = this.nextTokenInLineStartSince(Z + 5);
        const Q = this.codePointAtPos(Z);
        if (this.chStartsBindingIdentifier(Q, Z))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(1 | 2 | 4 | 8);
    }
    parseStatementListItem() {
      return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(Z = !1) {
      let Q = 0;
      if (this.options.annexB && !this.state.strict) {
        if (Q |= 4, Z)
          Q |= 8;
      }
      return this.parseStatementLike(Q);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(Z) {
      let Q = null;
      if (this.match(26))
        Q = this.parseDecorators(!0);
      return this.parseStatementContent(Z, Q);
    }
    parseStatementContent(Z, Q) {
      const J = this.state.type, X = this.startNode(), z = !!(Z & 2), Y = !!(Z & 4), W = Z & 1;
      switch (J) {
        case 60:
          return this.parseBreakContinueStatement(X, !0);
        case 63:
          return this.parseBreakContinueStatement(X, !1);
        case 64:
          return this.parseDebuggerStatement(X);
        case 90:
          return this.parseDoWhileStatement(X);
        case 91:
          return this.parseForStatement(X);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          if (!Y)
            this.raise(this.state.strict ? C.StrictFunction : this.options.annexB ? C.SloppyFunctionAnnexB : C.SloppyFunction, this.state.startLoc);
          return this.parseFunctionStatement(X, !1, !z && Y);
        case 80:
          if (!z)
            this.unexpected();
          return this.parseClass(this.maybeTakeDecorators(Q, X), !0);
        case 69:
          return this.parseIfStatement(X);
        case 70:
          return this.parseReturnStatement(X);
        case 71:
          return this.parseSwitchStatement(X);
        case 72:
          return this.parseThrowStatement(X);
        case 73:
          return this.parseTryStatement(X);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing()) {
            if (!this.isAwaitAllowed())
              this.raise(C.AwaitUsingNotInAsyncContext, X);
            else if (!z)
              this.raise(C.UnexpectedLexicalDeclaration, X);
            return this.next(), this.parseVarStatement(X, "await using");
          }
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          if (this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel)
            this.raise(C.UnexpectedUsingDeclaration, this.state.startLoc);
          else if (!z)
            this.raise(C.UnexpectedLexicalDeclaration, this.state.startLoc);
          return this.parseVarStatement(X, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          const M = this.nextTokenStart(), q = this.codePointAtPos(M);
          if (q !== 91) {
            if (!z && this.hasFollowingLineBreak())
              break;
            if (!this.chStartsBindingIdentifier(q, M) && q !== 123)
              break;
          }
        }
        case 75:
          if (!z)
            this.raise(C.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const M = this.state.value;
          return this.parseVarStatement(X, M);
        }
        case 92:
          return this.parseWhileStatement(X);
        case 76:
          return this.parseWithStatement(X);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(X);
        case 83: {
          const M = this.lookaheadCharCode();
          if (M === 40 || M === 46)
            break;
        }
        case 82: {
          if (!this.options.allowImportExportEverywhere && !W)
            this.raise(C.UnexpectedImportExport, this.state.startLoc);
          this.next();
          let M;
          if (J === 83) {
            if (M = this.parseImport(X), M.type === "ImportDeclaration" && (!M.importKind || M.importKind === "value"))
              this.sawUnambiguousESM = !0;
          } else if (M = this.parseExport(X, Q), M.type === "ExportNamedDeclaration" && (!M.exportKind || M.exportKind === "value") || M.type === "ExportAllDeclaration" && (!M.exportKind || M.exportKind === "value") || M.type === "ExportDefaultDeclaration")
            this.sawUnambiguousESM = !0;
          return this.assertModuleNodeAllowed(M), M;
        }
        default:
          if (this.isAsyncFunction()) {
            if (!z)
              this.raise(C.AsyncFunctionInSingleStatementContext, this.state.startLoc);
            return this.next(), this.parseFunctionStatement(X, !0, !z && Y);
          }
      }
      const U = this.state.value, V = this.parseExpression();
      if (K0(J) && V.type === "Identifier" && this.eat(14))
        return this.parseLabeledStatement(X, U, V, Z);
      else
        return this.parseExpressionStatement(X, V, Q);
    }
    assertModuleNodeAllowed(Z) {
      if (!this.options.allowImportExportEverywhere && !this.inModule)
        this.raise(C.ImportOutsideModule, Z);
    }
    decoratorsEnabledBeforeExport() {
      if (this.hasPlugin("decorators-legacy"))
        return !0;
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(Z, Q, J) {
      if (Z) {
        if (Q.decorators && Q.decorators.length > 0) {
          if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean")
            this.raise(C.DecoratorsBeforeAfterExport, Q.decorators[0]);
          Q.decorators.unshift(...Z);
        } else
          Q.decorators = Z;
        if (this.resetStartLocationFromNode(Q, Z[0]), J)
          this.resetStartLocationFromNode(J, Q);
      }
      return Q;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(Z) {
      const Q = [];
      do
        Q.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82)) {
        if (!Z)
          this.unexpected();
        if (!this.decoratorsEnabledBeforeExport())
          this.raise(C.DecoratorExportClass, this.state.startLoc);
      } else if (!this.canHaveLeadingDecorator())
        throw this.raise(C.UnexpectedLeadingDecorator, this.state.startLoc);
      return Q;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const Z = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const Q = this.state.startLoc;
        let J;
        if (this.match(10)) {
          const X = this.state.startLoc;
          this.next(), J = this.parseExpression(), this.expect(11), J = this.wrapParenthesis(X, J);
          const z = this.state.startLoc;
          if (Z.expression = this.parseMaybeDecoratorArguments(J), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && Z.expression !== J)
            this.raise(C.DecoratorArgumentsOutsideParentheses, z);
        } else {
          J = this.parseIdentifier(!1);
          while (this.eat(16)) {
            const X = this.startNodeAt(Q);
            if (X.object = J, this.match(138))
              this.classScope.usePrivateName(this.state.value, this.state.startLoc), X.property = this.parsePrivateName();
            else
              X.property = this.parseIdentifier(!0);
            X.computed = !1, J = this.finishNode(X, "MemberExpression");
          }
          Z.expression = this.parseMaybeDecoratorArguments(J);
        }
      } else
        Z.expression = this.parseExprSubscripts();
      return this.finishNode(Z, "Decorator");
    }
    parseMaybeDecoratorArguments(Z) {
      if (this.eat(10)) {
        const Q = this.startNodeAtNode(Z);
        return Q.callee = Z, Q.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(Q.arguments), this.finishNode(Q, "CallExpression");
      }
      return Z;
    }
    parseBreakContinueStatement(Z, Q) {
      if (this.next(), this.isLineTerminator())
        Z.label = null;
      else
        Z.label = this.parseIdentifier(), this.semicolon();
      return this.verifyBreakContinue(Z, Q), this.finishNode(Z, Q ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(Z, Q) {
      let J;
      for (J = 0;J < this.state.labels.length; ++J) {
        const X = this.state.labels[J];
        if (Z.label == null || X.name === Z.label.name) {
          if (X.kind != null && (Q || X.kind === 1))
            break;
          if (Z.label && Q)
            break;
        }
      }
      if (J === this.state.labels.length) {
        const X = Q ? "BreakStatement" : "ContinueStatement";
        this.raise(C.IllegalBreakContinue, Z, {
          type: X
        });
      }
    }
    parseDebuggerStatement(Z) {
      return this.next(), this.semicolon(), this.finishNode(Z, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const Z = this.parseExpression();
      return this.expect(11), Z;
    }
    parseDoWhileStatement(Z) {
      return this.next(), this.state.labels.push(I6), Z.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), Z.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(Z, "DoWhileStatement");
    }
    parseForStatement(Z) {
      this.next(), this.state.labels.push(I6);
      let Q = null;
      if (this.isAwaitAllowed() && this.eatContextual(96))
        Q = this.state.lastTokStartLoc;
      if (this.scope.enter(0), this.expect(10), this.match(13)) {
        if (Q !== null)
          this.unexpected(Q);
        return this.parseFor(Z, null);
      }
      const J = this.isContextual(100);
      {
        const U = this.isContextual(96) && this.startsAwaitUsing(), V = U || this.isContextual(107) && this.startsUsingForOf(), M = J && this.hasFollowingBindingAtom() || V;
        if (this.match(74) || this.match(75) || M) {
          const q = this.startNode();
          let L;
          if (U) {
            if (L = "await using", !this.isAwaitAllowed())
              this.raise(C.AwaitUsingNotInAsyncContext, this.state.startLoc);
            this.next();
          } else
            L = this.state.value;
          this.next(), this.parseVar(q, !0, L);
          const N = this.finishNode(q, "VariableDeclaration"), T = this.match(58);
          if (T && V)
            this.raise(C.ForInUsing, N);
          if ((T || this.isContextual(102)) && N.declarations.length === 1)
            return this.parseForIn(Z, N, Q);
          if (Q !== null)
            this.unexpected(Q);
          return this.parseFor(Z, N);
        }
      }
      const X = this.isContextual(95), z = new H8, Y = this.parseExpression(!0, z), W = this.isContextual(102);
      if (W) {
        if (J)
          this.raise(C.ForOfLet, Y);
        if (Q === null && X && Y.type === "Identifier")
          this.raise(C.ForOfAsync, Y);
      }
      if (W || this.match(58)) {
        this.checkDestructuringPrivate(z), this.toAssignable(Y, !0);
        const U = W ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(Y, {
          in: {
            type: U
          }
        }), this.parseForIn(Z, Y, Q);
      } else
        this.checkExpressionErrors(z, !0);
      if (Q !== null)
        this.unexpected(Q);
      return this.parseFor(Z, Y);
    }
    parseFunctionStatement(Z, Q, J) {
      return this.next(), this.parseFunction(Z, 1 | (J ? 2 : 0) | (Q ? 8 : 0));
    }
    parseIfStatement(Z) {
      return this.next(), Z.test = this.parseHeaderExpression(), Z.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), Z.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(Z, "IfStatement");
    }
    parseReturnStatement(Z) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction)
        this.raise(C.IllegalReturn, this.state.startLoc);
      if (this.next(), this.isLineTerminator())
        Z.argument = null;
      else
        Z.argument = this.parseExpression(), this.semicolon();
      return this.finishNode(Z, "ReturnStatement");
    }
    parseSwitchStatement(Z) {
      this.next(), Z.discriminant = this.parseHeaderExpression();
      const Q = Z.cases = [];
      this.expect(5), this.state.labels.push(oK), this.scope.enter(0);
      let J;
      for (let X;!this.match(8); )
        if (this.match(61) || this.match(65)) {
          const z = this.match(61);
          if (J)
            this.finishNode(J, "SwitchCase");
          if (Q.push(J = this.startNode()), J.consequent = [], this.next(), z)
            J.test = this.parseExpression();
          else {
            if (X)
              this.raise(C.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
            X = !0, J.test = null;
          }
          this.expect(14);
        } else if (J)
          J.consequent.push(this.parseStatementListItem());
        else
          this.unexpected();
      if (this.scope.exit(), J)
        this.finishNode(J, "SwitchCase");
      return this.next(), this.state.labels.pop(), this.finishNode(Z, "SwitchStatement");
    }
    parseThrowStatement(Z) {
      if (this.next(), this.hasPrecedingLineBreak())
        this.raise(C.NewlineAfterThrow, this.state.lastTokEndLoc);
      return Z.argument = this.parseExpression(), this.semicolon(), this.finishNode(Z, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const Z = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && Z.type === "Identifier" ? 8 : 0), this.checkLVal(Z, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), Z;
    }
    parseTryStatement(Z) {
      if (this.next(), Z.block = this.parseBlock(), Z.handler = null, this.match(62)) {
        const Q = this.startNode();
        if (this.next(), this.match(10))
          this.expect(10), Q.param = this.parseCatchClauseParam(), this.expect(11);
        else
          Q.param = null, this.scope.enter(0);
        Q.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), Z.handler = this.finishNode(Q, "CatchClause");
      }
      if (Z.finalizer = this.eat(67) ? this.parseBlock() : null, !Z.handler && !Z.finalizer)
        this.raise(C.NoCatchOrFinally, Z);
      return this.finishNode(Z, "TryStatement");
    }
    parseVarStatement(Z, Q, J = !1) {
      return this.next(), this.parseVar(Z, !1, Q, J), this.semicolon(), this.finishNode(Z, "VariableDeclaration");
    }
    parseWhileStatement(Z) {
      return this.next(), Z.test = this.parseHeaderExpression(), this.state.labels.push(I6), Z.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(Z, "WhileStatement");
    }
    parseWithStatement(Z) {
      if (this.state.strict)
        this.raise(C.StrictWith, this.state.startLoc);
      return this.next(), Z.object = this.parseHeaderExpression(), Z.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(Z, "WithStatement");
    }
    parseEmptyStatement(Z) {
      return this.next(), this.finishNode(Z, "EmptyStatement");
    }
    parseLabeledStatement(Z, Q, J, X) {
      for (let Y of this.state.labels)
        if (Y.name === Q)
          this.raise(C.LabelRedeclaration, J, {
            labelName: Q
          });
      const z = JK(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let Y = this.state.labels.length - 1;Y >= 0; Y--) {
        const W = this.state.labels[Y];
        if (W.statementStart === Z.start)
          W.statementStart = this.state.start, W.kind = z;
        else
          break;
      }
      return this.state.labels.push({
        name: Q,
        kind: z,
        statementStart: this.state.start
      }), Z.body = X & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), Z.label = J, this.finishNode(Z, "LabeledStatement");
    }
    parseExpressionStatement(Z, Q, J) {
      return Z.expression = Q, this.semicolon(), this.finishNode(Z, "ExpressionStatement");
    }
    parseBlock(Z = !1, Q = !0, J) {
      const X = this.startNode();
      if (Z)
        this.state.strictErrors.clear();
      if (this.expect(5), Q)
        this.scope.enter(0);
      if (this.parseBlockBody(X, Z, !1, 8, J), Q)
        this.scope.exit();
      return this.finishNode(X, "BlockStatement");
    }
    isValidDirective(Z) {
      return Z.type === "ExpressionStatement" && Z.expression.type === "StringLiteral" && !Z.expression.extra.parenthesized;
    }
    parseBlockBody(Z, Q, J, X, z) {
      const Y = Z.body = [], W = Z.directives = [];
      this.parseBlockOrModuleBlockBody(Y, Q ? W : void 0, J, X, z);
    }
    parseBlockOrModuleBlockBody(Z, Q, J, X, z) {
      const Y = this.state.strict;
      let W = !1, U = !1;
      while (!this.match(X)) {
        const V = J ? this.parseModuleItem() : this.parseStatementListItem();
        if (Q && !U) {
          if (this.isValidDirective(V)) {
            const M = this.stmtToDirective(V);
            if (Q.push(M), !W && M.value.value === "use strict")
              W = !0, this.setStrict(!0);
            continue;
          }
          U = !0, this.state.strictErrors.clear();
        }
        Z.push(V);
      }
      if (z == null || z.call(this, W), !Y)
        this.setStrict(!1);
      this.next();
    }
    parseFor(Z, Q) {
      return Z.init = Q, this.semicolon(!1), Z.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), Z.update = this.match(11) ? null : this.parseExpression(), this.expect(11), Z.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(Z, "ForStatement");
    }
    parseForIn(Z, Q, J) {
      const X = this.match(58);
      if (this.next(), X) {
        if (J !== null)
          this.unexpected(J);
      } else
        Z.await = J !== null;
      if (Q.type === "VariableDeclaration" && Q.declarations[0].init != null && (!X || !this.options.annexB || this.state.strict || Q.kind !== "var" || Q.declarations[0].id.type !== "Identifier"))
        this.raise(C.ForInOfLoopInitializer, Q, {
          type: X ? "ForInStatement" : "ForOfStatement"
        });
      if (Q.type === "AssignmentPattern")
        this.raise(C.InvalidLhs, Q, {
          ancestor: {
            type: "ForStatement"
          }
        });
      return Z.left = Q, Z.right = X ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), Z.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(Z, X ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(Z, Q, J, X = !1) {
      const z = Z.declarations = [];
      Z.kind = J;
      for (;; ) {
        const Y = this.startNode();
        if (this.parseVarId(Y, J), Y.init = !this.eat(29) ? null : Q ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn(), Y.init === null && !X) {
          if (Y.id.type !== "Identifier" && !(Q && (this.match(58) || this.isContextual(102))))
            this.raise(C.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind: "destructuring"
            });
          else if (J === "const" && !(this.match(58) || this.isContextual(102)))
            this.raise(C.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind: "const"
            });
        }
        if (z.push(this.finishNode(Y, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return Z;
    }
    parseVarId(Z, Q) {
      const J = this.parseBindingAtom();
      this.checkLVal(J, {
        in: {
          type: "VariableDeclarator"
        },
        binding: Q === "var" ? 5 : 8201
      }), Z.id = J;
    }
    parseAsyncFunctionExpression(Z) {
      return this.parseFunction(Z, 8);
    }
    parseFunction(Z, Q = 0) {
      const J = Q & 2, X = !!(Q & 1), z = X && !(Q & 4), Y = !!(Q & 8);
      if (this.initFunction(Z, Y), this.match(55)) {
        if (J)
          this.raise(C.GeneratorInSingleStatementContext, this.state.startLoc);
        this.next(), Z.generator = !0;
      }
      if (X)
        Z.id = this.parseFunctionId(z);
      const W = this.state.maybeInArrowParameters;
      if (this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Y7(Y, Z.generator)), !X)
        Z.id = this.parseFunctionId();
      if (this.parseFunctionParams(Z, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(Z, X ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), X && !J)
        this.registerFunctionStatementId(Z);
      return this.state.maybeInArrowParameters = W, Z;
    }
    parseFunctionId(Z) {
      return Z || K0(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(Z, Q) {
      this.expect(10), this.expressionScope.enter(NK()), Z.params = this.parseBindingList(11, 41, 2 | (Q ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(Z) {
      if (!Z.id)
        return;
      this.scope.declareName(Z.id.name, !this.options.annexB || this.state.strict || Z.generator || Z.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, Z.id.loc.start);
    }
    parseClass(Z, Q, J) {
      this.next();
      const X = this.state.strict;
      return this.state.strict = !0, this.parseClassId(Z, Q, J), this.parseClassSuper(Z), Z.body = this.parseClassBody(!!Z.superClass, X), this.finishNode(Z, Q ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(Z) {
      return !Z.computed && !Z.static && (Z.key.name === "constructor" || Z.key.value === "constructor");
    }
    parseClassBody(Z, Q) {
      this.classScope.enter();
      const J = {
        hadConstructor: !1,
        hadSuperClass: Z
      };
      let X = [];
      const z = this.startNode();
      if (z.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        while (!this.match(8)) {
          if (this.eat(13)) {
            if (X.length > 0)
              throw this.raise(C.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            X.push(this.parseDecorator());
            continue;
          }
          const Y = this.startNode();
          if (X.length)
            Y.decorators = X, this.resetStartLocationFromNode(Y, X[0]), X = [];
          if (this.parseClassMember(z, Y, J), Y.kind === "constructor" && Y.decorators && Y.decorators.length > 0)
            this.raise(C.DecoratorConstructor, Y);
        }
      }), this.state.strict = Q, this.next(), X.length)
        throw this.raise(C.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(z, "ClassBody");
    }
    parseClassMemberFromModifier(Z, Q) {
      const J = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        const X = Q;
        return X.kind = "method", X.computed = !1, X.key = J, X.static = !1, this.pushClassMethod(Z, X, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        const X = Q;
        return X.computed = !1, X.key = J, X.static = !1, Z.body.push(this.parseClassProperty(X)), !0;
      }
      return this.resetPreviousNodeTrailingComments(J), !1;
    }
    parseClassMember(Z, Q, J) {
      const X = this.isContextual(106);
      if (X) {
        if (this.parseClassMemberFromModifier(Z, Q))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(Z, Q);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(Z, Q, J, X);
    }
    parseClassMemberWithIsStatic(Z, Q, J, X) {
      const z = Q, Y = Q, W = Q, U = Q, V = Q, M = z, q = z;
      if (Q.static = X, this.parsePropertyNamePrefixOperator(Q), this.eat(55)) {
        M.kind = "method";
        const g = this.match(138);
        if (this.parseClassElementName(M), g) {
          this.pushClassPrivateMethod(Z, Y, !0, !1);
          return;
        }
        if (this.isNonstaticConstructor(z))
          this.raise(C.ConstructorIsGenerator, z.key);
        this.pushClassMethod(Z, z, !0, !1, !1, !1);
        return;
      }
      const L = K0(this.state.type) && !this.state.containsEsc, N = this.match(138), T = this.parseClassElementName(Q), E = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(q), this.isClassMethod()) {
        if (M.kind = "method", N) {
          this.pushClassPrivateMethod(Z, Y, !1, !1);
          return;
        }
        const g = this.isNonstaticConstructor(z);
        let n = !1;
        if (g) {
          if (z.kind = "constructor", J.hadConstructor && !this.hasPlugin("typescript"))
            this.raise(C.DuplicateConstructor, T);
          if (g && this.hasPlugin("typescript") && Q.override)
            this.raise(C.OverrideOnConstructor, T);
          J.hadConstructor = !0, n = J.hadSuperClass;
        }
        this.pushClassMethod(Z, z, !1, !1, g, n);
      } else if (this.isClassProperty())
        if (N)
          this.pushClassPrivateProperty(Z, U);
        else
          this.pushClassProperty(Z, W);
      else if (L && T.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(T);
        const g = this.eat(55);
        if (q.optional)
          this.unexpected(E);
        M.kind = "method";
        const n = this.match(138);
        if (this.parseClassElementName(M), this.parsePostMemberNameModifiers(q), n)
          this.pushClassPrivateMethod(Z, Y, g, !0);
        else {
          if (this.isNonstaticConstructor(z))
            this.raise(C.ConstructorIsAsync, z.key);
          this.pushClassMethod(Z, z, g, !0, !1, !1);
        }
      } else if (L && (T.name === "get" || T.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(T), M.kind = T.name;
        const g = this.match(138);
        if (this.parseClassElementName(z), g)
          this.pushClassPrivateMethod(Z, Y, !1, !1);
        else {
          if (this.isNonstaticConstructor(z))
            this.raise(C.ConstructorIsAccessor, z.key);
          this.pushClassMethod(Z, z, !1, !1, !1, !1);
        }
        this.checkGetterSetterParams(z);
      } else if (L && T.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(T);
        const g = this.match(138);
        this.parseClassElementName(W), this.pushClassAccessorProperty(Z, V, g);
      } else if (this.isLineTerminator())
        if (N)
          this.pushClassPrivateProperty(Z, U);
        else
          this.pushClassProperty(Z, W);
      else
        this.unexpected();
    }
    parseClassElementName(Z) {
      const {
        type: Q,
        value: J
      } = this.state;
      if ((Q === 132 || Q === 133) && Z.static && J === "prototype")
        this.raise(C.StaticPrototype, this.state.startLoc);
      if (Q === 138) {
        if (J === "constructor")
          this.raise(C.ConstructorClassPrivateField, this.state.startLoc);
        const X = this.parsePrivateName();
        return Z.key = X, X;
      }
      return this.parsePropertyName(Z);
    }
    parseClassStaticBlock(Z, Q) {
      var J;
      this.scope.enter(64 | 128 | 16);
      const X = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const z = Q.body = [];
      if (this.parseBlockOrModuleBlockBody(z, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = X, Z.body.push(this.finishNode(Q, "StaticBlock")), (J = Q.decorators) != null && J.length)
        this.raise(C.DecoratorStaticBlock, Q);
    }
    pushClassProperty(Z, Q) {
      if (!Q.computed && (Q.key.name === "constructor" || Q.key.value === "constructor"))
        this.raise(C.ConstructorClassField, Q.key);
      Z.body.push(this.parseClassProperty(Q));
    }
    pushClassPrivateProperty(Z, Q) {
      const J = this.parseClassPrivateProperty(Q);
      Z.body.push(J), this.classScope.declarePrivateName(this.getPrivateNameSV(J.key), 0, J.key.loc.start);
    }
    pushClassAccessorProperty(Z, Q, J) {
      if (!J && !Q.computed) {
        const z = Q.key;
        if (z.name === "constructor" || z.value === "constructor")
          this.raise(C.ConstructorClassField, z);
      }
      const X = this.parseClassAccessorProperty(Q);
      if (Z.body.push(X), J)
        this.classScope.declarePrivateName(this.getPrivateNameSV(X.key), 0, X.key.loc.start);
    }
    pushClassMethod(Z, Q, J, X, z, Y) {
      Z.body.push(this.parseMethod(Q, J, X, z, Y, "ClassMethod", !0));
    }
    pushClassPrivateMethod(Z, Q, J, X) {
      const z = this.parseMethod(Q, J, X, !1, !1, "ClassPrivateMethod", !0);
      Z.body.push(z);
      const Y = z.kind === "get" ? z.static ? 6 : 2 : z.kind === "set" ? z.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(z, Y);
    }
    declareClassPrivateMethodInScope(Z, Q) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(Z.key), Q, Z.key.loc.start);
    }
    parsePostMemberNameModifiers(Z) {
    }
    parseClassPrivateProperty(Z) {
      return this.parseInitializer(Z), this.semicolon(), this.finishNode(Z, "ClassPrivateProperty");
    }
    parseClassProperty(Z) {
      return this.parseInitializer(Z), this.semicolon(), this.finishNode(Z, "ClassProperty");
    }
    parseClassAccessorProperty(Z) {
      return this.parseInitializer(Z), this.semicolon(), this.finishNode(Z, "ClassAccessorProperty");
    }
    parseInitializer(Z) {
      this.scope.enter(64 | 16), this.expressionScope.enter(rz()), this.prodParam.enter(0), Z.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(Z, Q, J, X = 8331) {
      if (K0(this.state.type)) {
        if (Z.id = this.parseIdentifier(), Q)
          this.declareNameFromIdentifier(Z.id, X);
      } else if (J || !Q)
        Z.id = null;
      else
        throw this.raise(C.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(Z) {
      Z.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(Z, Q) {
      const J = this.parseMaybeImportPhase(Z, !0), X = this.maybeParseExportDefaultSpecifier(Z, J), z = !X || this.eat(12), Y = z && this.eatExportStar(Z), W = Y && this.maybeParseExportNamespaceSpecifier(Z), U = z && (!W || this.eat(12)), V = X || Y;
      if (Y && !W) {
        if (X)
          this.unexpected();
        if (Q)
          throw this.raise(C.UnsupportedDecoratorExport, Z);
        return this.parseExportFrom(Z, !0), this.finishNode(Z, "ExportAllDeclaration");
      }
      const M = this.maybeParseExportNamedSpecifiers(Z);
      if (X && z && !Y && !M)
        this.unexpected(null, 5);
      if (W && U)
        this.unexpected(null, 98);
      let q;
      if (V || M) {
        if (q = !1, Q)
          throw this.raise(C.UnsupportedDecoratorExport, Z);
        this.parseExportFrom(Z, V);
      } else
        q = this.maybeParseExportDeclaration(Z);
      if (V || M || q) {
        var L;
        const N = Z;
        if (this.checkExport(N, !0, !1, !!N.source), ((L = N.declaration) == null ? void 0 : L.type) === "ClassDeclaration")
          this.maybeTakeDecorators(Q, N.declaration, N);
        else if (Q)
          throw this.raise(C.UnsupportedDecoratorExport, Z);
        return this.finishNode(N, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const N = Z, T = this.parseExportDefaultExpression();
        if (N.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(Q, T, N);
        else if (Q)
          throw this.raise(C.UnsupportedDecoratorExport, Z);
        return this.checkExport(N, !0, !0), this.finishNode(N, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(Z) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(Z, Q) {
      if (Q || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", Q == null ? void 0 : Q.loc.start);
        const J = Q || this.parseIdentifier(!0), X = this.startNodeAtNode(J);
        return X.exported = J, Z.specifiers = [this.finishNode(X, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(Z) {
      if (this.isContextual(93)) {
        if (!Z.specifiers)
          Z.specifiers = [];
        const Q = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), Q.exported = this.parseModuleExportName(), Z.specifiers.push(this.finishNode(Q, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(Z) {
      if (this.match(5)) {
        if (!Z.specifiers)
          Z.specifiers = [];
        const Q = Z.exportKind === "type";
        if (Z.specifiers.push(...this.parseExportSpecifiers(Q)), Z.source = null, Z.declaration = null, this.hasPlugin("importAssertions"))
          Z.assertions = [];
        return !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(Z) {
      if (this.shouldParseExportDeclaration()) {
        if (Z.specifiers = [], Z.source = null, this.hasPlugin("importAssertions"))
          Z.assertions = [];
        return Z.declaration = this.parseExportDeclaration(Z), !0;
      }
      return !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return !1;
      const Z = this.nextTokenInLineStart();
      return this.isUnparsedContextual(Z, "function");
    }
    parseExportDefaultExpression() {
      const Z = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(Z, 1 | 4);
      else if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(Z, 1 | 4 | 8);
      if (this.match(80))
        return this.parseClass(Z, !0, !0);
      if (this.match(26)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0)
          this.raise(C.DecoratorBeforeExport, this.state.startLoc);
        return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      }
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(C.UnsupportedDefaultExport, this.state.startLoc);
      const Q = this.parseMaybeAssignAllowIn();
      return this.semicolon(), Q;
    }
    parseExportDeclaration(Z) {
      if (this.match(80))
        return this.parseClass(this.startNode(), !0, !1);
      return this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type: Z
      } = this.state;
      if (K0(Z)) {
        if (Z === 95 && !this.state.containsEsc || Z === 100)
          return !1;
        if ((Z === 130 || Z === 129) && !this.state.containsEsc) {
          const {
            type: X
          } = this.lookahead();
          if (K0(X) && X !== 98 || X === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      const Q = this.nextTokenStart(), J = this.isUnparsedContextual(Q, "from");
      if (this.input.charCodeAt(Q) === 44 || K0(this.state.type) && J)
        return !0;
      if (this.match(65) && J) {
        const X = this.input.charCodeAt(this.nextTokenStartSince(Q + 4));
        return X === 34 || X === 39;
      }
      return !1;
    }
    parseExportFrom(Z, Q) {
      if (this.eatContextual(98))
        Z.source = this.parseImportSource(), this.checkExport(Z), this.maybeParseImportAttributes(Z), this.checkJSONModuleImport(Z);
      else if (Q)
        this.unexpected();
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: Z
      } = this.state;
      if (Z === 26) {
        if (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0)
            this.raise(C.DecoratorBeforeExport, this.state.startLoc);
          return !0;
        }
      }
      return Z === 74 || Z === 75 || Z === 68 || Z === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(Z, Q, J, X) {
      if (Q) {
        var z;
        if (J) {
          if (this.checkDuplicateExports(Z, "default"), this.hasPlugin("exportDefaultFrom")) {
            var Y;
            const W = Z.declaration;
            if (W.type === "Identifier" && W.name === "from" && W.end - W.start === 4 && !((Y = W.extra) != null && Y.parenthesized))
              this.raise(C.ExportDefaultFromAsIdentifier, W);
          }
        } else if ((z = Z.specifiers) != null && z.length)
          for (let W of Z.specifiers) {
            const {
              exported: U
            } = W, V = U.type === "Identifier" ? U.name : U.value;
            if (this.checkDuplicateExports(W, V), !X && W.local) {
              const {
                local: M
              } = W;
              if (M.type !== "Identifier")
                this.raise(C.ExportBindingIsString, W, {
                  localName: M.value,
                  exportName: V
                });
              else
                this.checkReservedWord(M.name, M.loc.start, !0, !1), this.scope.checkLocalExport(M);
            }
          }
        else if (Z.declaration) {
          if (Z.declaration.type === "FunctionDeclaration" || Z.declaration.type === "ClassDeclaration") {
            const W = Z.declaration.id;
            if (!W)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(Z, W.name);
          } else if (Z.declaration.type === "VariableDeclaration")
            for (let W of Z.declaration.declarations)
              this.checkDeclaration(W.id);
        }
      }
    }
    checkDeclaration(Z) {
      if (Z.type === "Identifier")
        this.checkDuplicateExports(Z, Z.name);
      else if (Z.type === "ObjectPattern")
        for (let Q of Z.properties)
          this.checkDeclaration(Q);
      else if (Z.type === "ArrayPattern") {
        for (let Q of Z.elements)
          if (Q)
            this.checkDeclaration(Q);
      } else if (Z.type === "ObjectProperty")
        this.checkDeclaration(Z.value);
      else if (Z.type === "RestElement")
        this.checkDeclaration(Z.argument);
      else if (Z.type === "AssignmentPattern")
        this.checkDeclaration(Z.left);
    }
    checkDuplicateExports(Z, Q) {
      if (this.exportedIdentifiers.has(Q))
        if (Q === "default")
          this.raise(C.DuplicateDefaultExport, Z);
        else
          this.raise(C.DuplicateExport, Z, {
            exportName: Q
          });
      this.exportedIdentifiers.add(Q);
    }
    parseExportSpecifiers(Z) {
      const Q = [];
      let J = !0;
      this.expect(5);
      while (!this.eat(8)) {
        if (J)
          J = !1;
        else if (this.expect(12), this.eat(8))
          break;
        const X = this.isContextual(130), z = this.match(133), Y = this.startNode();
        Y.local = this.parseModuleExportName(), Q.push(this.parseExportSpecifier(Y, z, Z, X));
      }
      return Q;
    }
    parseExportSpecifier(Z, Q, J, X) {
      if (this.eatContextual(93))
        Z.exported = this.parseModuleExportName();
      else if (Q)
        Z.exported = TK(Z.local);
      else if (!Z.exported)
        Z.exported = v1(Z.local);
      return this.finishNode(Z, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        const Z = this.parseStringLiteral(this.state.value), Q = Z.value.match(eK);
        if (Q)
          this.raise(C.ModuleExportNameHasLoneSurrogate, Z, {
            surrogateCharCode: Q[0].charCodeAt(0)
          });
        return Z;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(Z) {
      if (Z.assertions != null)
        return Z.assertions.some(({
          key: Q,
          value: J
        }) => {
          return J.value === "json" && (Q.type === "Identifier" ? Q.name === "type" : Q.value === "type");
        });
      return !1;
    }
    checkImportReflection(Z) {
      const {
        specifiers: Q
      } = Z, J = Q.length === 1 ? Q[0].type : null;
      if (Z.phase === "source") {
        if (J !== "ImportDefaultSpecifier")
          this.raise(C.SourcePhaseImportRequiresDefault, Q[0].loc.start);
      } else if (Z.phase === "defer") {
        if (J !== "ImportNamespaceSpecifier")
          this.raise(C.DeferImportRequiresNamespace, Q[0].loc.start);
      } else if (Z.module) {
        var X;
        if (J !== "ImportDefaultSpecifier")
          this.raise(C.ImportReflectionNotBinding, Q[0].loc.start);
        if (((X = Z.assertions) == null ? void 0 : X.length) > 0)
          this.raise(C.ImportReflectionHasAssertion, Q[0].loc.start);
      }
    }
    checkJSONModuleImport(Z) {
      if (this.isJSONModuleImport(Z) && Z.type !== "ExportAllDeclaration") {
        const {
          specifiers: Q
        } = Z;
        if (Q != null) {
          const J = Q.find((X) => {
            let z;
            if (X.type === "ExportSpecifier")
              z = X.local;
            else if (X.type === "ImportSpecifier")
              z = X.imported;
            if (z !== void 0)
              return z.type === "Identifier" ? z.name !== "default" : z.value !== "default";
          });
          if (J !== void 0)
            this.raise(C.ImportJSONBindingNotDefault, J.loc.start);
        }
      }
    }
    isPotentialImportPhase(Z) {
      if (Z)
        return !1;
      return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(Z, Q, J, X) {
      if (Q)
        return;
      if (J === "module")
        this.expectPlugin("importReflection", X), Z.module = !0;
      else if (this.hasPlugin("importReflection"))
        Z.module = !1;
      if (J === "source")
        this.expectPlugin("sourcePhaseImports", X), Z.phase = "source";
      else if (J === "defer")
        this.expectPlugin("deferredImportEvaluation", X), Z.phase = "defer";
      else if (this.hasPlugin("sourcePhaseImports"))
        Z.phase = null;
    }
    parseMaybeImportPhase(Z, Q) {
      if (!this.isPotentialImportPhase(Q))
        return this.applyImportPhase(Z, Q, null), null;
      const J = this.parseIdentifier(!0), {
        type: X
      } = this.state;
      if (G1(X) ? X !== 98 || this.lookaheadCharCode() === 102 : X !== 12)
        return this.resetPreviousIdentifierLeadingComments(J), this.applyImportPhase(Z, Q, J.name, J.loc.start), null;
      else
        return this.applyImportPhase(Z, Q, null), J;
    }
    isPrecedingIdImportPhase(Z) {
      const {
        type: Q
      } = this.state;
      return K0(Q) ? Q !== 98 || this.lookaheadCharCode() === 102 : Q !== 12;
    }
    parseImport(Z) {
      if (this.match(133))
        return this.parseImportSourceAndAttributes(Z);
      return this.parseImportSpecifiersAndAfter(Z, this.parseMaybeImportPhase(Z, !1));
    }
    parseImportSpecifiersAndAfter(Z, Q) {
      Z.specifiers = [];
      const X = !this.maybeParseDefaultImportSpecifier(Z, Q) || this.eat(12), z = X && this.maybeParseStarImportSpecifier(Z);
      if (X && !z)
        this.parseNamedImportSpecifiers(Z);
      return this.expectContextual(98), this.parseImportSourceAndAttributes(Z);
    }
    parseImportSourceAndAttributes(Z) {
      var Q;
      return (Q = Z.specifiers) != null || (Z.specifiers = []), Z.source = this.parseImportSource(), this.maybeParseImportAttributes(Z), this.checkImportReflection(Z), this.checkJSONModuleImport(Z), this.semicolon(), this.finishNode(Z, "ImportDeclaration");
    }
    parseImportSource() {
      if (!this.match(133))
        this.unexpected();
      return this.parseExprAtom();
    }
    parseImportSpecifierLocal(Z, Q, J) {
      Q.local = this.parseIdentifier(), Z.specifiers.push(this.finishImportSpecifier(Q, J));
    }
    finishImportSpecifier(Z, Q, J = 8201) {
      return this.checkLVal(Z.local, {
        in: {
          type: Q
        },
        binding: J
      }), this.finishNode(Z, Q);
    }
    parseImportAttributes() {
      this.expect(5);
      const Z = [], Q = new Set;
      do {
        if (this.match(8))
          break;
        const J = this.startNode(), X = this.state.value;
        if (Q.has(X))
          this.raise(C.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
            key: X
          });
        if (Q.add(X), this.match(133))
          J.key = this.parseStringLiteral(X);
        else
          J.key = this.parseIdentifier(!0);
        if (this.expect(14), !this.match(133))
          throw this.raise(C.ModuleAttributeInvalidValue, this.state.startLoc);
        J.value = this.parseStringLiteral(this.state.value), Z.push(this.finishNode(J, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), Z;
    }
    parseModuleAttributes() {
      const Z = [], Q = new Set;
      do {
        const J = this.startNode();
        if (J.key = this.parseIdentifier(!0), J.key.name !== "type")
          this.raise(C.ModuleAttributeDifferentFromType, J.key);
        if (Q.has(J.key.name))
          this.raise(C.ModuleAttributesWithDuplicateKeys, J.key, {
            key: J.key.name
          });
        if (Q.add(J.key.name), this.expect(14), !this.match(133))
          throw this.raise(C.ModuleAttributeInvalidValue, this.state.startLoc);
        J.value = this.parseStringLiteral(this.state.value), Z.push(this.finishNode(J, "ImportAttribute"));
      } while (this.eat(12));
      return Z;
    }
    maybeParseImportAttributes(Z) {
      let Q, J = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        if (this.next(), this.hasPlugin("moduleAttributes"))
          Q = this.parseModuleAttributes();
        else
          this.expectImportAttributesPlugin(), Q = this.parseImportAttributes();
        J = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
        if (this.hasPlugin("importAttributes")) {
          if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0)
            this.raise(C.ImportAttributesUseAssert, this.state.startLoc);
          this.addExtra(Z, "deprecatedAssertSyntax", !0);
        } else
          this.expectOnePlugin(["importAttributes", "importAssertions"]);
        this.next(), Q = this.parseImportAttributes();
      } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        Q = [];
      else if (this.hasPlugin("moduleAttributes"))
        Q = [];
      else
        return;
      if (!J && this.hasPlugin("importAssertions"))
        Z.assertions = Q;
      else
        Z.attributes = Q;
    }
    maybeParseDefaultImportSpecifier(Z, Q) {
      if (Q) {
        const J = this.startNodeAtNode(Q);
        return J.local = Q, Z.specifiers.push(this.finishImportSpecifier(J, "ImportDefaultSpecifier")), !0;
      } else if (G1(this.state.type))
        return this.parseImportSpecifierLocal(Z, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(Z) {
      if (this.match(55)) {
        const Q = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(Z, Q, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(Z) {
      let Q = !0;
      this.expect(5);
      while (!this.eat(8)) {
        if (Q)
          Q = !1;
        else {
          if (this.eat(14))
            throw this.raise(C.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8))
            break;
        }
        const J = this.startNode(), X = this.match(133), z = this.isContextual(130);
        J.imported = this.parseModuleExportName();
        const Y = this.parseImportSpecifier(J, X, Z.importKind === "type" || Z.importKind === "typeof", z, void 0);
        Z.specifiers.push(Y);
      }
    }
    parseImportSpecifier(Z, Q, J, X, z) {
      if (this.eatContextual(93))
        Z.local = this.parseIdentifier();
      else {
        const {
          imported: Y
        } = Z;
        if (Q)
          throw this.raise(C.ImportBindingIsString, Z, {
            importName: Y.value
          });
        if (this.checkReservedWord(Y.name, Z.loc.start, !0, !0), !Z.local)
          Z.local = v1(Y);
      }
      return this.finishImportSpecifier(Z, "ImportSpecifier", z);
    }
    isThisParam(Z) {
      return Z.type === "Identifier" && Z.name === "this";
    }
  }

  class m6 extends Y4 {
    constructor(Z, Q) {
      Z = tK(Z);
      super(Z, Q);
      this.options = Z, this.initializeScopes(), this.plugins = Q3(this.options.plugins), this.filename = Z.sourceFilename;
    }
    getScopeHandler() {
      return U7;
    }
    parse() {
      this.enterInitialScopes();
      const Z = this.startNode(), Q = this.startNode();
      return this.nextToken(), Z.errors = null, this.parseTopLevel(Z, Q), Z.errors = this.state.errors, Z.comments.length = this.state.commentsLen, Z;
    }
  }
  var H3 = z3(oV), Sz = {};
  W4.parse = J3;
  W4.parseExpression = X3;
  W4.tokTypes = H3;
});

// node_modules/@babel/types/lib/utils/shallowEqual.js
var V7 = P((G4) => {
  var V3 = function(Z, Q) {
    const J = Object.keys(Q);
    for (let X of J)
      if (Z[X] !== Q[X])
        return !1;
    return !0;
  };
  Object.defineProperty(G4, "__esModule", {
    value: !0
  });
  G4.default = V3;
});

// node_modules/@babel/types/lib/utils/deprecationWarning.js
var V8 = P((V4) => {
  var M3 = function(Z, Q, J = "") {
    if (U4.has(Z))
      return;
    U4.add(Z);
    const {
      internal: X,
      trace: z
    } = F3(1, 2);
    if (X)
      return;
    console.warn(`${J}\`${Z}\` has been deprecated, please migrate to \`${Q}\`\n${z}`);
  }, F3 = function(Z, Q) {
    const {
      stackTraceLimit: J,
      prepareStackTrace: X
    } = Error;
    let z;
    if (Error.stackTraceLimit = 1 + Z + Q, Error.prepareStackTrace = function(W, U) {
      z = U;
    }, new Error().stack, Error.stackTraceLimit = J, Error.prepareStackTrace = X, !z)
      return {
        internal: !1,
        trace: ""
      };
    const Y = z.slice(1 + Z, 1 + Z + Q);
    return {
      internal: /[\\/]@babel[\\/]/.test(Y[1].getFileName()),
      trace: Y.map((W) => `    at ${W}`).join("\n")
    };
  };
  Object.defineProperty(V4, "__esModule", {
    value: !0
  });
  V4.default = M3;
  var U4 = new Set;
});

// node_modules/@babel/types/lib/validators/generated/index.js
var S0 = P((M4) => {
  var j3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ArrayExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, O3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "AssignmentExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, B3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BinaryExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, q3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "InterpreterDirective")
      return !1;
    return Q == null || B.default(Z, Q);
  }, $3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Directive")
      return !1;
    return Q == null || B.default(Z, Q);
  }, D3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DirectiveLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, I3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BlockStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, C3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BreakStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, A3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "CallExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, L3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "CatchClause")
      return !1;
    return Q == null || B.default(Z, Q);
  }, N3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ConditionalExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, P3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ContinueStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, S3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DebuggerStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, w3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DoWhileStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, T3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EmptyStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, v3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExpressionStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, b3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "File")
      return !1;
    return Q == null || B.default(Z, Q);
  }, E3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ForInStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, g3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ForStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, h3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "FunctionDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, _3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "FunctionExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, k3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Identifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, f3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "IfStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, y3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "LabeledStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, m3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "StringLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, u3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "NumericLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, x3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "NullLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, c3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BooleanLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, l3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "RegExpLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, i3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "LogicalExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, d3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "MemberExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, p3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "NewExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, a3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Program")
      return !1;
    return Q == null || B.default(Z, Q);
  }, r3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, n3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectMethod")
      return !1;
    return Q == null || B.default(Z, Q);
  }, s3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, t3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "RestElement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, o3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ReturnStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, e3 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "SequenceExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, Z2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ParenthesizedExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, Q2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "SwitchCase")
      return !1;
    return Q == null || B.default(Z, Q);
  }, J2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "SwitchStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, X2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ThisExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, z2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ThrowStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, H2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TryStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, Y2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "UnaryExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, W2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "UpdateExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, G2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "VariableDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, U2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "VariableDeclarator")
      return !1;
    return Q == null || B.default(Z, Q);
  }, V2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "WhileStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, K2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "WithStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, M2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "AssignmentPattern")
      return !1;
    return Q == null || B.default(Z, Q);
  }, F2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ArrayPattern")
      return !1;
    return Q == null || B.default(Z, Q);
  }, R2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ArrowFunctionExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, j2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassBody")
      return !1;
    return Q == null || B.default(Z, Q);
  }, O2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, B2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, q2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExportAllDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, $2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExportDefaultDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, D2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExportNamedDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, I2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExportSpecifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, C2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ForOfStatement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, A2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ImportDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, L2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ImportDefaultSpecifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, N2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ImportNamespaceSpecifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, P2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ImportSpecifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, S2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ImportExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, w2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "MetaProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, T2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassMethod")
      return !1;
    return Q == null || B.default(Z, Q);
  }, v2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectPattern")
      return !1;
    return Q == null || B.default(Z, Q);
  }, b2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "SpreadElement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, E2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Super")
      return !1;
    return Q == null || B.default(Z, Q);
  }, g2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TaggedTemplateExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, h2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TemplateElement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, _2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TemplateLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, k2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "YieldExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, f2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "AwaitExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, y2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Import")
      return !1;
    return Q == null || B.default(Z, Q);
  }, m2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BigIntLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, u2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExportNamespaceSpecifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, x2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "OptionalMemberExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, c2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "OptionalCallExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, l2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, i2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassAccessorProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, d2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassPrivateProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, p2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassPrivateMethod")
      return !1;
    return Q == null || B.default(Z, Q);
  }, a2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "PrivateName")
      return !1;
    return Q == null || B.default(Z, Q);
  }, r2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "StaticBlock")
      return !1;
    return Q == null || B.default(Z, Q);
  }, n2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "AnyTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, s2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ArrayTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, t2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BooleanTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, o2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BooleanLiteralTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, e2 = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "NullLiteralTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, ZM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ClassImplements")
      return !1;
    return Q == null || B.default(Z, Q);
  }, QM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareClass")
      return !1;
    return Q == null || B.default(Z, Q);
  }, JM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareFunction")
      return !1;
    return Q == null || B.default(Z, Q);
  }, XM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareInterface")
      return !1;
    return Q == null || B.default(Z, Q);
  }, zM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareModule")
      return !1;
    return Q == null || B.default(Z, Q);
  }, HM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareModuleExports")
      return !1;
    return Q == null || B.default(Z, Q);
  }, YM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareTypeAlias")
      return !1;
    return Q == null || B.default(Z, Q);
  }, WM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareOpaqueType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, GM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareVariable")
      return !1;
    return Q == null || B.default(Z, Q);
  }, UM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareExportDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, VM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclareExportAllDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, KM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DeclaredPredicate")
      return !1;
    return Q == null || B.default(Z, Q);
  }, MM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExistsTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, FM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "FunctionTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, RM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "FunctionTypeParam")
      return !1;
    return Q == null || B.default(Z, Q);
  }, jM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "GenericTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, OM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "InferredPredicate")
      return !1;
    return Q == null || B.default(Z, Q);
  }, BM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "InterfaceExtends")
      return !1;
    return Q == null || B.default(Z, Q);
  }, qM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "InterfaceDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, $M = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "InterfaceTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, DM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "IntersectionTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, IM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "MixedTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, CM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EmptyTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, AM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "NullableTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, LM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "NumberLiteralTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, NM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "NumberTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, PM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, SM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectTypeInternalSlot")
      return !1;
    return Q == null || B.default(Z, Q);
  }, wM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectTypeCallProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, TM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectTypeIndexer")
      return !1;
    return Q == null || B.default(Z, Q);
  }, vM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectTypeProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, bM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ObjectTypeSpreadProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, EM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "OpaqueType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, gM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "QualifiedTypeIdentifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, hM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "StringLiteralTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, _M = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "StringTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, kM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "SymbolTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, fM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ThisTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, yM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TupleTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, mM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TypeofTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, uM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TypeAlias")
      return !1;
    return Q == null || B.default(Z, Q);
  }, xM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, cM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TypeCastExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, lM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TypeParameter")
      return !1;
    return Q == null || B.default(Z, Q);
  }, iM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TypeParameterDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, dM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TypeParameterInstantiation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, pM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "UnionTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, aM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Variance")
      return !1;
    return Q == null || B.default(Z, Q);
  }, rM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "VoidTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, nM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, sM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumBooleanBody")
      return !1;
    return Q == null || B.default(Z, Q);
  }, tM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumNumberBody")
      return !1;
    return Q == null || B.default(Z, Q);
  }, oM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumStringBody")
      return !1;
    return Q == null || B.default(Z, Q);
  }, eM = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumSymbolBody")
      return !1;
    return Q == null || B.default(Z, Q);
  }, ZF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumBooleanMember")
      return !1;
    return Q == null || B.default(Z, Q);
  }, QF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumNumberMember")
      return !1;
    return Q == null || B.default(Z, Q);
  }, JF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumStringMember")
      return !1;
    return Q == null || B.default(Z, Q);
  }, XF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "EnumDefaultedMember")
      return !1;
    return Q == null || B.default(Z, Q);
  }, zF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "IndexedAccessType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, HF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "OptionalIndexedAccessType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, YF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXAttribute")
      return !1;
    return Q == null || B.default(Z, Q);
  }, WF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXClosingElement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, GF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXElement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, UF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXEmptyExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, VF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXExpressionContainer")
      return !1;
    return Q == null || B.default(Z, Q);
  }, KF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXSpreadChild")
      return !1;
    return Q == null || B.default(Z, Q);
  }, MF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXIdentifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, FF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXMemberExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, RF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXNamespacedName")
      return !1;
    return Q == null || B.default(Z, Q);
  }, jF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXOpeningElement")
      return !1;
    return Q == null || B.default(Z, Q);
  }, OF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXSpreadAttribute")
      return !1;
    return Q == null || B.default(Z, Q);
  }, BF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXText")
      return !1;
    return Q == null || B.default(Z, Q);
  }, qF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXFragment")
      return !1;
    return Q == null || B.default(Z, Q);
  }, $F = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXOpeningFragment")
      return !1;
    return Q == null || B.default(Z, Q);
  }, DF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "JSXClosingFragment")
      return !1;
    return Q == null || B.default(Z, Q);
  }, IF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Noop")
      return !1;
    return Q == null || B.default(Z, Q);
  }, CF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Placeholder")
      return !1;
    return Q == null || B.default(Z, Q);
  }, AF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "V8IntrinsicIdentifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, LF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ArgumentPlaceholder")
      return !1;
    return Q == null || B.default(Z, Q);
  }, NF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "BindExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, PF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ImportAttribute")
      return !1;
    return Q == null || B.default(Z, Q);
  }, SF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "Decorator")
      return !1;
    return Q == null || B.default(Z, Q);
  }, wF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DoExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, TF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ExportDefaultSpecifier")
      return !1;
    return Q == null || B.default(Z, Q);
  }, vF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "RecordExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, bF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TupleExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, EF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "DecimalLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, gF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "ModuleExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, hF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TopicReference")
      return !1;
    return Q == null || B.default(Z, Q);
  }, _F = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "PipelineTopicExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, kF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "PipelineBareFunction")
      return !1;
    return Q == null || B.default(Z, Q);
  }, fF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "PipelinePrimaryTopicReference")
      return !1;
    return Q == null || B.default(Z, Q);
  }, yF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSParameterProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, mF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSDeclareFunction")
      return !1;
    return Q == null || B.default(Z, Q);
  }, uF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSDeclareMethod")
      return !1;
    return Q == null || B.default(Z, Q);
  }, xF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSQualifiedName")
      return !1;
    return Q == null || B.default(Z, Q);
  }, cF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSCallSignatureDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, lF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSConstructSignatureDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, iF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSPropertySignature")
      return !1;
    return Q == null || B.default(Z, Q);
  }, dF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSMethodSignature")
      return !1;
    return Q == null || B.default(Z, Q);
  }, pF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSIndexSignature")
      return !1;
    return Q == null || B.default(Z, Q);
  }, aF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSAnyKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, rF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSBooleanKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, nF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSBigIntKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, sF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSIntrinsicKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, tF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSNeverKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, oF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSNullKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, eF = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSNumberKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, ZR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSObjectKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, QR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSStringKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, JR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSSymbolKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, XR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSUndefinedKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, zR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSUnknownKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, HR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSVoidKeyword")
      return !1;
    return Q == null || B.default(Z, Q);
  }, YR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSThisType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, WR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSFunctionType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, GR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSConstructorType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, UR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeReference")
      return !1;
    return Q == null || B.default(Z, Q);
  }, VR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypePredicate")
      return !1;
    return Q == null || B.default(Z, Q);
  }, KR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeQuery")
      return !1;
    return Q == null || B.default(Z, Q);
  }, MR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, FR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSArrayType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, RR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTupleType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, jR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSOptionalType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, OR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSRestType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, BR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSNamedTupleMember")
      return !1;
    return Q == null || B.default(Z, Q);
  }, qR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSUnionType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, $R = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSIntersectionType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, DR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSConditionalType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, IR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSInferType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, CR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSParenthesizedType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, AR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeOperator")
      return !1;
    return Q == null || B.default(Z, Q);
  }, LR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSIndexedAccessType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, NR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSMappedType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, PR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSLiteralType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, SR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSExpressionWithTypeArguments")
      return !1;
    return Q == null || B.default(Z, Q);
  }, wR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSInterfaceDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, TR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSInterfaceBody")
      return !1;
    return Q == null || B.default(Z, Q);
  }, vR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeAliasDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, bR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSInstantiationExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, ER = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSAsExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, gR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSSatisfiesExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, hR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeAssertion")
      return !1;
    return Q == null || B.default(Z, Q);
  }, _R = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSEnumDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, kR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSEnumMember")
      return !1;
    return Q == null || B.default(Z, Q);
  }, fR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSModuleDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, yR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSModuleBlock")
      return !1;
    return Q == null || B.default(Z, Q);
  }, mR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSImportType")
      return !1;
    return Q == null || B.default(Z, Q);
  }, uR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSImportEqualsDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, xR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSExternalModuleReference")
      return !1;
    return Q == null || B.default(Z, Q);
  }, cR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSNonNullExpression")
      return !1;
    return Q == null || B.default(Z, Q);
  }, lR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSExportAssignment")
      return !1;
    return Q == null || B.default(Z, Q);
  }, iR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSNamespaceExportDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, dR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeAnnotation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, pR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeParameterInstantiation")
      return !1;
    return Q == null || B.default(Z, Q);
  }, aR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeParameterDeclaration")
      return !1;
    return Q == null || B.default(Z, Q);
  }, rR = function(Z, Q) {
    if (!Z)
      return !1;
    if (Z.type !== "TSTypeParameter")
      return !1;
    return Q == null || B.default(Z, Q);
  }, nR = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (Z.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, sR = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (Z.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, tR = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, oR = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (Z.expectedNode === "BlockStatement")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, eR = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (Z.expectedNode === "BlockStatement")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Zj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (Z.expectedNode === "BlockStatement")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Qj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (Z.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Jj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Xj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, zj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Hj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Yj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Wj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Gj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Uj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Vj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Kj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Mj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (Z.expectedNode === "StringLiteral")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Fj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (Z.expectedNode === "Declaration")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Rj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (Z.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, jj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (Z.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Oj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (Z.expectedNode === "Identifier")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Bj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (Z.expectedNode === "StringLiteral")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, qj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (Z.expectedNode === "StringLiteral")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, $j = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Dj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Ij = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Cj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Aj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Lj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (Z.expectedNode === "Pattern")
          break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Nj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, K4 = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Pj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Sj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, wj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Tj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, vj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, bj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, Ej = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, gj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, hj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, _j = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, kj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, fj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, yj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, mj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, uj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, xj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, cj = function(Z, Q) {
    if (!Z)
      return !1;
    switch (Z.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return Q == null || B.default(Z, Q);
  }, lj = function(Z, Q) {
    if (K8.default("isNumberLiteral", "isNumericLiteral"), !Z)
      return !1;
    if (Z.type !== "NumberLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, ij = function(Z, Q) {
    if (K8.default("isRegexLiteral", "isRegExpLiteral"), !Z)
      return !1;
    if (Z.type !== "RegexLiteral")
      return !1;
    return Q == null || B.default(Z, Q);
  }, dj = function(Z, Q) {
    if (K8.default("isRestProperty", "isRestElement"), !Z)
      return !1;
    if (Z.type !== "RestProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, pj = function(Z, Q) {
    if (K8.default("isSpreadProperty", "isSpreadElement"), !Z)
      return !1;
    if (Z.type !== "SpreadProperty")
      return !1;
    return Q == null || B.default(Z, Q);
  }, aj = function(Z, Q) {
    return K8.default("isModuleDeclaration", "isImportOrExportDeclaration"), K4(Z, Q);
  };
  Object.defineProperty(M4, "__esModule", {
    value: !0
  });
  M4.isAccessor = wj;
  M4.isAnyTypeAnnotation = n2;
  M4.isArgumentPlaceholder = LF;
  M4.isArrayExpression = j3;
  M4.isArrayPattern = F2;
  M4.isArrayTypeAnnotation = s2;
  M4.isArrowFunctionExpression = R2;
  M4.isAssignmentExpression = O3;
  M4.isAssignmentPattern = M2;
  M4.isAwaitExpression = f2;
  M4.isBigIntLiteral = m2;
  M4.isBinary = tR;
  M4.isBinaryExpression = B3;
  M4.isBindExpression = NF;
  M4.isBlock = Zj;
  M4.isBlockParent = eR;
  M4.isBlockStatement = I3;
  M4.isBooleanLiteral = c3;
  M4.isBooleanLiteralTypeAnnotation = o2;
  M4.isBooleanTypeAnnotation = t2;
  M4.isBreakStatement = C3;
  M4.isCallExpression = A3;
  M4.isCatchClause = L3;
  M4.isClass = Nj;
  M4.isClassAccessorProperty = i2;
  M4.isClassBody = j2;
  M4.isClassDeclaration = B2;
  M4.isClassExpression = O2;
  M4.isClassImplements = ZM;
  M4.isClassMethod = T2;
  M4.isClassPrivateMethod = p2;
  M4.isClassPrivateProperty = d2;
  M4.isClassProperty = l2;
  M4.isCompletionStatement = Xj;
  M4.isConditional = zj;
  M4.isConditionalExpression = N3;
  M4.isContinueStatement = P3;
  M4.isDebuggerStatement = S3;
  M4.isDecimalLiteral = EF;
  M4.isDeclaration = Fj;
  M4.isDeclareClass = QM;
  M4.isDeclareExportAllDeclaration = VM;
  M4.isDeclareExportDeclaration = UM;
  M4.isDeclareFunction = JM;
  M4.isDeclareInterface = XM;
  M4.isDeclareModule = zM;
  M4.isDeclareModuleExports = HM;
  M4.isDeclareOpaqueType = WM;
  M4.isDeclareTypeAlias = YM;
  M4.isDeclareVariable = GM;
  M4.isDeclaredPredicate = KM;
  M4.isDecorator = SF;
  M4.isDirective = $3;
  M4.isDirectiveLiteral = D3;
  M4.isDoExpression = wF;
  M4.isDoWhileStatement = w3;
  M4.isEmptyStatement = T3;
  M4.isEmptyTypeAnnotation = CM;
  M4.isEnumBody = _j;
  M4.isEnumBooleanBody = sM;
  M4.isEnumBooleanMember = ZF;
  M4.isEnumDeclaration = nM;
  M4.isEnumDefaultedMember = XF;
  M4.isEnumMember = kj;
  M4.isEnumNumberBody = tM;
  M4.isEnumNumberMember = QF;
  M4.isEnumStringBody = oM;
  M4.isEnumStringMember = JF;
  M4.isEnumSymbolBody = eM;
  M4.isExistsTypeAnnotation = MM;
  M4.isExportAllDeclaration = q2;
  M4.isExportDeclaration = Pj;
  M4.isExportDefaultDeclaration = $2;
  M4.isExportDefaultSpecifier = TF;
  M4.isExportNamedDeclaration = D2;
  M4.isExportNamespaceSpecifier = u2;
  M4.isExportSpecifier = I2;
  M4.isExpression = sR;
  M4.isExpressionStatement = v3;
  M4.isExpressionWrapper = Wj;
  M4.isFile = b3;
  M4.isFlow = vj;
  M4.isFlowBaseAnnotation = Ej;
  M4.isFlowDeclaration = gj;
  M4.isFlowPredicate = hj;
  M4.isFlowType = bj;
  M4.isFor = Gj;
  M4.isForInStatement = E3;
  M4.isForOfStatement = C2;
  M4.isForStatement = g3;
  M4.isForXStatement = Uj;
  M4.isFunction = Vj;
  M4.isFunctionDeclaration = h3;
  M4.isFunctionExpression = _3;
  M4.isFunctionParent = Kj;
  M4.isFunctionTypeAnnotation = FM;
  M4.isFunctionTypeParam = RM;
  M4.isGenericTypeAnnotation = jM;
  M4.isIdentifier = k3;
  M4.isIfStatement = f3;
  M4.isImmutable = qj;
  M4.isImport = y2;
  M4.isImportAttribute = PF;
  M4.isImportDeclaration = A2;
  M4.isImportDefaultSpecifier = L2;
  M4.isImportExpression = S2;
  M4.isImportNamespaceSpecifier = N2;
  M4.isImportOrExportDeclaration = K4;
  M4.isImportSpecifier = P2;
  M4.isIndexedAccessType = zF;
  M4.isInferredPredicate = OM;
  M4.isInterfaceDeclaration = qM;
  M4.isInterfaceExtends = BM;
  M4.isInterfaceTypeAnnotation = $M;
  M4.isInterpreterDirective = q3;
  M4.isIntersectionTypeAnnotation = DM;
  M4.isJSX = fj;
  M4.isJSXAttribute = YF;
  M4.isJSXClosingElement = WF;
  M4.isJSXClosingFragment = DF;
  M4.isJSXElement = GF;
  M4.isJSXEmptyExpression = UF;
  M4.isJSXExpressionContainer = VF;
  M4.isJSXFragment = qF;
  M4.isJSXIdentifier = MF;
  M4.isJSXMemberExpression = FF;
  M4.isJSXNamespacedName = RF;
  M4.isJSXOpeningElement = jF;
  M4.isJSXOpeningFragment = $F;
  M4.isJSXSpreadAttribute = OF;
  M4.isJSXSpreadChild = KF;
  M4.isJSXText = BF;
  M4.isLVal = jj;
  M4.isLabeledStatement = y3;
  M4.isLiteral = Bj;
  M4.isLogicalExpression = i3;
  M4.isLoop = Hj;
  M4.isMemberExpression = d3;
  M4.isMetaProperty = w2;
  M4.isMethod = Dj;
  M4.isMiscellaneous = yj;
  M4.isMixedTypeAnnotation = IM;
  M4.isModuleDeclaration = aj;
  M4.isModuleExpression = gF;
  M4.isModuleSpecifier = Sj;
  M4.isNewExpression = p3;
  M4.isNoop = IF;
  M4.isNullLiteral = x3;
  M4.isNullLiteralTypeAnnotation = e2;
  M4.isNullableTypeAnnotation = AM;
  M4.isNumberLiteral = lj;
  M4.isNumberLiteralTypeAnnotation = LM;
  M4.isNumberTypeAnnotation = NM;
  M4.isNumericLiteral = u3;
  M4.isObjectExpression = r3;
  M4.isObjectMember = Ij;
  M4.isObjectMethod = n3;
  M4.isObjectPattern = v2;
  M4.isObjectProperty = s3;
  M4.isObjectTypeAnnotation = PM;
  M4.isObjectTypeCallProperty = wM;
  M4.isObjectTypeIndexer = TM;
  M4.isObjectTypeInternalSlot = SM;
  M4.isObjectTypeProperty = vM;
  M4.isObjectTypeSpreadProperty = bM;
  M4.isOpaqueType = EM;
  M4.isOptionalCallExpression = c2;
  M4.isOptionalIndexedAccessType = HF;
  M4.isOptionalMemberExpression = x2;
  M4.isParenthesizedExpression = Z2;
  M4.isPattern = Lj;
  M4.isPatternLike = Rj;
  M4.isPipelineBareFunction = kF;
  M4.isPipelinePrimaryTopicReference = fF;
  M4.isPipelineTopicExpression = _F;
  M4.isPlaceholder = CF;
  M4.isPrivate = Tj;
  M4.isPrivateName = a2;
  M4.isProgram = a3;
  M4.isProperty = Cj;
  M4.isPureish = Mj;
  M4.isQualifiedTypeIdentifier = gM;
  M4.isRecordExpression = vF;
  M4.isRegExpLiteral = l3;
  M4.isRegexLiteral = ij;
  M4.isRestElement = t3;
  M4.isRestProperty = dj;
  M4.isReturnStatement = o3;
  M4.isScopable = oR;
  M4.isSequenceExpression = e3;
  M4.isSpreadElement = b2;
  M4.isSpreadProperty = pj;
  M4.isStandardized = nR;
  M4.isStatement = Qj;
  M4.isStaticBlock = r2;
  M4.isStringLiteral = m3;
  M4.isStringLiteralTypeAnnotation = hM;
  M4.isStringTypeAnnotation = _M;
  M4.isSuper = E2;
  M4.isSwitchCase = Q2;
  M4.isSwitchStatement = J2;
  M4.isSymbolTypeAnnotation = kM;
  M4.isTSAnyKeyword = aF;
  M4.isTSArrayType = FR;
  M4.isTSAsExpression = ER;
  M4.isTSBaseType = cj;
  M4.isTSBigIntKeyword = nF;
  M4.isTSBooleanKeyword = rF;
  M4.isTSCallSignatureDeclaration = cF;
  M4.isTSConditionalType = DR;
  M4.isTSConstructSignatureDeclaration = lF;
  M4.isTSConstructorType = GR;
  M4.isTSDeclareFunction = mF;
  M4.isTSDeclareMethod = uF;
  M4.isTSEntityName = Oj;
  M4.isTSEnumDeclaration = _R;
  M4.isTSEnumMember = kR;
  M4.isTSExportAssignment = lR;
  M4.isTSExpressionWithTypeArguments = SR;
  M4.isTSExternalModuleReference = xR;
  M4.isTSFunctionType = WR;
  M4.isTSImportEqualsDeclaration = uR;
  M4.isTSImportType = mR;
  M4.isTSIndexSignature = pF;
  M4.isTSIndexedAccessType = LR;
  M4.isTSInferType = IR;
  M4.isTSInstantiationExpression = bR;
  M4.isTSInterfaceBody = TR;
  M4.isTSInterfaceDeclaration = wR;
  M4.isTSIntersectionType = $R;
  M4.isTSIntrinsicKeyword = sF;
  M4.isTSLiteralType = PR;
  M4.isTSMappedType = NR;
  M4.isTSMethodSignature = dF;
  M4.isTSModuleBlock = yR;
  M4.isTSModuleDeclaration = fR;
  M4.isTSNamedTupleMember = BR;
  M4.isTSNamespaceExportDeclaration = iR;
  M4.isTSNeverKeyword = tF;
  M4.isTSNonNullExpression = cR;
  M4.isTSNullKeyword = oF;
  M4.isTSNumberKeyword = eF;
  M4.isTSObjectKeyword = ZR;
  M4.isTSOptionalType = jR;
  M4.isTSParameterProperty = yF;
  M4.isTSParenthesizedType = CR;
  M4.isTSPropertySignature = iF;
  M4.isTSQualifiedName = xF;
  M4.isTSRestType = OR;
  M4.isTSSatisfiesExpression = gR;
  M4.isTSStringKeyword = QR;
  M4.isTSSymbolKeyword = JR;
  M4.isTSThisType = YR;
  M4.isTSTupleType = RR;
  M4.isTSType = xj;
  M4.isTSTypeAliasDeclaration = vR;
  M4.isTSTypeAnnotation = dR;
  M4.isTSTypeAssertion = hR;
  M4.isTSTypeElement = uj;
  M4.isTSTypeLiteral = MR;
  M4.isTSTypeOperator = AR;
  M4.isTSTypeParameter = rR;
  M4.isTSTypeParameterDeclaration = aR;
  M4.isTSTypeParameterInstantiation = pR;
  M4.isTSTypePredicate = VR;
  M4.isTSTypeQuery = KR;
  M4.isTSTypeReference = UR;
  M4.isTSUndefinedKeyword = XR;
  M4.isTSUnionType = qR;
  M4.isTSUnknownKeyword = zR;
  M4.isTSVoidKeyword = HR;
  M4.isTaggedTemplateExpression = g2;
  M4.isTemplateElement = h2;
  M4.isTemplateLiteral = _2;
  M4.isTerminatorless = Jj;
  M4.isThisExpression = X2;
  M4.isThisTypeAnnotation = fM;
  M4.isThrowStatement = z2;
  M4.isTopicReference = hF;
  M4.isTryStatement = H2;
  M4.isTupleExpression = bF;
  M4.isTupleTypeAnnotation = yM;
  M4.isTypeAlias = uM;
  M4.isTypeAnnotation = xM;
  M4.isTypeCastExpression = cM;
  M4.isTypeParameter = lM;
  M4.isTypeParameterDeclaration = iM;
  M4.isTypeParameterInstantiation = dM;
  M4.isTypeScript = mj;
  M4.isTypeofTypeAnnotation = mM;
  M4.isUnaryExpression = Y2;
  M4.isUnaryLike = Aj;
  M4.isUnionTypeAnnotation = pM;
  M4.isUpdateExpression = W2;
  M4.isUserWhitespacable = $j;
  M4.isV8IntrinsicIdentifier = AF;
  M4.isVariableDeclaration = G2;
  M4.isVariableDeclarator = U2;
  M4.isVariance = aM;
  M4.isVoidTypeAnnotation = rM;
  M4.isWhile = Yj;
  M4.isWhileStatement = V2;
  M4.isWithStatement = K2;
  M4.isYieldExpression = k2;
  var B = V7(), K8 = V8();
});

// node_modules/@babel/types/lib/validators/matchesPattern.js
var x6 = P((F4) => {
  var wI = function(Z, Q, J) {
    if (!M8.isMemberExpression(Z))
      return !1;
    const X = Array.isArray(Q) ? Q : Q.split("."), z = [];
    let Y;
    for (Y = Z;M8.isMemberExpression(Y); Y = Y.object)
      z.push(Y.property);
    if (z.push(Y), z.length < X.length)
      return !1;
    if (!J && z.length > X.length)
      return !1;
    for (let W = 0, U = z.length - 1;W < X.length; W++, U--) {
      const V = z[U];
      let M;
      if (M8.isIdentifier(V))
        M = V.name;
      else if (M8.isStringLiteral(V))
        M = V.value;
      else if (M8.isThisExpression(V))
        M = "this";
      else
        return !1;
      if (X[W] !== M)
        return !1;
    }
    return !0;
  };
  Object.defineProperty(F4, "__esModule", {
    value: !0
  });
  F4.default = wI;
  var M8 = S0();
});

// node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var c6 = P((R4) => {
  var bI = function(Z, Q) {
    const J = Z.split(".");
    return (X) => vI.default(X, J, Q);
  };
  Object.defineProperty(R4, "__esModule", {
    value: !0
  });
  R4.default = bI;
  var vI = x6();
});

// node_modules/@babel/types/lib/validators/react/isReactComponent.js
var B4 = P((j4) => {
  Object.defineProperty(j4, "__esModule", {
    value: !0
  });
  j4.default = void 0;
  var gI = c6(), hI = gI.default("React.Component"), po = j4.default = hI;
});

// node_modules/@babel/types/lib/validators/react/isCompatTag.js
var $4 = P((q4) => {
  var _I = function(Z) {
    return !!Z && /^[a-z]/.test(Z);
  };
  Object.defineProperty(q4, "__esModule", {
    value: !0
  });
  q4.default = _I;
});

// node_modules/to-fast-properties/index.js
var I4 = P((no, D4) => {
  var R8 = function(Z) {
    if (F8 !== null && typeof F8.property) {
      const Q = F8;
      return F8 = R8.prototype = null, Q;
    }
    return F8 = R8.prototype = Z == null ? Object.create(null) : Z, new R8;
  }, F8 = null;
  R8();
  D4.exports = function Z(Q) {
    return R8(Q);
  };
});

// node_modules/@babel/types/lib/validators/isType.js
var K7 = P((A4) => {
  var fI = function(Z, Q) {
    if (Z === Q)
      return !0;
    if (Z == null)
      return !1;
    if (C4.ALIAS_KEYS[Q])
      return !1;
    const J = C4.FLIPPED_ALIAS_KEYS[Q];
    if (J) {
      if (J[0] === Z)
        return !0;
      for (let X of J)
        if (Z === X)
          return !0;
    }
    return !1;
  };
  Object.defineProperty(A4, "__esModule", {
    value: !0
  });
  A4.default = fI;
  var C4 = z1();
});

// node_modules/@babel/types/lib/validators/isPlaceholderType.js
var l6 = P((L4) => {
  var uI = function(Z, Q) {
    if (Z === Q)
      return !0;
    const J = mI.PLACEHOLDERS_ALIAS[Z];
    if (J) {
      for (let X of J)
        if (Q === X)
          return !0;
    }
    return !1;
  };
  Object.defineProperty(L4, "__esModule", {
    value: !0
  });
  L4.default = uI;
  var mI = z1();
});

// node_modules/@babel/types/lib/validators/is.js
var g5 = P((N4) => {
  var pI = function(Z, Q, J) {
    if (!Q)
      return !1;
    if (!lI.default(Q.type, Z)) {
      if (!J && Q.type === "Placeholder" && Z in dI.FLIPPED_ALIAS_KEYS)
        return iI.default(Q.expectedNode, Z);
      return !1;
    }
    if (typeof J === "undefined")
      return !0;
    else
      return cI.default(Q, J);
  };
  Object.defineProperty(N4, "__esModule", {
    value: !0
  });
  N4.default = pI;
  var cI = V7(), lI = K7(), iI = l6(), dI = z1();
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var b4 = P((v4) => {
  var i6 = function(Z, Q) {
    let J = 65536;
    for (let X = 0, z = Q.length;X < z; X += 2) {
      if (J += Q[X], J > Z)
        return !1;
      if (J += Q[X + 1], J >= Z)
        return !0;
    }
    return !1;
  }, w4 = function(Z) {
    if (Z < 65)
      return Z === 36;
    if (Z <= 90)
      return !0;
    if (Z < 97)
      return Z === 95;
    if (Z <= 122)
      return !0;
    if (Z <= 65535)
      return Z >= 170 && rI.test(String.fromCharCode(Z));
    return i6(Z, S4);
  }, T4 = function(Z) {
    if (Z < 48)
      return Z === 36;
    if (Z < 58)
      return !0;
    if (Z < 65)
      return !1;
    if (Z <= 90)
      return !0;
    if (Z < 97)
      return Z === 95;
    if (Z <= 122)
      return !0;
    if (Z <= 65535)
      return Z >= 170 && nI.test(String.fromCharCode(Z));
    return i6(Z, S4) || i6(Z, sI);
  }, tI = function(Z) {
    let Q = !0;
    for (let J = 0;J < Z.length; J++) {
      let X = Z.charCodeAt(J);
      if ((X & 64512) === 55296 && J + 1 < Z.length) {
        const z = Z.charCodeAt(++J);
        if ((z & 64512) === 56320)
          X = 65536 + ((X & 1023) << 10) + (z & 1023);
      }
      if (Q) {
        if (Q = !1, !w4(X))
          return !1;
      } else if (!T4(X))
        return !1;
    }
    return !Q;
  };
  Object.defineProperty(v4, "__esModule", {
    value: !0
  });
  v4.isIdentifierChar = T4;
  v4.isIdentifierName = tI;
  v4.isIdentifierStart = w4;
  var d6 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", P4 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", rI = new RegExp("[" + d6 + "]"), nI = new RegExp("[" + d6 + P4 + "]");
  d6 = P4 = null;
  var S4 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], sI = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var k4 = P((_4) => {
  var E4 = function(Z, Q) {
    return Q && Z === "await" || Z === "enum";
  }, g4 = function(Z, Q) {
    return E4(Z, Q) || JC.has(Z);
  }, h4 = function(Z) {
    return XC.has(Z);
  }, zC = function(Z, Q) {
    return g4(Z, Q) || h4(Z);
  }, HC = function(Z) {
    return QC.has(Z);
  };
  Object.defineProperty(_4, "__esModule", {
    value: !0
  });
  _4.isKeyword = HC;
  _4.isReservedWord = E4;
  _4.isStrictBindOnlyReservedWord = h4;
  _4.isStrictBindReservedWord = zC;
  _4.isStrictReservedWord = g4;
  var p6 = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, QC = new Set(p6.keyword), JC = new Set(p6.strict), XC = new Set(p6.strictBind);
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var M7 = P((O1) => {
  Object.defineProperty(O1, "__esModule", {
    value: !0
  });
  Object.defineProperty(O1, "isIdentifierChar", {
    enumerable: !0,
    get: function() {
      return a6.isIdentifierChar;
    }
  });
  Object.defineProperty(O1, "isIdentifierName", {
    enumerable: !0,
    get: function() {
      return a6.isIdentifierName;
    }
  });
  Object.defineProperty(O1, "isIdentifierStart", {
    enumerable: !0,
    get: function() {
      return a6.isIdentifierStart;
    }
  });
  Object.defineProperty(O1, "isKeyword", {
    enumerable: !0,
    get: function() {
      return j8.isKeyword;
    }
  });
  Object.defineProperty(O1, "isReservedWord", {
    enumerable: !0,
    get: function() {
      return j8.isReservedWord;
    }
  });
  Object.defineProperty(O1, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: function() {
      return j8.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(O1, "isStrictBindReservedWord", {
    enumerable: !0,
    get: function() {
      return j8.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(O1, "isStrictReservedWord", {
    enumerable: !0,
    get: function() {
      return j8.isStrictReservedWord;
    }
  });
  var a6 = b4(), j8 = k4();
});

// node_modules/@babel/types/lib/validators/isValidIdentifier.js
var h5 = P((f4) => {
  var KC = function(Z, Q = !0) {
    if (typeof Z !== "string")
      return !1;
    if (Q) {
      if (r6.isKeyword(Z) || r6.isStrictReservedWord(Z, !0))
        return !1;
    }
    return r6.isIdentifierName(Z);
  };
  Object.defineProperty(f4, "__esModule", {
    value: !0
  });
  f4.default = KC;
  var r6 = M7();
});

// node_modules/@babel/helper-string-parser/lib/index.js
var c4 = P((x4) => {
  var RC = function(Z, Q, J, X, z, Y) {
    const W = J, U = X, V = z;
    let M = "", q = null, L = J;
    const {
      length: N
    } = Q;
    for (;; ) {
      if (J >= N) {
        Y.unterminated(W, U, V), M += Q.slice(L, J);
        break;
      }
      const T = Q.charCodeAt(J);
      if (jC(Z, T, Q, J)) {
        M += Q.slice(L, J);
        break;
      }
      if (T === 92) {
        M += Q.slice(L, J);
        const E = OC(Q, J, X, z, Z === "template", Y);
        if (E.ch === null && !q)
          q = {
            pos: J,
            lineStart: X,
            curLine: z
          };
        else
          M += E.ch;
        ({
          pos: J,
          lineStart: X,
          curLine: z
        } = E), L = J;
      } else if (T === 8232 || T === 8233)
        ++J, ++z, X = J;
      else if (T === 10 || T === 13)
        if (Z === "template") {
          if (M += Q.slice(L, J) + "\n", ++J, T === 13 && Q.charCodeAt(J) === 10)
            ++J;
          ++z, L = X = J;
        } else
          Y.unterminated(W, U, V);
      else
        ++J;
    }
    return {
      pos: J,
      str: M,
      firstInvalidLoc: q,
      lineStart: X,
      curLine: z,
      containsInvalid: !!q
    };
  }, jC = function(Z, Q, J, X) {
    if (Z === "template")
      return Q === 96 || Q === 36 && J.charCodeAt(X + 1) === 123;
    return Q === (Z === "double" ? 34 : 39);
  }, OC = function(Z, Q, J, X, z, Y) {
    const W = !z;
    Q++;
    const U = (M) => ({
      pos: Q,
      ch: M,
      lineStart: J,
      curLine: X
    }), V = Z.charCodeAt(Q++);
    switch (V) {
      case 110:
        return U("\n");
      case 114:
        return U("\r");
      case 120: {
        let M;
        return {
          code: M,
          pos: Q
        } = n6(Z, Q, J, X, 2, !1, W, Y), U(M === null ? null : String.fromCharCode(M));
      }
      case 117: {
        let M;
        return {
          code: M,
          pos: Q
        } = u4(Z, Q, J, X, W, Y), U(M === null ? null : String.fromCodePoint(M));
      }
      case 116:
        return U("\t");
      case 98:
        return U("\b");
      case 118:
        return U("\v");
      case 102:
        return U("\f");
      case 13:
        if (Z.charCodeAt(Q) === 10)
          ++Q;
      case 10:
        J = Q, ++X;
      case 8232:
      case 8233:
        return U("");
      case 56:
      case 57:
        if (z)
          return U(null);
        else
          Y.strictNumericEscape(Q - 1, J, X);
      default:
        if (V >= 48 && V <= 55) {
          const M = Q - 1;
          let L = Z.slice(M, Q + 2).match(/^[0-7]+/)[0], N = parseInt(L, 8);
          if (N > 255)
            L = L.slice(0, -1), N = parseInt(L, 8);
          Q += L.length - 1;
          const T = Z.charCodeAt(Q);
          if (L !== "0" || T === 56 || T === 57)
            if (z)
              return U(null);
            else
              Y.strictNumericEscape(M, J, X);
          return U(String.fromCharCode(N));
        }
        return U(String.fromCharCode(V));
    }
  }, n6 = function(Z, Q, J, X, z, Y, W, U) {
    const V = Q;
    let M;
    if ({
      n: M,
      pos: Q
    } = m4(Z, Q, J, X, 16, z, Y, !1, U, !W), M === null)
      if (W)
        U.invalidEscapeSequence(V, J, X);
      else
        Q = V - 1;
    return {
      code: M,
      pos: Q
    };
  }, m4 = function(Z, Q, J, X, z, Y, W, U, V, M) {
    const q = Q, L = z === 16 ? y4.hex : y4.decBinOct, N = z === 16 ? F7.hex : z === 10 ? F7.dec : z === 8 ? F7.oct : F7.bin;
    let T = !1, E = 0;
    for (let g = 0, n = Y == null ? Infinity : Y;g < n; ++g) {
      const x = Z.charCodeAt(Q);
      let d;
      if (x === 95 && U !== "bail") {
        const y = Z.charCodeAt(Q - 1), R = Z.charCodeAt(Q + 1);
        if (!U) {
          if (M)
            return {
              n: null,
              pos: Q
            };
          V.numericSeparatorInEscapeSequence(Q, J, X);
        } else if (Number.isNaN(R) || !N(R) || L.has(y) || L.has(R)) {
          if (M)
            return {
              n: null,
              pos: Q
            };
          V.unexpectedNumericSeparator(Q, J, X);
        }
        ++Q;
        continue;
      }
      if (x >= 97)
        d = x - 97 + 10;
      else if (x >= 65)
        d = x - 65 + 10;
      else if (FC(x))
        d = x - 48;
      else
        d = Infinity;
      if (d >= z)
        if (d <= 9 && M)
          return {
            n: null,
            pos: Q
          };
        else if (d <= 9 && V.invalidDigit(Q, J, X, z))
          d = 0;
        else if (W)
          d = 0, T = !0;
        else
          break;
      ++Q, E = E * z + d;
    }
    if (Q === q || Y != null && Q - q !== Y || T)
      return {
        n: null,
        pos: Q
      };
    return {
      n: E,
      pos: Q
    };
  }, u4 = function(Z, Q, J, X, z, Y) {
    const W = Z.charCodeAt(Q);
    let U;
    if (W === 123) {
      if (++Q, {
        code: U,
        pos: Q
      } = n6(Z, Q, J, X, Z.indexOf("}", Q) - Q, !0, z, Y), ++Q, U !== null && U > 1114111)
        if (z)
          Y.invalidCodePoint(Q, J, X);
        else
          return {
            code: null,
            pos: Q
          };
    } else
      ({
        code: U,
        pos: Q
      } = n6(Z, Q, J, X, 4, !1, z, Y));
    return {
      code: U,
      pos: Q
    };
  };
  Object.defineProperty(x4, "__esModule", {
    value: !0
  });
  x4.readCodePoint = u4;
  x4.readInt = m4;
  x4.readStringContents = RC;
  var FC = function Z(Q) {
    return Q >= 48 && Q <= 57;
  }, y4 = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  }, F7 = {
    bin: (Z) => Z === 48 || Z === 49,
    oct: (Z) => Z >= 48 && Z <= 55,
    dec: (Z) => Z >= 48 && Z <= 57,
    hex: (Z) => Z >= 48 && Z <= 57 || Z >= 65 && Z <= 70 || Z >= 97 && Z <= 102
  };
});

// node_modules/@babel/types/lib/constants/index.js
var l1 = P((i4) => {
  Object.defineProperty(i4, "__esModule", {
    value: !0
  });
  i4.UPDATE_OPERATORS = i4.UNARY_OPERATORS = i4.STRING_UNARY_OPERATORS = i4.STATEMENT_OR_BLOCK_KEYS = i4.NUMBER_UNARY_OPERATORS = i4.NUMBER_BINARY_OPERATORS = i4.NOT_LOCAL_BINDING = i4.LOGICAL_OPERATORS = i4.INHERIT_KEYS = i4.FOR_INIT_KEYS = i4.FLATTENABLE_KEYS = i4.EQUALITY_BINARY_OPERATORS = i4.COMPARISON_BINARY_OPERATORS = i4.COMMENT_KEYS = i4.BOOLEAN_UNARY_OPERATORS = i4.BOOLEAN_NUMBER_BINARY_OPERATORS = i4.BOOLEAN_BINARY_OPERATORS = i4.BLOCK_SCOPED_SYMBOL = i4.BINARY_OPERATORS = i4.ASSIGNMENT_OPERATORS = void 0;
  var ze = i4.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], He = i4.FLATTENABLE_KEYS = ["body", "expressions"], Ye = i4.FOR_INIT_KEYS = ["left", "init"], We = i4.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], DC = i4.LOGICAL_OPERATORS = ["||", "&&", "??"], Ge = i4.UPDATE_OPERATORS = ["++", "--"], IC = i4.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], CC = i4.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], AC = i4.COMPARISON_BINARY_OPERATORS = [...CC, "in", "instanceof"], LC = i4.BOOLEAN_BINARY_OPERATORS = [...AC, ...IC], l4 = i4.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], Ue = i4.BINARY_OPERATORS = ["+", ...l4, ...LC, "|>"], Ve = i4.ASSIGNMENT_OPERATORS = ["=", "+=", ...l4.map((Z) => Z + "="), ...DC.map((Z) => Z + "=")], NC = i4.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], PC = i4.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], SC = i4.STRING_UNARY_OPERATORS = ["typeof"], Ke = i4.UNARY_OPERATORS = ["void", "throw", ...NC, ...PC, ...SC], Me = i4.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, Fe = i4.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), Re = i4.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
});

// node_modules/@babel/types/lib/definitions/utils.js
var b1 = P((o4) => {
  var R7 = function(Z) {
    if (Array.isArray(Z))
      return "array";
    else if (Z === null)
      return "null";
    else
      return typeof Z;
  }, e6 = function(Z) {
    return {
      validate: Z
    };
  }, O7 = function(Z) {
    return typeof Z === "string" ? t6(Z) : t6(...Z);
  }, eC = function(Z) {
    return e6(O7(Z));
  }, ZA = function(Z) {
    return {
      validate: Z,
      optional: !0
    };
  }, QA = function(Z) {
    return {
      validate: O7(Z),
      optional: !0
    };
  }, a4 = function(Z) {
    return s4(ZZ("array"), n4(Z));
  }, r4 = function(Z) {
    return a4(O7(Z));
  }, JA = function(Z) {
    return e6(r4(Z));
  }, n4 = function(Z) {
    function Q(J, X, z) {
      if (!Array.isArray(z))
        return;
      for (let Y = 0;Y < z.length; Y++) {
        const W = `${X}[${Y}]`, U = z[Y];
        if (Z(J, W, U), process.env.BABEL_TYPES_8_BREAKING)
          j7.validateChild(J, W, U);
      }
    }
    return Q.each = Z, Q;
  }, XA = function(...Z) {
    function Q(J, X, z) {
      if (Z.indexOf(z) < 0)
        throw new TypeError(`Property ${X} expected value to be one of ${JSON.stringify(Z)} but got ${JSON.stringify(z)}`);
    }
    return Q.oneOf = Z, Q;
  }, t6 = function(...Z) {
    function Q(J, X, z) {
      for (let Y of Z)
        if (p4.default(Y, z)) {
          j7.validateChild(J, X, z);
          return;
        }
      throw new TypeError(`Property ${X} of ${J.type} expected node to be of a type ${JSON.stringify(Z)} but instead got ${JSON.stringify(z == null ? void 0 : z.type)}`);
    }
    return Q.oneOfNodeTypes = Z, Q;
  }, zA = function(...Z) {
    function Q(J, X, z) {
      for (let Y of Z)
        if (R7(z) === Y || p4.default(Y, z)) {
          j7.validateChild(J, X, z);
          return;
        }
      throw new TypeError(`Property ${X} of ${J.type} expected node to be of a type ${JSON.stringify(Z)} but instead got ${JSON.stringify(z == null ? void 0 : z.type)}`);
    }
    return Q.oneOfNodeOrValueTypes = Z, Q;
  }, ZZ = function(Z) {
    function Q(J, X, z) {
      if (R7(z) !== Z)
        throw new TypeError(`Property ${X} expected type of ${Z} but got ${R7(z)}`);
    }
    return Q.type = Z, Q;
  }, HA = function(Z) {
    function Q(J, X, z) {
      const Y = [];
      for (let W of Object.keys(Z))
        try {
          j7.validateField(J, W, z[W], Z[W]);
        } catch (U) {
          if (U instanceof TypeError) {
            Y.push(U.message);
            continue;
          }
          throw U;
        }
      if (Y.length)
        throw new TypeError(`Property ${X} of ${J.type} expected to have the following:\n${Y.join("\n")}`);
    }
    return Q.shapeOf = Z, Q;
  }, YA = function() {
    function Z(Q) {
      var J;
      let X = Q;
      while (Q) {
        const {
          type: z
        } = X;
        if (z === "OptionalCallExpression") {
          if (X.optional)
            return;
          X = X.callee;
          continue;
        }
        if (z === "OptionalMemberExpression") {
          if (X.optional)
            return;
          X = X.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${Q.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(J = X) == null ? void 0 : J.type}`);
    }
    return Z;
  }, s4 = function(...Z) {
    function Q(...J) {
      for (let X of Z)
        X(...J);
    }
    if (Q.chainOf = Z, Z.length >= 2 && "type" in Z[0] && Z[0].type === "array" && !("each" in Z[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return Q;
  }, UA = function(...Z) {
    return (Q, J = {}) => {
      let X = J.aliases;
      if (!X) {
        var z, Y;
        if (J.inherits)
          X = (z = o6[J.inherits].aliases) == null ? void 0 : z.slice();
        (Y = X) != null || (X = []), J.aliases = X;
      }
      const W = Z.filter((U) => !X.includes(U));
      X.unshift(...W), t4(Q, J);
    };
  }, t4 = function(Z, Q = {}) {
    const J = Q.inherits && o6[Q.inherits] || {};
    let X = Q.fields;
    if (!X) {
      if (X = {}, J.fields) {
        const U = Object.getOwnPropertyNames(J.fields);
        for (let V of U) {
          const M = J.fields[V], q = M.default;
          if (Array.isArray(q) ? q.length > 0 : q && typeof q === "object")
            throw new Error("field defaults can only be primitives or empty arrays currently");
          X[V] = {
            default: Array.isArray(q) ? [] : q,
            optional: M.optional,
            deprecated: M.deprecated,
            validate: M.validate
          };
        }
      }
    }
    const z = Q.visitor || J.visitor || [], Y = Q.aliases || J.aliases || [], W = Q.builder || J.builder || Q.visitor || [];
    for (let U of Object.keys(Q))
      if (WA.indexOf(U) === -1)
        throw new Error(`Unknown type option "${U}" on ${Z}`);
    if (Q.deprecatedAlias)
      tC[Q.deprecatedAlias] = Z;
    for (let U of z.concat(W))
      X[U] = X[U] || {};
    for (let U of Object.keys(X)) {
      const V = X[U];
      if (V.default !== void 0 && W.indexOf(U) === -1)
        V.optional = !0;
      if (V.default === void 0)
        V.default = null;
      else if (!V.validate && V.default != null)
        V.validate = ZZ(R7(V.default));
      for (let M of Object.keys(V))
        if (GA.indexOf(M) === -1)
          throw new Error(`Unknown field key "${M}" on ${Z}.${U}`);
    }
    if (aC[Z] = Q.visitor = z, sC[Z] = Q.builder = W, nC[Z] = Q.fields = X, rC[Z] = Q.aliases = Y, Y.forEach((U) => {
      s6[U] = s6[U] || [], s6[U].push(Z);
    }), Q.validate)
      oC[Z] = Q.validate;
    o6[Z] = Q;
  };
  Object.defineProperty(o4, "__esModule", {
    value: !0
  });
  o4.VISITOR_KEYS = o4.NODE_PARENT_VALIDATIONS = o4.NODE_FIELDS = o4.FLIPPED_ALIAS_KEYS = o4.DEPRECATED_KEYS = o4.BUILDER_KEYS = o4.ALIAS_KEYS = void 0;
  o4.arrayOf = a4;
  o4.arrayOfType = r4;
  o4.assertEach = n4;
  o4.assertNodeOrValueType = zA;
  o4.assertNodeType = t6;
  o4.assertOneOf = XA;
  o4.assertOptionalChainStart = YA;
  o4.assertShape = HA;
  o4.assertValueType = ZZ;
  o4.chain = s4;
  o4.default = t4;
  o4.defineAliasedType = UA;
  o4.typeIs = O7;
  o4.validate = e6;
  o4.validateArrayOfType = JA;
  o4.validateOptional = ZA;
  o4.validateOptionalType = QA;
  o4.validateType = eC;
  var p4 = g5(), j7 = B7(), aC = o4.VISITOR_KEYS = {}, rC = o4.ALIAS_KEYS = {}, s6 = o4.FLIPPED_ALIAS_KEYS = {}, nC = o4.NODE_FIELDS = {}, sC = o4.BUILDER_KEYS = {}, tC = o4.DEPRECATED_KEYS = {}, oC = o4.NODE_PARENT_VALIDATIONS = {}, WA = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], GA = ["default", "optional", "deprecated", "validate"], o6 = {};
});

// node_modules/@babel/types/lib/definitions/core.js
var JZ = P((J9) => {
  Object.defineProperty(J9, "__esModule", {
    value: !0
  });
  J9.patternLikeCommon = J9.functionTypeAnnotationCommon = J9.functionDeclarationCommon = J9.functionCommon = J9.classMethodOrPropertyCommon = J9.classMethodOrDeclareMethodCommon = void 0;
  var p0 = g5(), hA = h5(), Z9 = M7(), _A = c4(), O8 = l1(), F = b1(), h = F.defineAliasedType("Standardized");
  h("ArrayExpression", {
    fields: {
      elements: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeOrValueType("null", "Expression", "SpreadElement"))),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  h("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return F.assertValueType("string");
          const Z = F.assertOneOf(...O8.ASSIGNMENT_OPERATORS), Q = F.assertOneOf("=");
          return function(J, X, z) {
            (p0.default("Pattern", J.left) ? Q : Z)(J, X, z);
          };
        }()
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? F.assertNodeType("LVal", "OptionalMemberExpression") : F.assertNodeType("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: F.assertNodeType("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  h("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: F.assertOneOf(...O8.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const Z = F.assertNodeType("Expression"), Q = F.assertNodeType("Expression", "PrivateName");
          return Object.assign(function(X, z, Y) {
            (X.operator === "in" ? Q : Z)(X, z, Y);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: F.assertNodeType("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  h("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: F.assertValueType("string")
      }
    }
  });
  h("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: F.assertNodeType("DirectiveLiteral")
      }
    }
  });
  h("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: F.assertValueType("string")
      }
    }
  });
  h("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Directive"))),
        default: []
      },
      body: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  h("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: F.assertNodeType("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  h("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: F.assertNodeType("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: F.assertOneOf(!0, !1),
        optional: !0
      }
    } : {}, {
      typeArguments: {
        validate: F.assertNodeType("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: F.assertNodeType("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  h("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: F.assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: F.assertNodeType("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  h("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: F.assertNodeType("Expression")
      },
      consequent: {
        validate: F.assertNodeType("Expression")
      },
      alternate: {
        validate: F.assertNodeType("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  h("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: F.assertNodeType("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  h("DebuggerStatement", {
    aliases: ["Statement"]
  });
  h("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: F.assertNodeType("Expression")
      },
      body: {
        validate: F.assertNodeType("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  h("EmptyStatement", {
    aliases: ["Statement"]
  });
  h("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: F.assertNodeType("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  h("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: F.assertNodeType("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : F.assertEach(F.assertNodeType("CommentBlock", "CommentLine")),
        optional: !0
      },
      tokens: {
        validate: F.assertEach(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  h("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? F.assertNodeType("VariableDeclaration", "LVal") : F.assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: F.assertNodeType("Expression")
      },
      body: {
        validate: F.assertNodeType("Statement")
      }
    }
  });
  h("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: F.assertNodeType("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      },
      update: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      },
      body: {
        validate: F.assertNodeType("Statement")
      }
    }
  });
  var _5 = () => ({
    params: {
      validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  });
  J9.functionCommon = _5;
  var G5 = () => ({
    returnType: {
      validate: F.assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: F.assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  J9.functionTypeAnnotationCommon = G5;
  var Q9 = () => Object.assign({}, _5(), {
    declare: {
      validate: F.assertValueType("boolean"),
      optional: !0
    },
    id: {
      validate: F.assertNodeType("Identifier"),
      optional: !0
    }
  });
  J9.functionDeclarationCommon = Q9;
  h("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, Q9(), G5(), {
      body: {
        validate: F.assertNodeType("BlockStatement")
      },
      predicate: {
        validate: F.assertNodeType("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return () => {
        };
      const Z = F.assertNodeType("Identifier");
      return function(Q, J, X) {
        if (!p0.default("ExportDefaultDeclaration", Q))
          Z(X, "id", X.id);
      };
    }()
  });
  h("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, _5(), G5(), {
      id: {
        validate: F.assertNodeType("Identifier"),
        optional: !0
      },
      body: {
        validate: F.assertNodeType("BlockStatement")
      },
      predicate: {
        validate: F.assertNodeType("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var k5 = () => ({
    typeAnnotation: {
      validate: F.assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: F.assertValueType("boolean"),
      optional: !0
    },
    decorators: {
      validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
      optional: !0
    }
  });
  J9.patternLikeCommon = k5;
  h("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, k5(), {
      name: {
        validate: F.chain(F.assertValueType("string"), Object.assign(function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!hA.default(J, !1))
            throw new TypeError(`"${J}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(Z, Q, J) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const X = /\.(\w+)$/.exec(Q);
      if (!X)
        return;
      const [, z] = X, Y = {
        computed: !1
      };
      if (z === "property") {
        if (p0.default("MemberExpression", Z, Y))
          return;
        if (p0.default("OptionalMemberExpression", Z, Y))
          return;
      } else if (z === "key") {
        if (p0.default("Property", Z, Y))
          return;
        if (p0.default("Method", Z, Y))
          return;
      } else if (z === "exported") {
        if (p0.default("ExportSpecifier", Z))
          return;
      } else if (z === "imported") {
        if (p0.default("ImportSpecifier", Z, {
          imported: J
        }))
          return;
      } else if (z === "meta") {
        if (p0.default("MetaProperty", Z, {
          meta: J
        }))
          return;
      }
      if ((Z9.isKeyword(J.name) || Z9.isReservedWord(J.name, !1)) && J.name !== "this")
        throw new TypeError(`"${J.name}" is not a valid identifier`);
    }
  });
  h("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: F.assertNodeType("Expression")
      },
      consequent: {
        validate: F.assertNodeType("Statement")
      },
      alternate: {
        optional: !0,
        validate: F.assertNodeType("Statement")
      }
    }
  });
  h("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: F.assertNodeType("Identifier")
      },
      body: {
        validate: F.assertNodeType("Statement")
      }
    }
  });
  h("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: F.assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  h("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: F.chain(F.assertValueType("number"), Object.assign(function(Z, Q, J) {
          if (1 / J < 0 || !Number.isFinite(J)) {
            const X = new Error("NumericLiterals must be non-negative finite numbers. " + `You can use t.valueToNode(${J}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  h("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  h("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: F.assertValueType("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  h("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: F.assertValueType("string")
      },
      flags: {
        validate: F.chain(F.assertValueType("string"), Object.assign(function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const X = /[^gimsuy]/.exec(J);
          if (X)
            throw new TypeError(`"${X[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  h("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: F.assertOneOf(...O8.LOGICAL_OPERATORS)
      },
      left: {
        validate: F.assertNodeType("Expression")
      },
      right: {
        validate: F.assertNodeType("Expression")
      }
    }
  });
  h("MemberExpression", {
    builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: F.assertNodeType("Expression", "Super")
      },
      property: {
        validate: function() {
          const Z = F.assertNodeType("Identifier", "PrivateName"), Q = F.assertNodeType("Expression"), J = function(X, z, Y) {
            (X.computed ? Q : Z)(X, z, Y);
          };
          return J.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], J;
        }()
      },
      computed: {
        default: !1
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: F.assertOneOf(!0, !1),
        optional: !0
      }
    } : {})
  });
  h("NewExpression", {
    inherits: "CallExpression"
  });
  h("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: F.assertOneOf("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: F.assertNodeType("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Directive"))),
        default: []
      },
      body: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  h("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  });
  h("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, _5(), G5(), {
      kind: Object.assign({
        validate: F.assertOneOf("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        default: "method"
      } : {}),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const Z = F.assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), Q = F.assertNodeType("Expression"), J = function(X, z, Y) {
            (X.computed ? Q : Z)(X, z, Y);
          };
          return J.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], J;
        }()
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      },
      body: {
        validate: F.assertNodeType("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  h("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const Z = F.assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), Q = F.assertNodeType("Expression");
          return Object.assign(function(X, z, Y) {
            (X.computed ? Q : Z)(X, z, Y);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: F.assertNodeType("Expression", "PatternLike")
      },
      shorthand: {
        validate: F.chain(F.assertValueType("boolean"), Object.assign(function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (J && Z.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (J && !p0.default("Identifier", Z.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      const Z = F.assertNodeType("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), Q = F.assertNodeType("Expression");
      return function(J, X, z) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        (p0.default("ObjectPattern", J) ? Z : Q)(z, "value", z.value);
      };
    }()
  });
  h("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, k5(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? F.assertNodeType("LVal") : F.assertNodeType("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate(Z, Q) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const J = /(\w+)\[(\d+)\]/.exec(Q);
      if (!J)
        throw new Error("Internal Babel error: malformed key.");
      const [, X, z] = J;
      if (Z[X].length > +z + 1)
        throw new TypeError(`RestElement must be last element of ${X}`);
    }
  });
  h("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      }
    }
  });
  h("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  h("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: F.assertNodeType("Expression")
      }
    }
  });
  h("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      },
      consequent: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Statement")))
      }
    }
  });
  h("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: F.assertNodeType("Expression")
      },
      cases: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("SwitchCase")))
      }
    }
  });
  h("ThisExpression", {
    aliases: ["Expression"]
  });
  h("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: F.assertNodeType("Expression")
      }
    }
  });
  h("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: F.chain(F.assertNodeType("BlockStatement"), Object.assign(function(Z) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!Z.handler && !Z.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: F.assertNodeType("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: F.assertNodeType("BlockStatement")
      }
    }
  });
  h("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: F.assertNodeType("Expression")
      },
      operator: {
        validate: F.assertOneOf(...O8.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  h("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? F.assertNodeType("Expression") : F.assertNodeType("Identifier", "MemberExpression")
      },
      operator: {
        validate: F.assertOneOf(...O8.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  h("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      kind: {
        validate: F.assertOneOf("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("VariableDeclarator")))
      }
    },
    validate(Z, Q, J) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      if (!p0.default("ForXStatement", Z, {
        left: J
      }))
        return;
      if (J.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${Z.type}`);
    }
  });
  h("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return F.assertNodeType("LVal");
          const Z = F.assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"), Q = F.assertNodeType("Identifier");
          return function(J, X, z) {
            (J.init ? Z : Q)(J, X, z);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: F.assertValueType("boolean")
      },
      init: {
        optional: !0,
        validate: F.assertNodeType("Expression")
      }
    }
  });
  h("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: F.assertNodeType("Expression")
      },
      body: {
        validate: F.assertNodeType("Statement")
      }
    }
  });
  h("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: F.assertNodeType("Expression")
      },
      body: {
        validate: F.assertNodeType("Statement")
      }
    }
  });
  h("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, k5(), {
      left: {
        validate: F.assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: F.assertNodeType("Expression")
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      }
    })
  });
  h("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, k5(), {
      elements: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeOrValueType("null", "PatternLike", "LVal")))
      }
    })
  });
  h("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, _5(), G5(), {
      expression: {
        validate: F.assertValueType("boolean")
      },
      body: {
        validate: F.assertNodeType("BlockStatement", "Expression")
      },
      predicate: {
        validate: F.assertNodeType("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  h("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  h("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: F.assertNodeType("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: F.assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: F.assertNodeType("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: F.assertNodeType("Expression")
      },
      superTypeParameters: {
        validate: F.assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: F.assertNodeType("InterfaceExtends"),
        optional: !0
      }
    }
  });
  h("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: F.assertNodeType("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: F.assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: F.assertNodeType("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: F.assertNodeType("Expression")
      },
      superTypeParameters: {
        validate: F.assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: F.assertNodeType("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      abstract: {
        validate: F.assertValueType("boolean"),
        optional: !0
      }
    },
    validate: function() {
      const Z = F.assertNodeType("Identifier");
      return function(Q, J, X) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!p0.default("ExportDefaultDeclaration", Q))
          Z(X, "id", X.id);
      };
    }()
  });
  h("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: F.assertNodeType("StringLiteral")
      },
      exportKind: F.validateOptional(F.assertOneOf("type", "value")),
      attributes: {
        optional: !0,
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ImportAttribute")))
      }
    }
  });
  h("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: F.assertNodeType("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: F.validateOptional(F.assertOneOf("value"))
    }
  });
  h("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: F.chain(F.assertNodeType("Declaration"), Object.assign(function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (J && Z.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (J && Z.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: F.chain(F.assertValueType("array"), F.assertEach(function() {
          const Z = F.assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), Q = F.assertNodeType("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return Z;
          return function(J, X, z) {
            (J.source ? Z : Q)(J, X, z);
          };
        }()))
      },
      source: {
        validate: F.assertNodeType("StringLiteral"),
        optional: !0
      },
      exportKind: F.validateOptional(F.assertOneOf("type", "value"))
    }
  });
  h("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: F.assertNodeType("Identifier")
      },
      exported: {
        validate: F.assertNodeType("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: F.assertOneOf("type", "value"),
        optional: !0
      }
    }
  });
  h("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return F.assertNodeType("VariableDeclaration", "LVal");
          const Z = F.assertNodeType("VariableDeclaration"), Q = F.assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(J, X, z) {
            if (p0.default("VariableDeclaration", z))
              Z(J, X, z);
            else
              Q(J, X, z);
          };
        }()
      },
      right: {
        validate: F.assertNodeType("Expression")
      },
      body: {
        validate: F.assertNodeType("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  h("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: F.assertValueType("boolean")
      },
      phase: {
        default: null,
        validate: F.assertOneOf("source", "defer")
      },
      specifiers: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: F.assertNodeType("StringLiteral")
      },
      importKind: {
        validate: F.assertOneOf("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  h("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: F.assertNodeType("Identifier")
      }
    }
  });
  h("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: F.assertNodeType("Identifier")
      }
    }
  });
  h("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: F.assertNodeType("Identifier")
      },
      imported: {
        validate: F.assertNodeType("Identifier", "StringLiteral")
      },
      importKind: {
        validate: F.assertOneOf("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  h("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: F.assertOneOf("source", "defer")
      },
      source: {
        validate: F.assertNodeType("Expression")
      },
      options: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      }
    }
  });
  h("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: F.chain(F.assertNodeType("Identifier"), Object.assign(function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          let X;
          switch (J.name) {
            case "function":
              X = "sent";
              break;
            case "new":
              X = "target";
              break;
            case "import":
              X = "meta";
              break;
          }
          if (!p0.default("Identifier", Z.property, {
            name: X
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: F.assertNodeType("Identifier")
      }
    }
  });
  var q7 = () => ({
    abstract: {
      validate: F.assertValueType("boolean"),
      optional: !0
    },
    accessibility: {
      validate: F.assertOneOf("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: F.assertValueType("boolean"),
      optional: !0
    },
    key: {
      validate: F.chain(function() {
        const Z = F.assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), Q = F.assertNodeType("Expression");
        return function(J, X, z) {
          (J.computed ? Q : Z)(J, X, z);
        };
      }(), F.assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  J9.classMethodOrPropertyCommon = q7;
  var QZ = () => Object.assign({}, _5(), q7(), {
    params: {
      validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: F.assertOneOf("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: F.chain(F.assertValueType("string"), F.assertOneOf("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
      optional: !0
    }
  });
  J9.classMethodOrDeclareMethodCommon = QZ;
  h("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, QZ(), G5(), {
      body: {
        validate: F.assertNodeType("BlockStatement")
      }
    })
  });
  h("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, k5(), {
      properties: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("RestElement", "ObjectProperty")))
      }
    })
  });
  h("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: F.assertNodeType("Expression")
      }
    }
  });
  h("Super", {
    aliases: ["Expression"]
  });
  h("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: F.assertNodeType("Expression")
      },
      quasi: {
        validate: F.assertNodeType("TemplateLiteral")
      },
      typeParameters: {
        validate: F.assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  h("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: F.chain(F.assertShape({
          raw: {
            validate: F.assertValueType("string")
          },
          cooked: {
            validate: F.assertValueType("string"),
            optional: !0
          }
        }), function Z(Q) {
          const J = Q.value.raw;
          let X = !1;
          const z = () => {
            throw new Error("Internal @babel/types error.");
          }, {
            str: Y,
            firstInvalidLoc: W
          } = _A.readStringContents("template", J, 0, 0, 0, {
            unterminated() {
              X = !0;
            },
            strictNumericEscape: z,
            invalidEscapeSequence: z,
            numericSeparatorInEscapeSequence: z,
            unexpectedNumericSeparator: z,
            invalidDigit: z,
            invalidCodePoint: z
          });
          if (!X)
            throw new Error("Invalid raw");
          Q.value.cooked = W ? null : Y;
        })
      },
      tail: {
        default: !1
      }
    }
  });
  h("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("TemplateElement")))
      },
      expressions: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Expression", "TSType")), function(Z, Q, J) {
          if (Z.quasis.length !== J.length + 1)
            throw new TypeError(`Number of ${Z.type} quasis should be exactly one more than the number of expressions.\nExpected ${J.length + 1} quasis but got ${Z.quasis.length}`);
        })
      }
    }
  });
  h("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: F.chain(F.assertValueType("boolean"), Object.assign(function(Z, Q, J) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (J && !Z.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: F.assertNodeType("Expression")
      }
    }
  });
  h("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: F.assertNodeType("Expression")
      }
    }
  });
  h("Import", {
    aliases: ["Expression"]
  });
  h("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: F.assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  h("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: F.assertNodeType("Identifier")
      }
    }
  });
  h("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: F.assertNodeType("Expression")
      },
      property: {
        validate: function() {
          const Z = F.assertNodeType("Identifier"), Q = F.assertNodeType("Expression");
          return Object.assign(function(X, z, Y) {
            (X.computed ? Q : Z)(X, z, Y);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? F.assertValueType("boolean") : F.chain(F.assertValueType("boolean"), F.assertOptionalChainStart())
      }
    }
  });
  h("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: F.assertNodeType("Expression")
      },
      arguments: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? F.assertValueType("boolean") : F.chain(F.assertValueType("boolean"), F.assertOptionalChainStart())
      },
      typeArguments: {
        validate: F.assertNodeType("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: F.assertNodeType("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  h("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, q7(), {
      value: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      },
      definite: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: F.assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      declare: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      variance: {
        validate: F.assertNodeType("Variance"),
        optional: !0
      }
    })
  });
  h("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, q7(), {
      key: {
        validate: F.chain(function() {
          const Z = F.assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), Q = F.assertNodeType("Expression");
          return function(J, X, z) {
            (J.computed ? Q : Z)(J, X, z);
          };
        }(), F.assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      },
      definite: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: F.assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      declare: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      variance: {
        validate: F.assertNodeType("Variance"),
        optional: !0
      }
    })
  });
  h("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: F.assertNodeType("PrivateName")
      },
      value: {
        validate: F.assertNodeType("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: F.assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Decorator"))),
        optional: !0
      },
      static: {
        validate: F.assertValueType("boolean"),
        default: !1
      },
      readonly: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      definite: {
        validate: F.assertValueType("boolean"),
        optional: !0
      },
      variance: {
        validate: F.assertNodeType("Variance"),
        optional: !0
      }
    }
  });
  h("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, QZ(), G5(), {
      kind: {
        validate: F.assertOneOf("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: F.assertNodeType("PrivateName")
      },
      body: {
        validate: F.assertNodeType("BlockStatement")
      }
    })
  });
  h("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: F.assertNodeType("Identifier")
      }
    }
  });
  h("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: F.chain(F.assertValueType("array"), F.assertEach(F.assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// node_modules/@babel/types/lib/definitions/flow.js
var z9 = P(() => {
  var S = b1(), u = S.defineAliasedType("Flow"), XZ = (Z) => {
    const Q = Z === "DeclareClass";
    u(Z, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...Q ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: S.validateType("Identifier"),
        typeParameters: S.validateOptionalType("TypeParameterDeclaration"),
        extends: S.validateOptional(S.arrayOfType("InterfaceExtends"))
      }, Q ? {
        mixins: S.validateOptional(S.arrayOfType("InterfaceExtends")),
        implements: S.validateOptional(S.arrayOfType("ClassImplements"))
      } : {}, {
        body: S.validateType("ObjectTypeAnnotation")
      })
    });
  };
  u("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: S.validateType("FlowType")
    }
  });
  u("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: S.validate(S.assertValueType("boolean"))
    }
  });
  u("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: S.validateType("Identifier"),
      typeParameters: S.validateOptionalType("TypeParameterInstantiation")
    }
  });
  XZ("DeclareClass");
  u("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: S.validateType("Identifier"),
      predicate: S.validateOptionalType("DeclaredPredicate")
    }
  });
  XZ("DeclareInterface");
  u("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: S.validateType(["Identifier", "StringLiteral"]),
      body: S.validateType("BlockStatement"),
      kind: S.validateOptional(S.assertOneOf("CommonJS", "ES"))
    }
  });
  u("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: S.validateType("TypeAnnotation")
    }
  });
  u("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: S.validateType("Identifier"),
      typeParameters: S.validateOptionalType("TypeParameterDeclaration"),
      right: S.validateType("FlowType")
    }
  });
  u("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: S.validateType("Identifier"),
      typeParameters: S.validateOptionalType("TypeParameterDeclaration"),
      supertype: S.validateOptionalType("FlowType"),
      impltype: S.validateOptionalType("FlowType")
    }
  });
  u("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: S.validateType("Identifier")
    }
  });
  u("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: S.validateOptionalType("Flow"),
      specifiers: S.validateOptional(S.arrayOfType(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: S.validateOptionalType("StringLiteral"),
      default: S.validateOptional(S.assertValueType("boolean"))
    }
  });
  u("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: S.validateType("StringLiteral"),
      exportKind: S.validateOptional(S.assertOneOf("type", "value"))
    }
  });
  u("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: S.validateType("Flow")
    }
  });
  u("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  u("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: S.validateOptionalType("TypeParameterDeclaration"),
      params: S.validate(S.arrayOfType("FunctionTypeParam")),
      rest: S.validateOptionalType("FunctionTypeParam"),
      this: S.validateOptionalType("FunctionTypeParam"),
      returnType: S.validateType("FlowType")
    }
  });
  u("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: S.validateOptionalType("Identifier"),
      typeAnnotation: S.validateType("FlowType"),
      optional: S.validateOptional(S.assertValueType("boolean"))
    }
  });
  u("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: S.validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: S.validateOptionalType("TypeParameterInstantiation")
    }
  });
  u("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  u("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: S.validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: S.validateOptionalType("TypeParameterInstantiation")
    }
  });
  XZ("InterfaceDeclaration");
  u("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: S.validateOptional(S.arrayOfType("InterfaceExtends")),
      body: S.validateType("ObjectTypeAnnotation")
    }
  });
  u("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: S.validate(S.arrayOfType("FlowType"))
    }
  });
  u("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: S.validateType("FlowType")
    }
  });
  u("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: S.validate(S.assertValueType("number"))
    }
  });
  u("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: S.validate(S.arrayOfType(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: S.arrayOfType("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: S.arrayOfType("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: S.arrayOfType("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: S.assertValueType("boolean"),
        default: !1
      },
      inexact: S.validateOptional(S.assertValueType("boolean"))
    }
  });
  u("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: S.validateType("Identifier"),
      value: S.validateType("FlowType"),
      optional: S.validate(S.assertValueType("boolean")),
      static: S.validate(S.assertValueType("boolean")),
      method: S.validate(S.assertValueType("boolean"))
    }
  });
  u("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: S.validateType("FlowType"),
      static: S.validate(S.assertValueType("boolean"))
    }
  });
  u("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: S.validateOptionalType("Identifier"),
      key: S.validateType("FlowType"),
      value: S.validateType("FlowType"),
      static: S.validate(S.assertValueType("boolean")),
      variance: S.validateOptionalType("Variance")
    }
  });
  u("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: S.validateType(["Identifier", "StringLiteral"]),
      value: S.validateType("FlowType"),
      kind: S.validate(S.assertOneOf("init", "get", "set")),
      static: S.validate(S.assertValueType("boolean")),
      proto: S.validate(S.assertValueType("boolean")),
      optional: S.validate(S.assertValueType("boolean")),
      variance: S.validateOptionalType("Variance"),
      method: S.validate(S.assertValueType("boolean"))
    }
  });
  u("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: S.validateType("FlowType")
    }
  });
  u("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: S.validateType("Identifier"),
      typeParameters: S.validateOptionalType("TypeParameterDeclaration"),
      supertype: S.validateOptionalType("FlowType"),
      impltype: S.validateType("FlowType")
    }
  });
  u("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: S.validateType("Identifier"),
      qualification: S.validateType(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  u("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: S.validate(S.assertValueType("string"))
    }
  });
  u("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: S.validate(S.arrayOfType("FlowType"))
    }
  });
  u("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: S.validateType("FlowType")
    }
  });
  u("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: S.validateType("Identifier"),
      typeParameters: S.validateOptionalType("TypeParameterDeclaration"),
      right: S.validateType("FlowType")
    }
  });
  u("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: S.validateType("FlowType")
    }
  });
  u("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: S.validateType("Expression"),
      typeAnnotation: S.validateType("TypeAnnotation")
    }
  });
  u("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: S.validate(S.assertValueType("string")),
      bound: S.validateOptionalType("TypeAnnotation"),
      default: S.validateOptionalType("FlowType"),
      variance: S.validateOptionalType("Variance")
    }
  });
  u("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: S.validate(S.arrayOfType("TypeParameter"))
    }
  });
  u("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: S.validate(S.arrayOfType("FlowType"))
    }
  });
  u("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: S.validate(S.arrayOfType("FlowType"))
    }
  });
  u("Variance", {
    builder: ["kind"],
    fields: {
      kind: S.validate(S.assertOneOf("minus", "plus"))
    }
  });
  u("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  u("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: S.validateType("Identifier"),
      body: S.validateType(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  u("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: S.validate(S.assertValueType("boolean")),
      members: S.validateArrayOfType("EnumBooleanMember"),
      hasUnknownMembers: S.validate(S.assertValueType("boolean"))
    }
  });
  u("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: S.validate(S.assertValueType("boolean")),
      members: S.validateArrayOfType("EnumNumberMember"),
      hasUnknownMembers: S.validate(S.assertValueType("boolean"))
    }
  });
  u("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: S.validate(S.assertValueType("boolean")),
      members: S.validateArrayOfType(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: S.validate(S.assertValueType("boolean"))
    }
  });
  u("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: S.validateArrayOfType("EnumDefaultedMember"),
      hasUnknownMembers: S.validate(S.assertValueType("boolean"))
    }
  });
  u("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: S.validateType("Identifier"),
      init: S.validateType("BooleanLiteral")
    }
  });
  u("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: S.validateType("Identifier"),
      init: S.validateType("NumericLiteral")
    }
  });
  u("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: S.validateType("Identifier"),
      init: S.validateType("StringLiteral")
    }
  });
  u("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: S.validateType("Identifier")
    }
  });
  u("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: S.validateType("FlowType"),
      indexType: S.validateType("FlowType")
    }
  });
  u("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: S.validateType("FlowType"),
      indexType: S.validateType("FlowType"),
      optional: S.validate(S.assertValueType("boolean"))
    }
  });
});

// node_modules/@babel/types/lib/definitions/jsx.js
var H9 = P(() => {
  var M0 = b1(), a0 = M0.defineAliasedType("JSX");
  a0("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: M0.assertNodeType("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: M0.assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  a0("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: M0.assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  a0("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: M0.assertNodeType("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: M0.assertNodeType("JSXClosingElement")
      },
      children: {
        validate: M0.chain(M0.assertValueType("array"), M0.assertEach(M0.assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: M0.assertValueType("boolean"),
        optional: !0
      }
    })
  });
  a0("JSXEmptyExpression", {});
  a0("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: M0.assertNodeType("Expression", "JSXEmptyExpression")
      }
    }
  });
  a0("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: M0.assertNodeType("Expression")
      }
    }
  });
  a0("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: M0.assertValueType("string")
      }
    }
  });
  a0("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: M0.assertNodeType("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: M0.assertNodeType("JSXIdentifier")
      }
    }
  });
  a0("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: M0.assertNodeType("JSXIdentifier")
      },
      name: {
        validate: M0.assertNodeType("JSXIdentifier")
      }
    }
  });
  a0("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: M0.assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: M0.chain(M0.assertValueType("array"), M0.assertEach(M0.assertNodeType("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: M0.assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  a0("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: M0.assertNodeType("Expression")
      }
    }
  });
  a0("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: M0.assertValueType("string")
      }
    }
  });
  a0("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: M0.assertNodeType("JSXOpeningFragment")
      },
      closingFragment: {
        validate: M0.assertNodeType("JSXClosingFragment")
      },
      children: {
        validate: M0.chain(M0.assertValueType("array"), M0.assertEach(M0.assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  a0("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  a0("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// node_modules/@babel/types/lib/definitions/placeholders.js
var YZ = P((Y9) => {
  Object.defineProperty(Y9, "__esModule", {
    value: !0
  });
  Y9.PLACEHOLDERS_FLIPPED_ALIAS = Y9.PLACEHOLDERS_ALIAS = Y9.PLACEHOLDERS = void 0;
  var xA = b1(), cA = Y9.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], HZ = Y9.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let Z of cA) {
    const Q = xA.ALIAS_KEYS[Z];
    if (Q != null && Q.length)
      HZ[Z] = Q;
  }
  var zZ = Y9.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(HZ).forEach((Z) => {
    HZ[Z].forEach((Q) => {
      if (!Object.hasOwnProperty.call(zZ, Q))
        zZ[Q] = [];
      zZ[Q].push(Z);
    });
  });
});

// node_modules/@babel/types/lib/definitions/misc.js
var G9 = P(() => {
  var $7 = b1(), dA = YZ(), WZ = $7.defineAliasedType("Miscellaneous");
  WZ("Noop", {
    visitor: []
  });
  WZ("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: $7.assertNodeType("Identifier")
      },
      expectedNode: {
        validate: $7.assertOneOf(...dA.PLACEHOLDERS)
      }
    }
  });
  WZ("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: $7.assertValueType("string")
      }
    }
  });
});

// node_modules/@babel/types/lib/definitions/experimental.js
var U9 = P(() => {
  var V0 = b1();
  V0.default("ArgumentPlaceholder", {});
  V0.default("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: V0.assertNodeType("Expression")
      },
      callee: {
        validate: V0.assertNodeType("Expression")
      }
    }
  });
  V0.default("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: V0.assertNodeType("Identifier", "StringLiteral")
      },
      value: {
        validate: V0.assertNodeType("StringLiteral")
      }
    }
  });
  V0.default("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: V0.assertNodeType("Expression")
      }
    }
  });
  V0.default("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: V0.assertNodeType("BlockStatement")
      },
      async: {
        validate: V0.assertValueType("boolean"),
        default: !1
      }
    }
  });
  V0.default("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: V0.assertNodeType("Identifier")
      }
    }
  });
  V0.default("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: V0.chain(V0.assertValueType("array"), V0.assertEach(V0.assertNodeType("ObjectProperty", "SpreadElement")))
      }
    }
  });
  V0.default("TupleExpression", {
    fields: {
      elements: {
        validate: V0.chain(V0.assertValueType("array"), V0.assertEach(V0.assertNodeType("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  V0.default("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: V0.assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  V0.default("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: V0.assertNodeType("Program")
      }
    },
    aliases: ["Expression"]
  });
  V0.default("TopicReference", {
    aliases: ["Expression"]
  });
  V0.default("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: V0.assertNodeType("Expression")
      }
    },
    aliases: ["Expression"]
  });
  V0.default("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: V0.assertNodeType("Expression")
      }
    },
    aliases: ["Expression"]
  });
  V0.default("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// node_modules/@babel/types/lib/definitions/typescript.js
var B9 = P(() => {
  var b = b1(), V9 = JZ(), pA = g5(), r = b.defineAliasedType("TypeScript"), n0 = b.assertValueType("boolean"), K9 = () => ({
    returnType: {
      validate: b.assertNodeType("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: b.assertNodeType("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  r("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: b.assertOneOf("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: b.assertValueType("boolean"),
        optional: !0
      },
      parameter: {
        validate: b.assertNodeType("Identifier", "AssignmentPattern")
      },
      override: {
        validate: b.assertValueType("boolean"),
        optional: !0
      },
      decorators: {
        validate: b.chain(b.assertValueType("array"), b.assertEach(b.assertNodeType("Decorator"))),
        optional: !0
      }
    }
  });
  r("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, V9.functionDeclarationCommon(), K9())
  });
  r("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, V9.classMethodOrDeclareMethodCommon(), K9())
  });
  r("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: b.validateType("TSEntityName"),
      right: b.validateType("Identifier")
    }
  });
  var D7 = () => ({
    typeParameters: b.validateOptionalType("TSTypeParameterDeclaration"),
    ["parameters"]: b.validateArrayOfType(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    ["typeAnnotation"]: b.validateOptionalType("TSTypeAnnotation")
  }), M9 = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: D7()
  };
  r("TSCallSignatureDeclaration", M9);
  r("TSConstructSignatureDeclaration", M9);
  var F9 = () => ({
    key: b.validateType("Expression"),
    computed: {
      default: !1
    },
    optional: b.validateOptional(n0)
  });
  r("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, F9(), {
      readonly: b.validateOptional(n0),
      typeAnnotation: b.validateOptionalType("TSTypeAnnotation"),
      kind: {
        validate: b.assertOneOf("get", "set")
      }
    })
  });
  r("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, D7(), F9(), {
      kind: {
        validate: b.assertOneOf("method", "get", "set")
      }
    })
  });
  r("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: b.validateOptional(n0),
      static: b.validateOptional(n0),
      parameters: b.validateArrayOfType("Identifier"),
      typeAnnotation: b.validateOptionalType("TSTypeAnnotation")
    }
  });
  var aA = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let Z of aA)
    r(Z, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  r("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var R9 = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  r("TSFunctionType", Object.assign({}, R9, {
    fields: D7()
  }));
  r("TSConstructorType", Object.assign({}, R9, {
    fields: Object.assign({}, D7(), {
      abstract: b.validateOptional(n0)
    })
  }));
  r("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: b.validateType("TSEntityName"),
      typeParameters: b.validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  r("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: b.validateType(["Identifier", "TSThisType"]),
      typeAnnotation: b.validateOptionalType("TSTypeAnnotation"),
      asserts: b.validateOptional(n0)
    }
  });
  r("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: b.validateType(["TSEntityName", "TSImportType"]),
      typeParameters: b.validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  r("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: b.validateArrayOfType("TSTypeElement")
    }
  });
  r("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: b.validateType("TSType")
    }
  });
  r("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: b.validateArrayOfType(["TSType", "TSNamedTupleMember"])
    }
  });
  r("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: b.validateType("TSType")
    }
  });
  r("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: b.validateType("TSType")
    }
  });
  r("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: b.validateType("Identifier"),
      optional: {
        validate: n0,
        default: !1
      },
      elementType: b.validateType("TSType")
    }
  });
  var j9 = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: b.validateArrayOfType("TSType")
    }
  };
  r("TSUnionType", j9);
  r("TSIntersectionType", j9);
  r("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: b.validateType("TSType"),
      extendsType: b.validateType("TSType"),
      trueType: b.validateType("TSType"),
      falseType: b.validateType("TSType")
    }
  });
  r("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: b.validateType("TSTypeParameter")
    }
  });
  r("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: b.validateType("TSType")
    }
  });
  r("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: b.validate(b.assertValueType("string")),
      typeAnnotation: b.validateType("TSType")
    }
  });
  r("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: b.validateType("TSType"),
      indexType: b.validateType("TSType")
    }
  });
  r("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: b.validateOptional(b.assertOneOf(!0, !1, "+", "-")),
      typeParameter: b.validateType("TSTypeParameter"),
      optional: b.validateOptional(b.assertOneOf(!0, !1, "+", "-")),
      typeAnnotation: b.validateOptionalType("TSType"),
      nameType: b.validateOptionalType("TSType")
    }
  });
  r("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const Z = b.assertNodeType("NumericLiteral", "BigIntLiteral"), Q = b.assertOneOf("-"), J = b.assertNodeType("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function X(z, Y, W) {
            if (pA.default("UnaryExpression", W))
              Q(W, "operator", W.operator), Z(W, "argument", W.argument);
            else
              J(z, Y, W);
          }
          return X.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], X;
        }()
      }
    }
  });
  r("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: b.validateType("TSEntityName"),
      typeParameters: b.validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  r("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: b.validateOptional(n0),
      id: b.validateType("Identifier"),
      typeParameters: b.validateOptionalType("TSTypeParameterDeclaration"),
      extends: b.validateOptional(b.arrayOfType("TSExpressionWithTypeArguments")),
      body: b.validateType("TSInterfaceBody")
    }
  });
  r("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: b.validateArrayOfType("TSTypeElement")
    }
  });
  r("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: b.validateOptional(n0),
      id: b.validateType("Identifier"),
      typeParameters: b.validateOptionalType("TSTypeParameterDeclaration"),
      typeAnnotation: b.validateType("TSType")
    }
  });
  r("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: b.validateType("Expression"),
      typeParameters: b.validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  var O9 = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: b.validateType("Expression"),
      typeAnnotation: b.validateType("TSType")
    }
  };
  r("TSAsExpression", O9);
  r("TSSatisfiesExpression", O9);
  r("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: b.validateType("TSType"),
      expression: b.validateType("Expression")
    }
  });
  r("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: b.validateOptional(n0),
      const: b.validateOptional(n0),
      id: b.validateType("Identifier"),
      members: b.validateArrayOfType("TSEnumMember"),
      initializer: b.validateOptionalType("Expression")
    }
  });
  r("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: b.validateType(["Identifier", "StringLiteral"]),
      initializer: b.validateOptionalType("Expression")
    }
  });
  r("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: b.validateOptional(n0),
      global: b.validateOptional(n0),
      id: b.validateType(["Identifier", "StringLiteral"]),
      body: b.validateType(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  r("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: b.validateArrayOfType("Statement")
    }
  });
  r("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: b.validateType("StringLiteral"),
      qualifier: b.validateOptionalType("TSEntityName"),
      typeParameters: b.validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  r("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: b.validate(n0),
      id: b.validateType("Identifier"),
      moduleReference: b.validateType(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: b.assertOneOf("type", "value"),
        optional: !0
      }
    }
  });
  r("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: b.validateType("StringLiteral")
    }
  });
  r("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: b.validateType("Expression")
    }
  });
  r("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: b.validateType("Expression")
    }
  });
  r("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: b.validateType("Identifier")
    }
  });
  r("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: b.assertNodeType("TSType")
      }
    }
  });
  r("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: b.chain(b.assertValueType("array"), b.assertEach(b.assertNodeType("TSType")))
      }
    }
  });
  r("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: b.chain(b.assertValueType("array"), b.assertEach(b.assertNodeType("TSTypeParameter")))
      }
    }
  });
  r("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: b.assertValueType("string")
      },
      in: {
        validate: b.assertValueType("boolean"),
        optional: !0
      },
      out: {
        validate: b.assertValueType("boolean"),
        optional: !0
      },
      const: {
        validate: b.assertValueType("boolean"),
        optional: !0
      },
      constraint: {
        validate: b.assertNodeType("TSType"),
        optional: !0
      },
      default: {
        validate: b.assertNodeType("TSType"),
        optional: !0
      }
    }
  });
});

// node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var D9 = P((q9) => {
  Object.defineProperty(q9, "__esModule", {
    value: !0
  });
  q9.DEPRECATED_ALIASES = void 0;
  var Te = q9.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// node_modules/@babel/types/lib/definitions/index.js
var z1 = P((Z1) => {
  Object.defineProperty(Z1, "__esModule", {
    value: !0
  });
  Object.defineProperty(Z1, "ALIAS_KEYS", {
    enumerable: !0,
    get: function() {
      return _0.ALIAS_KEYS;
    }
  });
  Object.defineProperty(Z1, "BUILDER_KEYS", {
    enumerable: !0,
    get: function() {
      return _0.BUILDER_KEYS;
    }
  });
  Object.defineProperty(Z1, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: function() {
      return GZ.DEPRECATED_ALIASES;
    }
  });
  Object.defineProperty(Z1, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: function() {
      return _0.DEPRECATED_KEYS;
    }
  });
  Object.defineProperty(Z1, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: function() {
      return _0.FLIPPED_ALIAS_KEYS;
    }
  });
  Object.defineProperty(Z1, "NODE_FIELDS", {
    enumerable: !0,
    get: function() {
      return _0.NODE_FIELDS;
    }
  });
  Object.defineProperty(Z1, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: function() {
      return _0.NODE_PARENT_VALIDATIONS;
    }
  });
  Object.defineProperty(Z1, "PLACEHOLDERS", {
    enumerable: !0,
    get: function() {
      return B8.PLACEHOLDERS;
    }
  });
  Object.defineProperty(Z1, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: function() {
      return B8.PLACEHOLDERS_ALIAS;
    }
  });
  Object.defineProperty(Z1, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: function() {
      return B8.PLACEHOLDERS_FLIPPED_ALIAS;
    }
  });
  Z1.TYPES = void 0;
  Object.defineProperty(Z1, "VISITOR_KEYS", {
    enumerable: !0,
    get: function() {
      return _0.VISITOR_KEYS;
    }
  });
  var i1 = I4();
  JZ();
  z9();
  H9();
  G9();
  U9();
  B9();
  var _0 = b1(), B8 = YZ(), GZ = D9();
  Object.keys(GZ.DEPRECATED_ALIASES).forEach((Z) => {
    _0.FLIPPED_ALIAS_KEYS[Z] = _0.FLIPPED_ALIAS_KEYS[GZ.DEPRECATED_ALIASES[Z]];
  });
  i1(_0.VISITOR_KEYS);
  i1(_0.ALIAS_KEYS);
  i1(_0.FLIPPED_ALIAS_KEYS);
  i1(_0.NODE_FIELDS);
  i1(_0.BUILDER_KEYS);
  i1(_0.DEPRECATED_KEYS);
  i1(B8.PLACEHOLDERS_ALIAS);
  i1(B8.PLACEHOLDERS_FLIPPED_ALIAS);
  var be = Z1.TYPES = [].concat(Object.keys(_0.VISITOR_KEYS), Object.keys(_0.FLIPPED_ALIAS_KEYS), Object.keys(_0.DEPRECATED_KEYS));
});

// node_modules/@babel/types/lib/validators/validate.js
var B7 = P((N9) => {
  var rA = function(Z, Q, J) {
    if (!Z)
      return;
    const X = C9.NODE_FIELDS[Z.type];
    if (!X)
      return;
    const z = X[Q];
    A9(Z, Q, J, z), L9(Z, Q, J);
  }, A9 = function(Z, Q, J, X) {
    if (!(X != null && X.validate))
      return;
    if (X.optional && J == null)
      return;
    X.validate(Z, Q, J);
  }, L9 = function(Z, Q, J) {
    if (J == null)
      return;
    const X = C9.NODE_PARENT_VALIDATIONS[J.type];
    if (!X)
      return;
    X(Z, Q, J);
  };
  Object.defineProperty(N9, "__esModule", {
    value: !0
  });
  N9.default = rA;
  N9.validateChild = L9;
  N9.validateField = A9;
  var C9 = z1();
});

// node_modules/@babel/types/lib/builders/validateNode.js
var S9 = P((P9) => {
  var ZL = function(Z) {
    const Q = eA.BUILDER_KEYS[Z.type];
    for (let J of Q)
      oA.default(Z, J, Z[J]);
    return Z;
  };
  Object.defineProperty(P9, "__esModule", {
    value: !0
  });
  P9.default = ZL;
  var oA = B7(), eA = B1();
});

// node_modules/@babel/types/lib/builders/generated/index.js
var r0 = P((E9) => {
  var JL = function(Z = []) {
    return A.default({
      type: "ArrayExpression",
      elements: Z
    });
  }, XL = function(Z, Q, J) {
    return A.default({
      type: "AssignmentExpression",
      operator: Z,
      left: Q,
      right: J
    });
  }, zL = function(Z, Q, J) {
    return A.default({
      type: "BinaryExpression",
      operator: Z,
      left: Q,
      right: J
    });
  }, HL = function(Z) {
    return A.default({
      type: "InterpreterDirective",
      value: Z
    });
  }, YL = function(Z) {
    return A.default({
      type: "Directive",
      value: Z
    });
  }, WL = function(Z) {
    return A.default({
      type: "DirectiveLiteral",
      value: Z
    });
  }, GL = function(Z, Q = []) {
    return A.default({
      type: "BlockStatement",
      body: Z,
      directives: Q
    });
  }, UL = function(Z = null) {
    return A.default({
      type: "BreakStatement",
      label: Z
    });
  }, VL = function(Z, Q) {
    return A.default({
      type: "CallExpression",
      callee: Z,
      arguments: Q
    });
  }, KL = function(Z = null, Q) {
    return A.default({
      type: "CatchClause",
      param: Z,
      body: Q
    });
  }, ML = function(Z, Q, J) {
    return A.default({
      type: "ConditionalExpression",
      test: Z,
      consequent: Q,
      alternate: J
    });
  }, FL = function(Z = null) {
    return A.default({
      type: "ContinueStatement",
      label: Z
    });
  }, RL = function() {
    return {
      type: "DebuggerStatement"
    };
  }, jL = function(Z, Q) {
    return A.default({
      type: "DoWhileStatement",
      test: Z,
      body: Q
    });
  }, OL = function() {
    return {
      type: "EmptyStatement"
    };
  }, BL = function(Z) {
    return A.default({
      type: "ExpressionStatement",
      expression: Z
    });
  }, qL = function(Z, Q = null, J = null) {
    return A.default({
      type: "File",
      program: Z,
      comments: Q,
      tokens: J
    });
  }, $L = function(Z, Q, J) {
    return A.default({
      type: "ForInStatement",
      left: Z,
      right: Q,
      body: J
    });
  }, DL = function(Z = null, Q = null, J = null, X) {
    return A.default({
      type: "ForStatement",
      init: Z,
      test: Q,
      update: J,
      body: X
    });
  }, IL = function(Z = null, Q, J, X = !1, z = !1) {
    return A.default({
      type: "FunctionDeclaration",
      id: Z,
      params: Q,
      body: J,
      generator: X,
      async: z
    });
  }, CL = function(Z = null, Q, J, X = !1, z = !1) {
    return A.default({
      type: "FunctionExpression",
      id: Z,
      params: Q,
      body: J,
      generator: X,
      async: z
    });
  }, AL = function(Z) {
    return A.default({
      type: "Identifier",
      name: Z
    });
  }, LL = function(Z, Q, J = null) {
    return A.default({
      type: "IfStatement",
      test: Z,
      consequent: Q,
      alternate: J
    });
  }, NL = function(Z, Q) {
    return A.default({
      type: "LabeledStatement",
      label: Z,
      body: Q
    });
  }, PL = function(Z) {
    return A.default({
      type: "StringLiteral",
      value: Z
    });
  }, w9 = function(Z) {
    return A.default({
      type: "NumericLiteral",
      value: Z
    });
  }, SL = function() {
    return {
      type: "NullLiteral"
    };
  }, wL = function(Z) {
    return A.default({
      type: "BooleanLiteral",
      value: Z
    });
  }, T9 = function(Z, Q = "") {
    return A.default({
      type: "RegExpLiteral",
      pattern: Z,
      flags: Q
    });
  }, TL = function(Z, Q, J) {
    return A.default({
      type: "LogicalExpression",
      operator: Z,
      left: Q,
      right: J
    });
  }, vL = function(Z, Q, J = !1, X = null) {
    return A.default({
      type: "MemberExpression",
      object: Z,
      property: Q,
      computed: J,
      optional: X
    });
  }, bL = function(Z, Q) {
    return A.default({
      type: "NewExpression",
      callee: Z,
      arguments: Q
    });
  }, EL = function(Z, Q = [], J = "script", X = null) {
    return A.default({
      type: "Program",
      body: Z,
      directives: Q,
      sourceType: J,
      interpreter: X
    });
  }, gL = function(Z) {
    return A.default({
      type: "ObjectExpression",
      properties: Z
    });
  }, hL = function(Z = "method", Q, J, X, z = !1, Y = !1, W = !1) {
    return A.default({
      type: "ObjectMethod",
      kind: Z,
      key: Q,
      params: J,
      body: X,
      computed: z,
      generator: Y,
      async: W
    });
  }, _L = function(Z, Q, J = !1, X = !1, z = null) {
    return A.default({
      type: "ObjectProperty",
      key: Z,
      value: Q,
      computed: J,
      shorthand: X,
      decorators: z
    });
  }, v9 = function(Z) {
    return A.default({
      type: "RestElement",
      argument: Z
    });
  }, kL = function(Z = null) {
    return A.default({
      type: "ReturnStatement",
      argument: Z
    });
  }, fL = function(Z) {
    return A.default({
      type: "SequenceExpression",
      expressions: Z
    });
  }, yL = function(Z) {
    return A.default({
      type: "ParenthesizedExpression",
      expression: Z
    });
  }, mL = function(Z = null, Q) {
    return A.default({
      type: "SwitchCase",
      test: Z,
      consequent: Q
    });
  }, uL = function(Z, Q) {
    return A.default({
      type: "SwitchStatement",
      discriminant: Z,
      cases: Q
    });
  }, xL = function() {
    return {
      type: "ThisExpression"
    };
  }, cL = function(Z) {
    return A.default({
      type: "ThrowStatement",
      argument: Z
    });
  }, lL = function(Z, Q = null, J = null) {
    return A.default({
      type: "TryStatement",
      block: Z,
      handler: Q,
      finalizer: J
    });
  }, iL = function(Z, Q, J = !0) {
    return A.default({
      type: "UnaryExpression",
      operator: Z,
      argument: Q,
      prefix: J
    });
  }, dL = function(Z, Q, J = !1) {
    return A.default({
      type: "UpdateExpression",
      operator: Z,
      argument: Q,
      prefix: J
    });
  }, pL = function(Z, Q) {
    return A.default({
      type: "VariableDeclaration",
      kind: Z,
      declarations: Q
    });
  }, aL = function(Z, Q = null) {
    return A.default({
      type: "VariableDeclarator",
      id: Z,
      init: Q
    });
  }, rL = function(Z, Q) {
    return A.default({
      type: "WhileStatement",
      test: Z,
      body: Q
    });
  }, nL = function(Z, Q) {
    return A.default({
      type: "WithStatement",
      object: Z,
      body: Q
    });
  }, sL = function(Z, Q) {
    return A.default({
      type: "AssignmentPattern",
      left: Z,
      right: Q
    });
  }, tL = function(Z) {
    return A.default({
      type: "ArrayPattern",
      elements: Z
    });
  }, oL = function(Z, Q, J = !1) {
    return A.default({
      type: "ArrowFunctionExpression",
      params: Z,
      body: Q,
      async: J,
      expression: null
    });
  }, eL = function(Z) {
    return A.default({
      type: "ClassBody",
      body: Z
    });
  }, ZN = function(Z = null, Q = null, J, X = null) {
    return A.default({
      type: "ClassExpression",
      id: Z,
      superClass: Q,
      body: J,
      decorators: X
    });
  }, QN = function(Z = null, Q = null, J, X = null) {
    return A.default({
      type: "ClassDeclaration",
      id: Z,
      superClass: Q,
      body: J,
      decorators: X
    });
  }, JN = function(Z) {
    return A.default({
      type: "ExportAllDeclaration",
      source: Z
    });
  }, XN = function(Z) {
    return A.default({
      type: "ExportDefaultDeclaration",
      declaration: Z
    });
  }, zN = function(Z = null, Q = [], J = null) {
    return A.default({
      type: "ExportNamedDeclaration",
      declaration: Z,
      specifiers: Q,
      source: J
    });
  }, HN = function(Z, Q) {
    return A.default({
      type: "ExportSpecifier",
      local: Z,
      exported: Q
    });
  }, YN = function(Z, Q, J, X = !1) {
    return A.default({
      type: "ForOfStatement",
      left: Z,
      right: Q,
      body: J,
      await: X
    });
  }, WN = function(Z, Q) {
    return A.default({
      type: "ImportDeclaration",
      specifiers: Z,
      source: Q
    });
  }, GN = function(Z) {
    return A.default({
      type: "ImportDefaultSpecifier",
      local: Z
    });
  }, UN = function(Z) {
    return A.default({
      type: "ImportNamespaceSpecifier",
      local: Z
    });
  }, VN = function(Z, Q) {
    return A.default({
      type: "ImportSpecifier",
      local: Z,
      imported: Q
    });
  }, KN = function(Z, Q = null) {
    return A.default({
      type: "ImportExpression",
      source: Z,
      options: Q
    });
  }, MN = function(Z, Q) {
    return A.default({
      type: "MetaProperty",
      meta: Z,
      property: Q
    });
  }, FN = function(Z = "method", Q, J, X, z = !1, Y = !1, W = !1, U = !1) {
    return A.default({
      type: "ClassMethod",
      kind: Z,
      key: Q,
      params: J,
      body: X,
      computed: z,
      static: Y,
      generator: W,
      async: U
    });
  }, RN = function(Z) {
    return A.default({
      type: "ObjectPattern",
      properties: Z
    });
  }, b9 = function(Z) {
    return A.default({
      type: "SpreadElement",
      argument: Z
    });
  }, jN = function() {
    return {
      type: "Super"
    };
  }, ON = function(Z, Q) {
    return A.default({
      type: "TaggedTemplateExpression",
      tag: Z,
      quasi: Q
    });
  }, BN = function(Z, Q = !1) {
    return A.default({
      type: "TemplateElement",
      value: Z,
      tail: Q
    });
  }, qN = function(Z, Q) {
    return A.default({
      type: "TemplateLiteral",
      quasis: Z,
      expressions: Q
    });
  }, $N = function(Z = null, Q = !1) {
    return A.default({
      type: "YieldExpression",
      argument: Z,
      delegate: Q
    });
  }, DN = function(Z) {
    return A.default({
      type: "AwaitExpression",
      argument: Z
    });
  }, IN = function() {
    return {
      type: "Import"
    };
  }, CN = function(Z) {
    return A.default({
      type: "BigIntLiteral",
      value: Z
    });
  }, AN = function(Z) {
    return A.default({
      type: "ExportNamespaceSpecifier",
      exported: Z
    });
  }, LN = function(Z, Q, J = !1, X) {
    return A.default({
      type: "OptionalMemberExpression",
      object: Z,
      property: Q,
      computed: J,
      optional: X
    });
  }, NN = function(Z, Q, J) {
    return A.default({
      type: "OptionalCallExpression",
      callee: Z,
      arguments: Q,
      optional: J
    });
  }, PN = function(Z, Q = null, J = null, X = null, z = !1, Y = !1) {
    return A.default({
      type: "ClassProperty",
      key: Z,
      value: Q,
      typeAnnotation: J,
      decorators: X,
      computed: z,
      static: Y
    });
  }, SN = function(Z, Q = null, J = null, X = null, z = !1, Y = !1) {
    return A.default({
      type: "ClassAccessorProperty",
      key: Z,
      value: Q,
      typeAnnotation: J,
      decorators: X,
      computed: z,
      static: Y
    });
  }, wN = function(Z, Q = null, J = null, X = !1) {
    return A.default({
      type: "ClassPrivateProperty",
      key: Z,
      value: Q,
      decorators: J,
      static: X
    });
  }, TN = function(Z = "method", Q, J, X, z = !1) {
    return A.default({
      type: "ClassPrivateMethod",
      kind: Z,
      key: Q,
      params: J,
      body: X,
      static: z
    });
  }, vN = function(Z) {
    return A.default({
      type: "PrivateName",
      id: Z
    });
  }, bN = function(Z) {
    return A.default({
      type: "StaticBlock",
      body: Z
    });
  }, EN = function() {
    return {
      type: "AnyTypeAnnotation"
    };
  }, gN = function(Z) {
    return A.default({
      type: "ArrayTypeAnnotation",
      elementType: Z
    });
  }, hN = function() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }, _N = function(Z) {
    return A.default({
      type: "BooleanLiteralTypeAnnotation",
      value: Z
    });
  }, kN = function() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }, fN = function(Z, Q = null) {
    return A.default({
      type: "ClassImplements",
      id: Z,
      typeParameters: Q
    });
  }, yN = function(Z, Q = null, J = null, X) {
    return A.default({
      type: "DeclareClass",
      id: Z,
      typeParameters: Q,
      extends: J,
      body: X
    });
  }, mN = function(Z) {
    return A.default({
      type: "DeclareFunction",
      id: Z
    });
  }, uN = function(Z, Q = null, J = null, X) {
    return A.default({
      type: "DeclareInterface",
      id: Z,
      typeParameters: Q,
      extends: J,
      body: X
    });
  }, xN = function(Z, Q, J = null) {
    return A.default({
      type: "DeclareModule",
      id: Z,
      body: Q,
      kind: J
    });
  }, cN = function(Z) {
    return A.default({
      type: "DeclareModuleExports",
      typeAnnotation: Z
    });
  }, lN = function(Z, Q = null, J) {
    return A.default({
      type: "DeclareTypeAlias",
      id: Z,
      typeParameters: Q,
      right: J
    });
  }, iN = function(Z, Q = null, J = null) {
    return A.default({
      type: "DeclareOpaqueType",
      id: Z,
      typeParameters: Q,
      supertype: J
    });
  }, dN = function(Z) {
    return A.default({
      type: "DeclareVariable",
      id: Z
    });
  }, pN = function(Z = null, Q = null, J = null) {
    return A.default({
      type: "DeclareExportDeclaration",
      declaration: Z,
      specifiers: Q,
      source: J
    });
  }, aN = function(Z) {
    return A.default({
      type: "DeclareExportAllDeclaration",
      source: Z
    });
  }, rN = function(Z) {
    return A.default({
      type: "DeclaredPredicate",
      value: Z
    });
  }, nN = function() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }, sN = function(Z = null, Q, J = null, X) {
    return A.default({
      type: "FunctionTypeAnnotation",
      typeParameters: Z,
      params: Q,
      rest: J,
      returnType: X
    });
  }, tN = function(Z = null, Q) {
    return A.default({
      type: "FunctionTypeParam",
      name: Z,
      typeAnnotation: Q
    });
  }, oN = function(Z, Q = null) {
    return A.default({
      type: "GenericTypeAnnotation",
      id: Z,
      typeParameters: Q
    });
  }, eN = function() {
    return {
      type: "InferredPredicate"
    };
  }, ZP = function(Z, Q = null) {
    return A.default({
      type: "InterfaceExtends",
      id: Z,
      typeParameters: Q
    });
  }, QP = function(Z, Q = null, J = null, X) {
    return A.default({
      type: "InterfaceDeclaration",
      id: Z,
      typeParameters: Q,
      extends: J,
      body: X
    });
  }, JP = function(Z = null, Q) {
    return A.default({
      type: "InterfaceTypeAnnotation",
      extends: Z,
      body: Q
    });
  }, XP = function(Z) {
    return A.default({
      type: "IntersectionTypeAnnotation",
      types: Z
    });
  }, zP = function() {
    return {
      type: "MixedTypeAnnotation"
    };
  }, HP = function() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }, YP = function(Z) {
    return A.default({
      type: "NullableTypeAnnotation",
      typeAnnotation: Z
    });
  }, WP = function(Z) {
    return A.default({
      type: "NumberLiteralTypeAnnotation",
      value: Z
    });
  }, GP = function() {
    return {
      type: "NumberTypeAnnotation"
    };
  }, UP = function(Z, Q = [], J = [], X = [], z = !1) {
    return A.default({
      type: "ObjectTypeAnnotation",
      properties: Z,
      indexers: Q,
      callProperties: J,
      internalSlots: X,
      exact: z
    });
  }, VP = function(Z, Q, J, X, z) {
    return A.default({
      type: "ObjectTypeInternalSlot",
      id: Z,
      value: Q,
      optional: J,
      static: X,
      method: z
    });
  }, KP = function(Z) {
    return A.default({
      type: "ObjectTypeCallProperty",
      value: Z,
      static: null
    });
  }, MP = function(Z = null, Q, J, X = null) {
    return A.default({
      type: "ObjectTypeIndexer",
      id: Z,
      key: Q,
      value: J,
      variance: X,
      static: null
    });
  }, FP = function(Z, Q, J = null) {
    return A.default({
      type: "ObjectTypeProperty",
      key: Z,
      value: Q,
      variance: J,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }, RP = function(Z) {
    return A.default({
      type: "ObjectTypeSpreadProperty",
      argument: Z
    });
  }, jP = function(Z, Q = null, J = null, X) {
    return A.default({
      type: "OpaqueType",
      id: Z,
      typeParameters: Q,
      supertype: J,
      impltype: X
    });
  }, OP = function(Z, Q) {
    return A.default({
      type: "QualifiedTypeIdentifier",
      id: Z,
      qualification: Q
    });
  }, BP = function(Z) {
    return A.default({
      type: "StringLiteralTypeAnnotation",
      value: Z
    });
  }, qP = function() {
    return {
      type: "StringTypeAnnotation"
    };
  }, $P = function() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }, DP = function() {
    return {
      type: "ThisTypeAnnotation"
    };
  }, IP = function(Z) {
    return A.default({
      type: "TupleTypeAnnotation",
      types: Z
    });
  }, CP = function(Z) {
    return A.default({
      type: "TypeofTypeAnnotation",
      argument: Z
    });
  }, AP = function(Z, Q = null, J) {
    return A.default({
      type: "TypeAlias",
      id: Z,
      typeParameters: Q,
      right: J
    });
  }, LP = function(Z) {
    return A.default({
      type: "TypeAnnotation",
      typeAnnotation: Z
    });
  }, NP = function(Z, Q) {
    return A.default({
      type: "TypeCastExpression",
      expression: Z,
      typeAnnotation: Q
    });
  }, PP = function(Z = null, Q = null, J = null) {
    return A.default({
      type: "TypeParameter",
      bound: Z,
      default: Q,
      variance: J,
      name: null
    });
  }, SP = function(Z) {
    return A.default({
      type: "TypeParameterDeclaration",
      params: Z
    });
  }, wP = function(Z) {
    return A.default({
      type: "TypeParameterInstantiation",
      params: Z
    });
  }, TP = function(Z) {
    return A.default({
      type: "UnionTypeAnnotation",
      types: Z
    });
  }, vP = function(Z) {
    return A.default({
      type: "Variance",
      kind: Z
    });
  }, bP = function() {
    return {
      type: "VoidTypeAnnotation"
    };
  }, EP = function(Z, Q) {
    return A.default({
      type: "EnumDeclaration",
      id: Z,
      body: Q
    });
  }, gP = function(Z) {
    return A.default({
      type: "EnumBooleanBody",
      members: Z,
      explicitType: null,
      hasUnknownMembers: null
    });
  }, hP = function(Z) {
    return A.default({
      type: "EnumNumberBody",
      members: Z,
      explicitType: null,
      hasUnknownMembers: null
    });
  }, _P = function(Z) {
    return A.default({
      type: "EnumStringBody",
      members: Z,
      explicitType: null,
      hasUnknownMembers: null
    });
  }, kP = function(Z) {
    return A.default({
      type: "EnumSymbolBody",
      members: Z,
      hasUnknownMembers: null
    });
  }, fP = function(Z) {
    return A.default({
      type: "EnumBooleanMember",
      id: Z,
      init: null
    });
  }, yP = function(Z, Q) {
    return A.default({
      type: "EnumNumberMember",
      id: Z,
      init: Q
    });
  }, mP = function(Z, Q) {
    return A.default({
      type: "EnumStringMember",
      id: Z,
      init: Q
    });
  }, uP = function(Z) {
    return A.default({
      type: "EnumDefaultedMember",
      id: Z
    });
  }, xP = function(Z, Q) {
    return A.default({
      type: "IndexedAccessType",
      objectType: Z,
      indexType: Q
    });
  }, cP = function(Z, Q) {
    return A.default({
      type: "OptionalIndexedAccessType",
      objectType: Z,
      indexType: Q,
      optional: null
    });
  }, lP = function(Z, Q = null) {
    return A.default({
      type: "JSXAttribute",
      name: Z,
      value: Q
    });
  }, iP = function(Z) {
    return A.default({
      type: "JSXClosingElement",
      name: Z
    });
  }, dP = function(Z, Q = null, J, X = null) {
    return A.default({
      type: "JSXElement",
      openingElement: Z,
      closingElement: Q,
      children: J,
      selfClosing: X
    });
  }, pP = function() {
    return {
      type: "JSXEmptyExpression"
    };
  }, aP = function(Z) {
    return A.default({
      type: "JSXExpressionContainer",
      expression: Z
    });
  }, rP = function(Z) {
    return A.default({
      type: "JSXSpreadChild",
      expression: Z
    });
  }, nP = function(Z) {
    return A.default({
      type: "JSXIdentifier",
      name: Z
    });
  }, sP = function(Z, Q) {
    return A.default({
      type: "JSXMemberExpression",
      object: Z,
      property: Q
    });
  }, tP = function(Z, Q) {
    return A.default({
      type: "JSXNamespacedName",
      namespace: Z,
      name: Q
    });
  }, oP = function(Z, Q, J = !1) {
    return A.default({
      type: "JSXOpeningElement",
      name: Z,
      attributes: Q,
      selfClosing: J
    });
  }, eP = function(Z) {
    return A.default({
      type: "JSXSpreadAttribute",
      argument: Z
    });
  }, ZS = function(Z) {
    return A.default({
      type: "JSXText",
      value: Z
    });
  }, QS = function(Z, Q, J) {
    return A.default({
      type: "JSXFragment",
      openingFragment: Z,
      closingFragment: Q,
      children: J
    });
  }, JS = function() {
    return {
      type: "JSXOpeningFragment"
    };
  }, XS = function() {
    return {
      type: "JSXClosingFragment"
    };
  }, zS = function() {
    return {
      type: "Noop"
    };
  }, HS = function(Z, Q) {
    return A.default({
      type: "Placeholder",
      expectedNode: Z,
      name: Q
    });
  }, YS = function(Z) {
    return A.default({
      type: "V8IntrinsicIdentifier",
      name: Z
    });
  }, WS = function() {
    return {
      type: "ArgumentPlaceholder"
    };
  }, GS = function(Z, Q) {
    return A.default({
      type: "BindExpression",
      object: Z,
      callee: Q
    });
  }, US = function(Z, Q) {
    return A.default({
      type: "ImportAttribute",
      key: Z,
      value: Q
    });
  }, VS = function(Z) {
    return A.default({
      type: "Decorator",
      expression: Z
    });
  }, KS = function(Z, Q = !1) {
    return A.default({
      type: "DoExpression",
      body: Z,
      async: Q
    });
  }, MS = function(Z) {
    return A.default({
      type: "ExportDefaultSpecifier",
      exported: Z
    });
  }, FS = function(Z) {
    return A.default({
      type: "RecordExpression",
      properties: Z
    });
  }, RS = function(Z = []) {
    return A.default({
      type: "TupleExpression",
      elements: Z
    });
  }, jS = function(Z) {
    return A.default({
      type: "DecimalLiteral",
      value: Z
    });
  }, OS = function(Z) {
    return A.default({
      type: "ModuleExpression",
      body: Z
    });
  }, BS = function() {
    return {
      type: "TopicReference"
    };
  }, qS = function(Z) {
    return A.default({
      type: "PipelineTopicExpression",
      expression: Z
    });
  }, $S = function(Z) {
    return A.default({
      type: "PipelineBareFunction",
      callee: Z
    });
  }, DS = function() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }, IS = function(Z) {
    return A.default({
      type: "TSParameterProperty",
      parameter: Z
    });
  }, CS = function(Z = null, Q = null, J, X = null) {
    return A.default({
      type: "TSDeclareFunction",
      id: Z,
      typeParameters: Q,
      params: J,
      returnType: X
    });
  }, AS = function(Z = null, Q, J = null, X, z = null) {
    return A.default({
      type: "TSDeclareMethod",
      decorators: Z,
      key: Q,
      typeParameters: J,
      params: X,
      returnType: z
    });
  }, LS = function(Z, Q) {
    return A.default({
      type: "TSQualifiedName",
      left: Z,
      right: Q
    });
  }, NS = function(Z = null, Q, J = null) {
    return A.default({
      type: "TSCallSignatureDeclaration",
      typeParameters: Z,
      parameters: Q,
      typeAnnotation: J
    });
  }, PS = function(Z = null, Q, J = null) {
    return A.default({
      type: "TSConstructSignatureDeclaration",
      typeParameters: Z,
      parameters: Q,
      typeAnnotation: J
    });
  }, SS = function(Z, Q = null) {
    return A.default({
      type: "TSPropertySignature",
      key: Z,
      typeAnnotation: Q,
      kind: null
    });
  }, wS = function(Z, Q = null, J, X = null) {
    return A.default({
      type: "TSMethodSignature",
      key: Z,
      typeParameters: Q,
      parameters: J,
      typeAnnotation: X,
      kind: null
    });
  }, TS = function(Z, Q = null) {
    return A.default({
      type: "TSIndexSignature",
      parameters: Z,
      typeAnnotation: Q
    });
  }, vS = function() {
    return {
      type: "TSAnyKeyword"
    };
  }, bS = function() {
    return {
      type: "TSBooleanKeyword"
    };
  }, ES = function() {
    return {
      type: "TSBigIntKeyword"
    };
  }, gS = function() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }, hS = function() {
    return {
      type: "TSNeverKeyword"
    };
  }, _S = function() {
    return {
      type: "TSNullKeyword"
    };
  }, kS = function() {
    return {
      type: "TSNumberKeyword"
    };
  }, fS = function() {
    return {
      type: "TSObjectKeyword"
    };
  }, yS = function() {
    return {
      type: "TSStringKeyword"
    };
  }, mS = function() {
    return {
      type: "TSSymbolKeyword"
    };
  }, uS = function() {
    return {
      type: "TSUndefinedKeyword"
    };
  }, xS = function() {
    return {
      type: "TSUnknownKeyword"
    };
  }, cS = function() {
    return {
      type: "TSVoidKeyword"
    };
  }, lS = function() {
    return {
      type: "TSThisType"
    };
  }, iS = function(Z = null, Q, J = null) {
    return A.default({
      type: "TSFunctionType",
      typeParameters: Z,
      parameters: Q,
      typeAnnotation: J
    });
  }, dS = function(Z = null, Q, J = null) {
    return A.default({
      type: "TSConstructorType",
      typeParameters: Z,
      parameters: Q,
      typeAnnotation: J
    });
  }, pS = function(Z, Q = null) {
    return A.default({
      type: "TSTypeReference",
      typeName: Z,
      typeParameters: Q
    });
  }, aS = function(Z, Q = null, J = null) {
    return A.default({
      type: "TSTypePredicate",
      parameterName: Z,
      typeAnnotation: Q,
      asserts: J
    });
  }, rS = function(Z, Q = null) {
    return A.default({
      type: "TSTypeQuery",
      exprName: Z,
      typeParameters: Q
    });
  }, nS = function(Z) {
    return A.default({
      type: "TSTypeLiteral",
      members: Z
    });
  }, sS = function(Z) {
    return A.default({
      type: "TSArrayType",
      elementType: Z
    });
  }, tS = function(Z) {
    return A.default({
      type: "TSTupleType",
      elementTypes: Z
    });
  }, oS = function(Z) {
    return A.default({
      type: "TSOptionalType",
      typeAnnotation: Z
    });
  }, eS = function(Z) {
    return A.default({
      type: "TSRestType",
      typeAnnotation: Z
    });
  }, Zw = function(Z, Q, J = !1) {
    return A.default({
      type: "TSNamedTupleMember",
      label: Z,
      elementType: Q,
      optional: J
    });
  }, Qw = function(Z) {
    return A.default({
      type: "TSUnionType",
      types: Z
    });
  }, Jw = function(Z) {
    return A.default({
      type: "TSIntersectionType",
      types: Z
    });
  }, Xw = function(Z, Q, J, X) {
    return A.default({
      type: "TSConditionalType",
      checkType: Z,
      extendsType: Q,
      trueType: J,
      falseType: X
    });
  }, zw = function(Z) {
    return A.default({
      type: "TSInferType",
      typeParameter: Z
    });
  }, Hw = function(Z) {
    return A.default({
      type: "TSParenthesizedType",
      typeAnnotation: Z
    });
  }, Yw = function(Z) {
    return A.default({
      type: "TSTypeOperator",
      typeAnnotation: Z,
      operator: null
    });
  }, Ww = function(Z, Q) {
    return A.default({
      type: "TSIndexedAccessType",
      objectType: Z,
      indexType: Q
    });
  }, Gw = function(Z, Q = null, J = null) {
    return A.default({
      type: "TSMappedType",
      typeParameter: Z,
      typeAnnotation: Q,
      nameType: J
    });
  }, Uw = function(Z) {
    return A.default({
      type: "TSLiteralType",
      literal: Z
    });
  }, Vw = function(Z, Q = null) {
    return A.default({
      type: "TSExpressionWithTypeArguments",
      expression: Z,
      typeParameters: Q
    });
  }, Kw = function(Z, Q = null, J = null, X) {
    return A.default({
      type: "TSInterfaceDeclaration",
      id: Z,
      typeParameters: Q,
      extends: J,
      body: X
    });
  }, Mw = function(Z) {
    return A.default({
      type: "TSInterfaceBody",
      body: Z
    });
  }, Fw = function(Z, Q = null, J) {
    return A.default({
      type: "TSTypeAliasDeclaration",
      id: Z,
      typeParameters: Q,
      typeAnnotation: J
    });
  }, Rw = function(Z, Q = null) {
    return A.default({
      type: "TSInstantiationExpression",
      expression: Z,
      typeParameters: Q
    });
  }, jw = function(Z, Q) {
    return A.default({
      type: "TSAsExpression",
      expression: Z,
      typeAnnotation: Q
    });
  }, Ow = function(Z, Q) {
    return A.default({
      type: "TSSatisfiesExpression",
      expression: Z,
      typeAnnotation: Q
    });
  }, Bw = function(Z, Q) {
    return A.default({
      type: "TSTypeAssertion",
      typeAnnotation: Z,
      expression: Q
    });
  }, qw = function(Z, Q) {
    return A.default({
      type: "TSEnumDeclaration",
      id: Z,
      members: Q
    });
  }, $w = function(Z, Q = null) {
    return A.default({
      type: "TSEnumMember",
      id: Z,
      initializer: Q
    });
  }, Dw = function(Z, Q) {
    return A.default({
      type: "TSModuleDeclaration",
      id: Z,
      body: Q
    });
  }, Iw = function(Z) {
    return A.default({
      type: "TSModuleBlock",
      body: Z
    });
  }, Cw = function(Z, Q = null, J = null) {
    return A.default({
      type: "TSImportType",
      argument: Z,
      qualifier: Q,
      typeParameters: J
    });
  }, Aw = function(Z, Q) {
    return A.default({
      type: "TSImportEqualsDeclaration",
      id: Z,
      moduleReference: Q,
      isExport: null
    });
  }, Lw = function(Z) {
    return A.default({
      type: "TSExternalModuleReference",
      expression: Z
    });
  }, Nw = function(Z) {
    return A.default({
      type: "TSNonNullExpression",
      expression: Z
    });
  }, Pw = function(Z) {
    return A.default({
      type: "TSExportAssignment",
      expression: Z
    });
  }, Sw = function(Z) {
    return A.default({
      type: "TSNamespaceExportDeclaration",
      id: Z
    });
  }, ww = function(Z) {
    return A.default({
      type: "TSTypeAnnotation",
      typeAnnotation: Z
    });
  }, Tw = function(Z) {
    return A.default({
      type: "TSTypeParameterInstantiation",
      params: Z
    });
  }, vw = function(Z) {
    return A.default({
      type: "TSTypeParameterDeclaration",
      params: Z
    });
  }, bw = function(Z = null, Q = null, J) {
    return A.default({
      type: "TSTypeParameter",
      constraint: Z,
      default: Q,
      name: J
    });
  }, Ew = function(Z) {
    return I7.default("NumberLiteral", "NumericLiteral", "The node type "), w9(Z);
  }, gw = function(Z, Q = "") {
    return I7.default("RegexLiteral", "RegExpLiteral", "The node type "), T9(Z, Q);
  }, hw = function(Z) {
    return I7.default("RestProperty", "RestElement", "The node type "), v9(Z);
  }, _w = function(Z) {
    return I7.default("SpreadProperty", "SpreadElement", "The node type "), b9(Z);
  };
  Object.defineProperty(E9, "__esModule", {
    value: !0
  });
  E9.anyTypeAnnotation = EN;
  E9.argumentPlaceholder = WS;
  E9.arrayExpression = JL;
  E9.arrayPattern = tL;
  E9.arrayTypeAnnotation = gN;
  E9.arrowFunctionExpression = oL;
  E9.assignmentExpression = XL;
  E9.assignmentPattern = sL;
  E9.awaitExpression = DN;
  E9.bigIntLiteral = CN;
  E9.binaryExpression = zL;
  E9.bindExpression = GS;
  E9.blockStatement = GL;
  E9.booleanLiteral = wL;
  E9.booleanLiteralTypeAnnotation = _N;
  E9.booleanTypeAnnotation = hN;
  E9.breakStatement = UL;
  E9.callExpression = VL;
  E9.catchClause = KL;
  E9.classAccessorProperty = SN;
  E9.classBody = eL;
  E9.classDeclaration = QN;
  E9.classExpression = ZN;
  E9.classImplements = fN;
  E9.classMethod = FN;
  E9.classPrivateMethod = TN;
  E9.classPrivateProperty = wN;
  E9.classProperty = PN;
  E9.conditionalExpression = ML;
  E9.continueStatement = FL;
  E9.debuggerStatement = RL;
  E9.decimalLiteral = jS;
  E9.declareClass = yN;
  E9.declareExportAllDeclaration = aN;
  E9.declareExportDeclaration = pN;
  E9.declareFunction = mN;
  E9.declareInterface = uN;
  E9.declareModule = xN;
  E9.declareModuleExports = cN;
  E9.declareOpaqueType = iN;
  E9.declareTypeAlias = lN;
  E9.declareVariable = dN;
  E9.declaredPredicate = rN;
  E9.decorator = VS;
  E9.directive = YL;
  E9.directiveLiteral = WL;
  E9.doExpression = KS;
  E9.doWhileStatement = jL;
  E9.emptyStatement = OL;
  E9.emptyTypeAnnotation = HP;
  E9.enumBooleanBody = gP;
  E9.enumBooleanMember = fP;
  E9.enumDeclaration = EP;
  E9.enumDefaultedMember = uP;
  E9.enumNumberBody = hP;
  E9.enumNumberMember = yP;
  E9.enumStringBody = _P;
  E9.enumStringMember = mP;
  E9.enumSymbolBody = kP;
  E9.existsTypeAnnotation = nN;
  E9.exportAllDeclaration = JN;
  E9.exportDefaultDeclaration = XN;
  E9.exportDefaultSpecifier = MS;
  E9.exportNamedDeclaration = zN;
  E9.exportNamespaceSpecifier = AN;
  E9.exportSpecifier = HN;
  E9.expressionStatement = BL;
  E9.file = qL;
  E9.forInStatement = $L;
  E9.forOfStatement = YN;
  E9.forStatement = DL;
  E9.functionDeclaration = IL;
  E9.functionExpression = CL;
  E9.functionTypeAnnotation = sN;
  E9.functionTypeParam = tN;
  E9.genericTypeAnnotation = oN;
  E9.identifier = AL;
  E9.ifStatement = LL;
  E9.import = IN;
  E9.importAttribute = US;
  E9.importDeclaration = WN;
  E9.importDefaultSpecifier = GN;
  E9.importExpression = KN;
  E9.importNamespaceSpecifier = UN;
  E9.importSpecifier = VN;
  E9.indexedAccessType = xP;
  E9.inferredPredicate = eN;
  E9.interfaceDeclaration = QP;
  E9.interfaceExtends = ZP;
  E9.interfaceTypeAnnotation = JP;
  E9.interpreterDirective = HL;
  E9.intersectionTypeAnnotation = XP;
  E9.jSXAttribute = E9.jsxAttribute = lP;
  E9.jSXClosingElement = E9.jsxClosingElement = iP;
  E9.jSXClosingFragment = E9.jsxClosingFragment = XS;
  E9.jSXElement = E9.jsxElement = dP;
  E9.jSXEmptyExpression = E9.jsxEmptyExpression = pP;
  E9.jSXExpressionContainer = E9.jsxExpressionContainer = aP;
  E9.jSXFragment = E9.jsxFragment = QS;
  E9.jSXIdentifier = E9.jsxIdentifier = nP;
  E9.jSXMemberExpression = E9.jsxMemberExpression = sP;
  E9.jSXNamespacedName = E9.jsxNamespacedName = tP;
  E9.jSXOpeningElement = E9.jsxOpeningElement = oP;
  E9.jSXOpeningFragment = E9.jsxOpeningFragment = JS;
  E9.jSXSpreadAttribute = E9.jsxSpreadAttribute = eP;
  E9.jSXSpreadChild = E9.jsxSpreadChild = rP;
  E9.jSXText = E9.jsxText = ZS;
  E9.labeledStatement = NL;
  E9.logicalExpression = TL;
  E9.memberExpression = vL;
  E9.metaProperty = MN;
  E9.mixedTypeAnnotation = zP;
  E9.moduleExpression = OS;
  E9.newExpression = bL;
  E9.noop = zS;
  E9.nullLiteral = SL;
  E9.nullLiteralTypeAnnotation = kN;
  E9.nullableTypeAnnotation = YP;
  E9.numberLiteral = Ew;
  E9.numberLiteralTypeAnnotation = WP;
  E9.numberTypeAnnotation = GP;
  E9.numericLiteral = w9;
  E9.objectExpression = gL;
  E9.objectMethod = hL;
  E9.objectPattern = RN;
  E9.objectProperty = _L;
  E9.objectTypeAnnotation = UP;
  E9.objectTypeCallProperty = KP;
  E9.objectTypeIndexer = MP;
  E9.objectTypeInternalSlot = VP;
  E9.objectTypeProperty = FP;
  E9.objectTypeSpreadProperty = RP;
  E9.opaqueType = jP;
  E9.optionalCallExpression = NN;
  E9.optionalIndexedAccessType = cP;
  E9.optionalMemberExpression = LN;
  E9.parenthesizedExpression = yL;
  E9.pipelineBareFunction = $S;
  E9.pipelinePrimaryTopicReference = DS;
  E9.pipelineTopicExpression = qS;
  E9.placeholder = HS;
  E9.privateName = vN;
  E9.program = EL;
  E9.qualifiedTypeIdentifier = OP;
  E9.recordExpression = FS;
  E9.regExpLiteral = T9;
  E9.regexLiteral = gw;
  E9.restElement = v9;
  E9.restProperty = hw;
  E9.returnStatement = kL;
  E9.sequenceExpression = fL;
  E9.spreadElement = b9;
  E9.spreadProperty = _w;
  E9.staticBlock = bN;
  E9.stringLiteral = PL;
  E9.stringLiteralTypeAnnotation = BP;
  E9.stringTypeAnnotation = qP;
  E9.super = jN;
  E9.switchCase = mL;
  E9.switchStatement = uL;
  E9.symbolTypeAnnotation = $P;
  E9.taggedTemplateExpression = ON;
  E9.templateElement = BN;
  E9.templateLiteral = qN;
  E9.thisExpression = xL;
  E9.thisTypeAnnotation = DP;
  E9.throwStatement = cL;
  E9.topicReference = BS;
  E9.tryStatement = lL;
  E9.tSAnyKeyword = E9.tsAnyKeyword = vS;
  E9.tSArrayType = E9.tsArrayType = sS;
  E9.tSAsExpression = E9.tsAsExpression = jw;
  E9.tSBigIntKeyword = E9.tsBigIntKeyword = ES;
  E9.tSBooleanKeyword = E9.tsBooleanKeyword = bS;
  E9.tSCallSignatureDeclaration = E9.tsCallSignatureDeclaration = NS;
  E9.tSConditionalType = E9.tsConditionalType = Xw;
  E9.tSConstructSignatureDeclaration = E9.tsConstructSignatureDeclaration = PS;
  E9.tSConstructorType = E9.tsConstructorType = dS;
  E9.tSDeclareFunction = E9.tsDeclareFunction = CS;
  E9.tSDeclareMethod = E9.tsDeclareMethod = AS;
  E9.tSEnumDeclaration = E9.tsEnumDeclaration = qw;
  E9.tSEnumMember = E9.tsEnumMember = $w;
  E9.tSExportAssignment = E9.tsExportAssignment = Pw;
  E9.tSExpressionWithTypeArguments = E9.tsExpressionWithTypeArguments = Vw;
  E9.tSExternalModuleReference = E9.tsExternalModuleReference = Lw;
  E9.tSFunctionType = E9.tsFunctionType = iS;
  E9.tSImportEqualsDeclaration = E9.tsImportEqualsDeclaration = Aw;
  E9.tSImportType = E9.tsImportType = Cw;
  E9.tSIndexSignature = E9.tsIndexSignature = TS;
  E9.tSIndexedAccessType = E9.tsIndexedAccessType = Ww;
  E9.tSInferType = E9.tsInferType = zw;
  E9.tSInstantiationExpression = E9.tsInstantiationExpression = Rw;
  E9.tSInterfaceBody = E9.tsInterfaceBody = Mw;
  E9.tSInterfaceDeclaration = E9.tsInterfaceDeclaration = Kw;
  E9.tSIntersectionType = E9.tsIntersectionType = Jw;
  E9.tSIntrinsicKeyword = E9.tsIntrinsicKeyword = gS;
  E9.tSLiteralType = E9.tsLiteralType = Uw;
  E9.tSMappedType = E9.tsMappedType = Gw;
  E9.tSMethodSignature = E9.tsMethodSignature = wS;
  E9.tSModuleBlock = E9.tsModuleBlock = Iw;
  E9.tSModuleDeclaration = E9.tsModuleDeclaration = Dw;
  E9.tSNamedTupleMember = E9.tsNamedTupleMember = Zw;
  E9.tSNamespaceExportDeclaration = E9.tsNamespaceExportDeclaration = Sw;
  E9.tSNeverKeyword = E9.tsNeverKeyword = hS;
  E9.tSNonNullExpression = E9.tsNonNullExpression = Nw;
  E9.tSNullKeyword = E9.tsNullKeyword = _S;
  E9.tSNumberKeyword = E9.tsNumberKeyword = kS;
  E9.tSObjectKeyword = E9.tsObjectKeyword = fS;
  E9.tSOptionalType = E9.tsOptionalType = oS;
  E9.tSParameterProperty = E9.tsParameterProperty = IS;
  E9.tSParenthesizedType = E9.tsParenthesizedType = Hw;
  E9.tSPropertySignature = E9.tsPropertySignature = SS;
  E9.tSQualifiedName = E9.tsQualifiedName = LS;
  E9.tSRestType = E9.tsRestType = eS;
  E9.tSSatisfiesExpression = E9.tsSatisfiesExpression = Ow;
  E9.tSStringKeyword = E9.tsStringKeyword = yS;
  E9.tSSymbolKeyword = E9.tsSymbolKeyword = mS;
  E9.tSThisType = E9.tsThisType = lS;
  E9.tSTupleType = E9.tsTupleType = tS;
  E9.tSTypeAliasDeclaration = E9.tsTypeAliasDeclaration = Fw;
  E9.tSTypeAnnotation = E9.tsTypeAnnotation = ww;
  E9.tSTypeAssertion = E9.tsTypeAssertion = Bw;
  E9.tSTypeLiteral = E9.tsTypeLiteral = nS;
  E9.tSTypeOperator = E9.tsTypeOperator = Yw;
  E9.tSTypeParameter = E9.tsTypeParameter = bw;
  E9.tSTypeParameterDeclaration = E9.tsTypeParameterDeclaration = vw;
  E9.tSTypeParameterInstantiation = E9.tsTypeParameterInstantiation = Tw;
  E9.tSTypePredicate = E9.tsTypePredicate = aS;
  E9.tSTypeQuery = E9.tsTypeQuery = rS;
  E9.tSTypeReference = E9.tsTypeReference = pS;
  E9.tSUndefinedKeyword = E9.tsUndefinedKeyword = uS;
  E9.tSUnionType = E9.tsUnionType = Qw;
  E9.tSUnknownKeyword = E9.tsUnknownKeyword = xS;
  E9.tSVoidKeyword = E9.tsVoidKeyword = cS;
  E9.tupleExpression = RS;
  E9.tupleTypeAnnotation = IP;
  E9.typeAlias = AP;
  E9.typeAnnotation = LP;
  E9.typeCastExpression = NP;
  E9.typeParameter = PP;
  E9.typeParameterDeclaration = SP;
  E9.typeParameterInstantiation = wP;
  E9.typeofTypeAnnotation = CP;
  E9.unaryExpression = iL;
  E9.unionTypeAnnotation = TP;
  E9.updateExpression = dL;
  E9.v8IntrinsicIdentifier = YS;
  E9.variableDeclaration = pL;
  E9.variableDeclarator = aL;
  E9.variance = vP;
  E9.voidTypeAnnotation = bP;
  E9.whileStatement = rL;
  E9.withStatement = nL;
  E9.yieldExpression = $N;
  var A = S9(), I7 = V8();
});

// node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var h9 = P((g9) => {
  var Cg = function(Z, Q) {
    const J = Z.value.split(/\r\n|\n|\r/);
    let X = 0;
    for (let Y = 0;Y < J.length; Y++)
      if (J[Y].match(/[^ \t]/))
        X = Y;
    let z = "";
    for (let Y = 0;Y < J.length; Y++) {
      const W = J[Y], U = Y === 0, V = Y === J.length - 1, M = Y === X;
      let q = W.replace(/\t/g, " ");
      if (!U)
        q = q.replace(/^[ ]+/, "");
      if (!V)
        q = q.replace(/[ ]+$/, "");
      if (q) {
        if (!M)
          q += " ";
        z += q;
      }
    }
    if (z)
      Q.push(Ig.inherits(Dg.stringLiteral(z), Z));
  };
  Object.defineProperty(g9, "__esModule", {
    value: !0
  });
  g9.default = Cg;
  var Dg = r0(), Ig = B1();
});

// node_modules/@babel/types/lib/builders/react/buildChildren.js
var k9 = P((_9) => {
  var Ng = function(Z) {
    const Q = [];
    for (let J = 0;J < Z.children.length; J++) {
      let X = Z.children[J];
      if (UZ.isJSXText(X)) {
        Lg.default(X, Q);
        continue;
      }
      if (UZ.isJSXExpressionContainer(X))
        X = X.expression;
      if (UZ.isJSXEmptyExpression(X))
        continue;
      Q.push(X);
    }
    return Q;
  };
  Object.defineProperty(_9, "__esModule", {
    value: !0
  });
  _9.default = Ng;
  var UZ = S0(), Lg = h9();
});

// node_modules/@babel/types/lib/validators/isNode.js
var VZ = P((f9) => {
  var wg = function(Z) {
    return !!(Z && Sg.VISITOR_KEYS[Z.type]);
  };
  Object.defineProperty(f9, "__esModule", {
    value: !0
  });
  f9.default = wg;
  var Sg = z1();
});

// node_modules/@babel/types/lib/asserts/assertNode.js
var m9 = P((y9) => {
  var bg = function(Z) {
    if (!vg.default(Z)) {
      var Q;
      const J = (Q = Z == null ? void 0 : Z.type) != null ? Q : JSON.stringify(Z);
      throw new TypeError(`Not a valid node of type "${J}"`);
    }
  };
  Object.defineProperty(y9, "__esModule", {
    value: !0
  });
  y9.default = bg;
  var vg = VZ();
});

// node_modules/@babel/types/lib/asserts/generated/index.js
var x9 = P((u9) => {
  var O = function(Z, Q, J) {
    if (!gg.default(Z, Q, J))
      throw new Error(`Expected type "${Z}" with option ${JSON.stringify(J)}, ` + `but instead got "${Q.type}".`);
  }, hg = function(Z, Q) {
    O("ArrayExpression", Z, Q);
  }, _g = function(Z, Q) {
    O("AssignmentExpression", Z, Q);
  }, kg = function(Z, Q) {
    O("BinaryExpression", Z, Q);
  }, fg = function(Z, Q) {
    O("InterpreterDirective", Z, Q);
  }, yg = function(Z, Q) {
    O("Directive", Z, Q);
  }, mg = function(Z, Q) {
    O("DirectiveLiteral", Z, Q);
  }, ug = function(Z, Q) {
    O("BlockStatement", Z, Q);
  }, xg = function(Z, Q) {
    O("BreakStatement", Z, Q);
  }, cg = function(Z, Q) {
    O("CallExpression", Z, Q);
  }, lg = function(Z, Q) {
    O("CatchClause", Z, Q);
  }, ig = function(Z, Q) {
    O("ConditionalExpression", Z, Q);
  }, dg = function(Z, Q) {
    O("ContinueStatement", Z, Q);
  }, pg = function(Z, Q) {
    O("DebuggerStatement", Z, Q);
  }, ag = function(Z, Q) {
    O("DoWhileStatement", Z, Q);
  }, rg = function(Z, Q) {
    O("EmptyStatement", Z, Q);
  }, ng = function(Z, Q) {
    O("ExpressionStatement", Z, Q);
  }, sg = function(Z, Q) {
    O("File", Z, Q);
  }, tg = function(Z, Q) {
    O("ForInStatement", Z, Q);
  }, og = function(Z, Q) {
    O("ForStatement", Z, Q);
  }, eg = function(Z, Q) {
    O("FunctionDeclaration", Z, Q);
  }, Zh = function(Z, Q) {
    O("FunctionExpression", Z, Q);
  }, Qh = function(Z, Q) {
    O("Identifier", Z, Q);
  }, Jh = function(Z, Q) {
    O("IfStatement", Z, Q);
  }, Xh = function(Z, Q) {
    O("LabeledStatement", Z, Q);
  }, zh = function(Z, Q) {
    O("StringLiteral", Z, Q);
  }, Hh = function(Z, Q) {
    O("NumericLiteral", Z, Q);
  }, Yh = function(Z, Q) {
    O("NullLiteral", Z, Q);
  }, Wh = function(Z, Q) {
    O("BooleanLiteral", Z, Q);
  }, Gh = function(Z, Q) {
    O("RegExpLiteral", Z, Q);
  }, Uh = function(Z, Q) {
    O("LogicalExpression", Z, Q);
  }, Vh = function(Z, Q) {
    O("MemberExpression", Z, Q);
  }, Kh = function(Z, Q) {
    O("NewExpression", Z, Q);
  }, Mh = function(Z, Q) {
    O("Program", Z, Q);
  }, Fh = function(Z, Q) {
    O("ObjectExpression", Z, Q);
  }, Rh = function(Z, Q) {
    O("ObjectMethod", Z, Q);
  }, jh = function(Z, Q) {
    O("ObjectProperty", Z, Q);
  }, Oh = function(Z, Q) {
    O("RestElement", Z, Q);
  }, Bh = function(Z, Q) {
    O("ReturnStatement", Z, Q);
  }, qh = function(Z, Q) {
    O("SequenceExpression", Z, Q);
  }, $h = function(Z, Q) {
    O("ParenthesizedExpression", Z, Q);
  }, Dh = function(Z, Q) {
    O("SwitchCase", Z, Q);
  }, Ih = function(Z, Q) {
    O("SwitchStatement", Z, Q);
  }, Ch = function(Z, Q) {
    O("ThisExpression", Z, Q);
  }, Ah = function(Z, Q) {
    O("ThrowStatement", Z, Q);
  }, Lh = function(Z, Q) {
    O("TryStatement", Z, Q);
  }, Nh = function(Z, Q) {
    O("UnaryExpression", Z, Q);
  }, Ph = function(Z, Q) {
    O("UpdateExpression", Z, Q);
  }, Sh = function(Z, Q) {
    O("VariableDeclaration", Z, Q);
  }, wh = function(Z, Q) {
    O("VariableDeclarator", Z, Q);
  }, Th = function(Z, Q) {
    O("WhileStatement", Z, Q);
  }, vh = function(Z, Q) {
    O("WithStatement", Z, Q);
  }, bh = function(Z, Q) {
    O("AssignmentPattern", Z, Q);
  }, Eh = function(Z, Q) {
    O("ArrayPattern", Z, Q);
  }, gh = function(Z, Q) {
    O("ArrowFunctionExpression", Z, Q);
  }, hh = function(Z, Q) {
    O("ClassBody", Z, Q);
  }, _h = function(Z, Q) {
    O("ClassExpression", Z, Q);
  }, kh = function(Z, Q) {
    O("ClassDeclaration", Z, Q);
  }, fh = function(Z, Q) {
    O("ExportAllDeclaration", Z, Q);
  }, yh = function(Z, Q) {
    O("ExportDefaultDeclaration", Z, Q);
  }, mh = function(Z, Q) {
    O("ExportNamedDeclaration", Z, Q);
  }, uh = function(Z, Q) {
    O("ExportSpecifier", Z, Q);
  }, xh = function(Z, Q) {
    O("ForOfStatement", Z, Q);
  }, ch = function(Z, Q) {
    O("ImportDeclaration", Z, Q);
  }, lh = function(Z, Q) {
    O("ImportDefaultSpecifier", Z, Q);
  }, ih = function(Z, Q) {
    O("ImportNamespaceSpecifier", Z, Q);
  }, dh = function(Z, Q) {
    O("ImportSpecifier", Z, Q);
  }, ph = function(Z, Q) {
    O("ImportExpression", Z, Q);
  }, ah = function(Z, Q) {
    O("MetaProperty", Z, Q);
  }, rh = function(Z, Q) {
    O("ClassMethod", Z, Q);
  }, nh = function(Z, Q) {
    O("ObjectPattern", Z, Q);
  }, sh = function(Z, Q) {
    O("SpreadElement", Z, Q);
  }, th = function(Z, Q) {
    O("Super", Z, Q);
  }, oh = function(Z, Q) {
    O("TaggedTemplateExpression", Z, Q);
  }, eh = function(Z, Q) {
    O("TemplateElement", Z, Q);
  }, Z_ = function(Z, Q) {
    O("TemplateLiteral", Z, Q);
  }, Q_ = function(Z, Q) {
    O("YieldExpression", Z, Q);
  }, J_ = function(Z, Q) {
    O("AwaitExpression", Z, Q);
  }, X_ = function(Z, Q) {
    O("Import", Z, Q);
  }, z_ = function(Z, Q) {
    O("BigIntLiteral", Z, Q);
  }, H_ = function(Z, Q) {
    O("ExportNamespaceSpecifier", Z, Q);
  }, Y_ = function(Z, Q) {
    O("OptionalMemberExpression", Z, Q);
  }, W_ = function(Z, Q) {
    O("OptionalCallExpression", Z, Q);
  }, G_ = function(Z, Q) {
    O("ClassProperty", Z, Q);
  }, U_ = function(Z, Q) {
    O("ClassAccessorProperty", Z, Q);
  }, V_ = function(Z, Q) {
    O("ClassPrivateProperty", Z, Q);
  }, K_ = function(Z, Q) {
    O("ClassPrivateMethod", Z, Q);
  }, M_ = function(Z, Q) {
    O("PrivateName", Z, Q);
  }, F_ = function(Z, Q) {
    O("StaticBlock", Z, Q);
  }, R_ = function(Z, Q) {
    O("AnyTypeAnnotation", Z, Q);
  }, j_ = function(Z, Q) {
    O("ArrayTypeAnnotation", Z, Q);
  }, O_ = function(Z, Q) {
    O("BooleanTypeAnnotation", Z, Q);
  }, B_ = function(Z, Q) {
    O("BooleanLiteralTypeAnnotation", Z, Q);
  }, q_ = function(Z, Q) {
    O("NullLiteralTypeAnnotation", Z, Q);
  }, $_ = function(Z, Q) {
    O("ClassImplements", Z, Q);
  }, D_ = function(Z, Q) {
    O("DeclareClass", Z, Q);
  }, I_ = function(Z, Q) {
    O("DeclareFunction", Z, Q);
  }, C_ = function(Z, Q) {
    O("DeclareInterface", Z, Q);
  }, A_ = function(Z, Q) {
    O("DeclareModule", Z, Q);
  }, L_ = function(Z, Q) {
    O("DeclareModuleExports", Z, Q);
  }, N_ = function(Z, Q) {
    O("DeclareTypeAlias", Z, Q);
  }, P_ = function(Z, Q) {
    O("DeclareOpaqueType", Z, Q);
  }, S_ = function(Z, Q) {
    O("DeclareVariable", Z, Q);
  }, w_ = function(Z, Q) {
    O("DeclareExportDeclaration", Z, Q);
  }, T_ = function(Z, Q) {
    O("DeclareExportAllDeclaration", Z, Q);
  }, v_ = function(Z, Q) {
    O("DeclaredPredicate", Z, Q);
  }, b_ = function(Z, Q) {
    O("ExistsTypeAnnotation", Z, Q);
  }, E_ = function(Z, Q) {
    O("FunctionTypeAnnotation", Z, Q);
  }, g_ = function(Z, Q) {
    O("FunctionTypeParam", Z, Q);
  }, h_ = function(Z, Q) {
    O("GenericTypeAnnotation", Z, Q);
  }, __ = function(Z, Q) {
    O("InferredPredicate", Z, Q);
  }, k_ = function(Z, Q) {
    O("InterfaceExtends", Z, Q);
  }, f_ = function(Z, Q) {
    O("InterfaceDeclaration", Z, Q);
  }, y_ = function(Z, Q) {
    O("InterfaceTypeAnnotation", Z, Q);
  }, m_ = function(Z, Q) {
    O("IntersectionTypeAnnotation", Z, Q);
  }, u_ = function(Z, Q) {
    O("MixedTypeAnnotation", Z, Q);
  }, x_ = function(Z, Q) {
    O("EmptyTypeAnnotation", Z, Q);
  }, c_ = function(Z, Q) {
    O("NullableTypeAnnotation", Z, Q);
  }, l_ = function(Z, Q) {
    O("NumberLiteralTypeAnnotation", Z, Q);
  }, i_ = function(Z, Q) {
    O("NumberTypeAnnotation", Z, Q);
  }, d_ = function(Z, Q) {
    O("ObjectTypeAnnotation", Z, Q);
  }, p_ = function(Z, Q) {
    O("ObjectTypeInternalSlot", Z, Q);
  }, a_ = function(Z, Q) {
    O("ObjectTypeCallProperty", Z, Q);
  }, r_ = function(Z, Q) {
    O("ObjectTypeIndexer", Z, Q);
  }, n_ = function(Z, Q) {
    O("ObjectTypeProperty", Z, Q);
  }, s_ = function(Z, Q) {
    O("ObjectTypeSpreadProperty", Z, Q);
  }, t_ = function(Z, Q) {
    O("OpaqueType", Z, Q);
  }, o_ = function(Z, Q) {
    O("QualifiedTypeIdentifier", Z, Q);
  }, e_ = function(Z, Q) {
    O("StringLiteralTypeAnnotation", Z, Q);
  }, Zk = function(Z, Q) {
    O("StringTypeAnnotation", Z, Q);
  }, Qk = function(Z, Q) {
    O("SymbolTypeAnnotation", Z, Q);
  }, Jk = function(Z, Q) {
    O("ThisTypeAnnotation", Z, Q);
  }, Xk = function(Z, Q) {
    O("TupleTypeAnnotation", Z, Q);
  }, zk = function(Z, Q) {
    O("TypeofTypeAnnotation", Z, Q);
  }, Hk = function(Z, Q) {
    O("TypeAlias", Z, Q);
  }, Yk = function(Z, Q) {
    O("TypeAnnotation", Z, Q);
  }, Wk = function(Z, Q) {
    O("TypeCastExpression", Z, Q);
  }, Gk = function(Z, Q) {
    O("TypeParameter", Z, Q);
  }, Uk = function(Z, Q) {
    O("TypeParameterDeclaration", Z, Q);
  }, Vk = function(Z, Q) {
    O("TypeParameterInstantiation", Z, Q);
  }, Kk = function(Z, Q) {
    O("UnionTypeAnnotation", Z, Q);
  }, Mk = function(Z, Q) {
    O("Variance", Z, Q);
  }, Fk = function(Z, Q) {
    O("VoidTypeAnnotation", Z, Q);
  }, Rk = function(Z, Q) {
    O("EnumDeclaration", Z, Q);
  }, jk = function(Z, Q) {
    O("EnumBooleanBody", Z, Q);
  }, Ok = function(Z, Q) {
    O("EnumNumberBody", Z, Q);
  }, Bk = function(Z, Q) {
    O("EnumStringBody", Z, Q);
  }, qk = function(Z, Q) {
    O("EnumSymbolBody", Z, Q);
  }, $k = function(Z, Q) {
    O("EnumBooleanMember", Z, Q);
  }, Dk = function(Z, Q) {
    O("EnumNumberMember", Z, Q);
  }, Ik = function(Z, Q) {
    O("EnumStringMember", Z, Q);
  }, Ck = function(Z, Q) {
    O("EnumDefaultedMember", Z, Q);
  }, Ak = function(Z, Q) {
    O("IndexedAccessType", Z, Q);
  }, Lk = function(Z, Q) {
    O("OptionalIndexedAccessType", Z, Q);
  }, Nk = function(Z, Q) {
    O("JSXAttribute", Z, Q);
  }, Pk = function(Z, Q) {
    O("JSXClosingElement", Z, Q);
  }, Sk = function(Z, Q) {
    O("JSXElement", Z, Q);
  }, wk = function(Z, Q) {
    O("JSXEmptyExpression", Z, Q);
  }, Tk = function(Z, Q) {
    O("JSXExpressionContainer", Z, Q);
  }, vk = function(Z, Q) {
    O("JSXSpreadChild", Z, Q);
  }, bk = function(Z, Q) {
    O("JSXIdentifier", Z, Q);
  }, Ek = function(Z, Q) {
    O("JSXMemberExpression", Z, Q);
  }, gk = function(Z, Q) {
    O("JSXNamespacedName", Z, Q);
  }, hk = function(Z, Q) {
    O("JSXOpeningElement", Z, Q);
  }, _k = function(Z, Q) {
    O("JSXSpreadAttribute", Z, Q);
  }, kk = function(Z, Q) {
    O("JSXText", Z, Q);
  }, fk = function(Z, Q) {
    O("JSXFragment", Z, Q);
  }, yk = function(Z, Q) {
    O("JSXOpeningFragment", Z, Q);
  }, mk = function(Z, Q) {
    O("JSXClosingFragment", Z, Q);
  }, uk = function(Z, Q) {
    O("Noop", Z, Q);
  }, xk = function(Z, Q) {
    O("Placeholder", Z, Q);
  }, ck = function(Z, Q) {
    O("V8IntrinsicIdentifier", Z, Q);
  }, lk = function(Z, Q) {
    O("ArgumentPlaceholder", Z, Q);
  }, ik = function(Z, Q) {
    O("BindExpression", Z, Q);
  }, dk = function(Z, Q) {
    O("ImportAttribute", Z, Q);
  }, pk = function(Z, Q) {
    O("Decorator", Z, Q);
  }, ak = function(Z, Q) {
    O("DoExpression", Z, Q);
  }, rk = function(Z, Q) {
    O("ExportDefaultSpecifier", Z, Q);
  }, nk = function(Z, Q) {
    O("RecordExpression", Z, Q);
  }, sk = function(Z, Q) {
    O("TupleExpression", Z, Q);
  }, tk = function(Z, Q) {
    O("DecimalLiteral", Z, Q);
  }, ok = function(Z, Q) {
    O("ModuleExpression", Z, Q);
  }, ek = function(Z, Q) {
    O("TopicReference", Z, Q);
  }, Zf = function(Z, Q) {
    O("PipelineTopicExpression", Z, Q);
  }, Qf = function(Z, Q) {
    O("PipelineBareFunction", Z, Q);
  }, Jf = function(Z, Q) {
    O("PipelinePrimaryTopicReference", Z, Q);
  }, Xf = function(Z, Q) {
    O("TSParameterProperty", Z, Q);
  }, zf = function(Z, Q) {
    O("TSDeclareFunction", Z, Q);
  }, Hf = function(Z, Q) {
    O("TSDeclareMethod", Z, Q);
  }, Yf = function(Z, Q) {
    O("TSQualifiedName", Z, Q);
  }, Wf = function(Z, Q) {
    O("TSCallSignatureDeclaration", Z, Q);
  }, Gf = function(Z, Q) {
    O("TSConstructSignatureDeclaration", Z, Q);
  }, Uf = function(Z, Q) {
    O("TSPropertySignature", Z, Q);
  }, Vf = function(Z, Q) {
    O("TSMethodSignature", Z, Q);
  }, Kf = function(Z, Q) {
    O("TSIndexSignature", Z, Q);
  }, Mf = function(Z, Q) {
    O("TSAnyKeyword", Z, Q);
  }, Ff = function(Z, Q) {
    O("TSBooleanKeyword", Z, Q);
  }, Rf = function(Z, Q) {
    O("TSBigIntKeyword", Z, Q);
  }, jf = function(Z, Q) {
    O("TSIntrinsicKeyword", Z, Q);
  }, Of = function(Z, Q) {
    O("TSNeverKeyword", Z, Q);
  }, Bf = function(Z, Q) {
    O("TSNullKeyword", Z, Q);
  }, qf = function(Z, Q) {
    O("TSNumberKeyword", Z, Q);
  }, $f = function(Z, Q) {
    O("TSObjectKeyword", Z, Q);
  }, Df = function(Z, Q) {
    O("TSStringKeyword", Z, Q);
  }, If = function(Z, Q) {
    O("TSSymbolKeyword", Z, Q);
  }, Cf = function(Z, Q) {
    O("TSUndefinedKeyword", Z, Q);
  }, Af = function(Z, Q) {
    O("TSUnknownKeyword", Z, Q);
  }, Lf = function(Z, Q) {
    O("TSVoidKeyword", Z, Q);
  }, Nf = function(Z, Q) {
    O("TSThisType", Z, Q);
  }, Pf = function(Z, Q) {
    O("TSFunctionType", Z, Q);
  }, Sf = function(Z, Q) {
    O("TSConstructorType", Z, Q);
  }, wf = function(Z, Q) {
    O("TSTypeReference", Z, Q);
  }, Tf = function(Z, Q) {
    O("TSTypePredicate", Z, Q);
  }, vf = function(Z, Q) {
    O("TSTypeQuery", Z, Q);
  }, bf = function(Z, Q) {
    O("TSTypeLiteral", Z, Q);
  }, Ef = function(Z, Q) {
    O("TSArrayType", Z, Q);
  }, gf = function(Z, Q) {
    O("TSTupleType", Z, Q);
  }, hf = function(Z, Q) {
    O("TSOptionalType", Z, Q);
  }, _f = function(Z, Q) {
    O("TSRestType", Z, Q);
  }, kf = function(Z, Q) {
    O("TSNamedTupleMember", Z, Q);
  }, ff = function(Z, Q) {
    O("TSUnionType", Z, Q);
  }, yf = function(Z, Q) {
    O("TSIntersectionType", Z, Q);
  }, mf = function(Z, Q) {
    O("TSConditionalType", Z, Q);
  }, uf = function(Z, Q) {
    O("TSInferType", Z, Q);
  }, xf = function(Z, Q) {
    O("TSParenthesizedType", Z, Q);
  }, cf = function(Z, Q) {
    O("TSTypeOperator", Z, Q);
  }, lf = function(Z, Q) {
    O("TSIndexedAccessType", Z, Q);
  }, df = function(Z, Q) {
    O("TSMappedType", Z, Q);
  }, pf = function(Z, Q) {
    O("TSLiteralType", Z, Q);
  }, af = function(Z, Q) {
    O("TSExpressionWithTypeArguments", Z, Q);
  }, rf = function(Z, Q) {
    O("TSInterfaceDeclaration", Z, Q);
  }, nf = function(Z, Q) {
    O("TSInterfaceBody", Z, Q);
  }, sf = function(Z, Q) {
    O("TSTypeAliasDeclaration", Z, Q);
  }, tf = function(Z, Q) {
    O("TSInstantiationExpression", Z, Q);
  }, of = function(Z, Q) {
    O("TSAsExpression", Z, Q);
  }, ef = function(Z, Q) {
    O("TSSatisfiesExpression", Z, Q);
  }, Zy = function(Z, Q) {
    O("TSTypeAssertion", Z, Q);
  }, Qy = function(Z, Q) {
    O("TSEnumDeclaration", Z, Q);
  }, Jy = function(Z, Q) {
    O("TSEnumMember", Z, Q);
  }, Xy = function(Z, Q) {
    O("TSModuleDeclaration", Z, Q);
  }, zy = function(Z, Q) {
    O("TSModuleBlock", Z, Q);
  }, Hy = function(Z, Q) {
    O("TSImportType", Z, Q);
  }, Yy = function(Z, Q) {
    O("TSImportEqualsDeclaration", Z, Q);
  }, Wy = function(Z, Q) {
    O("TSExternalModuleReference", Z, Q);
  }, Gy = function(Z, Q) {
    O("TSNonNullExpression", Z, Q);
  }, Uy = function(Z, Q) {
    O("TSExportAssignment", Z, Q);
  }, Vy = function(Z, Q) {
    O("TSNamespaceExportDeclaration", Z, Q);
  }, Ky = function(Z, Q) {
    O("TSTypeAnnotation", Z, Q);
  }, My = function(Z, Q) {
    O("TSTypeParameterInstantiation", Z, Q);
  }, Fy = function(Z, Q) {
    O("TSTypeParameterDeclaration", Z, Q);
  }, Ry = function(Z, Q) {
    O("TSTypeParameter", Z, Q);
  }, jy = function(Z, Q) {
    O("Standardized", Z, Q);
  }, Oy = function(Z, Q) {
    O("Expression", Z, Q);
  }, By = function(Z, Q) {
    O("Binary", Z, Q);
  }, qy = function(Z, Q) {
    O("Scopable", Z, Q);
  }, $y = function(Z, Q) {
    O("BlockParent", Z, Q);
  }, Dy = function(Z, Q) {
    O("Block", Z, Q);
  }, Iy = function(Z, Q) {
    O("Statement", Z, Q);
  }, Cy = function(Z, Q) {
    O("Terminatorless", Z, Q);
  }, Ay = function(Z, Q) {
    O("CompletionStatement", Z, Q);
  }, Ly = function(Z, Q) {
    O("Conditional", Z, Q);
  }, Ny = function(Z, Q) {
    O("Loop", Z, Q);
  }, Py = function(Z, Q) {
    O("While", Z, Q);
  }, Sy = function(Z, Q) {
    O("ExpressionWrapper", Z, Q);
  }, wy = function(Z, Q) {
    O("For", Z, Q);
  }, Ty = function(Z, Q) {
    O("ForXStatement", Z, Q);
  }, vy = function(Z, Q) {
    O("Function", Z, Q);
  }, by = function(Z, Q) {
    O("FunctionParent", Z, Q);
  }, Ey = function(Z, Q) {
    O("Pureish", Z, Q);
  }, gy = function(Z, Q) {
    O("Declaration", Z, Q);
  }, hy = function(Z, Q) {
    O("PatternLike", Z, Q);
  }, _y = function(Z, Q) {
    O("LVal", Z, Q);
  }, ky = function(Z, Q) {
    O("TSEntityName", Z, Q);
  }, fy = function(Z, Q) {
    O("Literal", Z, Q);
  }, yy = function(Z, Q) {
    O("Immutable", Z, Q);
  }, my = function(Z, Q) {
    O("UserWhitespacable", Z, Q);
  }, uy = function(Z, Q) {
    O("Method", Z, Q);
  }, xy = function(Z, Q) {
    O("ObjectMember", Z, Q);
  }, cy = function(Z, Q) {
    O("Property", Z, Q);
  }, ly = function(Z, Q) {
    O("UnaryLike", Z, Q);
  }, iy = function(Z, Q) {
    O("Pattern", Z, Q);
  }, dy = function(Z, Q) {
    O("Class", Z, Q);
  }, py = function(Z, Q) {
    O("ImportOrExportDeclaration", Z, Q);
  }, ay = function(Z, Q) {
    O("ExportDeclaration", Z, Q);
  }, ry = function(Z, Q) {
    O("ModuleSpecifier", Z, Q);
  }, ny = function(Z, Q) {
    O("Accessor", Z, Q);
  }, sy = function(Z, Q) {
    O("Private", Z, Q);
  }, ty = function(Z, Q) {
    O("Flow", Z, Q);
  }, oy = function(Z, Q) {
    O("FlowType", Z, Q);
  }, ey = function(Z, Q) {
    O("FlowBaseAnnotation", Z, Q);
  }, Zm = function(Z, Q) {
    O("FlowDeclaration", Z, Q);
  }, Qm = function(Z, Q) {
    O("FlowPredicate", Z, Q);
  }, Jm = function(Z, Q) {
    O("EnumBody", Z, Q);
  }, Xm = function(Z, Q) {
    O("EnumMember", Z, Q);
  }, zm = function(Z, Q) {
    O("JSX", Z, Q);
  }, Hm = function(Z, Q) {
    O("Miscellaneous", Z, Q);
  }, Ym = function(Z, Q) {
    O("TypeScript", Z, Q);
  }, Wm = function(Z, Q) {
    O("TSTypeElement", Z, Q);
  }, Gm = function(Z, Q) {
    O("TSType", Z, Q);
  }, Um = function(Z, Q) {
    O("TSBaseType", Z, Q);
  }, Vm = function(Z, Q) {
    q8.default("assertNumberLiteral", "assertNumericLiteral"), O("NumberLiteral", Z, Q);
  }, Km = function(Z, Q) {
    q8.default("assertRegexLiteral", "assertRegExpLiteral"), O("RegexLiteral", Z, Q);
  }, Mm = function(Z, Q) {
    q8.default("assertRestProperty", "assertRestElement"), O("RestProperty", Z, Q);
  }, Fm = function(Z, Q) {
    q8.default("assertSpreadProperty", "assertSpreadElement"), O("SpreadProperty", Z, Q);
  }, Rm = function(Z, Q) {
    q8.default("assertModuleDeclaration", "assertImportOrExportDeclaration"), O("ModuleDeclaration", Z, Q);
  };
  Object.defineProperty(u9, "__esModule", {
    value: !0
  });
  u9.assertAccessor = ny;
  u9.assertAnyTypeAnnotation = R_;
  u9.assertArgumentPlaceholder = lk;
  u9.assertArrayExpression = hg;
  u9.assertArrayPattern = Eh;
  u9.assertArrayTypeAnnotation = j_;
  u9.assertArrowFunctionExpression = gh;
  u9.assertAssignmentExpression = _g;
  u9.assertAssignmentPattern = bh;
  u9.assertAwaitExpression = J_;
  u9.assertBigIntLiteral = z_;
  u9.assertBinary = By;
  u9.assertBinaryExpression = kg;
  u9.assertBindExpression = ik;
  u9.assertBlock = Dy;
  u9.assertBlockParent = $y;
  u9.assertBlockStatement = ug;
  u9.assertBooleanLiteral = Wh;
  u9.assertBooleanLiteralTypeAnnotation = B_;
  u9.assertBooleanTypeAnnotation = O_;
  u9.assertBreakStatement = xg;
  u9.assertCallExpression = cg;
  u9.assertCatchClause = lg;
  u9.assertClass = dy;
  u9.assertClassAccessorProperty = U_;
  u9.assertClassBody = hh;
  u9.assertClassDeclaration = kh;
  u9.assertClassExpression = _h;
  u9.assertClassImplements = $_;
  u9.assertClassMethod = rh;
  u9.assertClassPrivateMethod = K_;
  u9.assertClassPrivateProperty = V_;
  u9.assertClassProperty = G_;
  u9.assertCompletionStatement = Ay;
  u9.assertConditional = Ly;
  u9.assertConditionalExpression = ig;
  u9.assertContinueStatement = dg;
  u9.assertDebuggerStatement = pg;
  u9.assertDecimalLiteral = tk;
  u9.assertDeclaration = gy;
  u9.assertDeclareClass = D_;
  u9.assertDeclareExportAllDeclaration = T_;
  u9.assertDeclareExportDeclaration = w_;
  u9.assertDeclareFunction = I_;
  u9.assertDeclareInterface = C_;
  u9.assertDeclareModule = A_;
  u9.assertDeclareModuleExports = L_;
  u9.assertDeclareOpaqueType = P_;
  u9.assertDeclareTypeAlias = N_;
  u9.assertDeclareVariable = S_;
  u9.assertDeclaredPredicate = v_;
  u9.assertDecorator = pk;
  u9.assertDirective = yg;
  u9.assertDirectiveLiteral = mg;
  u9.assertDoExpression = ak;
  u9.assertDoWhileStatement = ag;
  u9.assertEmptyStatement = rg;
  u9.assertEmptyTypeAnnotation = x_;
  u9.assertEnumBody = Jm;
  u9.assertEnumBooleanBody = jk;
  u9.assertEnumBooleanMember = $k;
  u9.assertEnumDeclaration = Rk;
  u9.assertEnumDefaultedMember = Ck;
  u9.assertEnumMember = Xm;
  u9.assertEnumNumberBody = Ok;
  u9.assertEnumNumberMember = Dk;
  u9.assertEnumStringBody = Bk;
  u9.assertEnumStringMember = Ik;
  u9.assertEnumSymbolBody = qk;
  u9.assertExistsTypeAnnotation = b_;
  u9.assertExportAllDeclaration = fh;
  u9.assertExportDeclaration = ay;
  u9.assertExportDefaultDeclaration = yh;
  u9.assertExportDefaultSpecifier = rk;
  u9.assertExportNamedDeclaration = mh;
  u9.assertExportNamespaceSpecifier = H_;
  u9.assertExportSpecifier = uh;
  u9.assertExpression = Oy;
  u9.assertExpressionStatement = ng;
  u9.assertExpressionWrapper = Sy;
  u9.assertFile = sg;
  u9.assertFlow = ty;
  u9.assertFlowBaseAnnotation = ey;
  u9.assertFlowDeclaration = Zm;
  u9.assertFlowPredicate = Qm;
  u9.assertFlowType = oy;
  u9.assertFor = wy;
  u9.assertForInStatement = tg;
  u9.assertForOfStatement = xh;
  u9.assertForStatement = og;
  u9.assertForXStatement = Ty;
  u9.assertFunction = vy;
  u9.assertFunctionDeclaration = eg;
  u9.assertFunctionExpression = Zh;
  u9.assertFunctionParent = by;
  u9.assertFunctionTypeAnnotation = E_;
  u9.assertFunctionTypeParam = g_;
  u9.assertGenericTypeAnnotation = h_;
  u9.assertIdentifier = Qh;
  u9.assertIfStatement = Jh;
  u9.assertImmutable = yy;
  u9.assertImport = X_;
  u9.assertImportAttribute = dk;
  u9.assertImportDeclaration = ch;
  u9.assertImportDefaultSpecifier = lh;
  u9.assertImportExpression = ph;
  u9.assertImportNamespaceSpecifier = ih;
  u9.assertImportOrExportDeclaration = py;
  u9.assertImportSpecifier = dh;
  u9.assertIndexedAccessType = Ak;
  u9.assertInferredPredicate = __;
  u9.assertInterfaceDeclaration = f_;
  u9.assertInterfaceExtends = k_;
  u9.assertInterfaceTypeAnnotation = y_;
  u9.assertInterpreterDirective = fg;
  u9.assertIntersectionTypeAnnotation = m_;
  u9.assertJSX = zm;
  u9.assertJSXAttribute = Nk;
  u9.assertJSXClosingElement = Pk;
  u9.assertJSXClosingFragment = mk;
  u9.assertJSXElement = Sk;
  u9.assertJSXEmptyExpression = wk;
  u9.assertJSXExpressionContainer = Tk;
  u9.assertJSXFragment = fk;
  u9.assertJSXIdentifier = bk;
  u9.assertJSXMemberExpression = Ek;
  u9.assertJSXNamespacedName = gk;
  u9.assertJSXOpeningElement = hk;
  u9.assertJSXOpeningFragment = yk;
  u9.assertJSXSpreadAttribute = _k;
  u9.assertJSXSpreadChild = vk;
  u9.assertJSXText = kk;
  u9.assertLVal = _y;
  u9.assertLabeledStatement = Xh;
  u9.assertLiteral = fy;
  u9.assertLogicalExpression = Uh;
  u9.assertLoop = Ny;
  u9.assertMemberExpression = Vh;
  u9.assertMetaProperty = ah;
  u9.assertMethod = uy;
  u9.assertMiscellaneous = Hm;
  u9.assertMixedTypeAnnotation = u_;
  u9.assertModuleDeclaration = Rm;
  u9.assertModuleExpression = ok;
  u9.assertModuleSpecifier = ry;
  u9.assertNewExpression = Kh;
  u9.assertNoop = uk;
  u9.assertNullLiteral = Yh;
  u9.assertNullLiteralTypeAnnotation = q_;
  u9.assertNullableTypeAnnotation = c_;
  u9.assertNumberLiteral = Vm;
  u9.assertNumberLiteralTypeAnnotation = l_;
  u9.assertNumberTypeAnnotation = i_;
  u9.assertNumericLiteral = Hh;
  u9.assertObjectExpression = Fh;
  u9.assertObjectMember = xy;
  u9.assertObjectMethod = Rh;
  u9.assertObjectPattern = nh;
  u9.assertObjectProperty = jh;
  u9.assertObjectTypeAnnotation = d_;
  u9.assertObjectTypeCallProperty = a_;
  u9.assertObjectTypeIndexer = r_;
  u9.assertObjectTypeInternalSlot = p_;
  u9.assertObjectTypeProperty = n_;
  u9.assertObjectTypeSpreadProperty = s_;
  u9.assertOpaqueType = t_;
  u9.assertOptionalCallExpression = W_;
  u9.assertOptionalIndexedAccessType = Lk;
  u9.assertOptionalMemberExpression = Y_;
  u9.assertParenthesizedExpression = $h;
  u9.assertPattern = iy;
  u9.assertPatternLike = hy;
  u9.assertPipelineBareFunction = Qf;
  u9.assertPipelinePrimaryTopicReference = Jf;
  u9.assertPipelineTopicExpression = Zf;
  u9.assertPlaceholder = xk;
  u9.assertPrivate = sy;
  u9.assertPrivateName = M_;
  u9.assertProgram = Mh;
  u9.assertProperty = cy;
  u9.assertPureish = Ey;
  u9.assertQualifiedTypeIdentifier = o_;
  u9.assertRecordExpression = nk;
  u9.assertRegExpLiteral = Gh;
  u9.assertRegexLiteral = Km;
  u9.assertRestElement = Oh;
  u9.assertRestProperty = Mm;
  u9.assertReturnStatement = Bh;
  u9.assertScopable = qy;
  u9.assertSequenceExpression = qh;
  u9.assertSpreadElement = sh;
  u9.assertSpreadProperty = Fm;
  u9.assertStandardized = jy;
  u9.assertStatement = Iy;
  u9.assertStaticBlock = F_;
  u9.assertStringLiteral = zh;
  u9.assertStringLiteralTypeAnnotation = e_;
  u9.assertStringTypeAnnotation = Zk;
  u9.assertSuper = th;
  u9.assertSwitchCase = Dh;
  u9.assertSwitchStatement = Ih;
  u9.assertSymbolTypeAnnotation = Qk;
  u9.assertTSAnyKeyword = Mf;
  u9.assertTSArrayType = Ef;
  u9.assertTSAsExpression = of;
  u9.assertTSBaseType = Um;
  u9.assertTSBigIntKeyword = Rf;
  u9.assertTSBooleanKeyword = Ff;
  u9.assertTSCallSignatureDeclaration = Wf;
  u9.assertTSConditionalType = mf;
  u9.assertTSConstructSignatureDeclaration = Gf;
  u9.assertTSConstructorType = Sf;
  u9.assertTSDeclareFunction = zf;
  u9.assertTSDeclareMethod = Hf;
  u9.assertTSEntityName = ky;
  u9.assertTSEnumDeclaration = Qy;
  u9.assertTSEnumMember = Jy;
  u9.assertTSExportAssignment = Uy;
  u9.assertTSExpressionWithTypeArguments = af;
  u9.assertTSExternalModuleReference = Wy;
  u9.assertTSFunctionType = Pf;
  u9.assertTSImportEqualsDeclaration = Yy;
  u9.assertTSImportType = Hy;
  u9.assertTSIndexSignature = Kf;
  u9.assertTSIndexedAccessType = lf;
  u9.assertTSInferType = uf;
  u9.assertTSInstantiationExpression = tf;
  u9.assertTSInterfaceBody = nf;
  u9.assertTSInterfaceDeclaration = rf;
  u9.assertTSIntersectionType = yf;
  u9.assertTSIntrinsicKeyword = jf;
  u9.assertTSLiteralType = pf;
  u9.assertTSMappedType = df;
  u9.assertTSMethodSignature = Vf;
  u9.assertTSModuleBlock = zy;
  u9.assertTSModuleDeclaration = Xy;
  u9.assertTSNamedTupleMember = kf;
  u9.assertTSNamespaceExportDeclaration = Vy;
  u9.assertTSNeverKeyword = Of;
  u9.assertTSNonNullExpression = Gy;
  u9.assertTSNullKeyword = Bf;
  u9.assertTSNumberKeyword = qf;
  u9.assertTSObjectKeyword = $f;
  u9.assertTSOptionalType = hf;
  u9.assertTSParameterProperty = Xf;
  u9.assertTSParenthesizedType = xf;
  u9.assertTSPropertySignature = Uf;
  u9.assertTSQualifiedName = Yf;
  u9.assertTSRestType = _f;
  u9.assertTSSatisfiesExpression = ef;
  u9.assertTSStringKeyword = Df;
  u9.assertTSSymbolKeyword = If;
  u9.assertTSThisType = Nf;
  u9.assertTSTupleType = gf;
  u9.assertTSType = Gm;
  u9.assertTSTypeAliasDeclaration = sf;
  u9.assertTSTypeAnnotation = Ky;
  u9.assertTSTypeAssertion = Zy;
  u9.assertTSTypeElement = Wm;
  u9.assertTSTypeLiteral = bf;
  u9.assertTSTypeOperator = cf;
  u9.assertTSTypeParameter = Ry;
  u9.assertTSTypeParameterDeclaration = Fy;
  u9.assertTSTypeParameterInstantiation = My;
  u9.assertTSTypePredicate = Tf;
  u9.assertTSTypeQuery = vf;
  u9.assertTSTypeReference = wf;
  u9.assertTSUndefinedKeyword = Cf;
  u9.assertTSUnionType = ff;
  u9.assertTSUnknownKeyword = Af;
  u9.assertTSVoidKeyword = Lf;
  u9.assertTaggedTemplateExpression = oh;
  u9.assertTemplateElement = eh;
  u9.assertTemplateLiteral = Z_;
  u9.assertTerminatorless = Cy;
  u9.assertThisExpression = Ch;
  u9.assertThisTypeAnnotation = Jk;
  u9.assertThrowStatement = Ah;
  u9.assertTopicReference = ek;
  u9.assertTryStatement = Lh;
  u9.assertTupleExpression = sk;
  u9.assertTupleTypeAnnotation = Xk;
  u9.assertTypeAlias = Hk;
  u9.assertTypeAnnotation = Yk;
  u9.assertTypeCastExpression = Wk;
  u9.assertTypeParameter = Gk;
  u9.assertTypeParameterDeclaration = Uk;
  u9.assertTypeParameterInstantiation = Vk;
  u9.assertTypeScript = Ym;
  u9.assertTypeofTypeAnnotation = zk;
  u9.assertUnaryExpression = Nh;
  u9.assertUnaryLike = ly;
  u9.assertUnionTypeAnnotation = Kk;
  u9.assertUpdateExpression = Ph;
  u9.assertUserWhitespacable = my;
  u9.assertV8IntrinsicIdentifier = ck;
  u9.assertVariableDeclaration = Sh;
  u9.assertVariableDeclarator = wh;
  u9.assertVariance = Mk;
  u9.assertVoidTypeAnnotation = Fk;
  u9.assertWhile = Py;
  u9.assertWhileStatement = Th;
  u9.assertWithStatement = vh;
  u9.assertYieldExpression = Q_;
  var gg = g5(), q8 = V8();
});

// node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var i9 = P((c9) => {
  var ni = function(Z) {
    switch (Z) {
      case "string":
        return U1.stringTypeAnnotation();
      case "number":
        return U1.numberTypeAnnotation();
      case "undefined":
        return U1.voidTypeAnnotation();
      case "boolean":
        return U1.booleanTypeAnnotation();
      case "function":
        return U1.genericTypeAnnotation(U1.identifier("Function"));
      case "object":
        return U1.genericTypeAnnotation(U1.identifier("Object"));
      case "symbol":
        return U1.genericTypeAnnotation(U1.identifier("Symbol"));
      case "bigint":
        return U1.anyTypeAnnotation();
    }
    throw new Error("Invalid typeof value: " + Z);
  };
  Object.defineProperty(c9, "__esModule", {
    value: !0
  });
  c9.default = void 0;
  var U1 = r0(), F10 = c9.default = ni;
});

// node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var KZ = P((a9) => {
  var d9 = function(Z) {
    return $8.isIdentifier(Z) ? Z.name : `${Z.id.name}.${d9(Z.qualification)}`;
  }, p9 = function(Z) {
    const Q = Array.from(Z), J = new Map, X = new Map, z = new Set, Y = [];
    for (let W = 0;W < Q.length; W++) {
      const U = Q[W];
      if (!U)
        continue;
      if (Y.indexOf(U) >= 0)
        continue;
      if ($8.isAnyTypeAnnotation(U))
        return [U];
      if ($8.isFlowBaseAnnotation(U)) {
        X.set(U.type, U);
        continue;
      }
      if ($8.isUnionTypeAnnotation(U)) {
        if (!z.has(U.types))
          Q.push(...U.types), z.add(U.types);
        continue;
      }
      if ($8.isGenericTypeAnnotation(U)) {
        const V = d9(U.id);
        if (J.has(V)) {
          let M = J.get(V);
          if (M.typeParameters) {
            if (U.typeParameters)
              M.typeParameters.params.push(...U.typeParameters.params), M.typeParameters.params = p9(M.typeParameters.params);
          } else
            M = U.typeParameters;
        } else
          J.set(V, U);
        continue;
      }
      Y.push(U);
    }
    for (let [, W] of X)
      Y.push(W);
    for (let [, W] of J)
      Y.push(W);
    return Y;
  };
  Object.defineProperty(a9, "__esModule", {
    value: !0
  });
  a9.default = p9;
  var $8 = S0();
});

// node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var n9 = P((r9) => {
  var ei = function(Z) {
    const Q = oi.default(Z);
    if (Q.length === 1)
      return Q[0];
    else
      return ti.unionTypeAnnotation(Q);
  };
  Object.defineProperty(r9, "__esModule", {
    value: !0
  });
  r9.default = ei;
  var ti = r0(), oi = KZ();
});

// node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var e9 = P((o9) => {
  var s9 = function(Z) {
    return D8.isIdentifier(Z) ? Z.name : `${Z.right.name}.${s9(Z.left)}`;
  }, t9 = function(Z) {
    const Q = Array.from(Z), J = new Map, X = new Map, z = new Set, Y = [];
    for (let W = 0;W < Q.length; W++) {
      const U = Q[W];
      if (!U)
        continue;
      if (Y.indexOf(U) >= 0)
        continue;
      if (D8.isTSAnyKeyword(U))
        return [U];
      if (D8.isTSBaseType(U)) {
        X.set(U.type, U);
        continue;
      }
      if (D8.isTSUnionType(U)) {
        if (!z.has(U.types))
          Q.push(...U.types), z.add(U.types);
        continue;
      }
      if (D8.isTSTypeReference(U) && U.typeParameters) {
        const V = s9(U.typeName);
        if (J.has(V)) {
          let M = J.get(V);
          if (M.typeParameters) {
            if (U.typeParameters)
              M.typeParameters.params.push(...U.typeParameters.params), M.typeParameters.params = t9(M.typeParameters.params);
          } else
            M = U.typeParameters;
        } else
          J.set(V, U);
        continue;
      }
      Y.push(U);
    }
    for (let [, W] of X)
      Y.push(W);
    for (let [, W] of J)
      Y.push(W);
    return Y;
  };
  Object.defineProperty(o9, "__esModule", {
    value: !0
  });
  o9.default = t9;
  var D8 = S0();
});

// node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var QH = P((ZH) => {
  var Hd = function(Z) {
    const Q = Z.map((X) => {
      return zd.isTSTypeAnnotation(X) ? X.typeAnnotation : X;
    }), J = Xd.default(Q);
    if (J.length === 1)
      return J[0];
    else
      return Jd.tsUnionType(J);
  };
  Object.defineProperty(ZH, "__esModule", {
    value: !0
  });
  ZH.default = Hd;
  var Jd = r0(), Xd = e9(), zd = S0();
});

// node_modules/@babel/types/lib/builders/generated/uppercase.js
var JH = P(($) => {
  Object.defineProperty($, "__esModule", {
    value: !0
  });
  Object.defineProperty($, "AnyTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.anyTypeAnnotation;
    }
  });
  Object.defineProperty($, "ArgumentPlaceholder", {
    enumerable: !0,
    get: function() {
      return D.argumentPlaceholder;
    }
  });
  Object.defineProperty($, "ArrayExpression", {
    enumerable: !0,
    get: function() {
      return D.arrayExpression;
    }
  });
  Object.defineProperty($, "ArrayPattern", {
    enumerable: !0,
    get: function() {
      return D.arrayPattern;
    }
  });
  Object.defineProperty($, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.arrayTypeAnnotation;
    }
  });
  Object.defineProperty($, "ArrowFunctionExpression", {
    enumerable: !0,
    get: function() {
      return D.arrowFunctionExpression;
    }
  });
  Object.defineProperty($, "AssignmentExpression", {
    enumerable: !0,
    get: function() {
      return D.assignmentExpression;
    }
  });
  Object.defineProperty($, "AssignmentPattern", {
    enumerable: !0,
    get: function() {
      return D.assignmentPattern;
    }
  });
  Object.defineProperty($, "AwaitExpression", {
    enumerable: !0,
    get: function() {
      return D.awaitExpression;
    }
  });
  Object.defineProperty($, "BigIntLiteral", {
    enumerable: !0,
    get: function() {
      return D.bigIntLiteral;
    }
  });
  Object.defineProperty($, "BinaryExpression", {
    enumerable: !0,
    get: function() {
      return D.binaryExpression;
    }
  });
  Object.defineProperty($, "BindExpression", {
    enumerable: !0,
    get: function() {
      return D.bindExpression;
    }
  });
  Object.defineProperty($, "BlockStatement", {
    enumerable: !0,
    get: function() {
      return D.blockStatement;
    }
  });
  Object.defineProperty($, "BooleanLiteral", {
    enumerable: !0,
    get: function() {
      return D.booleanLiteral;
    }
  });
  Object.defineProperty($, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.booleanLiteralTypeAnnotation;
    }
  });
  Object.defineProperty($, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.booleanTypeAnnotation;
    }
  });
  Object.defineProperty($, "BreakStatement", {
    enumerable: !0,
    get: function() {
      return D.breakStatement;
    }
  });
  Object.defineProperty($, "CallExpression", {
    enumerable: !0,
    get: function() {
      return D.callExpression;
    }
  });
  Object.defineProperty($, "CatchClause", {
    enumerable: !0,
    get: function() {
      return D.catchClause;
    }
  });
  Object.defineProperty($, "ClassAccessorProperty", {
    enumerable: !0,
    get: function() {
      return D.classAccessorProperty;
    }
  });
  Object.defineProperty($, "ClassBody", {
    enumerable: !0,
    get: function() {
      return D.classBody;
    }
  });
  Object.defineProperty($, "ClassDeclaration", {
    enumerable: !0,
    get: function() {
      return D.classDeclaration;
    }
  });
  Object.defineProperty($, "ClassExpression", {
    enumerable: !0,
    get: function() {
      return D.classExpression;
    }
  });
  Object.defineProperty($, "ClassImplements", {
    enumerable: !0,
    get: function() {
      return D.classImplements;
    }
  });
  Object.defineProperty($, "ClassMethod", {
    enumerable: !0,
    get: function() {
      return D.classMethod;
    }
  });
  Object.defineProperty($, "ClassPrivateMethod", {
    enumerable: !0,
    get: function() {
      return D.classPrivateMethod;
    }
  });
  Object.defineProperty($, "ClassPrivateProperty", {
    enumerable: !0,
    get: function() {
      return D.classPrivateProperty;
    }
  });
  Object.defineProperty($, "ClassProperty", {
    enumerable: !0,
    get: function() {
      return D.classProperty;
    }
  });
  Object.defineProperty($, "ConditionalExpression", {
    enumerable: !0,
    get: function() {
      return D.conditionalExpression;
    }
  });
  Object.defineProperty($, "ContinueStatement", {
    enumerable: !0,
    get: function() {
      return D.continueStatement;
    }
  });
  Object.defineProperty($, "DebuggerStatement", {
    enumerable: !0,
    get: function() {
      return D.debuggerStatement;
    }
  });
  Object.defineProperty($, "DecimalLiteral", {
    enumerable: !0,
    get: function() {
      return D.decimalLiteral;
    }
  });
  Object.defineProperty($, "DeclareClass", {
    enumerable: !0,
    get: function() {
      return D.declareClass;
    }
  });
  Object.defineProperty($, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: function() {
      return D.declareExportAllDeclaration;
    }
  });
  Object.defineProperty($, "DeclareExportDeclaration", {
    enumerable: !0,
    get: function() {
      return D.declareExportDeclaration;
    }
  });
  Object.defineProperty($, "DeclareFunction", {
    enumerable: !0,
    get: function() {
      return D.declareFunction;
    }
  });
  Object.defineProperty($, "DeclareInterface", {
    enumerable: !0,
    get: function() {
      return D.declareInterface;
    }
  });
  Object.defineProperty($, "DeclareModule", {
    enumerable: !0,
    get: function() {
      return D.declareModule;
    }
  });
  Object.defineProperty($, "DeclareModuleExports", {
    enumerable: !0,
    get: function() {
      return D.declareModuleExports;
    }
  });
  Object.defineProperty($, "DeclareOpaqueType", {
    enumerable: !0,
    get: function() {
      return D.declareOpaqueType;
    }
  });
  Object.defineProperty($, "DeclareTypeAlias", {
    enumerable: !0,
    get: function() {
      return D.declareTypeAlias;
    }
  });
  Object.defineProperty($, "DeclareVariable", {
    enumerable: !0,
    get: function() {
      return D.declareVariable;
    }
  });
  Object.defineProperty($, "DeclaredPredicate", {
    enumerable: !0,
    get: function() {
      return D.declaredPredicate;
    }
  });
  Object.defineProperty($, "Decorator", {
    enumerable: !0,
    get: function() {
      return D.decorator;
    }
  });
  Object.defineProperty($, "Directive", {
    enumerable: !0,
    get: function() {
      return D.directive;
    }
  });
  Object.defineProperty($, "DirectiveLiteral", {
    enumerable: !0,
    get: function() {
      return D.directiveLiteral;
    }
  });
  Object.defineProperty($, "DoExpression", {
    enumerable: !0,
    get: function() {
      return D.doExpression;
    }
  });
  Object.defineProperty($, "DoWhileStatement", {
    enumerable: !0,
    get: function() {
      return D.doWhileStatement;
    }
  });
  Object.defineProperty($, "EmptyStatement", {
    enumerable: !0,
    get: function() {
      return D.emptyStatement;
    }
  });
  Object.defineProperty($, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.emptyTypeAnnotation;
    }
  });
  Object.defineProperty($, "EnumBooleanBody", {
    enumerable: !0,
    get: function() {
      return D.enumBooleanBody;
    }
  });
  Object.defineProperty($, "EnumBooleanMember", {
    enumerable: !0,
    get: function() {
      return D.enumBooleanMember;
    }
  });
  Object.defineProperty($, "EnumDeclaration", {
    enumerable: !0,
    get: function() {
      return D.enumDeclaration;
    }
  });
  Object.defineProperty($, "EnumDefaultedMember", {
    enumerable: !0,
    get: function() {
      return D.enumDefaultedMember;
    }
  });
  Object.defineProperty($, "EnumNumberBody", {
    enumerable: !0,
    get: function() {
      return D.enumNumberBody;
    }
  });
  Object.defineProperty($, "EnumNumberMember", {
    enumerable: !0,
    get: function() {
      return D.enumNumberMember;
    }
  });
  Object.defineProperty($, "EnumStringBody", {
    enumerable: !0,
    get: function() {
      return D.enumStringBody;
    }
  });
  Object.defineProperty($, "EnumStringMember", {
    enumerable: !0,
    get: function() {
      return D.enumStringMember;
    }
  });
  Object.defineProperty($, "EnumSymbolBody", {
    enumerable: !0,
    get: function() {
      return D.enumSymbolBody;
    }
  });
  Object.defineProperty($, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.existsTypeAnnotation;
    }
  });
  Object.defineProperty($, "ExportAllDeclaration", {
    enumerable: !0,
    get: function() {
      return D.exportAllDeclaration;
    }
  });
  Object.defineProperty($, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: function() {
      return D.exportDefaultDeclaration;
    }
  });
  Object.defineProperty($, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: function() {
      return D.exportDefaultSpecifier;
    }
  });
  Object.defineProperty($, "ExportNamedDeclaration", {
    enumerable: !0,
    get: function() {
      return D.exportNamedDeclaration;
    }
  });
  Object.defineProperty($, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: function() {
      return D.exportNamespaceSpecifier;
    }
  });
  Object.defineProperty($, "ExportSpecifier", {
    enumerable: !0,
    get: function() {
      return D.exportSpecifier;
    }
  });
  Object.defineProperty($, "ExpressionStatement", {
    enumerable: !0,
    get: function() {
      return D.expressionStatement;
    }
  });
  Object.defineProperty($, "File", {
    enumerable: !0,
    get: function() {
      return D.file;
    }
  });
  Object.defineProperty($, "ForInStatement", {
    enumerable: !0,
    get: function() {
      return D.forInStatement;
    }
  });
  Object.defineProperty($, "ForOfStatement", {
    enumerable: !0,
    get: function() {
      return D.forOfStatement;
    }
  });
  Object.defineProperty($, "ForStatement", {
    enumerable: !0,
    get: function() {
      return D.forStatement;
    }
  });
  Object.defineProperty($, "FunctionDeclaration", {
    enumerable: !0,
    get: function() {
      return D.functionDeclaration;
    }
  });
  Object.defineProperty($, "FunctionExpression", {
    enumerable: !0,
    get: function() {
      return D.functionExpression;
    }
  });
  Object.defineProperty($, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.functionTypeAnnotation;
    }
  });
  Object.defineProperty($, "FunctionTypeParam", {
    enumerable: !0,
    get: function() {
      return D.functionTypeParam;
    }
  });
  Object.defineProperty($, "GenericTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.genericTypeAnnotation;
    }
  });
  Object.defineProperty($, "Identifier", {
    enumerable: !0,
    get: function() {
      return D.identifier;
    }
  });
  Object.defineProperty($, "IfStatement", {
    enumerable: !0,
    get: function() {
      return D.ifStatement;
    }
  });
  Object.defineProperty($, "Import", {
    enumerable: !0,
    get: function() {
      return D.import;
    }
  });
  Object.defineProperty($, "ImportAttribute", {
    enumerable: !0,
    get: function() {
      return D.importAttribute;
    }
  });
  Object.defineProperty($, "ImportDeclaration", {
    enumerable: !0,
    get: function() {
      return D.importDeclaration;
    }
  });
  Object.defineProperty($, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: function() {
      return D.importDefaultSpecifier;
    }
  });
  Object.defineProperty($, "ImportExpression", {
    enumerable: !0,
    get: function() {
      return D.importExpression;
    }
  });
  Object.defineProperty($, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: function() {
      return D.importNamespaceSpecifier;
    }
  });
  Object.defineProperty($, "ImportSpecifier", {
    enumerable: !0,
    get: function() {
      return D.importSpecifier;
    }
  });
  Object.defineProperty($, "IndexedAccessType", {
    enumerable: !0,
    get: function() {
      return D.indexedAccessType;
    }
  });
  Object.defineProperty($, "InferredPredicate", {
    enumerable: !0,
    get: function() {
      return D.inferredPredicate;
    }
  });
  Object.defineProperty($, "InterfaceDeclaration", {
    enumerable: !0,
    get: function() {
      return D.interfaceDeclaration;
    }
  });
  Object.defineProperty($, "InterfaceExtends", {
    enumerable: !0,
    get: function() {
      return D.interfaceExtends;
    }
  });
  Object.defineProperty($, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.interfaceTypeAnnotation;
    }
  });
  Object.defineProperty($, "InterpreterDirective", {
    enumerable: !0,
    get: function() {
      return D.interpreterDirective;
    }
  });
  Object.defineProperty($, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.intersectionTypeAnnotation;
    }
  });
  Object.defineProperty($, "JSXAttribute", {
    enumerable: !0,
    get: function() {
      return D.jsxAttribute;
    }
  });
  Object.defineProperty($, "JSXClosingElement", {
    enumerable: !0,
    get: function() {
      return D.jsxClosingElement;
    }
  });
  Object.defineProperty($, "JSXClosingFragment", {
    enumerable: !0,
    get: function() {
      return D.jsxClosingFragment;
    }
  });
  Object.defineProperty($, "JSXElement", {
    enumerable: !0,
    get: function() {
      return D.jsxElement;
    }
  });
  Object.defineProperty($, "JSXEmptyExpression", {
    enumerable: !0,
    get: function() {
      return D.jsxEmptyExpression;
    }
  });
  Object.defineProperty($, "JSXExpressionContainer", {
    enumerable: !0,
    get: function() {
      return D.jsxExpressionContainer;
    }
  });
  Object.defineProperty($, "JSXFragment", {
    enumerable: !0,
    get: function() {
      return D.jsxFragment;
    }
  });
  Object.defineProperty($, "JSXIdentifier", {
    enumerable: !0,
    get: function() {
      return D.jsxIdentifier;
    }
  });
  Object.defineProperty($, "JSXMemberExpression", {
    enumerable: !0,
    get: function() {
      return D.jsxMemberExpression;
    }
  });
  Object.defineProperty($, "JSXNamespacedName", {
    enumerable: !0,
    get: function() {
      return D.jsxNamespacedName;
    }
  });
  Object.defineProperty($, "JSXOpeningElement", {
    enumerable: !0,
    get: function() {
      return D.jsxOpeningElement;
    }
  });
  Object.defineProperty($, "JSXOpeningFragment", {
    enumerable: !0,
    get: function() {
      return D.jsxOpeningFragment;
    }
  });
  Object.defineProperty($, "JSXSpreadAttribute", {
    enumerable: !0,
    get: function() {
      return D.jsxSpreadAttribute;
    }
  });
  Object.defineProperty($, "JSXSpreadChild", {
    enumerable: !0,
    get: function() {
      return D.jsxSpreadChild;
    }
  });
  Object.defineProperty($, "JSXText", {
    enumerable: !0,
    get: function() {
      return D.jsxText;
    }
  });
  Object.defineProperty($, "LabeledStatement", {
    enumerable: !0,
    get: function() {
      return D.labeledStatement;
    }
  });
  Object.defineProperty($, "LogicalExpression", {
    enumerable: !0,
    get: function() {
      return D.logicalExpression;
    }
  });
  Object.defineProperty($, "MemberExpression", {
    enumerable: !0,
    get: function() {
      return D.memberExpression;
    }
  });
  Object.defineProperty($, "MetaProperty", {
    enumerable: !0,
    get: function() {
      return D.metaProperty;
    }
  });
  Object.defineProperty($, "MixedTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.mixedTypeAnnotation;
    }
  });
  Object.defineProperty($, "ModuleExpression", {
    enumerable: !0,
    get: function() {
      return D.moduleExpression;
    }
  });
  Object.defineProperty($, "NewExpression", {
    enumerable: !0,
    get: function() {
      return D.newExpression;
    }
  });
  Object.defineProperty($, "Noop", {
    enumerable: !0,
    get: function() {
      return D.noop;
    }
  });
  Object.defineProperty($, "NullLiteral", {
    enumerable: !0,
    get: function() {
      return D.nullLiteral;
    }
  });
  Object.defineProperty($, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.nullLiteralTypeAnnotation;
    }
  });
  Object.defineProperty($, "NullableTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.nullableTypeAnnotation;
    }
  });
  Object.defineProperty($, "NumberLiteral", {
    enumerable: !0,
    get: function() {
      return D.numberLiteral;
    }
  });
  Object.defineProperty($, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.numberLiteralTypeAnnotation;
    }
  });
  Object.defineProperty($, "NumberTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.numberTypeAnnotation;
    }
  });
  Object.defineProperty($, "NumericLiteral", {
    enumerable: !0,
    get: function() {
      return D.numericLiteral;
    }
  });
  Object.defineProperty($, "ObjectExpression", {
    enumerable: !0,
    get: function() {
      return D.objectExpression;
    }
  });
  Object.defineProperty($, "ObjectMethod", {
    enumerable: !0,
    get: function() {
      return D.objectMethod;
    }
  });
  Object.defineProperty($, "ObjectPattern", {
    enumerable: !0,
    get: function() {
      return D.objectPattern;
    }
  });
  Object.defineProperty($, "ObjectProperty", {
    enumerable: !0,
    get: function() {
      return D.objectProperty;
    }
  });
  Object.defineProperty($, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.objectTypeAnnotation;
    }
  });
  Object.defineProperty($, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: function() {
      return D.objectTypeCallProperty;
    }
  });
  Object.defineProperty($, "ObjectTypeIndexer", {
    enumerable: !0,
    get: function() {
      return D.objectTypeIndexer;
    }
  });
  Object.defineProperty($, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: function() {
      return D.objectTypeInternalSlot;
    }
  });
  Object.defineProperty($, "ObjectTypeProperty", {
    enumerable: !0,
    get: function() {
      return D.objectTypeProperty;
    }
  });
  Object.defineProperty($, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: function() {
      return D.objectTypeSpreadProperty;
    }
  });
  Object.defineProperty($, "OpaqueType", {
    enumerable: !0,
    get: function() {
      return D.opaqueType;
    }
  });
  Object.defineProperty($, "OptionalCallExpression", {
    enumerable: !0,
    get: function() {
      return D.optionalCallExpression;
    }
  });
  Object.defineProperty($, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: function() {
      return D.optionalIndexedAccessType;
    }
  });
  Object.defineProperty($, "OptionalMemberExpression", {
    enumerable: !0,
    get: function() {
      return D.optionalMemberExpression;
    }
  });
  Object.defineProperty($, "ParenthesizedExpression", {
    enumerable: !0,
    get: function() {
      return D.parenthesizedExpression;
    }
  });
  Object.defineProperty($, "PipelineBareFunction", {
    enumerable: !0,
    get: function() {
      return D.pipelineBareFunction;
    }
  });
  Object.defineProperty($, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: function() {
      return D.pipelinePrimaryTopicReference;
    }
  });
  Object.defineProperty($, "PipelineTopicExpression", {
    enumerable: !0,
    get: function() {
      return D.pipelineTopicExpression;
    }
  });
  Object.defineProperty($, "Placeholder", {
    enumerable: !0,
    get: function() {
      return D.placeholder;
    }
  });
  Object.defineProperty($, "PrivateName", {
    enumerable: !0,
    get: function() {
      return D.privateName;
    }
  });
  Object.defineProperty($, "Program", {
    enumerable: !0,
    get: function() {
      return D.program;
    }
  });
  Object.defineProperty($, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: function() {
      return D.qualifiedTypeIdentifier;
    }
  });
  Object.defineProperty($, "RecordExpression", {
    enumerable: !0,
    get: function() {
      return D.recordExpression;
    }
  });
  Object.defineProperty($, "RegExpLiteral", {
    enumerable: !0,
    get: function() {
      return D.regExpLiteral;
    }
  });
  Object.defineProperty($, "RegexLiteral", {
    enumerable: !0,
    get: function() {
      return D.regexLiteral;
    }
  });
  Object.defineProperty($, "RestElement", {
    enumerable: !0,
    get: function() {
      return D.restElement;
    }
  });
  Object.defineProperty($, "RestProperty", {
    enumerable: !0,
    get: function() {
      return D.restProperty;
    }
  });
  Object.defineProperty($, "ReturnStatement", {
    enumerable: !0,
    get: function() {
      return D.returnStatement;
    }
  });
  Object.defineProperty($, "SequenceExpression", {
    enumerable: !0,
    get: function() {
      return D.sequenceExpression;
    }
  });
  Object.defineProperty($, "SpreadElement", {
    enumerable: !0,
    get: function() {
      return D.spreadElement;
    }
  });
  Object.defineProperty($, "SpreadProperty", {
    enumerable: !0,
    get: function() {
      return D.spreadProperty;
    }
  });
  Object.defineProperty($, "StaticBlock", {
    enumerable: !0,
    get: function() {
      return D.staticBlock;
    }
  });
  Object.defineProperty($, "StringLiteral", {
    enumerable: !0,
    get: function() {
      return D.stringLiteral;
    }
  });
  Object.defineProperty($, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.stringLiteralTypeAnnotation;
    }
  });
  Object.defineProperty($, "StringTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.stringTypeAnnotation;
    }
  });
  Object.defineProperty($, "Super", {
    enumerable: !0,
    get: function() {
      return D.super;
    }
  });
  Object.defineProperty($, "SwitchCase", {
    enumerable: !0,
    get: function() {
      return D.switchCase;
    }
  });
  Object.defineProperty($, "SwitchStatement", {
    enumerable: !0,
    get: function() {
      return D.switchStatement;
    }
  });
  Object.defineProperty($, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.symbolTypeAnnotation;
    }
  });
  Object.defineProperty($, "TSAnyKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsAnyKeyword;
    }
  });
  Object.defineProperty($, "TSArrayType", {
    enumerable: !0,
    get: function() {
      return D.tsArrayType;
    }
  });
  Object.defineProperty($, "TSAsExpression", {
    enumerable: !0,
    get: function() {
      return D.tsAsExpression;
    }
  });
  Object.defineProperty($, "TSBigIntKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsBigIntKeyword;
    }
  });
  Object.defineProperty($, "TSBooleanKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsBooleanKeyword;
    }
  });
  Object.defineProperty($, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsCallSignatureDeclaration;
    }
  });
  Object.defineProperty($, "TSConditionalType", {
    enumerable: !0,
    get: function() {
      return D.tsConditionalType;
    }
  });
  Object.defineProperty($, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsConstructSignatureDeclaration;
    }
  });
  Object.defineProperty($, "TSConstructorType", {
    enumerable: !0,
    get: function() {
      return D.tsConstructorType;
    }
  });
  Object.defineProperty($, "TSDeclareFunction", {
    enumerable: !0,
    get: function() {
      return D.tsDeclareFunction;
    }
  });
  Object.defineProperty($, "TSDeclareMethod", {
    enumerable: !0,
    get: function() {
      return D.tsDeclareMethod;
    }
  });
  Object.defineProperty($, "TSEnumDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsEnumDeclaration;
    }
  });
  Object.defineProperty($, "TSEnumMember", {
    enumerable: !0,
    get: function() {
      return D.tsEnumMember;
    }
  });
  Object.defineProperty($, "TSExportAssignment", {
    enumerable: !0,
    get: function() {
      return D.tsExportAssignment;
    }
  });
  Object.defineProperty($, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: function() {
      return D.tsExpressionWithTypeArguments;
    }
  });
  Object.defineProperty($, "TSExternalModuleReference", {
    enumerable: !0,
    get: function() {
      return D.tsExternalModuleReference;
    }
  });
  Object.defineProperty($, "TSFunctionType", {
    enumerable: !0,
    get: function() {
      return D.tsFunctionType;
    }
  });
  Object.defineProperty($, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsImportEqualsDeclaration;
    }
  });
  Object.defineProperty($, "TSImportType", {
    enumerable: !0,
    get: function() {
      return D.tsImportType;
    }
  });
  Object.defineProperty($, "TSIndexSignature", {
    enumerable: !0,
    get: function() {
      return D.tsIndexSignature;
    }
  });
  Object.defineProperty($, "TSIndexedAccessType", {
    enumerable: !0,
    get: function() {
      return D.tsIndexedAccessType;
    }
  });
  Object.defineProperty($, "TSInferType", {
    enumerable: !0,
    get: function() {
      return D.tsInferType;
    }
  });
  Object.defineProperty($, "TSInstantiationExpression", {
    enumerable: !0,
    get: function() {
      return D.tsInstantiationExpression;
    }
  });
  Object.defineProperty($, "TSInterfaceBody", {
    enumerable: !0,
    get: function() {
      return D.tsInterfaceBody;
    }
  });
  Object.defineProperty($, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsInterfaceDeclaration;
    }
  });
  Object.defineProperty($, "TSIntersectionType", {
    enumerable: !0,
    get: function() {
      return D.tsIntersectionType;
    }
  });
  Object.defineProperty($, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsIntrinsicKeyword;
    }
  });
  Object.defineProperty($, "TSLiteralType", {
    enumerable: !0,
    get: function() {
      return D.tsLiteralType;
    }
  });
  Object.defineProperty($, "TSMappedType", {
    enumerable: !0,
    get: function() {
      return D.tsMappedType;
    }
  });
  Object.defineProperty($, "TSMethodSignature", {
    enumerable: !0,
    get: function() {
      return D.tsMethodSignature;
    }
  });
  Object.defineProperty($, "TSModuleBlock", {
    enumerable: !0,
    get: function() {
      return D.tsModuleBlock;
    }
  });
  Object.defineProperty($, "TSModuleDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsModuleDeclaration;
    }
  });
  Object.defineProperty($, "TSNamedTupleMember", {
    enumerable: !0,
    get: function() {
      return D.tsNamedTupleMember;
    }
  });
  Object.defineProperty($, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsNamespaceExportDeclaration;
    }
  });
  Object.defineProperty($, "TSNeverKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsNeverKeyword;
    }
  });
  Object.defineProperty($, "TSNonNullExpression", {
    enumerable: !0,
    get: function() {
      return D.tsNonNullExpression;
    }
  });
  Object.defineProperty($, "TSNullKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsNullKeyword;
    }
  });
  Object.defineProperty($, "TSNumberKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsNumberKeyword;
    }
  });
  Object.defineProperty($, "TSObjectKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsObjectKeyword;
    }
  });
  Object.defineProperty($, "TSOptionalType", {
    enumerable: !0,
    get: function() {
      return D.tsOptionalType;
    }
  });
  Object.defineProperty($, "TSParameterProperty", {
    enumerable: !0,
    get: function() {
      return D.tsParameterProperty;
    }
  });
  Object.defineProperty($, "TSParenthesizedType", {
    enumerable: !0,
    get: function() {
      return D.tsParenthesizedType;
    }
  });
  Object.defineProperty($, "TSPropertySignature", {
    enumerable: !0,
    get: function() {
      return D.tsPropertySignature;
    }
  });
  Object.defineProperty($, "TSQualifiedName", {
    enumerable: !0,
    get: function() {
      return D.tsQualifiedName;
    }
  });
  Object.defineProperty($, "TSRestType", {
    enumerable: !0,
    get: function() {
      return D.tsRestType;
    }
  });
  Object.defineProperty($, "TSSatisfiesExpression", {
    enumerable: !0,
    get: function() {
      return D.tsSatisfiesExpression;
    }
  });
  Object.defineProperty($, "TSStringKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsStringKeyword;
    }
  });
  Object.defineProperty($, "TSSymbolKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsSymbolKeyword;
    }
  });
  Object.defineProperty($, "TSThisType", {
    enumerable: !0,
    get: function() {
      return D.tsThisType;
    }
  });
  Object.defineProperty($, "TSTupleType", {
    enumerable: !0,
    get: function() {
      return D.tsTupleType;
    }
  });
  Object.defineProperty($, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsTypeAliasDeclaration;
    }
  });
  Object.defineProperty($, "TSTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.tsTypeAnnotation;
    }
  });
  Object.defineProperty($, "TSTypeAssertion", {
    enumerable: !0,
    get: function() {
      return D.tsTypeAssertion;
    }
  });
  Object.defineProperty($, "TSTypeLiteral", {
    enumerable: !0,
    get: function() {
      return D.tsTypeLiteral;
    }
  });
  Object.defineProperty($, "TSTypeOperator", {
    enumerable: !0,
    get: function() {
      return D.tsTypeOperator;
    }
  });
  Object.defineProperty($, "TSTypeParameter", {
    enumerable: !0,
    get: function() {
      return D.tsTypeParameter;
    }
  });
  Object.defineProperty($, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: function() {
      return D.tsTypeParameterDeclaration;
    }
  });
  Object.defineProperty($, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: function() {
      return D.tsTypeParameterInstantiation;
    }
  });
  Object.defineProperty($, "TSTypePredicate", {
    enumerable: !0,
    get: function() {
      return D.tsTypePredicate;
    }
  });
  Object.defineProperty($, "TSTypeQuery", {
    enumerable: !0,
    get: function() {
      return D.tsTypeQuery;
    }
  });
  Object.defineProperty($, "TSTypeReference", {
    enumerable: !0,
    get: function() {
      return D.tsTypeReference;
    }
  });
  Object.defineProperty($, "TSUndefinedKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsUndefinedKeyword;
    }
  });
  Object.defineProperty($, "TSUnionType", {
    enumerable: !0,
    get: function() {
      return D.tsUnionType;
    }
  });
  Object.defineProperty($, "TSUnknownKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsUnknownKeyword;
    }
  });
  Object.defineProperty($, "TSVoidKeyword", {
    enumerable: !0,
    get: function() {
      return D.tsVoidKeyword;
    }
  });
  Object.defineProperty($, "TaggedTemplateExpression", {
    enumerable: !0,
    get: function() {
      return D.taggedTemplateExpression;
    }
  });
  Object.defineProperty($, "TemplateElement", {
    enumerable: !0,
    get: function() {
      return D.templateElement;
    }
  });
  Object.defineProperty($, "TemplateLiteral", {
    enumerable: !0,
    get: function() {
      return D.templateLiteral;
    }
  });
  Object.defineProperty($, "ThisExpression", {
    enumerable: !0,
    get: function() {
      return D.thisExpression;
    }
  });
  Object.defineProperty($, "ThisTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.thisTypeAnnotation;
    }
  });
  Object.defineProperty($, "ThrowStatement", {
    enumerable: !0,
    get: function() {
      return D.throwStatement;
    }
  });
  Object.defineProperty($, "TopicReference", {
    enumerable: !0,
    get: function() {
      return D.topicReference;
    }
  });
  Object.defineProperty($, "TryStatement", {
    enumerable: !0,
    get: function() {
      return D.tryStatement;
    }
  });
  Object.defineProperty($, "TupleExpression", {
    enumerable: !0,
    get: function() {
      return D.tupleExpression;
    }
  });
  Object.defineProperty($, "TupleTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.tupleTypeAnnotation;
    }
  });
  Object.defineProperty($, "TypeAlias", {
    enumerable: !0,
    get: function() {
      return D.typeAlias;
    }
  });
  Object.defineProperty($, "TypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.typeAnnotation;
    }
  });
  Object.defineProperty($, "TypeCastExpression", {
    enumerable: !0,
    get: function() {
      return D.typeCastExpression;
    }
  });
  Object.defineProperty($, "TypeParameter", {
    enumerable: !0,
    get: function() {
      return D.typeParameter;
    }
  });
  Object.defineProperty($, "TypeParameterDeclaration", {
    enumerable: !0,
    get: function() {
      return D.typeParameterDeclaration;
    }
  });
  Object.defineProperty($, "TypeParameterInstantiation", {
    enumerable: !0,
    get: function() {
      return D.typeParameterInstantiation;
    }
  });
  Object.defineProperty($, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.typeofTypeAnnotation;
    }
  });
  Object.defineProperty($, "UnaryExpression", {
    enumerable: !0,
    get: function() {
      return D.unaryExpression;
    }
  });
  Object.defineProperty($, "UnionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.unionTypeAnnotation;
    }
  });
  Object.defineProperty($, "UpdateExpression", {
    enumerable: !0,
    get: function() {
      return D.updateExpression;
    }
  });
  Object.defineProperty($, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: function() {
      return D.v8IntrinsicIdentifier;
    }
  });
  Object.defineProperty($, "VariableDeclaration", {
    enumerable: !0,
    get: function() {
      return D.variableDeclaration;
    }
  });
  Object.defineProperty($, "VariableDeclarator", {
    enumerable: !0,
    get: function() {
      return D.variableDeclarator;
    }
  });
  Object.defineProperty($, "Variance", {
    enumerable: !0,
    get: function() {
      return D.variance;
    }
  });
  Object.defineProperty($, "VoidTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return D.voidTypeAnnotation;
    }
  });
  Object.defineProperty($, "WhileStatement", {
    enumerable: !0,
    get: function() {
      return D.whileStatement;
    }
  });
  Object.defineProperty($, "WithStatement", {
    enumerable: !0,
    get: function() {
      return D.withStatement;
    }
  });
  Object.defineProperty($, "YieldExpression", {
    enumerable: !0,
    get: function() {
      return D.yieldExpression;
    }
  });
  var D = r0();
});

// node_modules/@babel/types/lib/builders/productions.js
var HH = P((zH) => {
  var Wd = function() {
    return XH.unaryExpression("void", XH.numericLiteral(0), !0);
  };
  Object.defineProperty(zH, "__esModule", {
    value: !0
  });
  zH.buildUndefinedNode = Wd;
  var XH = r0();
});

// node_modules/@babel/types/lib/clone/cloneNode.js
var d1 = P((KH) => {
  var GH = function(Z, Q, J, X) {
    if (Z && typeof Z.type === "string")
      return VH(Z, Q, J, X);
    return Z;
  }, UH = function(Z, Q, J, X) {
    if (Array.isArray(Z))
      return Z.map((z) => GH(z, Q, J, X));
    return GH(Z, Q, J, X);
  }, Ud = function(Z, Q = !0, J = !1) {
    return VH(Z, Q, J, new Map);
  }, VH = function(Z, Q = !0, J = !1, X) {
    if (!Z)
      return Z;
    const {
      type: z
    } = Z, Y = {
      type: Z.type
    };
    if (WH.isIdentifier(Z)) {
      if (Y.name = Z.name, E1(Z, "optional") && typeof Z.optional === "boolean")
        Y.optional = Z.optional;
      if (E1(Z, "typeAnnotation"))
        Y.typeAnnotation = Q ? UH(Z.typeAnnotation, !0, J, X) : Z.typeAnnotation;
    } else if (!E1(YH.NODE_FIELDS, z))
      throw new Error(`Unknown node type: "${z}"`);
    else
      for (let W of Object.keys(YH.NODE_FIELDS[z]))
        if (E1(Z, W))
          if (Q)
            Y[W] = WH.isFile(Z) && W === "comments" ? C7(Z.comments, Q, J, X) : UH(Z[W], !0, J, X);
          else
            Y[W] = Z[W];
    if (E1(Z, "loc"))
      if (J)
        Y.loc = null;
      else
        Y.loc = Z.loc;
    if (E1(Z, "leadingComments"))
      Y.leadingComments = C7(Z.leadingComments, Q, J, X);
    if (E1(Z, "innerComments"))
      Y.innerComments = C7(Z.innerComments, Q, J, X);
    if (E1(Z, "trailingComments"))
      Y.trailingComments = C7(Z.trailingComments, Q, J, X);
    if (E1(Z, "extra"))
      Y.extra = Object.assign({}, Z.extra);
    return Y;
  }, C7 = function(Z, Q, J, X) {
    if (!Z || !Q)
      return Z;
    return Z.map((z) => {
      const Y = X.get(z);
      if (Y)
        return Y;
      const {
        type: W,
        value: U,
        loc: V
      } = z, M = {
        type: W,
        value: U,
        loc: V
      };
      if (J)
        M.loc = null;
      return X.set(z, M), M;
    });
  };
  Object.defineProperty(KH, "__esModule", {
    value: !0
  });
  KH.default = Ud;
  var YH = z1(), WH = S0(), E1 = Function.call.bind(Object.prototype.hasOwnProperty);
});

// node_modules/@babel/types/lib/clone/clone.js
var FH = P((MH) => {
  var Md = function(Z) {
    return Kd.default(Z, !1);
  };
  Object.defineProperty(MH, "__esModule", {
    value: !0
  });
  MH.default = Md;
  var Kd = d1();
});

// node_modules/@babel/types/lib/clone/cloneDeep.js
var jH = P((RH) => {
  var jd = function(Z) {
    return Rd.default(Z);
  };
  Object.defineProperty(RH, "__esModule", {
    value: !0
  });
  RH.default = jd;
  var Rd = d1();
});

// node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var BH = P((OH) => {
  var qd = function(Z) {
    return Bd.default(Z, !0, !0);
  };
  Object.defineProperty(OH, "__esModule", {
    value: !0
  });
  OH.default = qd;
  var Bd = d1();
});

// node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var $H = P((qH) => {
  var Id = function(Z) {
    return Dd.default(Z, !1, !0);
  };
  Object.defineProperty(qH, "__esModule", {
    value: !0
  });
  qH.default = Id;
  var Dd = d1();
});

// node_modules/@babel/types/lib/comments/addComments.js
var MZ = P((DH) => {
  var Ad = function(Z, Q, J) {
    if (!J || !Z)
      return Z;
    const X = `${Q}Comments`;
    if (Z[X])
      if (Q === "leading")
        Z[X] = J.concat(Z[X]);
      else
        Z[X].push(...J);
    else
      Z[X] = J;
    return Z;
  };
  Object.defineProperty(DH, "__esModule", {
    value: !0
  });
  DH.default = Ad;
});

// node_modules/@babel/types/lib/comments/addComment.js
var CH = P((IH) => {
  var Pd = function(Z, Q, J, X) {
    return Nd.default(Z, Q, [{
      type: X ? "CommentLine" : "CommentBlock",
      value: J
    }]);
  };
  Object.defineProperty(IH, "__esModule", {
    value: !0
  });
  IH.default = Pd;
  var Nd = MZ();
});

// node_modules/@babel/types/lib/utils/inherit.js
var A7 = P((AH) => {
  var wd = function(Z, Q, J) {
    if (Q && J)
      Q[Z] = Array.from(new Set([].concat(Q[Z], J[Z]).filter(Boolean)));
  };
  Object.defineProperty(AH, "__esModule", {
    value: !0
  });
  AH.default = wd;
});

// node_modules/@babel/types/lib/comments/inheritInnerComments.js
var FZ = P((LH) => {
  var bd = function(Z, Q) {
    vd.default("innerComments", Z, Q);
  };
  Object.defineProperty(LH, "__esModule", {
    value: !0
  });
  LH.default = bd;
  var vd = A7();
});

// node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var RZ = P((NH) => {
  var hd = function(Z, Q) {
    gd.default("leadingComments", Z, Q);
  };
  Object.defineProperty(NH, "__esModule", {
    value: !0
  });
  NH.default = hd;
  var gd = A7();
});

// node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var jZ = P((PH) => {
  var fd = function(Z, Q) {
    kd.default("trailingComments", Z, Q);
  };
  Object.defineProperty(PH, "__esModule", {
    value: !0
  });
  PH.default = fd;
  var kd = A7();
});

// node_modules/@babel/types/lib/comments/inheritsComments.js
var OZ = P((SH) => {
  var cd = function(Z, Q) {
    return md.default(Z, Q), ud.default(Z, Q), xd.default(Z, Q), Z;
  };
  Object.defineProperty(SH, "__esModule", {
    value: !0
  });
  SH.default = cd;
  var md = jZ(), ud = RZ(), xd = FZ();
});

// node_modules/@babel/types/lib/comments/removeComments.js
var TH = P((wH) => {
  var dd = function(Z) {
    return id.COMMENT_KEYS.forEach((Q) => {
      Z[Q] = null;
    }), Z;
  };
  Object.defineProperty(wH, "__esModule", {
    value: !0
  });
  wH.default = dd;
  var id = l1();
});

// node_modules/@babel/types/lib/constants/generated/index.js
var EH = P((vH) => {
  Object.defineProperty(vH, "__esModule", {
    value: !0
  });
  vH.WHILE_TYPES = vH.USERWHITESPACABLE_TYPES = vH.UNARYLIKE_TYPES = vH.TYPESCRIPT_TYPES = vH.TSTYPE_TYPES = vH.TSTYPEELEMENT_TYPES = vH.TSENTITYNAME_TYPES = vH.TSBASETYPE_TYPES = vH.TERMINATORLESS_TYPES = vH.STATEMENT_TYPES = vH.STANDARDIZED_TYPES = vH.SCOPABLE_TYPES = vH.PUREISH_TYPES = vH.PROPERTY_TYPES = vH.PRIVATE_TYPES = vH.PATTERN_TYPES = vH.PATTERNLIKE_TYPES = vH.OBJECTMEMBER_TYPES = vH.MODULESPECIFIER_TYPES = vH.MODULEDECLARATION_TYPES = vH.MISCELLANEOUS_TYPES = vH.METHOD_TYPES = vH.LVAL_TYPES = vH.LOOP_TYPES = vH.LITERAL_TYPES = vH.JSX_TYPES = vH.IMPORTOREXPORTDECLARATION_TYPES = vH.IMMUTABLE_TYPES = vH.FUNCTION_TYPES = vH.FUNCTIONPARENT_TYPES = vH.FOR_TYPES = vH.FORXSTATEMENT_TYPES = vH.FLOW_TYPES = vH.FLOWTYPE_TYPES = vH.FLOWPREDICATE_TYPES = vH.FLOWDECLARATION_TYPES = vH.FLOWBASEANNOTATION_TYPES = vH.EXPRESSION_TYPES = vH.EXPRESSIONWRAPPER_TYPES = vH.EXPORTDECLARATION_TYPES = vH.ENUMMEMBER_TYPES = vH.ENUMBODY_TYPES = vH.DECLARATION_TYPES = vH.CONDITIONAL_TYPES = vH.COMPLETIONSTATEMENT_TYPES = vH.CLASS_TYPES = vH.BLOCK_TYPES = vH.BLOCKPARENT_TYPES = vH.BINARY_TYPES = vH.ACCESSOR_TYPES = void 0;
  var s = z1(), h10 = vH.STANDARDIZED_TYPES = s.FLIPPED_ALIAS_KEYS.Standardized, _10 = vH.EXPRESSION_TYPES = s.FLIPPED_ALIAS_KEYS.Expression, k10 = vH.BINARY_TYPES = s.FLIPPED_ALIAS_KEYS.Binary, f10 = vH.SCOPABLE_TYPES = s.FLIPPED_ALIAS_KEYS.Scopable, y10 = vH.BLOCKPARENT_TYPES = s.FLIPPED_ALIAS_KEYS.BlockParent, m10 = vH.BLOCK_TYPES = s.FLIPPED_ALIAS_KEYS.Block, u10 = vH.STATEMENT_TYPES = s.FLIPPED_ALIAS_KEYS.Statement, x10 = vH.TERMINATORLESS_TYPES = s.FLIPPED_ALIAS_KEYS.Terminatorless, c10 = vH.COMPLETIONSTATEMENT_TYPES = s.FLIPPED_ALIAS_KEYS.CompletionStatement, l10 = vH.CONDITIONAL_TYPES = s.FLIPPED_ALIAS_KEYS.Conditional, i10 = vH.LOOP_TYPES = s.FLIPPED_ALIAS_KEYS.Loop, d10 = vH.WHILE_TYPES = s.FLIPPED_ALIAS_KEYS.While, p10 = vH.EXPRESSIONWRAPPER_TYPES = s.FLIPPED_ALIAS_KEYS.ExpressionWrapper, a10 = vH.FOR_TYPES = s.FLIPPED_ALIAS_KEYS.For, r10 = vH.FORXSTATEMENT_TYPES = s.FLIPPED_ALIAS_KEYS.ForXStatement, n10 = vH.FUNCTION_TYPES = s.FLIPPED_ALIAS_KEYS.Function, s10 = vH.FUNCTIONPARENT_TYPES = s.FLIPPED_ALIAS_KEYS.FunctionParent, t10 = vH.PUREISH_TYPES = s.FLIPPED_ALIAS_KEYS.Pureish, o10 = vH.DECLARATION_TYPES = s.FLIPPED_ALIAS_KEYS.Declaration, e10 = vH.PATTERNLIKE_TYPES = s.FLIPPED_ALIAS_KEYS.PatternLike, Z50 = vH.LVAL_TYPES = s.FLIPPED_ALIAS_KEYS.LVal, Q50 = vH.TSENTITYNAME_TYPES = s.FLIPPED_ALIAS_KEYS.TSEntityName, J50 = vH.LITERAL_TYPES = s.FLIPPED_ALIAS_KEYS.Literal, X50 = vH.IMMUTABLE_TYPES = s.FLIPPED_ALIAS_KEYS.Immutable, z50 = vH.USERWHITESPACABLE_TYPES = s.FLIPPED_ALIAS_KEYS.UserWhitespacable, H50 = vH.METHOD_TYPES = s.FLIPPED_ALIAS_KEYS.Method, Y50 = vH.OBJECTMEMBER_TYPES = s.FLIPPED_ALIAS_KEYS.ObjectMember, W50 = vH.PROPERTY_TYPES = s.FLIPPED_ALIAS_KEYS.Property, G50 = vH.UNARYLIKE_TYPES = s.FLIPPED_ALIAS_KEYS.UnaryLike, U50 = vH.PATTERN_TYPES = s.FLIPPED_ALIAS_KEYS.Pattern, V50 = vH.CLASS_TYPES = s.FLIPPED_ALIAS_KEYS.Class, ad = vH.IMPORTOREXPORTDECLARATION_TYPES = s.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, K50 = vH.EXPORTDECLARATION_TYPES = s.FLIPPED_ALIAS_KEYS.ExportDeclaration, M50 = vH.MODULESPECIFIER_TYPES = s.FLIPPED_ALIAS_KEYS.ModuleSpecifier, F50 = vH.ACCESSOR_TYPES = s.FLIPPED_ALIAS_KEYS.Accessor, R50 = vH.PRIVATE_TYPES = s.FLIPPED_ALIAS_KEYS.Private, j50 = vH.FLOW_TYPES = s.FLIPPED_ALIAS_KEYS.Flow, O50 = vH.FLOWTYPE_TYPES = s.FLIPPED_ALIAS_KEYS.FlowType, B50 = vH.FLOWBASEANNOTATION_TYPES = s.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, q50 = vH.FLOWDECLARATION_TYPES = s.FLIPPED_ALIAS_KEYS.FlowDeclaration, $50 = vH.FLOWPREDICATE_TYPES = s.FLIPPED_ALIAS_KEYS.FlowPredicate, D50 = vH.ENUMBODY_TYPES = s.FLIPPED_ALIAS_KEYS.EnumBody, I50 = vH.ENUMMEMBER_TYPES = s.FLIPPED_ALIAS_KEYS.EnumMember, C50 = vH.JSX_TYPES = s.FLIPPED_ALIAS_KEYS.JSX, A50 = vH.MISCELLANEOUS_TYPES = s.FLIPPED_ALIAS_KEYS.Miscellaneous, L50 = vH.TYPESCRIPT_TYPES = s.FLIPPED_ALIAS_KEYS.TypeScript, N50 = vH.TSTYPEELEMENT_TYPES = s.FLIPPED_ALIAS_KEYS.TSTypeElement, P50 = vH.TSTYPE_TYPES = s.FLIPPED_ALIAS_KEYS.TSType, S50 = vH.TSBASETYPE_TYPES = s.FLIPPED_ALIAS_KEYS.TSBaseType, w50 = vH.MODULEDECLARATION_TYPES = ad;
});

// node_modules/@babel/types/lib/converters/toBlock.js
var qZ = P((gH) => {
  var lp = function(Z, Q) {
    if (L7.isBlockStatement(Z))
      return Z;
    let J = [];
    if (L7.isEmptyStatement(Z))
      J = [];
    else {
      if (!L7.isStatement(Z))
        if (L7.isFunction(Q))
          Z = BZ.returnStatement(Z);
        else
          Z = BZ.expressionStatement(Z);
      J = [Z];
    }
    return BZ.blockStatement(J);
  };
  Object.defineProperty(gH, "__esModule", {
    value: !0
  });
  gH.default = lp;
  var L7 = S0(), BZ = r0();
});

// node_modules/@babel/types/lib/converters/ensureBlock.js
var _H = P((hH) => {
  var pp = function(Z, Q = "body") {
    const J = dp.default(Z[Q], Z);
    return Z[Q] = J, J;
  };
  Object.defineProperty(hH, "__esModule", {
    value: !0
  });
  hH.default = pp;
  var dp = qZ();
});

// node_modules/@babel/types/lib/converters/toIdentifier.js
var $Z = P((kH) => {
  var sp = function(Z) {
    Z = Z + "";
    let Q = "";
    for (let J of Z)
      Q += np.isIdentifierChar(J.codePointAt(0)) ? J : "-";
    if (Q = Q.replace(/^[-0-9]+/, ""), Q = Q.replace(/[-\s]+(.)?/g, function(J, X) {
      return X ? X.toUpperCase() : "";
    }), !rp.default(Q))
      Q = `_${Q}`;
    return Q || "_";
  };
  Object.defineProperty(kH, "__esModule", {
    value: !0
  });
  kH.default = sp;
  var rp = h5(), np = M7();
});

// node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var yH = P((fH) => {
  var ep = function(Z) {
    if (Z = op.default(Z), Z === "eval" || Z === "arguments")
      Z = "_" + Z;
    return Z;
  };
  Object.defineProperty(fH, "__esModule", {
    value: !0
  });
  fH.default = ep;
  var op = $Z();
});

// node_modules/@babel/types/lib/converters/toComputedKey.js
var uH = P((mH) => {
  var Xa = function(Z, Q = Z.key || Z.property) {
    if (!Z.computed && Qa.isIdentifier(Q))
      Q = Ja.stringLiteral(Q.name);
    return Q;
  };
  Object.defineProperty(mH, "__esModule", {
    value: !0
  });
  mH.default = Xa;
  var Qa = S0(), Ja = r0();
});

// node_modules/@babel/types/lib/converters/toExpression.js
var lH = P((xH) => {
  var Ha = function(Z) {
    if (I8.isExpressionStatement(Z))
      Z = Z.expression;
    if (I8.isExpression(Z))
      return Z;
    if (I8.isClass(Z))
      Z.type = "ClassExpression";
    else if (I8.isFunction(Z))
      Z.type = "FunctionExpression";
    if (!I8.isExpression(Z))
      throw new Error(`cannot turn ${Z.type} to an expression`);
    return Z;
  };
  Object.defineProperty(xH, "__esModule", {
    value: !0
  });
  xH.default = void 0;
  var I8 = S0(), _50 = xH.default = Ha;
});

// node_modules/@babel/types/lib/traverse/traverseFast.js
var IZ = P((iH) => {
  var DZ = function(Z, Q, J) {
    if (!Z)
      return;
    const X = Ya.VISITOR_KEYS[Z.type];
    if (!X)
      return;
    J = J || {}, Q(Z, J);
    for (let z of X) {
      const Y = Z[z];
      if (Array.isArray(Y))
        for (let W of Y)
          DZ(W, Q, J);
      else
        DZ(Y, Q, J);
    }
  };
  Object.defineProperty(iH, "__esModule", {
    value: !0
  });
  iH.default = DZ;
  var Ya = z1();
});

// node_modules/@babel/types/lib/modifications/removeProperties.js
var CZ = P((pH) => {
  var Va = function(Z, Q = {}) {
    const J = Q.preserveComments ? dH : Ua;
    for (let z of J)
      if (Z[z] != null)
        Z[z] = void 0;
    for (let z of Object.keys(Z))
      if (z[0] === "_" && Z[z] != null)
        Z[z] = void 0;
    const X = Object.getOwnPropertySymbols(Z);
    for (let z of X)
      Z[z] = null;
  };
  Object.defineProperty(pH, "__esModule", {
    value: !0
  });
  pH.default = Va;
  var Ga = l1(), dH = ["tokens", "start", "end", "loc", "raw", "rawValue"], Ua = [...Ga.COMMENT_KEYS, "comments", ...dH];
});

// node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var AZ = P((aH) => {
  var Ra = function(Z, Q) {
    return Ma.default(Z, Fa.default, Q), Z;
  };
  Object.defineProperty(aH, "__esModule", {
    value: !0
  });
  aH.default = Ra;
  var Ma = IZ(), Fa = CZ();
});

// node_modules/@babel/types/lib/converters/toKeyAlias.js
var sH = P((nH) => {
  var U5 = function(Z, Q = Z.key) {
    let J;
    if (Z.kind === "method")
      return U5.increment() + "";
    else if (rH.isIdentifier(Q))
      J = Q.name;
    else if (rH.isStringLiteral(Q))
      J = JSON.stringify(Q.value);
    else
      J = JSON.stringify(Ba.default(Oa.default(Q)));
    if (Z.computed)
      J = `[${J}]`;
    if (Z.static)
      J = `static:${J}`;
    return J;
  };
  Object.defineProperty(nH, "__esModule", {
    value: !0
  });
  nH.default = U5;
  var rH = S0(), Oa = d1(), Ba = AZ();
  U5.uid = 0;
  U5.increment = function() {
    if (U5.uid >= Number.MAX_SAFE_INTEGER)
      return U5.uid = 0;
    else
      return U5.uid++;
  };
});

// node_modules/@babel/types/lib/converters/toStatement.js
var eH = P((tH) => {
  var Da = function(Z, Q) {
    if (N7.isStatement(Z))
      return Z;
    let J = !1, X;
    if (N7.isClass(Z))
      J = !0, X = "ClassDeclaration";
    else if (N7.isFunction(Z))
      J = !0, X = "FunctionDeclaration";
    else if (N7.isAssignmentExpression(Z))
      return $a.expressionStatement(Z);
    if (J && !Z.id)
      X = !1;
    if (!X)
      if (Q)
        return !1;
      else
        throw new Error(`cannot turn ${Z.type} to a statement`);
    return Z.type = X, Z;
  };
  Object.defineProperty(tH, "__esModule", {
    value: !0
  });
  tH.default = void 0;
  var N7 = S0(), $a = r0(), x50 = tH.default = Da;
});

// node_modules/@babel/types/lib/converters/valueToNode.js
var JY = P((ZY) => {
  var Aa = function(Z) {
    return Ca(Z) === "[object RegExp]";
  }, La = function(Z) {
    if (typeof Z !== "object" || Z === null || Object.prototype.toString.call(Z) !== "[object Object]")
      return !1;
    const Q = Object.getPrototypeOf(Z);
    return Q === null || Object.getPrototypeOf(Q) === null;
  }, LZ = function(Z) {
    if (Z === void 0)
      return u0.identifier("undefined");
    if (Z === !0 || Z === !1)
      return u0.booleanLiteral(Z);
    if (Z === null)
      return u0.nullLiteral();
    if (typeof Z === "string")
      return u0.stringLiteral(Z);
    if (typeof Z === "number") {
      let Q;
      if (Number.isFinite(Z))
        Q = u0.numericLiteral(Math.abs(Z));
      else {
        let J;
        if (Number.isNaN(Z))
          J = u0.numericLiteral(0);
        else
          J = u0.numericLiteral(1);
        Q = u0.binaryExpression("/", J, u0.numericLiteral(0));
      }
      if (Z < 0 || Object.is(Z, -0))
        Q = u0.unaryExpression("-", Q);
      return Q;
    }
    if (Aa(Z)) {
      const Q = Z.source, J = Z.toString().match(/\/([a-z]+|)$/)[1];
      return u0.regExpLiteral(Q, J);
    }
    if (Array.isArray(Z))
      return u0.arrayExpression(Z.map(LZ));
    if (La(Z)) {
      const Q = [];
      for (let J of Object.keys(Z)) {
        let X;
        if (Ia.default(J))
          X = u0.identifier(J);
        else
          X = u0.stringLiteral(J);
        Q.push(u0.objectProperty(X, LZ(Z[J])));
      }
      return u0.objectExpression(Q);
    }
    throw new Error("don't know how to turn this value into a node");
  };
  Object.defineProperty(ZY, "__esModule", {
    value: !0
  });
  ZY.default = void 0;
  var Ia = h5(), u0 = r0(), l50 = ZY.default = LZ, Ca = Function.call.bind(Object.prototype.toString);
});

// node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var zY = P((XY) => {
  var Pa = function(Z, Q, J = !1) {
    return Z.object = Na.memberExpression(Z.object, Z.property, Z.computed), Z.property = Q, Z.computed = !!J, Z;
  };
  Object.defineProperty(XY, "__esModule", {
    value: !0
  });
  XY.default = Pa;
  var Na = r0();
});

// node_modules/@babel/types/lib/modifications/inherits.js
var WY = P((YY) => {
  var Ta = function(Z, Q) {
    if (!Z || !Q)
      return Z;
    for (let J of HY.INHERIT_KEYS.optional)
      if (Z[J] == null)
        Z[J] = Q[J];
    for (let J of Object.keys(Q))
      if (J[0] === "_" && J !== "__clone")
        Z[J] = Q[J];
    for (let J of HY.INHERIT_KEYS.force)
      Z[J] = Q[J];
    return wa.default(Z, Q), Z;
  };
  Object.defineProperty(YY, "__esModule", {
    value: !0
  });
  YY.default = Ta;
  var HY = l1(), wa = OZ();
});

// node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var UY = P((GY) => {
  var ga = function(Z, Q) {
    if (Ea.isSuper(Z.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return Z.object = ba.memberExpression(Q, Z.object), Z;
  };
  Object.defineProperty(GY, "__esModule", {
    value: !0
  });
  GY.default = ga;
  var ba = r0(), Ea = B1();
});

// node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var C8 = P((VY) => {
  var NZ = function(Z, Q, J, X) {
    const z = [].concat(Z), Y = Object.create(null);
    while (z.length) {
      const W = z.shift();
      if (!W)
        continue;
      if (X && (p1.isAssignmentExpression(W) || p1.isUnaryExpression(W)))
        continue;
      const U = NZ.keys[W.type];
      if (p1.isIdentifier(W)) {
        if (Q)
          (Y[W.name] = Y[W.name] || []).push(W);
        else
          Y[W.name] = W;
        continue;
      }
      if (p1.isExportDeclaration(W) && !p1.isExportAllDeclaration(W)) {
        if (p1.isDeclaration(W.declaration))
          z.push(W.declaration);
        continue;
      }
      if (J) {
        if (p1.isFunctionDeclaration(W)) {
          z.push(W.id);
          continue;
        }
        if (p1.isFunctionExpression(W))
          continue;
      }
      if (U)
        for (let V = 0;V < U.length; V++) {
          const M = U[V], q = W[M];
          if (q)
            Array.isArray(q) ? z.push(...q) : z.push(q);
        }
    }
    return Y;
  };
  Object.defineProperty(VY, "__esModule", {
    value: !0
  });
  VY.default = NZ;
  var p1 = S0();
  NZ.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var FY = P((KY) => {
  var fa = function(Z, Q) {
    return ka.default(Z, Q, !0);
  };
  Object.defineProperty(KY, "__esModule", {
    value: !0
  });
  KY.default = void 0;
  var ka = C8(), n50 = KY.default = fa;
});

// node_modules/@babel/types/lib/traverse/traverse.js
var jY = P((RY) => {
  var ma = function(Z, Q, J) {
    if (typeof Q === "function")
      Q = {
        enter: Q
      };
    const {
      enter: X,
      exit: z
    } = Q;
    PZ(Z, X, z, J, []);
  }, PZ = function(Z, Q, J, X, z) {
    const Y = ya.VISITOR_KEYS[Z.type];
    if (!Y)
      return;
    if (Q)
      Q(Z, z, X);
    for (let W of Y) {
      const U = Z[W];
      if (Array.isArray(U))
        for (let V = 0;V < U.length; V++) {
          const M = U[V];
          if (!M)
            continue;
          z.push({
            node: Z,
            key: W,
            index: V
          }), PZ(M, Q, J, X, z), z.pop();
        }
      else if (U)
        z.push({
          node: Z,
          key: W
        }), PZ(U, Q, J, X, z), z.pop();
    }
    if (J)
      J(Z, z, X);
  };
  Object.defineProperty(RY, "__esModule", {
    value: !0
  });
  RY.default = ma;
  var ya = z1();
});

// node_modules/@babel/types/lib/validators/isBinding.js
var BY = P((OY) => {
  var ca = function(Z, Q, J) {
    if (J && Z.type === "Identifier" && Q.type === "ObjectProperty" && J.type === "ObjectExpression")
      return !1;
    const X = xa.default.keys[Q.type];
    if (X)
      for (let z = 0;z < X.length; z++) {
        const Y = X[z], W = Q[Y];
        if (Array.isArray(W)) {
          if (W.indexOf(Z) >= 0)
            return !0;
        } else if (W === Z)
          return !0;
      }
    return !1;
  };
  Object.defineProperty(OY, "__esModule", {
    value: !0
  });
  OY.default = ca;
  var xa = C8();
});

// node_modules/@babel/types/lib/validators/isLet.js
var SZ = P((qY) => {
  var pa = function(Z) {
    return ia.isVariableDeclaration(Z) && (Z.kind !== "var" || Z[da.BLOCK_SCOPED_SYMBOL]);
  };
  Object.defineProperty(qY, "__esModule", {
    value: !0
  });
  qY.default = pa;
  var ia = S0(), da = l1();
});

// node_modules/@babel/types/lib/validators/isBlockScoped.js
var IY = P((DY) => {
  var na = function(Z) {
    return $Y.isFunctionDeclaration(Z) || $Y.isClassDeclaration(Z) || ra.default(Z);
  };
  Object.defineProperty(DY, "__esModule", {
    value: !0
  });
  DY.default = na;
  var $Y = S0(), ra = SZ();
});

// node_modules/@babel/types/lib/validators/isImmutable.js
var AY = P((CY) => {
  var ea = function(Z) {
    if (ta.default(Z.type, "Immutable"))
      return !0;
    if (oa.isIdentifier(Z))
      if (Z.name === "undefined")
        return !0;
      else
        return !1;
    return !1;
  };
  Object.defineProperty(CY, "__esModule", {
    value: !0
  });
  CY.default = ea;
  var ta = K7(), oa = S0();
});

// node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var PY = P((NY) => {
  var wZ = function(Z, Q) {
    if (typeof Z !== "object" || typeof Q !== "object" || Z == null || Q == null)
      return Z === Q;
    if (Z.type !== Q.type)
      return !1;
    const J = Object.keys(LY.NODE_FIELDS[Z.type] || Z.type), X = LY.VISITOR_KEYS[Z.type];
    for (let z of J) {
      const Y = Z[z], W = Q[z];
      if (typeof Y !== typeof W)
        return !1;
      if (Y == null && W == null)
        continue;
      else if (Y == null || W == null)
        return !1;
      if (Array.isArray(Y)) {
        if (!Array.isArray(W))
          return !1;
        if (Y.length !== W.length)
          return !1;
        for (let U = 0;U < Y.length; U++)
          if (!wZ(Y[U], W[U]))
            return !1;
        continue;
      }
      if (typeof Y === "object" && !(X != null && X.includes(z))) {
        for (let U of Object.keys(Y))
          if (Y[U] !== W[U])
            return !1;
        continue;
      }
      if (!wZ(Y, W))
        return !1;
    }
    return !0;
  };
  Object.defineProperty(NY, "__esModule", {
    value: !0
  });
  NY.default = wZ;
  var LY = z1();
});

// node_modules/@babel/types/lib/validators/isReferenced.js
var wY = P((SY) => {
  var Jr = function(Z, Q, J) {
    switch (Q.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (Q.property === Z)
          return !!Q.computed;
        return Q.object === Z;
      case "JSXMemberExpression":
        return Q.object === Z;
      case "VariableDeclarator":
        return Q.init === Z;
      case "ArrowFunctionExpression":
        return Q.body === Z;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (Q.key === Z)
          return !!Q.computed;
        return !1;
      case "ObjectProperty":
        if (Q.key === Z)
          return !!Q.computed;
        return !J || J.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (Q.key === Z)
          return !!Q.computed;
        return !0;
      case "ClassPrivateProperty":
        return Q.key !== Z;
      case "ClassDeclaration":
      case "ClassExpression":
        return Q.superClass === Z;
      case "AssignmentExpression":
        return Q.right === Z;
      case "AssignmentPattern":
        return Q.right === Z;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        if (J != null && J.source)
          return !1;
        return Q.local === Z;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return Q.key !== Z;
      case "TSEnumMember":
        return Q.id !== Z;
      case "TSPropertySignature":
        if (Q.key === Z)
          return !!Q.computed;
        return !0;
    }
    return !0;
  };
  Object.defineProperty(SY, "__esModule", {
    value: !0
  });
  SY.default = Jr;
});

// node_modules/@babel/types/lib/validators/isScope.js
var vY = P((TY) => {
  var zr = function(Z, Q) {
    if (V5.isBlockStatement(Z) && (V5.isFunction(Q) || V5.isCatchClause(Q)))
      return !1;
    if (V5.isPattern(Z) && (V5.isFunction(Q) || V5.isCatchClause(Q)))
      return !0;
    return V5.isScopable(Z);
  };
  Object.defineProperty(TY, "__esModule", {
    value: !0
  });
  TY.default = zr;
  var V5 = S0();
});

// node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var gY = P((EY) => {
  var Yr = function(Z) {
    return bY.isImportDefaultSpecifier(Z) || bY.isIdentifier(Z.imported || Z.exported, {
      name: "default"
    });
  };
  Object.defineProperty(EY, "__esModule", {
    value: !0
  });
  EY.default = Yr;
  var bY = S0();
});

// node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var _Y = P((hY) => {
  var Vr = function(Z) {
    return Gr.default(Z) && !Ur.has(Z);
  };
  Object.defineProperty(hY, "__esModule", {
    value: !0
  });
  hY.default = Vr;
  var Gr = h5(), Ur = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
});

// node_modules/@babel/types/lib/validators/isVar.js
var fY = P((kY) => {
  var Rr = function(Z) {
    return Mr.isVariableDeclaration(Z, {
      kind: "var"
    }) && !Z[Fr.BLOCK_SCOPED_SYMBOL];
  };
  Object.defineProperty(kY, "__esModule", {
    value: !0
  });
  kY.default = Rr;
  var Mr = S0(), Fr = l1();
});

// node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var mY = P((yY) => {
  var P7 = function(Z, Q, J) {
    const X = [];
    let z = !0;
    for (let Y of Z) {
      if (!K5.isEmptyStatement(Y))
        z = !1;
      if (K5.isExpression(Y))
        X.push(Y);
      else if (K5.isExpressionStatement(Y))
        X.push(Y.expression);
      else if (K5.isVariableDeclaration(Y)) {
        if (Y.kind !== "var")
          return;
        for (let W of Y.declarations) {
          const U = Or.default(W);
          for (let V of Object.keys(U))
            J.push({
              kind: Y.kind,
              id: Br.default(U[V])
            });
          if (W.init)
            X.push(TZ.assignmentExpression("=", W.id, W.init));
        }
        z = !0;
      } else if (K5.isIfStatement(Y)) {
        const W = Y.consequent ? P7([Y.consequent], Q, J) : Q.buildUndefinedNode(), U = Y.alternate ? P7([Y.alternate], Q, J) : Q.buildUndefinedNode();
        if (!W || !U)
          return;
        X.push(TZ.conditionalExpression(Y.test, W, U));
      } else if (K5.isBlockStatement(Y)) {
        const W = P7(Y.body, Q, J);
        if (!W)
          return;
        X.push(W);
      } else if (K5.isEmptyStatement(Y)) {
        if (Z.indexOf(Y) === 0)
          z = !0;
      } else
        return;
    }
    if (z)
      X.push(Q.buildUndefinedNode());
    if (X.length === 1)
      return X[0];
    else
      return TZ.sequenceExpression(X);
  };
  Object.defineProperty(yY, "__esModule", {
    value: !0
  });
  yY.default = P7;
  var Or = C8(), K5 = S0(), TZ = r0(), Br = d1();
});

// node_modules/@babel/types/lib/converters/toSequenceExpression.js
var xY = P((uY) => {
  var Dr = function(Z, Q) {
    if (!(Z != null && Z.length))
      return;
    const J = [], X = $r.default(Z, Q, J);
    if (!X)
      return;
    for (let z of J)
      Q.push(z);
    return X;
  };
  Object.defineProperty(uY, "__esModule", {
    value: !0
  });
  uY.default = Dr;
  var $r = mY();
});

// node_modules/@babel/types/lib/index.js
var B1 = P((_) => {
  Object.defineProperty(_, "__esModule", {
    value: !0
  });
  var g1 = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(_, "__internal__deprecationWarning", {
    enumerable: !0,
    get: function() {
      return An.default;
    }
  });
  Object.defineProperty(_, "addComment", {
    enumerable: !0,
    get: function() {
      return gr.default;
    }
  });
  Object.defineProperty(_, "addComments", {
    enumerable: !0,
    get: function() {
      return hr.default;
    }
  });
  Object.defineProperty(_, "appendToMemberExpression", {
    enumerable: !0,
    get: function() {
      return nr.default;
    }
  });
  Object.defineProperty(_, "assertNode", {
    enumerable: !0,
    get: function() {
      return Nr.default;
    }
  });
  Object.defineProperty(_, "buildMatchMemberExpression", {
    enumerable: !0,
    get: function() {
      return Cn.default;
    }
  });
  Object.defineProperty(_, "clone", {
    enumerable: !0,
    get: function() {
      return Tr.default;
    }
  });
  Object.defineProperty(_, "cloneDeep", {
    enumerable: !0,
    get: function() {
      return vr.default;
    }
  });
  Object.defineProperty(_, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: function() {
      return br.default;
    }
  });
  Object.defineProperty(_, "cloneNode", {
    enumerable: !0,
    get: function() {
      return wr.default;
    }
  });
  Object.defineProperty(_, "cloneWithoutLoc", {
    enumerable: !0,
    get: function() {
      return Er.default;
    }
  });
  Object.defineProperty(_, "createFlowUnionType", {
    enumerable: !0,
    get: function() {
      return cY.default;
    }
  });
  Object.defineProperty(_, "createTSUnionType", {
    enumerable: !0,
    get: function() {
      return Sr.default;
    }
  });
  Object.defineProperty(_, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: function() {
      return Pr.default;
    }
  });
  Object.defineProperty(_, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return cY.default;
    }
  });
  Object.defineProperty(_, "ensureBlock", {
    enumerable: !0,
    get: function() {
      return ur.default;
    }
  });
  Object.defineProperty(_, "getBindingIdentifiers", {
    enumerable: !0,
    get: function() {
      return Qn.default;
    }
  });
  Object.defineProperty(_, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: function() {
      return Jn.default;
    }
  });
  Object.defineProperty(_, "inheritInnerComments", {
    enumerable: !0,
    get: function() {
      return _r.default;
    }
  });
  Object.defineProperty(_, "inheritLeadingComments", {
    enumerable: !0,
    get: function() {
      return kr.default;
    }
  });
  Object.defineProperty(_, "inheritTrailingComments", {
    enumerable: !0,
    get: function() {
      return yr.default;
    }
  });
  Object.defineProperty(_, "inherits", {
    enumerable: !0,
    get: function() {
      return sr.default;
    }
  });
  Object.defineProperty(_, "inheritsComments", {
    enumerable: !0,
    get: function() {
      return fr.default;
    }
  });
  Object.defineProperty(_, "is", {
    enumerable: !0,
    get: function() {
      return Hn.default;
    }
  });
  Object.defineProperty(_, "isBinding", {
    enumerable: !0,
    get: function() {
      return Yn.default;
    }
  });
  Object.defineProperty(_, "isBlockScoped", {
    enumerable: !0,
    get: function() {
      return Wn.default;
    }
  });
  Object.defineProperty(_, "isImmutable", {
    enumerable: !0,
    get: function() {
      return Gn.default;
    }
  });
  Object.defineProperty(_, "isLet", {
    enumerable: !0,
    get: function() {
      return Un.default;
    }
  });
  Object.defineProperty(_, "isNode", {
    enumerable: !0,
    get: function() {
      return Vn.default;
    }
  });
  Object.defineProperty(_, "isNodesEquivalent", {
    enumerable: !0,
    get: function() {
      return Kn.default;
    }
  });
  Object.defineProperty(_, "isPlaceholderType", {
    enumerable: !0,
    get: function() {
      return Mn.default;
    }
  });
  Object.defineProperty(_, "isReferenced", {
    enumerable: !0,
    get: function() {
      return Fn.default;
    }
  });
  Object.defineProperty(_, "isScope", {
    enumerable: !0,
    get: function() {
      return Rn.default;
    }
  });
  Object.defineProperty(_, "isSpecifierDefault", {
    enumerable: !0,
    get: function() {
      return jn.default;
    }
  });
  Object.defineProperty(_, "isType", {
    enumerable: !0,
    get: function() {
      return On.default;
    }
  });
  Object.defineProperty(_, "isValidES3Identifier", {
    enumerable: !0,
    get: function() {
      return Bn.default;
    }
  });
  Object.defineProperty(_, "isValidIdentifier", {
    enumerable: !0,
    get: function() {
      return qn.default;
    }
  });
  Object.defineProperty(_, "isVar", {
    enumerable: !0,
    get: function() {
      return $n.default;
    }
  });
  Object.defineProperty(_, "matchesPattern", {
    enumerable: !0,
    get: function() {
      return Dn.default;
    }
  });
  Object.defineProperty(_, "prependToMemberExpression", {
    enumerable: !0,
    get: function() {
      return tr.default;
    }
  });
  _.react = void 0;
  Object.defineProperty(_, "removeComments", {
    enumerable: !0,
    get: function() {
      return mr.default;
    }
  });
  Object.defineProperty(_, "removeProperties", {
    enumerable: !0,
    get: function() {
      return or.default;
    }
  });
  Object.defineProperty(_, "removePropertiesDeep", {
    enumerable: !0,
    get: function() {
      return er.default;
    }
  });
  Object.defineProperty(_, "removeTypeDuplicates", {
    enumerable: !0,
    get: function() {
      return Zn.default;
    }
  });
  Object.defineProperty(_, "shallowEqual", {
    enumerable: !0,
    get: function() {
      return zn.default;
    }
  });
  Object.defineProperty(_, "toBindingIdentifierName", {
    enumerable: !0,
    get: function() {
      return xr.default;
    }
  });
  Object.defineProperty(_, "toBlock", {
    enumerable: !0,
    get: function() {
      return cr.default;
    }
  });
  Object.defineProperty(_, "toComputedKey", {
    enumerable: !0,
    get: function() {
      return lr.default;
    }
  });
  Object.defineProperty(_, "toExpression", {
    enumerable: !0,
    get: function() {
      return ir.default;
    }
  });
  Object.defineProperty(_, "toIdentifier", {
    enumerable: !0,
    get: function() {
      return dr.default;
    }
  });
  Object.defineProperty(_, "toKeyAlias", {
    enumerable: !0,
    get: function() {
      return pr.default;
    }
  });
  Object.defineProperty(_, "toStatement", {
    enumerable: !0,
    get: function() {
      return ar.default;
    }
  });
  Object.defineProperty(_, "traverse", {
    enumerable: !0,
    get: function() {
      return S7.default;
    }
  });
  Object.defineProperty(_, "traverseFast", {
    enumerable: !0,
    get: function() {
      return Xn.default;
    }
  });
  Object.defineProperty(_, "validate", {
    enumerable: !0,
    get: function() {
      return In.default;
    }
  });
  Object.defineProperty(_, "valueToNode", {
    enumerable: !0,
    get: function() {
      return rr.default;
    }
  });
  var Cr = B4(), Ar = $4(), Lr = k9(), Nr = m9(), vZ = x9();
  Object.keys(vZ).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === vZ[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return vZ[Z];
      }
    });
  });
  var Pr = i9(), cY = n9(), Sr = QH(), bZ = r0();
  Object.keys(bZ).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === bZ[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return bZ[Z];
      }
    });
  });
  var EZ = JH();
  Object.keys(EZ).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === EZ[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return EZ[Z];
      }
    });
  });
  var gZ = HH();
  Object.keys(gZ).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === gZ[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return gZ[Z];
      }
    });
  });
  var wr = d1(), Tr = FH(), vr = jH(), br = BH(), Er = $H(), gr = CH(), hr = MZ(), _r = FZ(), kr = RZ(), fr = OZ(), yr = jZ(), mr = TH(), hZ = EH();
  Object.keys(hZ).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === hZ[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return hZ[Z];
      }
    });
  });
  var _Z = l1();
  Object.keys(_Z).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === _Z[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return _Z[Z];
      }
    });
  });
  var ur = _H(), xr = yH(), cr = qZ(), lr = uH(), ir = lH(), dr = $Z(), pr = sH(), ar = eH(), rr = JY(), kZ = z1();
  Object.keys(kZ).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === kZ[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return kZ[Z];
      }
    });
  });
  var nr = zY(), sr = WY(), tr = UY(), or = CZ(), er = AZ(), Zn = KZ(), Qn = C8(), Jn = FY(), S7 = jY();
  Object.keys(S7).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === S7[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return S7[Z];
      }
    });
  });
  var Xn = IZ(), zn = V7(), Hn = g5(), Yn = BY(), Wn = IY(), Gn = AY(), Un = SZ(), Vn = VZ(), Kn = PY(), Mn = l6(), Fn = wY(), Rn = vY(), jn = gY(), On = K7(), Bn = _Y(), qn = h5(), $n = fY(), Dn = x6(), In = B7(), Cn = c6(), fZ = S0();
  Object.keys(fZ).forEach(function(Z) {
    if (Z === "default" || Z === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(g1, Z))
      return;
    if (Z in _ && _[Z] === fZ[Z])
      return;
    Object.defineProperty(_, Z, {
      enumerable: !0,
      get: function() {
        return fZ[Z];
      }
    });
  });
  var An = V8(), V80 = _.react = {
    isReactComponent: Cr.default,
    isCompatTag: Ar.default,
    buildChildren: Lr.default
  };
  _.toSequenceExpression = xY().default;
});

// node_modules/constantinople/lib/binaryOperation.js
var iY = P((Nn) => {
  var Ln = function(Z, Q, J) {
    switch (Z) {
      case "+":
        return Q + J;
      case "-":
        return Q - J;
      case "/":
        return Q / J;
      case "%":
        return Q % J;
      case "*":
        return Q * J;
      case "**":
        return Math.pow(Q, J);
      case "&":
        return Q & J;
      case "|":
        return Q | J;
      case ">>":
        return Q >> J;
      case ">>>":
        return Q >>> J;
      case "<<":
        return Q << J;
      case "^":
        return Q ^ J;
      case "==":
        return Q == J;
      case "===":
        return Q === J;
      case "!=":
        return Q != J;
      case "!==":
        return Q !== J;
      case "in":
        return Q in J;
      case "instanceof":
        return Q instanceof J;
      case ">":
        return Q > J;
      case "<":
        return Q < J;
      case ">=":
        return Q >= J;
      case "<=":
        return Q <= J;
    }
  };
  Nn.__esModule = !0;
  Nn.default = Ln;
});

// node_modules/constantinople/lib/index.js
var w7 = P((R80, m5) => {
  var mZ = function(Z, Q) {
    if (Q === void 0)
      Q = {};
    var J = !0;
    function X(Y) {
      if (!J)
        return;
      if (F0.isArrayExpression(Y)) {
        var W = [];
        for (var U = 0;J && U < Y.elements.length; U++) {
          var V = Y.elements[U];
          if (F0.isSpreadElement(V)) {
            var M = X(V.argument);
            if (!(dY(M) && J))
              J = !1;
            else
              W.push.apply(W, M);
          } else if (F0.isExpression(V))
            W.push(X(V));
          else
            J = !1;
        }
        return W;
      }
      if (F0.isBinaryExpression(Y)) {
        var q = X(Y.left), L = X(Y.right);
        return J && Tn.default(Y.operator, q, L);
      }
      if (F0.isBooleanLiteral(Y))
        return Y.value;
      if (F0.isCallExpression(Y)) {
        var N = [];
        for (var U = 0;J && U < Y.arguments.length; U++) {
          var T = Y.arguments[U];
          if (F0.isSpreadElement(T)) {
            var M = X(T.argument);
            if (!(dY(M) && J))
              J = !1;
            else
              N.push.apply(N, M);
          } else if (F0.isExpression(T))
            N.push(X(T));
          else
            J = !1;
        }
        if (!J)
          return;
        if (F0.isMemberExpression(Y.callee)) {
          var E = X(Y.callee.object);
          if (!E || !J) {
            J = !1;
            return;
          }
          var g = Y.callee.computed ? X(Y.callee.property) : F0.isIdentifier(Y.callee.property) ? Y.callee.property.name : void 0;
          if (g === void 0 && !Y.callee.computed)
            J = !1;
          if (!J)
            return;
          if (vn(E, "" + g))
            return E[g].apply(E, N);
        } else {
          if (!F0.isExpression(Y.callee)) {
            J = !1;
            return;
          }
          var n = X(Y.callee);
          if (!J)
            return;
          return n.apply(null, N);
        }
      }
      if (F0.isConditionalExpression(Y)) {
        var x = X(Y.test);
        return x ? X(Y.consequent) : X(Y.alternate);
      }
      if (F0.isIdentifier(Y)) {
        if (Q.constants && {}.hasOwnProperty.call(Q.constants, Y.name))
          return Q.constants[Y.name];
      }
      if (F0.isLogicalExpression(Y)) {
        var q = X(Y.left), L = X(Y.right);
        if (J && Y.operator === "&&")
          return q && L;
        if (J && Y.operator === "||")
          return q || L;
      }
      if (F0.isMemberExpression(Y)) {
        var E = X(Y.object);
        if (!E || !J) {
          J = !1;
          return;
        }
        var g = Y.computed ? X(Y.property) : F0.isIdentifier(Y.property) ? Y.property.name : void 0;
        if (g === void 0 && !Y.computed)
          J = !1;
        if (!J)
          return;
        if ({}.hasOwnProperty.call(E, "" + g) && g[0] !== "_")
          return E[g];
      }
      if (F0.isNullLiteral(Y))
        return null;
      if (F0.isNumericLiteral(Y))
        return Y.value;
      if (F0.isObjectExpression(Y)) {
        var d = {};
        for (var U = 0;J && U < Y.properties.length; U++) {
          var y = Y.properties[U];
          if (F0.isObjectProperty(y)) {
            if (y.shorthand) {
              J = !1;
              return;
            }
            var R = y.computed ? X(y.key) : F0.isIdentifier(y.key) ? y.key.name : F0.isStringLiteral(y.key) ? y.key.value : void 0;
            if (!R || R[0] === "_")
              J = !1;
            if (!J)
              return;
            if (F0.isExpression(y.value)) {
              var L0 = X(y.value);
              if (!J)
                return;
              d[R] = L0;
            } else
              J = !1;
          } else if (F0.isObjectMethod(y))
            J = !1;
          else if (F0.isSpreadProperty(y)) {
            var B0 = X(y.argument);
            if (!B0)
              J = !1;
            if (!J)
              return;
            Object.assign(d, B0);
          }
        }
        return d;
      }
      if (F0.isParenthesizedExpression(Y))
        return X(Y.expression);
      if (F0.isRegExpLiteral(Y))
        return new RegExp(Y.pattern, Y.flags);
      if (F0.isSequenceExpression(Y)) {
        for (var U = 0;U < Y.expressions.length - 1 && J; U++)
          X(Y.expressions[U]);
        return X(Y.expressions[Y.expressions.length - 1]);
      }
      if (F0.isStringLiteral(Y))
        return Y.value;
      if (F0.isTemplateLiteral(Y)) {
        var e = "";
        for (var U = 0;U < Y.quasis.length; U++) {
          var q0 = Y.quasis[U];
          if (e += q0.value.cooked, U < Y.expressions.length)
            e += "" + X(Y.expressions[U]);
        }
        return e;
      }
      if (F0.isUnaryExpression(Y)) {
        var B0 = X(Y.argument);
        if (!J)
          return;
        switch (Y.operator) {
          case "-":
            return -B0;
          case "+":
            return +B0;
          case "!":
            return !B0;
          case "~":
            return ~B0;
          case "typeof":
            return typeof B0;
          case "void":
            return;
        }
      }
      J = !1;
    }
    var z = X(Z);
    return J ? { constant: !0, result: z } : { constant: !1 };
  }, dY = function(Z) {
    return typeof Z === "string" || Array.isArray(Z) || typeof Set !== "undefined" && Z instanceof Set || typeof Map !== "undefined" && Z instanceof Map;
  }, pY = function(Z, Q) {
    if (Z === Q)
      return !0;
    if (Z && Q && typeof Z === "object" && typeof Q === "object") {
      for (var J in Z)
        if (Z[J] !== Q[J])
          return !1;
      for (var J in Q)
        if (Z[J] !== Q[J])
          return !1;
      return !0;
    }
    return !1;
  }, vn = function(Z, Q) {
    switch (typeof Z) {
      case "boolean":
        switch (Q) {
          case "toString":
            return !0;
          default:
            return !1;
        }
      case "number":
        switch (Q) {
          case "toExponential":
          case "toFixed":
          case "toPrecision":
          case "toString":
            return !0;
          default:
            return !1;
        }
      case "string":
        switch (Q) {
          case "charAt":
          case "charCodeAt":
          case "codePointAt":
          case "concat":
          case "endsWith":
          case "includes":
          case "indexOf":
          case "lastIndexOf":
          case "match":
          case "normalize":
          case "padEnd":
          case "padStart":
          case "repeat":
          case "replace":
          case "search":
          case "slice":
          case "split":
          case "startsWith":
          case "substr":
          case "substring":
          case "toLowerCase":
          case "toUpperCase":
          case "trim":
            return !0;
          default:
            return !1;
        }
      default:
        if (Z instanceof RegExp)
          switch (Q) {
            case "test":
            case "exec":
              return !0;
            default:
              return !1;
          }
        return {}.hasOwnProperty.call(Z, Q) && Q[0] !== "_";
    }
  }, y5 = function(Z, Q, J) {
    if (Q === void 0)
      Q = f5;
    if (J === void 0)
      J = f5;
    if (aY === Z && pY(rY, Q) && pY(bn, J))
      return yZ;
    aY = Z, rY = Q;
    var X;
    try {
      X = wn.parseExpression(Z, J);
    } catch (U) {
      return yZ = !1;
    }
    var z = mZ(X, { constants: Q }), Y = z.result, W = z.constant;
    return nY = Y, yZ = W;
  }, sY = function(Z, Q, J) {
    if (Q === void 0)
      Q = f5;
    if (J === void 0)
      J = f5;
    if (!y5(Z, Q, J))
      throw new Error(JSON.stringify(Z) + " is not constant.");
    return nY;
  };
  R80.__esModule = !0;
  var wn = u6(), F0 = B1(), Tn = iY();
  R80.expressionToConstant = mZ;
  var f5 = {}, aY = "", rY = f5, bn = f5, nY = null, yZ = !1;
  R80.isConstant = y5;
  R80.toConstant = sY;
  R80.default = y5;
  m5.exports = y5;
  m5.exports.default = y5;
  m5.exports.expressionToConstant = mZ;
  m5.exports.isConstant = y5;
  m5.exports.toConstant = sY;
});

// node_modules/pug-filters/lib/handle-filters.js
var eY = P((j80, oY) => {
  var tY = function(Z, Q, J, X) {
    J = J || {}, mn(Z, function(Y) {
      var W = Y.filename ? fn(Y.filename) : null;
      if (Y.type === "Filter") {
        xn(Y, Q, J, X);
        var U = cn(Y), V = uZ(Y, J);
        V.filename = Y.filename, Y.type = "Text", Y.val = L(Y, U, V);
      } else if (Y.type === "RawInclude" && Y.filters.length) {
        var M = Y.filters.pop(), V = uZ(M, J), q = V.filename = Y.file.fullPath;
        Y.type = "Text", Y.val = N(M, q, Y.file, V), Y.filters.slice().reverse().forEach(function(E) {
          var g = uZ(E, J);
          g.filename = q, Y.val = L(E, Y.val, g);
        }), Y.filters = void 0, Y.file = void 0;
      }
      function L(T, E, g, n) {
        try {
          var x = z(T);
          if (Q && Q[x])
            return Q[x](E, g);
          else
            return un(x, E, g, W, n);
        } catch (d) {
          if (d.code === "UNKNOWN_FILTER")
            throw xZ(d.code, d.message, T);
          throw d;
        }
      }
      function N(T, E, g, n) {
        var x = z(T);
        if (Q && Q[x])
          if (Q[x].renderBuffer)
            return Q[x].renderBuffer(g.raw, n);
          else
            return Q[x](g.str, n);
        else
          return L(T, E, n, "renderFile");
      }
    }, { includeDependencies: !0 });
    function z(Y) {
      var W = Y.name;
      if (X && X[W]) {
        if (W = X[W], X[W])
          throw xZ("FILTER_ALISE_CHAIN", 'The filter "' + Y.name + '" is an alias for "' + W + '", which is an alias for "' + X[W] + '".  Pug does not support chains of filter aliases.', Y);
      }
      return W;
    }
    return Z;
  }, xn = function(Z, Q, J, X) {
    if (Z.block.nodes[0] && Z.block.nodes[0].type === "Filter")
      Z.block.nodes[0] = tY(Z.block, Q, J, X).nodes[0];
  }, cn = function(Z) {
    return Z.block.nodes.map(function(Q) {
      return Q.val;
    }).join("");
  }, uZ = function(Z, Q) {
    var J = {};
    Z.attrs.forEach(function(z) {
      try {
        J[z.name] = z.val === !0 ? !0 : yn.toConstant(z.val);
      } catch (Y) {
        if (/not constant/.test(Y.message))
          throw xZ("FILTER_OPTION_NOT_CONSTANT", Y.message + " All filters are rendered compile-time so filter options must be constants.", Z);
        throw Y;
      }
    });
    var X = Q[Z.name] || {};
    return Object.keys(X).forEach(function(z) {
      if (!J.hasOwnProperty(z))
        J[z] = X[z];
    }), J;
  }, fn = A0("path").dirname, yn = w7(), mn = p8(), xZ = Q5(), un = B6();
  oY.exports = tY;
});

// node_modules/pug-filters/index.js
var ZW = P((ln) => {
  ln.runFilter = B6();
  ln.handleFilters = eY();
});

// node_modules/pug-linker/index.js
var XW = P((B80, JW) => {
  var cZ = function() {
    throw Q5().apply(null, arguments);
  }, lZ = function(Z) {
    an(Z.type === "Block", "The top level element should always be a block");
    var Q = null;
    if (Z.nodes.length) {
      var J = Z.nodes[0].type === "Extends";
      if (en(Z, J), J)
        Q = Z.nodes.shift();
    }
    if (Z = sn(Z), Z.declaredBlocks = rn(Z), Q) {
      var X = [], z = [];
      Z.nodes.forEach(function U(V) {
        if (V.type === "NamedBlock")
          z.push(V);
        else if (V.type === "Block")
          V.nodes.forEach(U);
        else if (V.type === "Mixin" && V.call === !1)
          X.push(V);
        else
          cZ("UNEXPECTED_NODES_IN_EXTENDING_ROOT", "Only named blocks and mixins can appear at the top level of an extending template", V);
      });
      var Y = lZ(Q.file.ast);
      nn(Y.declaredBlocks, Z);
      var W = [];
      return M5(Y, function(U) {
        if (U.type === "NamedBlock")
          W.push(U.name);
      }), z.forEach(function(U) {
        if (W.indexOf(U.name) === -1)
          cZ("UNEXPECTED_BLOCK", "Unexpected block " + U.name, U);
      }), Object.keys(Z.declaredBlocks).forEach(function(U) {
        Y.declaredBlocks[U] = Z.declaredBlocks[U];
      }), Y.nodes = X.concat(Y.nodes), Y.hasExtends = !0, Y;
    }
    return Z;
  }, rn = function(Z) {
    var Q = {};
    return M5(Z, function J(X) {
      if (X.type === "NamedBlock" && X.mode === "replace")
        Q[X.name] = Q[X.name] || [], Q[X.name].push(X);
    }), Q;
  }, QW = function(Z, Q) {
    return Q = Q || [], Z.forEach(function(J) {
      if (J.parents)
        QW(J.parents, Q);
      Q.push(J);
    }), Q;
  }, nn = function(Z, Q) {
    var J = {};
    M5(Q, function X(z) {
      if (z.type === "NamedBlock") {
        if (J[z.name] === z.name)
          return z.ignore = !0;
        J[z.name] = z.name;
        var Y = Z[z.name] ? QW(Z[z.name]) : [];
        if (Y.length)
          z.parents = Y, Y.forEach(function(W) {
            switch (z.mode) {
              case "append":
                W.nodes = W.nodes.concat(z.nodes);
                break;
              case "prepend":
                W.nodes = z.nodes.concat(W.nodes);
                break;
              case "replace":
                W.nodes = z.nodes;
                break;
            }
          });
      }
    }, function X(z) {
      if (z.type === "NamedBlock" && !z.ignore)
        delete J[z.name];
    });
  }, sn = function(Z, Q) {
    return M5(Z, function J(X, z) {
      if (X.type === "RawInclude")
        z({ type: "Text", val: X.file.str.replace(/\r/g, "") });
    }, function J(X, z) {
      if (X.type === "Include") {
        var Y = lZ(X.file.ast);
        if (Y.hasExtends)
          Y = tn(Y);
        z(on(Y, X.block));
      }
    });
  }, tn = function(Z) {
    return M5(Z, function(Q, J) {
      if (Q.type === "NamedBlock")
        J({
          type: "Block",
          nodes: Q.nodes
        });
    });
  }, on = function(Z, Q) {
    if (!Q || !Q.nodes.length)
      return Z;
    var J = !1;
    Z = M5(Z, null, function(z, Y) {
      if (z.type === "YieldBlock")
        J = !0, z.type = "Block", z.nodes = [Q];
    });
    function X(z) {
      var Y = z;
      for (var W = 0;W < z.nodes.length; W++) {
        if (z.nodes[W].textOnly)
          continue;
        if (z.nodes[W].type === "Block")
          Y = X(z.nodes[W]);
        else if (z.nodes[W].block && z.nodes[W].block.nodes.length)
          Y = X(z.nodes[W].block);
      }
      return Y;
    }
    if (!J)
      X(Z).nodes.push(Q);
    return Z;
  }, en = function(Z, Q) {
    var J = !1;
    M5(Z, function(X) {
      if (X.type === "Extends")
        if (Q && !J)
          J = !0;
        else
          cZ("EXTENDS_NOT_FIRST", 'Declaration of template inheritance ("extends") should be the first thing in the file. There can only be one extends statement per file.', X);
    });
  }, an = A0("assert"), M5 = p8();
  JW.exports = lZ;
});

// node_modules/doctypes/index.js
var HW = P((q80, zW) => {
  zW.exports = {
    html: "<!DOCTYPE html>",
    xml: '<?xml version="1.0" encoding="utf-8" ?>',
    transitional: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
    strict: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
    frameset: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
    "1.1": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
    basic: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">',
    mobile: '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">',
    plist: '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
  };
});

// node_modules/pug-runtime/lib/dependencies.js
var WW = P(($80, YW) => {
  YW.exports = {
    has_own_property: [],
    merge: [
      "style"
    ],
    classes_array: [
      "classes",
      "escape"
    ],
    classes_object: [
      "has_own_property"
    ],
    classes: [
      "classes_array",
      "classes_object"
    ],
    style: [
      "has_own_property"
    ],
    attr: [
      "escape"
    ],
    attrs: [
      "attr",
      "classes",
      "has_own_property",
      "style"
    ],
    match_html: [],
    escape: [
      "match_html"
    ],
    rethrow: []
  };
});

// node_modules/pug-runtime/lib/internals.js
var UW = P((D80, GW) => {
  GW.exports = {
    dependencies: !0,
    internals: !0,
    has_own_property: !0,
    classes_array: !0,
    classes_object: !0,
    match_html: !0
  };
});

// node_modules/pug-runtime/lib/sources.js
var KW = P((I80, VW) => {
  VW.exports = {
    has_own_property: "var pug_has_own_property=Object.prototype.hasOwnProperty;",
    merge: "function pug_merge(e,r){if(1===arguments.length){for(var t=e[0],g=1;g<e.length;g++)t=pug_merge(t,e[g]);return t}for(var l in r)if(\"class\"===l){var n=e[l]||[];e[l]=(Array.isArray(n)?n:[n]).concat(r[l]||[])}else if(\"style\"===l){var n=pug_style(e[l]);n=n&&\";\"!==n[n.length-1]?n+\";\":n;var a=pug_style(r[l]);a=a&&\";\"!==a[a.length-1]?a+\";\":a,e[l]=n+a}else e[l]=r[l];return e}",
    classes_array: "function pug_classes_array(r,a){for(var s,e=\"\",u=\"\",c=Array.isArray(a),g=0;g<r.length;g++)(s=pug_classes(r[g]))&&(c&&a[g]&&(s=pug_escape(s)),e=e+u+s,u=\" \");return e}",
    classes_object: "function pug_classes_object(r){var a=\"\",n=\"\";for(var o in r)o&&r[o]&&pug_has_own_property.call(r,o)&&(a=a+n+o,n=\" \");return a}",
    classes: "function pug_classes(s,r){return Array.isArray(s)?pug_classes_array(s,r):s&&\"object\"==typeof s?pug_classes_object(s):s||\"\"}",
    style: "function pug_style(r){if(!r)return\"\";if(\"object\"==typeof r){var t=\"\";for(var e in r)pug_has_own_property.call(r,e)&&(t=t+e+\":\"+r[e]+\";\");return t}return r+\"\"}",
    attr: "function pug_attr(t,e,n,r){if(!1===e||null==e||!e&&(\"class\"===t||\"style\"===t))return\"\";if(!0===e)return\" \"+(r?t:t+'=\"'+t+'\"');var f=typeof e;return\"object\"!==f&&\"function\"!==f||\"function\"!=typeof e.toJSON||(e=e.toJSON()),\"string\"==typeof e||(e=JSON.stringify(e),n||-1===e.indexOf('\"'))?(n&&(e=pug_escape(e)),\" \"+t+'=\"'+e+'\"'):\" \"+t+\"='\"+e.replace(/'/g,\"&#39;\")+\"'\"}",
    attrs: "function pug_attrs(t,r){var a=\"\";for(var s in t)if(pug_has_own_property.call(t,s)){var u=t[s];if(\"class\"===s){u=pug_classes(u),a=pug_attr(s,u,!1,r)+a;continue}\"style\"===s&&(u=pug_style(u)),a+=pug_attr(s,u,!1,r)}return a}",
    match_html: "var pug_match_html=/[\"&<>]/;",
    escape: "function pug_escape(e){var a=\"\"+e,t=pug_match_html.exec(a);if(!t)return e;var r,c,n,s=\"\";for(r=t.index,c=0;r<a.length;r++){switch(a.charCodeAt(r)){case 34:n=\"&quot;\";break;case 38:n=\"&amp;\";break;case 60:n=\"&lt;\";break;case 62:n=\"&gt;\";break;default:continue}c!==r&&(s+=a.substring(c,r)),c=r+1,s+=n}return c!==r?s+a.substring(c,r):s}",
    rethrow: "function pug_rethrow(e,n,r,t){if(!(e instanceof Error))throw e;if(!(\"undefined\"==typeof window&&n||t))throw e.message+=\" on line \"+r,e;var o,a,i,s;try{t=t||require(\"fs\").readFileSync(n,{encoding:\"utf8\"}),o=3,a=t.split(\"\\n\"),i=Math.max(r-o,0),s=Math.min(a.length,r+o)}catch(t){return e.message+=\" - could not read from \"+n+\" (\"+t.message+\")\",void pug_rethrow(e,null,r)}o=a.slice(i,s).map(function(e,n){var t=n+i+1;return(t==r?\"  > \":\"    \")+t+\"| \"+e}).join(\"\\n\"),e.path=n;try{e.message=(n||\"Pug\")+\":\"+r+\"\\n\"+o+\"\\n\\n\"+e.message}catch(e){}throw e}"
  };
});

// node_modules/pug-runtime/build.js
var FW = P((A80, MW) => {
  var Xs = function(Z) {
    var Q = [];
    Z = Z.filter(function(X) {
      return !Qs[X];
    });
    for (var J = 0;J < Z.length; J++)
      if (Q.indexOf(Z[J]) === -1)
        Q.push(Z[J]), Z.push.apply(Z, Zs[Z[J]]);
    return Q.sort().map(function(X) {
      return Js[X];
    }).join("\n");
  }, C80 = A0("fs"), Zs = WW(), Qs = UW(), Js = KW();
  MW.exports = Xs;
});

// node_modules/pug-runtime/index.js
var A8 = P((Gs) => {
  var RW = function(Z, Q) {
    if (arguments.length === 1) {
      var J = Z[0];
      for (var X = 1;X < Z.length; X++)
        J = RW(J, Z[X]);
      return J;
    }
    for (var z in Q)
      if (z === "class") {
        var Y = Z[z] || [];
        Z[z] = (Array.isArray(Y) ? Y : [Y]).concat(Q[z] || []);
      } else if (z === "style") {
        var Y = T7(Z[z]);
        Y = Y && Y[Y.length - 1] !== ";" ? Y + ";" : Y;
        var W = T7(Q[z]);
        W = W && W[W.length - 1] !== ";" ? W + ";" : W, Z[z] = Y + W;
      } else
        Z[z] = Q[z];
    return Z;
  }, zs = function(Z, Q) {
    var J = "", X, z = "", Y = Array.isArray(Q);
    for (var W = 0;W < Z.length; W++) {
      if (X = pZ(Z[W]), !X)
        continue;
      Y && Q[W] && (X = aZ(X)), J = J + z + X, z = " ";
    }
    return J;
  }, Hs = function(Z) {
    var Q = "", J = "";
    for (var X in Z)
      if (X && Z[X] && dZ.call(Z, X))
        Q = Q + J + X, J = " ";
    return Q;
  }, pZ = function(Z, Q) {
    if (Array.isArray(Z))
      return zs(Z, Q);
    else if (Z && typeof Z === "object")
      return Hs(Z);
    else
      return Z || "";
  }, T7 = function(Z) {
    if (!Z)
      return "";
    if (typeof Z === "object") {
      var Q = "";
      for (var J in Z)
        if (dZ.call(Z, J))
          Q = Q + J + ":" + Z[J] + ";";
      return Q;
    } else
      return Z + "";
  }, iZ = function(Z, Q, J, X) {
    if (Q === !1 || Q == null || !Q && (Z === "class" || Z === "style"))
      return "";
    if (Q === !0)
      return " " + (X ? Z : Z + '="' + Z + '"');
    var z = typeof Q;
    if ((z === "object" || z === "function") && typeof Q.toJSON === "function")
      Q = Q.toJSON();
    if (typeof Q !== "string") {
      if (Q = JSON.stringify(Q), !J && Q.indexOf('"') !== -1)
        return " " + Z + "='" + Q.replace(/'/g, "&#39;") + "'";
    }
    if (J)
      Q = aZ(Q);
    return " " + Z + '="' + Q + '"';
  }, Ys = function(Z, Q) {
    var J = "";
    for (var X in Z)
      if (dZ.call(Z, X)) {
        var z = Z[X];
        if (X === "class") {
          z = pZ(z), J = iZ(X, z, !1, Q) + J;
          continue;
        }
        if (X === "style")
          z = T7(z);
        J += iZ(X, z, !1, Q);
      }
    return J;
  }, aZ = function(Z) {
    var Q = "" + Z, J = Ws.exec(Q);
    if (!J)
      return Z;
    var X = "", z, Y, W;
    for (z = J.index, Y = 0;z < Q.length; z++) {
      switch (Q.charCodeAt(z)) {
        case 34:
          W = "&quot;";
          break;
        case 38:
          W = "&amp;";
          break;
        case 60:
          W = "&lt;";
          break;
        case 62:
          W = "&gt;";
          break;
        default:
          continue;
      }
      if (Y !== z)
        X += Q.substring(Y, z);
      Y = z + 1, X += W;
    }
    if (Y !== z)
      return X + Q.substring(Y, z);
    else
      return X;
  }, jW = function(Z, Q, J, X) {
    if (!(Z instanceof Error))
      throw Z;
    if ((typeof window != "undefined" || !Q) && !X)
      throw Z.message += " on line " + J, Z;
    var z, Y, W, U;
    try {
      X = X || A0("fs").readFileSync(Q, { encoding: "utf8" }), z = 3, Y = X.split("\n"), W = Math.max(J - z, 0), U = Math.min(Y.length, J + z);
    } catch (V) {
      Z.message += " - could not read from " + Q + " (" + V.message + ")", jW(Z, null, J);
      return;
    }
    z = Y.slice(W, U).map(function(V, M) {
      var q = M + W + 1;
      return (q == J ? "  > " : "    ") + q + "| " + V;
    }).join("\n"), Z.path = Q;
    try {
      Z.message = (Q || "Pug") + ":" + J + "\n" + z + "\n\n" + Z.message;
    } catch (V) {
    }
    throw Z;
  }, dZ = Object.prototype.hasOwnProperty;
  Gs.merge = RW;
  Gs.classes = pZ;
  Gs.style = T7;
  Gs.attr = iZ;
  Gs.attrs = Ys;
  var Ws = /["&<>]/;
  Gs.escape = aZ;
  Gs.rethrow = jW;
});

// node_modules/js-stringify/index.js
var rZ = P((N80, BW) => {
  var OW = function(Z) {
    if (Z instanceof Date)
      return "new Date(" + OW(Z.toISOString()) + ")";
    if (Z === void 0)
      return "undefined";
    return JSON.stringify(Z).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/</g, "\\u003C").replace(/>/g, "\\u003E").replace(/\//g, "\\u002F");
  };
  BW.exports = OW;
});

// node_modules/pug-attrs/index.js
var DW = P((P80, $W) => {
  var v7 = function(Z) {
    return qW(Z, { pug: F5, pug_interp: void 0 });
  }, x5 = function(Z) {
    return qW.toConstant(Z, { pug: F5, pug_interp: void 0 });
  }, Os = function(Z, Q) {
    u5(Array.isArray(Z), "Attrs should be an array"), u5(Z.every(function(U) {
      return U && typeof U === "object" && typeof U.name === "string" && (typeof U.val === "string" || typeof U.val === "boolean") && typeof U.mustEscape === "boolean";
    }), "All attributes should be supplied as an object of the form {name, val, mustEscape}"), u5(Q && typeof Q === "object", "Options should be an object"), u5(typeof Q.terse === "boolean", "Options.terse should be a boolean"), u5(typeof Q.runtime === "function", "Options.runtime should be a function that takes a runtime function name and returns the source code that will evaluate to that function at runtime"), u5(Q.format === "html" || Q.format === "object", 'Options.format should be "html" or "object"');
    var J = [], X = [], z = [];
    function Y(U, V, M, q) {
      if (v7(V))
        if (Q.format === "html") {
          var L = q1(F5.attr(U, x5(V), M, Q.terse)), N = q[q.length - 1];
          if (N && N[N.length - 1] === L[0])
            q[q.length - 1] = N.substr(0, N.length - 1) + L.substr(1);
          else
            q.push(L);
        } else {
          if (V = x5(V), M)
            V = F5.escape(V);
          q.push(q1(U) + ": " + q1(V));
        }
      else if (Q.format === "html")
        q.push(Q.runtime("attr") + '("' + U + '", ' + V + ", " + q1(M) + ", " + q1(Q.terse) + ")");
      else {
        if (M)
          V = Q.runtime("escape") + "(" + V + ")";
        q.push(q1(U) + ": " + V);
      }
    }
    Z.forEach(function(U) {
      var { name: V, val: M, mustEscape: q } = U;
      if (V === "class")
        X.push(M), z.push(q);
      else {
        if (V === "style")
          if (v7(M))
            M = q1(F5.style(x5(M)));
          else
            M = Q.runtime("style") + "(" + M + ")";
        Y(V, M, q, J);
      }
    });
    var W = [];
    if (X.length)
      if (X.every(v7))
        Y("class", q1(F5.classes(X.map(x5), z)), !1, W);
      else
        X = X.map(function(U, V) {
          if (v7(U))
            U = q1(z[V] ? F5.escape(x5(U)) : x5(U)), z[V] = !1;
          return U;
        }), Y("class", Q.runtime("classes") + "([" + X.join(",") + "], " + q1(z) + ")", !1, W);
    if (J = W.concat(J), Q.format === "html")
      return J.length ? J.join("+") : '""';
    else
      return "{" + J.join(",") + "}";
  }, u5 = A0("assert"), qW = w7(), F5 = A8(), q1 = rZ();
  $W.exports = Os;
});

// node_modules/void-elements/index.js
var CW = P((S80, IW) => {
  IW.exports = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  };
});

// node_modules/babel-walk/lib/explode.js
var AW = P((h1) => {
  var Is = function(Z) {
    const Q = {};
    for (let J in Z) {
      const X = c5[J];
      if (X)
        for (let z of X)
          if (z in Q)
            if (typeof Z[J] === "function")
              Q[z].enter.push(Z[J]);
            else {
              if (Z[J].enter)
                Q[z].enter.push(Z[J].enter);
              if (Z[J].exit)
                Q[z].exit.push(Z[J].exit);
            }
          else if (typeof Z[J] === "function")
            Q[z] = {
              enter: [Z[J]],
              exit: []
            };
          else
            Q[z] = {
              enter: Z[J].enter ? [Z[J].enter] : [],
              exit: Z[J].exit ? [Z[J].exit] : []
            };
      else if (Ds.has(J))
        if (J in Q)
          if (typeof Z[J] === "function")
            Q[J].enter.push(Z[J]);
          else {
            if (Z[J].enter)
              Q[J].enter.push(Z[J].enter);
            if (Z[J].exit)
              Q[J].exit.push(Z[J].exit);
          }
        else if (typeof Z[J] === "function")
          Q[J] = {
            enter: [Z[J]],
            exit: []
          };
        else
          Q[J] = {
            enter: Z[J].enter ? [Z[J].enter] : [],
            exit: Z[J].exit ? [Z[J].exit] : []
          };
    }
    return Q;
  }, Bs = h1 && h1.__createBinding || (Object.create ? function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Object.defineProperty(Z, X, { enumerable: !0, get: function() {
      return Q[J];
    } });
  } : function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Z[X] = Q[J];
  }), qs = h1 && h1.__setModuleDefault || (Object.create ? function(Z, Q) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: Q });
  } : function(Z, Q) {
    Z.default = Q;
  }), $s = h1 && h1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var Q = {};
    if (Z != null) {
      for (var J in Z)
        if (Object.hasOwnProperty.call(Z, J))
          Bs(Q, Z, J);
    }
    return qs(Q, Z), Q;
  };
  Object.defineProperty(h1, "__esModule", { value: !0 });
  var b7 = $s(B1());
  if (!(Array.isArray(b7.TYPES) && b7.TYPES.every((Z) => typeof Z === "string")))
    throw new Error("@babel/types TYPES does not match the expected type.");
  var c5 = b7.FLIPPED_ALIAS_KEYS, Ds = new Set(b7.TYPES);
  if (!(c5 && typeof c5 === "object" && Object.keys(c5).every((Z) => Array.isArray(c5[Z]) && c5[Z].every((Q) => typeof Q === "string"))))
    throw new Error("@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.");
  h1.default = Is;
});

// node_modules/babel-walk/lib/index.js
var sZ = P((x0) => {
  var Ss = function(Z) {
    const Q = nZ.default(Z);
    return (J, X) => {
      (function z(Y) {
        if (!Y)
          return;
        const W = Q[Y.type];
        if (W === null || W === void 0 ? void 0 : W.enter)
          for (let U of W.enter)
            U(Y, X);
        for (let U of a1[Y.type] || []) {
          const V = Y[U];
          if (Array.isArray(V))
            for (let M of V)
              z(M);
          else
            z(V);
        }
        if (W === null || W === void 0 ? void 0 : W.exit)
          for (let U of W.exit)
            U(Y, X);
      })(J);
    };
  }, ws = function(Z) {
    const Q = nZ.default(Z);
    return (J, X) => {
      const z = [];
      (function Y(W) {
        if (!W)
          return;
        const U = Q[W.type], V = W !== z[z.length - 1];
        if (V)
          z.push(W);
        if (U === null || U === void 0 ? void 0 : U.enter)
          for (let M of U.enter)
            M(W, X, z);
        for (let M of a1[W.type] || []) {
          const q = W[M];
          if (Array.isArray(q))
            for (let L of q)
              Y(L);
          else
            Y(q);
        }
        if (U === null || U === void 0 ? void 0 : U.exit)
          for (let M of U.exit)
            M(W, X, z);
        if (V)
          z.pop();
      })(J);
    };
  }, Ts = function(Z) {
    const Q = nZ.default(Z);
    return (J, X) => {
      (function z(Y) {
        if (!Y)
          return;
        const W = Q[Y.type];
        if (W === null || W === void 0 ? void 0 : W.enter)
          for (let U of W.enter)
            U(Y, X, z);
        else
          for (let U of a1[Y.type] || []) {
            const V = Y[U];
            if (Array.isArray(V))
              for (let M of V)
                z(M);
            else
              z(V);
          }
      })(J);
    };
  }, Cs = x0 && x0.__createBinding || (Object.create ? function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Object.defineProperty(Z, X, { enumerable: !0, get: function() {
      return Q[J];
    } });
  } : function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Z[X] = Q[J];
  }), As = x0 && x0.__setModuleDefault || (Object.create ? function(Z, Q) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: Q });
  } : function(Z, Q) {
    Z.default = Q;
  }), Ls = x0 && x0.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var Q = {};
    if (Z != null) {
      for (var J in Z)
        if (Object.hasOwnProperty.call(Z, J))
          Cs(Q, Z, J);
    }
    return As(Q, Z), Q;
  }, Ns = x0 && x0.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(x0, "__esModule", { value: !0 });
  x0.recursive = x0.ancestor = x0.simple = void 0;
  var Ps = Ls(B1()), nZ = Ns(AW()), a1 = Ps.VISITOR_KEYS;
  if (!(a1 && typeof a1 === "object" && Object.keys(a1).every((Z) => Array.isArray(a1[Z]) && a1[Z].every((Q) => typeof Q === "string"))))
    throw new Error("@babel/types VISITOR_KEYS does not match the expected type.");
  x0.simple = Ss;
  x0.ancestor = ws;
  x0.recursive = Ts;
});

// node_modules/assert-never/index.js
var PW = P((NW) => {
  var LW = function(Z, Q) {
    if (Q)
      return Z;
    throw new Error("Unhandled discriminated union member: " + JSON.stringify(Z));
  };
  Object.defineProperty(NW, "__esModule", { value: !0 });
  NW.assertNever = LW;
  NW.default = LW;
});

// node_modules/with/lib/reference.js
var SW = P((_1) => {
  var ks = function(Z, Q) {
    switch (Q.type) {
      case "ObjectProperty":
        return Q.value === Z || Q.computed;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "AssignmentExpression":
        return !0;
    }
    return _s.isReferenced(Z, Q);
  }, Es = _1 && _1.__createBinding || (Object.create ? function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Object.defineProperty(Z, X, { enumerable: !0, get: function() {
      return Q[J];
    } });
  } : function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Z[X] = Q[J];
  }), gs = _1 && _1.__setModuleDefault || (Object.create ? function(Z, Q) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: Q });
  } : function(Z, Q) {
    Z.default = Q;
  }), hs = _1 && _1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var Q = {};
    if (Z != null) {
      for (var J in Z)
        if (Object.hasOwnProperty.call(Z, J))
          Es(Q, Z, J);
    }
    return gs(Q, Z), Q;
  };
  Object.defineProperty(_1, "__esModule", { value: !0 });
  var _s = hs(B1());
  _1.default = ks;
});

// node_modules/with/lib/globals.js
var bW = P((V1) => {
  var ps = function(Z) {
    for (let J of Z.params)
      r1(J, Z);
    const Q = Z.id;
    if (Q)
      L8(Z, Q.name);
  }, r1 = function(Z, Q) {
    switch (Z.type) {
      case "Identifier":
        L8(Q, Z.name);
        break;
      case "ObjectPattern":
        for (let J of Z.properties)
          switch (J.type) {
            case "RestElement":
              r1(J.argument, Q);
              break;
            case "ObjectProperty":
              r1(J.value, Q);
              break;
            default:
              us.default(J);
              break;
          }
        break;
      case "ArrayPattern":
        for (let J of Z.elements)
          if (J)
            r1(J, Q);
        break;
      case "RestElement":
        r1(Z.argument, Q);
        break;
      case "AssignmentPattern":
        r1(Z.left, Q);
        break;
      default:
        throw new Error("Unrecognized pattern type: " + Z.type);
    }
  }, tZ = function(Z, Q, J) {
    for (let X = J.length - 2;X >= 0; X--)
      if (E7(J[X])) {
        L8(J[X], Z.local.name);
        return;
      }
  }, ns = function(Z) {
    const Q = [];
    if (!R5.isNode(Z))
      throw new TypeError("Source must be a Babylon AST");
    as(Z, void 0), rs(Z, { globals: Q });
    const J = new Map;
    for (let X of Q) {
      const z = X.type === "ThisExpression" ? "this" : X.name, Y = J.get(z);
      if (Y)
        Y.push(X);
      else
        J.set(z, [X]);
    }
    return [...J].map(([X, z]) => ({ name: X, nodes: z })).sort((X, z) => X.name < z.name ? -1 : 1);
  }, fs = V1 && V1.__createBinding || (Object.create ? function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Object.defineProperty(Z, X, { enumerable: !0, get: function() {
      return Q[J];
    } });
  } : function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Z[X] = Q[J];
  }), ys = V1 && V1.__setModuleDefault || (Object.create ? function(Z, Q) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: Q });
  } : function(Z, Q) {
    Z.default = Q;
  }), ms = V1 && V1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var Q = {};
    if (Z != null) {
      for (var J in Z)
        if (Object.hasOwnProperty.call(Z, J))
          fs(Q, Z, J);
    }
    return ys(Q, Z), Q;
  }, wW = V1 && V1.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(V1, "__esModule", { value: !0 });
  var us = wW(PW()), TW = sZ(), R5 = ms(B1()), xs = wW(SW()), E7 = (Z) => R5.isFunctionParent(Z) || R5.isProgram(Z), cs = (Z) => R5.isBlockStatement(Z) || E7(Z), vW = (Z) => R5.isFunction(Z) && !R5.isArrowFunctionExpression(Z), ls = vW, oZ = Symbol("locals"), is = (Z) => Z[oZ], ds = (Z) => Z[oZ] = Z[oZ] || new Set, L8 = (Z, Q) => ds(Z).add(Q), as = TW.ancestor({
    VariableDeclaration(Z, Q, J) {
      for (let X = J.length - 2;X >= 0; X--)
        if (Z.kind === "var" ? R5.isFunctionParent(J[X]) : cs(J[X])) {
          for (let z of Z.declarations)
            r1(z.id, J[X]);
          return;
        }
    },
    FunctionDeclaration(Z, Q, J) {
      if (Z.id) {
        for (let X = J.length - 2;X >= 0; X--)
          if (E7(J[X])) {
            L8(J[X], Z.id.name);
            return;
          }
      }
    },
    Function: ps,
    ClassDeclaration(Z, Q, J) {
      for (let X = J.length - 2;X >= 0; X--)
        if (E7(J[X])) {
          L8(J[X], Z.id.name);
          return;
        }
    },
    TryStatement(Z) {
      if (Z.handler === null)
        return;
      if (Z.handler.param === null)
        return;
      r1(Z.handler.param, Z.handler);
    },
    ImportDefaultSpecifier: tZ,
    ImportSpecifier: tZ,
    ImportNamespaceSpecifier: tZ
  }), rs = TW.ancestor({
    Identifier(Z, Q, J) {
      var X;
      const z = Z.name;
      if (z === "undefined")
        return;
      const Y = J[J.length - 2];
      if (Y) {
        if (!xs.default(Z, Y))
          return;
        for (let W of J) {
          if (z === "arguments" && vW(W))
            return;
          if ((X = is(W)) === null || X === void 0 ? void 0 : X.has(z))
            return;
        }
      }
      Q.globals.push(Z);
    },
    ThisExpression(Z, Q, J) {
      for (let X of J)
        if (ls(X))
          return;
      Q.globals.push(Z);
    }
  });
  V1.default = ns;
});

// node_modules/with/lib/index.js
var _W = P((K1, ZQ) => {
  var eZ = function(Z, Q, J = []) {
    Z = Z + "", Q = Q + "";
    let X;
    try {
      X = EW.parse(Q, hW);
    } catch (N) {
      throw Object.assign(new Error("Error parsing body of the with expression"), {
        component: "src",
        babylonError: N
      });
    }
    let z;
    try {
      z = EW.parse(Z, hW);
    } catch (N) {
      throw Object.assign(new Error("Error parsing object part of the with expression"), {
        component: "obj",
        babylonError: N
      });
    }
    const Y = new Set([
      "undefined",
      "this",
      ...J,
      ...gW.default(z).map((N) => N.name)
    ]), W = new Set(gW.default(X).map((N) => N.name).filter((N) => !Y.has(N)));
    if (W.size === 0)
      return Q;
    let U = "", V = "locals_for_with", M = "result_of_with";
    if (Qt.isValidIdentifier(Z))
      V = Z;
    else {
      while (W.has(V) || Y.has(V))
        V += "_";
      U = `var ${V} = (${Z});`;
    }
    while (W.has(M) || Y.has(M))
      M += "_";
    const q = [
      "this",
      ...Array.from(W).map((N) => `${JSON.stringify(N)} in ${V} ?
        ${V}.${N} :
        typeof ${N} !== 'undefined' ? ${N} : undefined`)
    ], L = Xt(X, Q, M);
    return `;
    ${U}
    ${L.before}
    (function (${Array.from(W).join(", ")}) {
      ${L.body}
    }.call(${q.join(", ")}));
    ${L.after};`;
  }, Xt = function(Z, Q, J) {
    const X = Q.split(""), z = {
      hasReturn: !1,
      source(Y) {
        return Q.slice(Y.start, Y.end);
      },
      replace(Y, W) {
        X.fill("", Y.start, Y.end), X[Y.start] = W;
      }
    };
    return Jt(Z, z), {
      before: z.hasReturn ? `var ${J} = ` : "",
      body: X.join(""),
      after: z.hasReturn ? `;if (${J}) return ${J}.value` : ""
    };
  }, ss = K1 && K1.__createBinding || (Object.create ? function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Object.defineProperty(Z, X, { enumerable: !0, get: function() {
      return Q[J];
    } });
  } : function(Z, Q, J, X) {
    if (X === void 0)
      X = J;
    Z[X] = Q[J];
  }), ts = K1 && K1.__setModuleDefault || (Object.create ? function(Z, Q) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: Q });
  } : function(Z, Q) {
    Z.default = Q;
  }), os = K1 && K1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var Q = {};
    if (Z != null) {
      for (var J in Z)
        if (Object.hasOwnProperty.call(Z, J))
          ss(Q, Z, J);
    }
    return ts(Q, Z), Q;
  }, es = K1 && K1.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(K1, "__esModule", { value: !0 });
  var EW = u6(), Zt = sZ(), Qt = os(B1()), gW = es(bW()), hW = {
    allowReturnOutsideFunction: !0,
    allowImportExportEverywhere: !0
  };
  K1.default = eZ;
  var Jt = Zt.recursive({
    Function(Z, Q, J) {
    },
    ReturnStatement(Z, Q) {
      Q.hasReturn = !0;
      let J = "";
      if (Z.argument)
        J = `value: (${Q.source(Z.argument)})`;
      Q.replace(Z, `return {${J}};`);
    }
  });
  ZQ.exports = eZ;
  ZQ.exports.default = eZ;
});

// node_modules/pug-code-gen/index.js
var mW = P((g80, XQ) => {
  var Vt = function(Z, Q) {
    return new JQ(Z, Q).compile();
  }, Kt = function(Z) {
    return yW(Z, { pug: fW, pug_interp: void 0 });
  }, Mt = function(Z) {
    return yW.toConstant(Z, { pug: fW, pug_interp: void 0 });
  }, JQ = function(Z, Q) {
    if (this.options = Q = Q || {}, this.node = Z, this.bufferedConcatenationCount = 0, this.hasCompiledDoctype = !1, this.hasCompiledTag = !1, this.pp = Q.pretty || !1, this.pp && typeof this.pp !== "string")
      this.pp = "  ";
    if (this.pp && !/^\s+$/.test(this.pp))
      throw new Error("The pretty parameter should either be a boolean or whitespace only string");
    if (this.debug = Q.compileDebug !== !1, this.indents = 0, this.parentIndents = 0, this.terse = !1, this.mixins = {}, this.dynamicMixins = !1, this.eachCount = 0, Q.doctype)
      this.setDoctype(Q.doctype);
    if (this.runtimeFunctionsUsed = [], this.inlineRuntimeFunctions = Q.inlineRuntimeFunctions || !1, this.debug && this.inlineRuntimeFunctions)
      this.runtimeFunctionsUsed.push("rethrow");
  }, Ft = function(Z) {
    function Q(J) {
      if (J.type === "Block")
        return J.nodes.every(Q);
      if (J.type === "YieldBlock")
        return !0;
      return J.type === "Text" && !/\n/.test(J.val) || J.isInline;
    }
    return Z.block.nodes.every(Q);
  }, zt = HW(), Ht = Q5(), Yt = FW(), fW = A8(), Wt = DW(), Gt = CW(), yW = w7(), j5 = rZ(), Ut = _W(), QQ = {
    pre: !0,
    textarea: !0
  }, kW = [
    "pug",
    "pug_mixins",
    "pug_interp",
    "pug_debug_filename",
    "pug_debug_line",
    "pug_debug_sources",
    "pug_html"
  ];
  XQ.exports = Vt;
  XQ.exports.CodeGenerator = JQ;
  JQ.prototype = {
    runtime: function(Z) {
      if (this.inlineRuntimeFunctions)
        return this.runtimeFunctionsUsed.push(Z), "pug_" + Z;
      else
        return "pug." + Z;
    },
    error: function(Z, Q, J) {
      var X = Ht(Q, Z, {
        line: J.line,
        column: J.column,
        filename: J.filename
      });
      throw X;
    },
    compile: function() {
      if (this.buf = [], this.pp)
        this.buf.push("var pug_indent = [];");
      if (this.lastBufferedIdx = -1, this.visit(this.node), !this.dynamicMixins) {
        var Z = Object.keys(this.mixins);
        for (var Q = 0;Q < Z.length; Q++) {
          var J = this.mixins[Z[Q]];
          if (!J.used)
            for (var X = 0;X < J.instances.length; X++)
              for (var z = J.instances[X].start;z < J.instances[X].end; z++)
                this.buf[z] = "";
        }
      }
      var Y = this.buf.join("\n"), W = this.options.globals ? this.options.globals.concat(kW) : kW;
      if (this.options.self)
        Y = "var self = locals || {};" + Y;
      else
        Y = Ut("locals || {}", Y, W.concat(this.runtimeFunctionsUsed.map(function(U) {
          return "pug_" + U;
        })));
      if (this.debug) {
        if (this.options.includeSources)
          Y = "var pug_debug_sources = " + j5(this.options.includeSources) + ";\n" + Y;
        Y = "var pug_debug_filename, pug_debug_line;try {" + Y + "} catch (err) {" + (this.inlineRuntimeFunctions ? "pug_rethrow" : "pug.rethrow") + "(err, pug_debug_filename, pug_debug_line" + (this.options.includeSources ? ", pug_debug_sources[pug_debug_filename]" : "") + ");}";
      }
      return Yt(this.runtimeFunctionsUsed) + "function " + (this.options.templateName || "template") + '(locals) {var pug_html = "", pug_mixins = {}, pug_interp;' + Y + ";return pug_html;}";
    },
    setDoctype: function(Z) {
      this.doctype = zt[Z.toLowerCase()] || "<!DOCTYPE " + Z + ">", this.terse = this.doctype.toLowerCase() == "<!doctype html>", this.xml = this.doctype.indexOf("<?xml") == 0;
    },
    buffer: function(Z) {
      var Q = this;
      if (Z = j5(Z), Z = Z.substr(1, Z.length - 2), this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
        if (this.lastBufferedType === "code")
          this.lastBuffered += ' + "', this.bufferedConcatenationCount++;
        this.lastBufferedType = "text", this.lastBuffered += Z, this.buf[this.lastBufferedIdx - 1] = "pug_html = pug_html + " + this.bufferStartChar + this.lastBuffered + '";';
      } else
        this.bufferedConcatenationCount = 0, this.buf.push('pug_html = pug_html + "' + Z + '";'), this.lastBufferedType = "text", this.bufferStartChar = '"', this.lastBuffered = Z, this.lastBufferedIdx = this.buf.length;
    },
    bufferExpression: function(Z) {
      if (Kt(Z))
        return this.buffer(Mt(Z) + "");
      if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
        if (this.bufferedConcatenationCount++, this.lastBufferedType === "text")
          this.lastBuffered += '"';
        this.lastBufferedType = "code", this.lastBuffered += " + (" + Z + ")", this.buf[this.lastBufferedIdx - 1] = "pug_html = pug_html + (" + this.bufferStartChar + this.lastBuffered + ");";
      } else
        this.bufferedConcatenationCount = 0, this.buf.push("pug_html = pug_html + (" + Z + ");"), this.lastBufferedType = "code", this.bufferStartChar = "", this.lastBuffered = "(" + Z + ")", this.lastBufferedIdx = this.buf.length;
    },
    prettyIndent: function(Z, Q) {
      if (Z = Z || 0, Q = Q ? "\n" : "", this.buffer(Q + Array(this.indents + Z).join(this.pp)), this.parentIndents)
        this.buf.push('pug_html = pug_html + pug_indent.join("");');
    },
    visit: function(Z, Q) {
      var J = this.debug;
      if (!Z) {
        var X;
        if (Q)
          X = "A child of " + Q.type + " (" + (Q.filename || "Pug") + ":" + Q.line + ")";
        else
          X = "A top-level node";
        throw X += " is " + Z + ", expected a Pug AST Node.", new TypeError(X);
      }
      if (J && Z.debug !== !1 && Z.type !== "Block") {
        if (Z.line) {
          var z = ";pug_debug_line = " + Z.line;
          if (Z.filename)
            z += ";pug_debug_filename = " + j5(Z.filename);
          this.buf.push(z + ";");
        }
      }
      if (!this["visit" + Z.type]) {
        var X;
        if (Q)
          X = "A child of " + Q.type;
        else
          X = "A top-level node";
        switch (X += " (" + (Z.filename || "Pug") + ":" + Z.line + ") is of type " + Z.type + ", which is not supported by pug-code-gen.", Z.type) {
          case "Filter":
            X += " Please use pug-filters to preprocess this AST.";
            break;
          case "Extends":
          case "Include":
          case "NamedBlock":
          case "FileReference":
            X += " Please use pug-linker to preprocess this AST.";
            break;
        }
        throw new TypeError(X);
      }
      this.visitNode(Z);
    },
    visitNode: function(Z) {
      return this["visit" + Z.type](Z);
    },
    visitCase: function(Z) {
      this.buf.push("switch (" + Z.expr + "){"), this.visit(Z.block, Z), this.buf.push("}");
    },
    visitWhen: function(Z) {
      if (Z.expr == "default")
        this.buf.push("default:");
      else
        this.buf.push("case " + Z.expr + ":");
      if (Z.block)
        this.visit(Z.block, Z), this.buf.push("  break;");
    },
    visitLiteral: function(Z) {
      this.buffer(Z.str);
    },
    visitNamedBlock: function(Z) {
      return this.visitBlock(Z);
    },
    visitBlock: function(Z) {
      var Q = this.escapePrettyMode, J = this.pp;
      if (J && Z.nodes.length > 1 && !Q && Z.nodes[0].type === "Text" && Z.nodes[1].type === "Text")
        this.prettyIndent(1, !0);
      for (var X = 0;X < Z.nodes.length; ++X) {
        if (J && X > 0 && !Q && Z.nodes[X].type === "Text" && Z.nodes[X - 1].type === "Text" && /\n$/.test(Z.nodes[X - 1].val))
          this.prettyIndent(1, !1);
        this.visit(Z.nodes[X], Z);
      }
    },
    visitMixinBlock: function(Z) {
      if (this.pp)
        this.buf.push("pug_indent.push(" + j5(Array(this.indents + 1).join(this.pp)) + ");");
      if (this.buf.push("block && block();"), this.pp)
        this.buf.push("pug_indent.pop();");
    },
    visitDoctype: function(Z) {
      if (Z && (Z.val || !this.doctype))
        this.setDoctype(Z.val || "html");
      if (this.doctype)
        this.buffer(this.doctype);
      this.hasCompiledDoctype = !0;
    },
    visitMixin: function(Z) {
      var Q = "pug_mixins[", J = Z.args || "", X = Z.block, z = Z.attrs, Y = this.attributeBlocks(Z.attributeBlocks), W = this.pp, U = Z.name[0] === "#", V = Z.name;
      if (U)
        this.dynamicMixins = !0;
      if (Q += (U ? Z.name.substr(2, Z.name.length - 3) : '"' + Z.name + '"') + "]", this.mixins[V] = this.mixins[V] || { used: !1, instances: [] }, Z.call) {
        if (this.mixins[V].used = !0, W)
          this.buf.push("pug_indent.push(" + j5(Array(this.indents + 1).join(W)) + ");");
        if (X || z.length || Y.length) {
          if (this.buf.push(Q + ".call({"), X) {
            this.buf.push("block: function(){"), this.parentIndents++;
            var M = this.indents;
            if (this.indents = 0, this.visit(Z.block, Z), this.indents = M, this.parentIndents--, z.length || Y.length)
              this.buf.push("},");
            else
              this.buf.push("}");
          }
          if (Y.length) {
            if (z.length) {
              var q = this.attrs(z);
              Y.unshift(q);
            }
            if (Y.length > 1)
              this.buf.push("attributes: " + this.runtime("merge") + "([" + Y.join(",") + "])");
            else
              this.buf.push("attributes: " + Y[0]);
          } else if (z.length) {
            var q = this.attrs(z);
            this.buf.push("attributes: " + q);
          }
          if (J)
            this.buf.push("}, " + J + ");");
          else
            this.buf.push("});");
        } else
          this.buf.push(Q + "(" + J + ");");
        if (W)
          this.buf.push("pug_indent.pop();");
      } else {
        var L = this.buf.length;
        J = J ? J.split(",") : [];
        var N;
        if (J.length && /^\.\.\./.test(J[J.length - 1].trim()))
          N = J.pop().trim().replace(/^\.\.\./, "");
        if (this.buf.push(Q + " = pug_interp = function(" + J.join(",") + "){"), this.buf.push("var block = (this && this.block), attributes = (this && this.attributes) || {};"), N)
          this.buf.push("var " + N + " = [];"), this.buf.push("for (pug_interp = " + J.length + "; pug_interp < arguments.length; pug_interp++) {"), this.buf.push("  " + N + ".push(arguments[pug_interp]);"), this.buf.push("}");
        this.parentIndents++, this.visit(X, Z), this.parentIndents--, this.buf.push("};");
        var T = this.buf.length;
        this.mixins[V].instances.push({ start: L, end: T });
      }
    },
    visitTag: function(Z, Q) {
      this.indents++;
      var J = Z.name, X = this.pp, z = this;
      function Y() {
        if (Q)
          z.bufferExpression(Z.expr);
        else
          z.buffer(J);
      }
      if (QQ[Z.name] === !0)
        this.escapePrettyMode = !0;
      if (!this.hasCompiledTag) {
        if (!this.hasCompiledDoctype && J == "html")
          this.visitDoctype();
        this.hasCompiledTag = !0;
      }
      if (X && !Z.isInline)
        this.prettyIndent(0, !0);
      if (Z.selfClosing || !this.xml && Gt[Z.name]) {
        if (this.buffer("<"), Y(), this.visitAttributes(Z.attrs, this.attributeBlocks(Z.attributeBlocks)), this.terse && !Z.selfClosing)
          this.buffer(">");
        else
          this.buffer("/>");
        if (Z.code || Z.block && !(Z.block.type === "Block" && Z.block.nodes.length === 0) && Z.block.nodes.some(function(W) {
          return W.type !== "Text" || !/^\s*$/.test(W.val);
        }))
          this.error(J + " is a self closing element: <" + J + "/> but contains nested content.", "SELF_CLOSING_CONTENT", Z);
      } else {
        if (this.buffer("<"), Y(), this.visitAttributes(Z.attrs, this.attributeBlocks(Z.attributeBlocks)), this.buffer(">"), Z.code)
          this.visitCode(Z.code);
        if (this.visit(Z.block, Z), X && !Z.isInline && QQ[Z.name] !== !0 && !Ft(Z))
          this.prettyIndent(0, !0);
        this.buffer("</"), Y(), this.buffer(">");
      }
      if (QQ[Z.name] === !0)
        this.escapePrettyMode = !1;
      this.indents--;
    },
    visitInterpolatedTag: function(Z) {
      return this.visitTag(Z, !0);
    },
    visitText: function(Z) {
      this.buffer(Z.val);
    },
    visitComment: function(Z) {
      if (!Z.buffer)
        return;
      if (this.pp)
        this.prettyIndent(1, !0);
      this.buffer("<!--" + Z.val + "-->");
    },
    visitYieldBlock: function(Z) {
    },
    visitBlockComment: function(Z) {
      if (!Z.buffer)
        return;
      if (this.pp)
        this.prettyIndent(1, !0);
      if (this.buffer("<!--" + (Z.val || "")), this.visit(Z.block, Z), this.pp)
        this.prettyIndent(1, !0);
      this.buffer("-->");
    },
    visitCode: function(Z) {
      if (Z.buffer) {
        var Q = Z.val.trim();
        if (Q = "null == (pug_interp = " + Q + ') ? "" : pug_interp', Z.mustEscape !== !1)
          Q = this.runtime("escape") + "(" + Q + ")";
        this.bufferExpression(Q);
      } else
        this.buf.push(Z.val);
      if (Z.block) {
        if (!Z.buffer)
          this.buf.push("{");
        if (this.visit(Z.block, Z), !Z.buffer)
          this.buf.push("}");
      }
    },
    visitConditional: function(Z) {
      var Q = Z.test;
      if (this.buf.push("if (" + Q + ") {"), this.visit(Z.consequent, Z), this.buf.push("}"), Z.alternate)
        if (Z.alternate.type === "Conditional")
          this.buf.push("else"), this.visitConditional(Z.alternate);
        else
          this.buf.push("else {"), this.visit(Z.alternate, Z), this.buf.push("}");
    },
    visitWhile: function(Z) {
      var Q = Z.test;
      this.buf.push("while (" + Q + ") {"), this.visit(Z.block, Z), this.buf.push("}");
    },
    visitEach: function(Z) {
      var Q = Z.key || "pug_index" + this.eachCount;
      if (this.eachCount++, this.buf.push("// iterate " + Z.obj + "\n;(function(){\n  var $$obj = " + Z.obj + ";\n  if ('number' == typeof $$obj.length) {"), Z.alternate)
        this.buf.push("    if ($$obj.length) {");
      if (this.buf.push("      for (var " + Q + " = 0, $$l = $$obj.length; " + Q + " < $$l; " + Q + "++) {\n        var " + Z.val + " = $$obj[" + Q + "];"), this.visit(Z.block, Z), this.buf.push("      }"), Z.alternate)
        this.buf.push("    } else {"), this.visit(Z.alternate, Z), this.buf.push("    }");
      if (this.buf.push("  } else {\n    var $$l = 0;\n    for (var " + Q + " in $$obj) {\n      $$l++;\n      var " + Z.val + " = $$obj[" + Q + "];"), this.visit(Z.block, Z), this.buf.push("    }"), Z.alternate)
        this.buf.push("    if ($$l === 0) {"), this.visit(Z.alternate, Z), this.buf.push("    }");
      this.buf.push("  }\n}).call(this);\n");
    },
    visitEachOf: function(Z) {
      this.buf.push("// iterate " + Z.obj + "\nfor (const " + Z.val + " of " + Z.obj + ") {\n"), this.visit(Z.block, Z), this.buf.push("}\n");
    },
    visitAttributes: function(Z, Q) {
      if (Q.length) {
        if (Z.length) {
          var J = this.attrs(Z);
          Q.unshift(J);
        }
        if (Q.length > 1)
          this.bufferExpression(this.runtime("attrs") + "(" + this.runtime("merge") + "([" + Q.join(",") + "]), " + j5(this.terse) + ")");
        else
          this.bufferExpression(this.runtime("attrs") + "(" + Q[0] + ", " + j5(this.terse) + ")");
      } else if (Z.length)
        this.attrs(Z, !0);
    },
    attrs: function(Z, Q) {
      var J = Wt(Z, {
        terse: this.terse,
        format: Q ? "html" : "object",
        runtime: this.runtime.bind(this)
      });
      if (Q)
        this.bufferExpression(J);
      return J;
    },
    attributeBlocks: function(Z) {
      return Z && Z.slice().map(function(Q) {
        return Q.val;
      });
    }
  };
});

// node_modules/pug-runtime/wrap.js
var xW = P((h80, uW) => {
  var jt = function(Z, Q) {
    return Q = Q || "template", Function("pug", Z + "\nreturn " + Q + ";")(Rt);
  }, Rt = A8();
  uW.exports = jt;
});

// node_modules/pug/lib/index.js
var aW = P((Nt) => {
  var H1 = function(Z, Q, J, X) {
    return J.reduce(function(z, Y) {
      return Y[X] ? Y[X](z, Q) : z;
    }, Z);
  }, HQ = function(Z, Q) {
    var J = Z.filter(function(X) {
      return X[Q];
    });
    if (J.length > 1)
      throw new Error("Two or more plugins all implement " + Q + " method.");
    else if (J.length)
      return J[0][Q].bind(J[0]);
    return null;
  }, iW = function(Z, Q) {
    var J = {};
    J[Q.filename] = Z;
    var X = [], z = Q.plugins || [], Y = zQ.string(Z, {
      filename: Q.filename,
      basedir: Q.basedir,
      lex: function(V, M) {
        var q = {};
        Object.keys(M).forEach(function(N) {
          q[N] = M[N];
        }), q.plugins = z.filter(function(N) {
          return !!N.lex;
        }).map(function(N) {
          return N.lex;
        });
        var L = H1(V, { filename: M.filename }, z, "preLex");
        return H1(Bt(L, q), M, z, "postLex");
      },
      parse: function(V, M) {
        V = V.map(function(L) {
          if (L.type === "path" && Ot.extname(L.val) === "")
            return {
              type: "path",
              loc: L.loc,
              val: L.val + ".pug"
            };
          return L;
        }), V = qt(V, M), V = H1(V, M, z, "preParse");
        var q = {};
        return Object.keys(M).forEach(function(L) {
          q[L] = M[L];
        }), q.plugins = z.filter(function(L) {
          return !!L.parse;
        }).map(function(L) {
          return L.parse;
        }), H1(H1($t(V, q), M, z, "postParse"), M, z, "preLoad");
      },
      resolve: function(V, M, q) {
        var L = HQ(z, "resolve");
        if (L)
          return L(V, M, Q);
        return zQ.resolve(V, M, q);
      },
      read: function(V, M) {
        X.push(V);
        var q, L = HQ(z, "read");
        if (L)
          q = L(V, Q);
        else
          q = zQ.read(V, M);
        return J[V] = Buffer.isBuffer(q) ? q.toString("utf8") : q, q;
      }
    });
    Y = H1(Y, Q, z, "postLoad"), Y = H1(Y, Q, z, "preFilters");
    var W = {};
    if (Object.keys(Nt.filters).forEach(function(V) {
      W[V] = Nt.filters[V];
    }), Q.filters)
      Object.keys(Q.filters).forEach(function(V) {
        W[V] = Q.filters[V];
      });
    Y = Dt.handleFilters(Y, W, Q.filterOptions, Q.filterAliases), Y = H1(Y, Q, z, "postFilters"), Y = H1(Y, Q, z, "preLink"), Y = It(Y), Y = H1(Y, Q, z, "postLink"), Y = H1(Y, Q, z, "preCodeGen");
    var U = (HQ(z, "generateCode") || Ct)(Y, {
      pretty: Q.pretty,
      compileDebug: Q.compileDebug,
      doctype: Q.doctype,
      inlineRuntimeFunctions: Q.inlineRuntimeFunctions,
      globals: Q.globals,
      self: Q.self,
      includeSources: Q.includeSources ? J : !1,
      templateName: Q.templateName
    });
    if (U = H1(U, Q, z, "postCodeGen"), Q.debug)
      console.error(`
Compiled Function:

\x1B[90m%s\x1B[0m`, U.replace(/^/gm, "  "));
    return { body: U, dependencies: X };
  }, GQ = function(Z, Q) {
    var J = Z.filename;
    if (Z.cache && Nt.cache[J])
      return Nt.cache[J];
    else {
      if (Q === void 0)
        Q = lW.readFileSync(Z.filename, "utf8");
      var X = Nt.compile(Q, Z);
      if (Z.cache)
        Nt.cache[J] = X;
      return X;
    }
  };
  /*!
   * Pug
   * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   */
  var lW = A0("fs"), Ot = A0("path"), Bt = nJ(), qt = tJ(), $t = JX(), zQ = YX(), Dt = ZW(), It = XW(), Ct = mW(), At = A8(), Lt = xW();
  Nt.name = "Pug";
  Nt.runtime = At;
  Nt.cache = {};
  Nt.filters = {};
  Nt.compile = function(Z, J) {
    var J = J || {};
    Z = String(Z);
    var X = iW(Z, {
      compileDebug: J.compileDebug !== !1,
      filename: J.filename,
      basedir: J.basedir,
      pretty: J.pretty,
      doctype: J.doctype,
      inlineRuntimeFunctions: J.inlineRuntimeFunctions,
      globals: J.globals,
      self: J.self,
      includeSources: J.compileDebug === !0,
      debug: J.debug,
      templateName: "template",
      filters: J.filters,
      filterOptions: J.filterOptions,
      filterAliases: J.filterAliases,
      plugins: J.plugins
    }), z = J.inlineRuntimeFunctions ? new Function("", X.body + ";return template;")() : Lt(X.body);
    return z.dependencies = X.dependencies, z;
  };
  Nt.compileClientWithDependenciesTracked = function(Z, J) {
    var J = J || {};
    Z = String(Z);
    var X = iW(Z, {
      compileDebug: J.compileDebug,
      filename: J.filename,
      basedir: J.basedir,
      pretty: J.pretty,
      doctype: J.doctype,
      inlineRuntimeFunctions: J.inlineRuntimeFunctions !== !1,
      globals: J.globals,
      self: J.self,
      includeSources: J.compileDebug,
      debug: J.debug,
      templateName: J.name || "template",
      filters: J.filters,
      filterOptions: J.filterOptions,
      filterAliases: J.filterAliases,
      plugins: J.plugins
    }), z = X.body;
    if (J.module) {
      if (J.inlineRuntimeFunctions === !1)
        z = 'var pug = require("pug-runtime");' + z;
      z += " module.exports = " + (J.name || "template") + ";";
    }
    return { body: z, dependencies: X.dependencies };
  };
  Nt.compileClient = function(Z, Q) {
    return Nt.compileClientWithDependenciesTracked(Z, Q).body;
  };
  Nt.compileFile = function(Z, Q) {
    return Q = Q || {}, Q.filename = Z, GQ(Q);
  };
  Nt.render = function(Z, Q, J) {
    if (typeof Q == "function")
      J = Q, Q = void 0;
    if (typeof J === "function") {
      var X;
      try {
        X = Nt.render(Z, Q);
      } catch (z) {
        return J(z);
      }
      return J(null, X);
    }
    if (Q = Q || {}, Q.cache && !Q.filename)
      throw new Error('the "filename" option is required for caching');
    return GQ(Q, Z)(Q);
  };
  Nt.renderFile = function(Z, Q, J) {
    if (typeof Q == "function")
      J = Q, Q = void 0;
    if (typeof J === "function") {
      var X;
      try {
        X = Nt.renderFile(Z, Q);
      } catch (z) {
        return J(z);
      }
      return J(null, X);
    }
    return Q = Q || {}, Q.filename = Z, GQ(Q)(Q);
  };
  Nt.compileFileClient = function(Z, Q) {
    var J = Z + ":client";
    if (Q = Q || {}, Q.filename = Z, Q.cache && Nt.cache[J])
      return Nt.cache[J];
    var X = lW.readFileSync(Q.filename, "utf8"), z = Nt.compileClient(X, Q);
    if (Q.cache)
      Nt.cache[J] = z;
    return z;
  };
  Nt.__express = function(Z, Q, J) {
    Q.compileDebug == null, Nt.renderFile(Z, Q, J);
  };
});

// main.mjs
var rW = BG(aW(), 1), f80 = rW.default;
export {
  f80 as default
};
