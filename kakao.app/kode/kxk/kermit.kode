###
000   000  00000000  00000000   00     00  000  000000000
000  000   000       000   000  000   000  000     000   
0000000    0000000   0000000    000000000  000     000   
000  000   000       000   000  000 0 000  000     000   
000   000  00000000  000   000  000   000  000     000   
###

use ◆ kstr
    
stackTopOrLast = (ctx) ->
    
    lr = last ctx.result
    if valid ctx.stack
        lr = lr[last(ctx.stack)[1..]]
        lr.push {}
        lr = last lr
    lr
    
wrapIndex = (ctx,offset) -> (ctx.pind+offset) % ctx.ptn.length
    
strongMatchAhead = (lr, cp, ci, cpt, splt, ctx) ->
    
    if splt[0] == ctx.ptn[wrapIndex(ctx,1)][0][0]
        return true
    false
    
#  0000000   0000000    0000000    00     00   0000000   000000000   0000000  000   000  
# 000   000  000   000  000   000  000   000  000   000     000     000       000   000  
# 000000000  000   000  000   000  000000000  000000000     000     000       000000000  
# 000   000  000   000  000   000  000 0 000  000   000     000     000       000   000  
# 000   000  0000000    0000000    000   000  000   000     000      0000000  000   000  

addMatch = (cpt, splt, ctx) ->
    
    strongMatch = false
    varMatch = false
    varName = null
    
    lr = stackTopOrLast ctx
    ci = 0
    si = 0
    
    while ci < cpt.length
        
        cp = cpt[ci]
        
        if cp == splt[si]
            log 'sm' cp
            strongMatch = true
            varName = null
            si++
            ci++
            continue
            
        if cp?[0] in '●'
            
            if ci == 0 and strongMatchAhead lr, cp, ci, cpt, splt, ctx
                ctx.pind = wrapIndex ctx, 1
                if valid ctx.stack
                    last(ctx.result)[last(ctx.stack)[1..]].pop()
                ctx.stack = []
                cptn = ctx.ptn[ctx.pind]
                ctx.result.push {}
                return addMatch cptn[0], splt, ctx

            varMatch = true
            varName = cp[1..]
            lr[varName] = splt[si]
            si++
            ci++
            continue
            
        else if varMatch and varName and valid splt[si+1]
            
            log 'swallow'
            lr[varName] += ' ' + splt[si]
            si++
            continue
        else
            log 'bail?' cp, splt[si]
            return false
            
    if ci == cpt.length and varName and si < splt.length
        lr[varName] += ' ' + splt[si..].join ' '
        log 'add rest' varName, lr[varName]
            
    if empty ctx.stack and (strongMatch or varMatch)
        ctx.pind = wrapIndex ctx, 1
        if ctx.pind == 0 ➜ ctx.result.push {}
        # log 'wrapIndex' strongMatch, varMatch, ctx.pind
    true
    
# 000000000  00000000    0000000   000   000  00000000  00000000    0000000  00000000  
#    000     000   000  000   000  000   000  000       000   000  000       000       
#    000     0000000    000000000   000 000   0000000   0000000    0000000   0000000   
#    000     000   000  000   000     000     000       000   000       000  000       
#    000     000   000  000   000      0      00000000  000   000  0000000   00000000  

traverse = (lines, ctx) ->
    
    while line = lines.shift()
        
        splt = trim(line).split /\s+/
        cptn = ctx.ptn[ctx.pind]
        
        # log y2('▸'), y5(line), ctx.pind, m5(cptn)
    
        if empty cptn
            log 'empty pattern at index' ctx.pind
            ctx.pind = 0
            ctx.result.push {}
            cptn = ctx.ptn[ctx.pind]
            
        if valid cptn[1] # ■
            if last ctx.stack == last cptn[1]
                log 'one???'
                1
            else
                lr = stackTopOrLast ctx
                ctx.stack.push cptn[1][0]
                lr[cptn[1][0][1..]] = []
        else if valid ctx.stack
            ctx.pind = wrapIndex ctx, 1
            ctx.stack = []
        
        if addMatch cptn[0], splt, ctx
        else
            log b4('no match'), cptn[0], splt
            
    if empty last ctx.result ➜ ctx.result.pop()
             
# 00000000    0000000   000000000  000000000  00000000  00000000   000   000  
# 000   000  000   000     000        000     000       000   000  0000  000  
# 00000000   000000000     000        000     0000000   0000000    000 0 000  
# 000        000   000     000        000     000       000   000  000  0000  
# 000        000   000     000        000     00000000  000   000  000   000  

pattern = (kmt) ->
    
    p = []
    lines = kmt.split '\n'
    while line = lines.shift()
        lpt = trim(line).split /\s+/
        if lpt[0][0] == '■'
            while child = lines.shift()
                cpt = child.split /\s+/
                if empty cpt[0]
                    p.push [cpt[1..], [lpt[0]]]
                else
                    lines.unshift child
                    break
        else
            p.push [lpt, []]
    p
        
# 000   000  00000000  00000000   00     00  000  000000000  
# 000  000   000       000   000  000   000  000     000     
# 0000000    0000000   0000000    000000000  000     000     
# 000  000   000       000   000  000 0 000  000     000     
# 000   000  00000000  000   000  000   000  000     000     

kermit = (kmt, str) ->

    lines = str.split '\n'
    lines = lines.filter (l) -> valid trim l

    ctx = result:[{}], stack:[], pind:0 ptn:pattern kmt
    traverse lines, ctx
    ctx.result
    
kermit.pattern = pattern

export kermit
