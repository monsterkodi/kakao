###
     0000000  000000000  000   000  000    
    000          000      000 000   000    
    0000000      000       00000    000    
         000     000        000     000    
    0000000      000        000     0000000
    
    poor man's stylus :)
###

use ./kstr â–ª unfillet blockFillets

# 00000000   00000000  000   000  0000000    00000000  00000000   
# 000   000  000       0000  000  000   000  000       000   000  
# 0000000    0000000   000 0 000  000   000  0000000   0000000    
# 000   000  000       000  0000  000   000  000       000   000  
# 000   000  00000000  000   000  0000000    00000000  000   000  

vars = {}
funcs = {}
ampersands = []

subvars = (fillets) ->
    
    for fillet in fillets
        if value = vars[fillet.match]
            fillet.match = value
        
    fillets
    
calculus = (fillets) ->
    
    for fillet,index in fillets
        continue if index < 1
        if fillet.match in '*+-/'
            lhs  = parseFloat fillets[index-1].match
            rhs  = parseFloat fillets[index+1].match
            if lhs is num and rhs is num
                lhu  = trim fillets[index-1].match[("#{lhs}").length..]
                rhu  = trim fillets[index+1].match[("#{rhs}").length..]
                unit = valid lhu ? lhu : rhu
                result = eval "#{lhs} #{fillet.match} #{rhs}"
                result += unit
                # log 'calculus' result
                fillets.splice index-1, 3, match:result
                return calculus fillets
        
    fillets

render = (block, text) ->
    
    if block.fillet[0]?.match == '//'
        return text
        
    if block.fillet[1]?.match == '='
        varName = block.fillet[0]?.match
        varValue = unfillet calculus subvars block.fillet[2..]
        vars[varName] = varValue
        return text
        
    if block.fillet[1]?.match == '()'
        funcName = block.fillet[0]?.match
        
        if funcs[funcName]
            text += funcs[funcName]
            return text
        
        funcValue = ''
        for cb in block.blocks
            funcValue = render cb, funcValue
        funcs[funcName] = funcValue
        return text
        
    if block.fillet[0]?.match[0] == '&'
        ampersands.push block
        return text
        
    idt = rpad block.indent
        
    if valid block.blocks
        text += '\n' + idt + unfillet block.fillet
        text += '\n' + idt + '{'
        for b in block.blocks
            text += render b, ''
        text += '\n' + idt + '}\n'
    else
        text += '\n'
        text += idt + block.fillet[0].match + ': ' + unfillet calculus subvars block.fillet[1..]
        text += ';'
    
    if valid ampersands
        
        prefix = unfillet block.fillet
        
        amps = ampersands
        ampersands = []

        while ampersand = amps.shift()

            text += prefix + unfillet(ampersand.fillet)[1..]

            if valid ampersand.blocks
                text += '\n' + '{'
                for b in ampersand.blocks
                    text += render b, ''
                text += '\n' + '}\n'
                    
            text += '\n'
    text
    
#  0000000  000000000  000   000  000      
# 000          000      000 000   000      
# 0000000      000       00000    000      
#      000     000        000     000      
# 0000000      000        000     0000000  

styl = (srcText) ->
    
    vars = {}
    funcs = {}
    
    tgtText = ''
    lines   = srcText.split '\n'
    blocks  = blockFillets lines.map (line) -> kstr.fillet line, '-'
    
    for block in blocks
        tgtText = render block, tgtText

    tgtText

export styl
