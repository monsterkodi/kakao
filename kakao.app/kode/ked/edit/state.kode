###
 0000000  000000000   0000000   000000000  00000000
000          000     000   000     000     000
0000000      000     000000000     000     0000000
     000     000     000   000     000     000
0000000      000     000   000     000     00000000
###

use child_process os
use ../../kxk ▪ immutable kstr kseg
use ../util   ◆ syntax
use ./act     ◆ del insert select join indent multi main
use ./tool    ◆ belt
use           ◆ keys mode

function state

    @: @cells name ->

        @name = name + '.state'
        
        @allowedModes = {}

        for act in [del insert select join indent multi main]
            for k,v of act
                @[k] = v.bind @
                
        @handleKey = keys.bind @

        @syntax = new syntax
        @hasFocus = false

        @s = immutable
            lines:       [[]]
            selections:  []
            highlights:  []
            cursors:     [[0 0]]
            main:        0
            view:        [0 0]
            
        @clearHistory()

    toggleMode: name -> mode.toggle @ name if @allowedModes[name]
    startMode: name -> mode.start @ name if @allowedModes[name]
    stopMode: name -> mode.stop @ name if @allowedModes[name]
        
    owner: -> 
        
        if @name.endsWith '.state'
            @name[0...-6]
        else
            @name
        
    clearHistory: ->
    
        @h = [@s] # undo states (history)
        @r = []   # redo states

    #  0000000  00000000  000000000
    # 000       000          000
    # 0000000   0000000      000
    #      000  000          000
    # 0000000   00000000     000

    set: item arg =>

        # log item noon(arg) if item=='selections'
        @s = @s.set item arg
        @swapState()
        @

    setSelections: selections -> @set 'selections' belt.mergeLineRanges(@allLines() selections)
    setHighlights: highlights -> @set 'highlights' belt.normalizeSpans(highlights)

    #  0000000  000   000  00000000    0000000   0000000   00000000    0000000
    # 000       000   000  000   000  000       000   000  000   000  000
    # 000       000   000  0000000    0000000   000   000  0000000    0000000
    # 000       000   000  000   000       000  000   000  000   000       000
    #  0000000   0000000   000   000  0000000    0000000   000   000  0000000

    setCursors: cursors opt ->
        
        opt ?= {}
        main = opt.main

        if main is arr ➜ main = belt.indexOfPosInPositions main cursors
        if main is num and main < 0 ➜ main = cursors.length+main

        if main?
            mainCursor = copy cursors[clamp 0 cursors.length-1 main]
        else
            mainCursor = @mainCursor()
        
        cursors = belt.normalizePositions cursors @s.lines.length-1

        @s = @s.set 'cursors' cursors

        main = -1
        for cur,idx in cursors
            if cur eql mainCursor
                main = idx
                break

        main = @s.main if main < 0
        main = clamp 0 @s.cursors.length-1 main

        @s = @s.set 'main' main

        @adjustViewForMainCursor opt
        @swapState()
        
        mode.cursorsSet @
        
        if not mode.isActive @ 'salter'
            mode.modes.salter.checkCursorsSet @
        @
            
    textOfSelectionOrWordAtCursor: -> 
        
        if @s.selections.length
            ⮐ @textOfSelection()
        else
            log 'wordAtCursor' @wordAtCursor()
            ⮐ @wordAtCursor()

    # 000      000  000   000  00000000   0000000
    # 000      000  0000  000  000       000
    # 000      000  000 0 000  0000000   0000000
    # 000      000  000  0000  000            000
    # 0000000  000  000   000  00000000  0000000

    setLines: lines =>
        
        if empty lines ➜ lines = ['']
            
        # if not lines[0] is str ➜ log 'state.setLines' @name lines
            
        @setSegls kseg.segls(lines)
        
    setSegls: @segls =>
        
        if empty @segls ➜ @segls = [[]]
        
        # log 'state.setSegls' @name @segls
            
        @syntax.setSegls @segls
        
        @s = @s.set 'lines' @segls
        @r = []
        @pushState()

    allLines: => @s.lines.asMutable()
    
    linesInView: => @s.lines[@s.view[1]...@s.view[1]+@cells.rows]

    loadLines: lines => 
    
        if valid lines and not lines[0] is str ➜ log 'state.loadLines - first line no segl?' @name lines 
        
        @loadSegls kseg.segls(lines)
    
    loadSegls: segls =>

        @s = @s.set 'cursors' [[0 0]]
        @s = @s.set 'view' [0 0]
        @s = @s.set 'main' 0
        @clearCursorsHighlightsAndSelections()
        @r = []
        @h = []
        @setSegls segls

    clearLines: =>

        @setSegls [[]]
        @setMainCursor 0 0

    isValidLineIndex:   li => 0 <= li < @s.lines.length
    isInvalidLineIndex: li => not @isValidLineIndex li

    # 000   000  000   000  0000000     0000000
    # 000   000  0000  000  000   000  000   000
    # 000   000  000 0 000  000   000  000   000
    # 000   000  000  0000  000   000  000   000
    #  0000000   000   000  0000000     0000000

    undo: =>

        ⮐ if @h.length <= 1
        @r.push @h.pop()
        @s = @h[-1]
        @syntax.setSegls @allLines()

    redo: =>

        ⮐ if empty @r
        @h.push @r.pop()
        @s = @h[-1]
        @syntax.setSegls @allLines()

    begin: => @beginIndex = @h.length

    end: =>

        if valid @beginIndex

            @h.splice @beginIndex @h.length-@beginIndex-1

            delete @beginIndex
        @

    pushState: -> @h.push @s ; @
    swapState: -> @h.pop() ; @pushState()

    isDirty: => @h.length > 1
    hasRedo: => @r.length > 0

    gutterWidth: => max 4 2 + Math.ceil(Math.log10(@s.lines.length+1))

    #  0000000  000   000  000000000
    # 000       000   000     000
    # 000       000   000     000
    # 000       000   000     000
    #  0000000   0000000      000

    cut: =>
        # log 'state.cut'
        @copy deselect:false
        if empty @s.selections
            @selectCursorLines()
            # log 'state.cut' @allSelections()
        @deleteSelection()

    #  0000000   0000000   00000000   000   000
    # 000       000   000  000   000   000 000
    # 000       000   000  00000000     00000
    # 000       000   000  000           000
    #  0000000   0000000   000           000

    copy: opt =>
    
        opt ?= {}

        switch os.platform()

            'darwin'

                proc = child_process.spawn 'pbcopy'
                proc.stdin.end @textOfSelectionOrCursorLines()

            'linux'

                proc = child_process.spawn 'xsel' ['-i' '--clipboard']
                proc.stdin.write @textOfSelectionOrCursorLines()
                proc.stdin.end()

            'win32'

                proc = child_process.spawn "#{◆dir}/../../bin/utf8clip.exe"
                proc.stdin.write @textOfSelectionOrCursorLines()
                proc.stdin.end()
                
        @deselect() if opt.deselect != false

    # 00000000    0000000    0000000  000000000  00000000
    # 000   000  000   000  000          000     000
    # 00000000   000000000  0000000      000     0000000
    # 000        000   000       000     000     000
    # 000        000   000  0000000      000     00000000

    paste: =>

        switch os.platform()

            'darwin'

                @insert child_process.execSync('pbpaste').toString("utf8")

            'linux'

                text = child_process.execSync('xsel -o --clipboard')

                log 'paste\n' noon(text.toString("utf8"))

                @insert text.toString("utf8")

            'win32'

                @insert child_process.execSync("#{◆dir}/../../bin/utf8clip.exe").toString("utf8")

    #  0000000   0000000  00000000    0000000   000      000          000   000  000  00000000  000   000  
    # 000       000       000   000  000   000  000      000          000   000  000  000       000 0 000  
    # 0000000   000       0000000    000   000  000      000           000 000   000  0000000   000000000  
    #      000  000       000   000  000   000  000      000             000     000  000       000   000  
    # 0000000    0000000  000   000   0000000   0000000  0000000          0      000  00000000  00     00  

    scrollView: dir steps=1 =>

        sx = sy = 0

        switch dir
            'left'  ➜ sx = -1
            'right' ➜ sx =  1
            'up'    ➜ sy = -steps
            'down'  ➜ sy =  steps

        view = @s.view.asMutable()

        view[0] += sx
        view[1] += sy

        view[1] = clamp 0 max(0 @s.lines.length-@cells.rows) view[1]

        width = belt.widthOfLines @s.lines
        
        maxOffsetX = max 0 width-@cells.cols+2
        maxOffsetX = max maxOffsetX @mainCursor()[0]-@cells.cols+2
        view[0] = clamp 0 maxOffsetX view[0]
        
        ⮐ if view eql @s.view

        @setView view

    #  0000000   0000000          000  000   000   0000000  000000000       000   000  000  00000000  000   000  
    # 000   000  000   000        000  000   000  000          000          000   000  000  000       000 0 000  
    # 000000000  000   000        000  000   000  0000000      000           000 000   000  0000000   000000000  
    # 000   000  000   000  000   000  000   000       000     000             000     000  000       000   000  
    # 000   000  0000000     0000000    0000000   0000000      000              0      000  00000000  00     00  
    
    adjustViewForMainCursor: opt =>

        [x y] = @mainCursor()

        view = @s.view.asMutable()
        
        opt ?= {}
        
        if opt.adjust == 'topBotDelta'
            topBotDelta = min 6 int(@cells.rows/4)
        else
            topBotDelta = 0

        if y >= view[1] + @cells.rows - 1 - topBotDelta
            view[1] = y - @cells.rows + 1 + topBotDelta
        else if y < view[1] + topBotDelta
            view[1] = y - topBotDelta

        if view[1] > 0 and @s.lines.length < @cells.rows
            view[1] = 0

        view[0] = max 0 x - @cells.cols + 2 # adding one for wide graphemes
        
        ⮐ if view eql @s.view
        
        @setView view

    initView: =>

        view = @s.view.asMutable()
        view[1] = clamp 0 max(0 @s.lines.length-@cells.rows) view[1]
        view[0] = max 0 view[0]

        @setView view

    setView: view =>

        @set 'view' view
        @

    rangeForVisibleLines: =>

        [@s.view[0] @s.view[1] @s.view[0]+@cells.cols-1 @s.view[1]+@cells.rows-1]

export state
