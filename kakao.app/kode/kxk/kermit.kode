###
000   000  00000000  00000000   00     00  000  000000000
000  000   000       000   000  000   000  000     000   
0000000    0000000   0000000    000000000  000     000   
000  000   000       000   000  000 0 000  000     000   
000   000  00000000  000   000  000   000  000     000   
###

use ◆ kstr

pattern = (kmt) ->
    
    p = []
    lines = kmt.split '\n'
    while line = lines.shift()
        lpt = trim(line).split /\s+/
        if lpt[0][0] == '■'
            while child = lines.shift()
                cpt = child.split /\s+/
                if empty cpt[0]
                    p.push [cpt[1..], lpt[0]]
                else
                    lines.unshift child
                    break
        else
            p.push [lpt, null]
    p
    
stackTopOrLast = (ctx) ->
    
    lr = last ctx.result
    if valid ctx.stack
        lr = lr[last(ctx.stack)[1..]]
        lr.push {}
        lr = last lr
    lr
    
strongMatchAhead = (lr, cp, ci, cpt, splt, ctx) ->
    
    # log 'strongMatchAhead?' lr, cp, ci, cpt, splt, ctx.ptn[ctx.pind+1]
    # log 'strongMatchAhead?' splt, ctx.ptn[(ctx.pind+1) % ctx.ptn.length]
    if splt[0] == ctx.ptn[(ctx.pind+1) % ctx.ptn.length][0][0]
        log 'strongMatchAhead!'
        return true
    log 'no strong match' splt[0], ctx.ptn[(ctx.pind+1) % ctx.ptn.length][0][0]
    false
    
addMatch = (cpt, splt, ctx) ->
    
    log 'addMatch' cpt, splt, ctx.pind, ctx.result

    lr = stackTopOrLast ctx
    for cp,ci in cpt
        if cp?[0] in '●'
            log 'var match' ci, cpt[ci+1..], splt[ci+1..]
            if strongMatchAhead lr, cp, ci, cpt, splt, ctx
                log 'strong match ahead!' kstr ctx
                ctx.pind += 1
                ctx.stack = []
                cptn = ctx.ptn[ctx.pind]
                log 'recurse' cpt[0], splt, ctx
                addMatch cpt[0], splt, ctx
                return true
            else
                lr[cp[1..]] = splt[ci]
                if empty cpt[ci+1..] and valid splt[ci+1..]
                    # log 'add remaining' splt[ci+1..].join ' '
                    lr[cp[1..]] += ' ' + splt[ci+1..].join ' '
        else if cp == splt[ci]
            log 'strong match' ci, cp, 'next' cpt[ci+1..], splt[ci+1..]
        else
            log 'missmatch' ci, cp, splt[ci]
            return false
    if empty ctx.stack
        ctx.pind += 1
    true
    
traverse = (lines, ctx) ->
    
    while line = lines.shift()
        
        splt = trim(line).split /\s+/
        cptn = ctx.ptn[ctx.pind]
        
        log y2('▸'), y5(line), ctx.pind, m5(cptn)
    
        if empty cptn
            log 'empty pattern at index' ctx.pind
            ctx.pind = 0
            ctx.result.push {}
            cptn = ctx.ptn[ctx.pind]
            
        if cptn[1]
            # log 'cptn[1] ------' cptn[1], ctx
            if last ctx.stack == cptn[1]
                log 'cont stack'
            else
                lr = stackTopOrLast ctx
                ctx.stack.push cptn[1]
                lr[cptn[1][1..]] = []
                log 'push stack' ctx.stack, lr
        else if valid ctx.stack
            log 'clear stack'
            ctx.pind += 1
            ctx.stack = []
        
        if addMatch cptn[0], splt, ctx
        else
            log b4('no match'), cptn[0], splt
                
kermit = (kmt, str) ->

    lines = str.split '\n'
    lines = lines.filter (l) -> valid trim l

    ctx = result:[{}], stack:[], pind:0 ptn:pattern kmt
    traverse lines, ctx
    log 'result' ctx.result
    ctx.result

export kermit
