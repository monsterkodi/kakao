# ████████   ███   ███  ███████    ████████ 
# ███   ███  ████  ███  ███   ███  ███   ███
# ███████    ███ █ ███  ███   ███  ███████  
# ███   ███  ███  ████  ███   ███  ███   ███
# ███   ███  ███   ███  ███████    ███   ███

import std/[strformat, strutils]
import kommon
import lexi
import pars

type
    Rndr = object
        s           : string
        indent      : int
        needsIndent : bool

proc add(r: var Rndr, text: string)     = r.s &= text
proc space(r: var Rndr)                 = r.s &= " "
proc addTok(r: var Rndr, n: Node)       = r.s &= n.token.str
proc addLine(r: var Rndr, text: string) = 

    r.s &= text

proc indent(r: var Rndr) = log 'indent'
 
proc dedent(r: var Rndr) = log 'dedent'

proc render(r: var Rndr, n: Node)

proc render(r: var Rndr, nodes: seq[Node]) =

    for i,n in nodes
        r.render n
        if i<nodes.len-1
            r.add ", "

proc ▸block(r: var Rndr, n: Node) = 

    for exp in n.expressions
        
        r.render exp

proc ▸operation(r: var Rndr, n: Node) = 

    if n.token.tok notin {◆assign}
        r.add "("
    r.render n.operand_left
    r.space()
    case n.token.tok
        of ◆and
            r.add 'and'
        of ◆or
            r.add 'or'
        else 
            r.addTok n
    r.space()
    r.render n.operand_right
    if n.token.tok notin {◆assign}
        r.add ")"

proc ▸preOp(r: var Rndr, n: Node) = 

    if n.token.tok == ◆not
        r.add "not "
    else
        r.addTok n
        
    r.render n.operand
    
proc ▸postOp(r: var Rndr, n: Node) = 

    r.render n.operand
    r.addTok n
    
proc ▸propertyAccess(r: var Rndr, n: Node) = 

    r.render n.owner
    r.addTok n
    r.render n.property

proc ▸func(r: var Rndr, n: Node) = 

    r.add "proc "
    r.render n.func_name
    r.add "("
    r.render n.func_args
    r.add ")"
    if n.func_type != nil
        r.add " : "
        r.render n.func_type
    r.add " ="
    
proc ▸argType(r: var Rndr, n: Node) =

    r.render n.arg_name
    if n.arg_type != nil
        r.add ":"
        if n.token.tok == ◆var
            r.add "var "
        r.render n.arg_type
    if n.arg_default != nil
        r.add "="
        r.render n.arg_default.default

proc ▸string(r: var Rndr, n: Node) = 

    r.add "\""
    r.addTok n
    r.add "\""
    
proc ▸call(r: var Rndr, n: Node) =

    r.render n.callee
    r.add "("
    r.render n.call_args
    r.add ")"

proc ▸if(r: var Rndr, n: Node) =

    r.add "if "
    for i,condThen in n.cond_thens
        # log &"if.condThen {condThen} kind:{condThen.kind}"
        if i > 0
            r.add " elif "
        r.render condThen.cond
        r.add ": "
        r.render condThen.then
    if n.else != nil   
        r.add " else: "
        r.render n.else
        
proc ▸return(r: var Rndr, n: Node) =

    r.add "return"
    if n.return_value != nil
        r.space()
        r.render n.return_value
     
proc ▸switch(r: var Rndr, n: Node)         = log '▸switch'
proc ▸switchCase(r: var Rndr, n: Node)     = log '▸switchCase'
proc ▸range(r: var Rndr, n: Node)          = log '▸range'
proc ▸ident(r: var Rndr, n: Node)          = log '▸iden'
proc ▸var(r: var Rndr, n: Node)            = log '▸var'
proc ▸testCase(r: var Rndr, n: Node)       = log '▸testCase'

proc render(r: var Rndr, n: Node) =

    if n == nil
        ⮐  
    # let b1 = true
    # let b2 = false
    # log &"render {node.kind} {b1 and b2}"
    
    case n.kind
    
        of ●block
            r.▸block(n)
        of ●if
            r.▸if(n)
        of ●switch
            r.▸switch(n)
        of ●switchCase
            r.▸switchCase(n)
        of ●func
            r.▸func(n)
        of ●argType
            r.▸argType(n)
        of ●call
            r.▸call(n)
        of ●operation
            r.▸operation(n)
        of ●postOp
            r.▸postOp(n)
        of ●preOp
            r.▸preOp(n)
        of ●range
            r.▸range(n)
        of ●propertyAccess
            r.▸propertyAccess(n)
        of ●var
            r.▸var(n)
        of ●return
            r.▸return(n)
        of ●testCase
            r.▸testCase(n)
        of ●literal
            if n.token.tok == ◆string
                r.▸string(n)
            else
                r.addTok n
        else
            log &"unhandled {n}"
            r.addTok n

proc rndr*(root: Node): string =

    var r = Rndr()
    r.render(root)
    r.s

proc rndr*(code: string): string =

    rndr(ast(code))
                            