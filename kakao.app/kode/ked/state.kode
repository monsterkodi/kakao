###
 0000000  000000000   0000000   000000000  00000000  
000          000     000   000     000     000       
0000000      000     000000000     000     0000000   
     000     000     000   000     000     000       
0000000      000     000   000     000     00000000  
###

use ../kxk ◆ immutable kstr
use ◆ color

function state

    @: @cells -> @init ['']
    
    init: lines ->
        
        @s = immutable
            lines:       lines
            selections:  []
            cursor:      [0 0]
            view:        [0 0]
            gutter:      @calcGutter(lines.length)

        @setCursor 0 0
        
    calcGutter: numLines =>
        
        2 + Math.ceil(Math.log10(numLines))
            
    #  0000000  000   000  00000000    0000000   0000000   00000000   
    # 000       000   000  000   000  000       000   000  000   000  
    # 000       000   000  0000000    0000000   000   000  0000000    
    # 000       000   000  000   000       000  000   000  000   000  
    #  0000000   0000000   000   000  0000000    0000000   000   000  
    
    setCursor: x y =>
        
        y = clamp 0 @s.lines.length-1 y
        x = max 0 x
                        
        @s = @s.set 'cursor' [x y]
        
        view = @s.view.asMutable()
        
        if y >= view[1] + @cells.t.rows() - 1
            view[1] = y - @cells.t.rows() + 2
        else if y < view[1]
            view[1] = y

        view[0] = max 0 x - @cells.t.cols() + @s.gutter + 1
            
        @s = @s.set 'view' view
            
        @cells.t.setCursor x+@s.gutter y-@s.view[1]
        
    moveCursor: dir steps=1 merge=true =>
        
        c = @s.cursor.asMutable() 
        
        switch dir
            'left'  ➜ c[0] -= 1
            'right' ➜ c[0] += 1
            'up'    ➜ c[1] -= steps
            'down'  ➜ c[1] += steps 
        
        if merge
            @s = @s.set 'selections' @mergeSelections(@s.selections.asMutable())
        
        @setCursor c[0] c[1]
        
    moveCursorAndSelect: dir =>
        
        cpos = -1
        
        selections = @s.selections.asMutable()
        selection = [@s.cursor[0] @s.cursor[1] @s.cursor[0] @s.cursor[1]]
        selections.push selection 
        
        switch dir
            'up'
            'left'  ➜ cpos = 0
            'down'
            'right' ➜ cpos = 2

        @moveCursor dir 1 false
        
        switch dir
            'left'  ➜ selection[cpos]   = selection[cpos]-1
            'right' ➜ selection[cpos]   = selection[cpos]+1
            'up'    ➜ selection[cpos+1] = max 0 selection[cpos+1]-1
            'down'  ➜ selection[cpos+1] = min @s.lines.length-1 selection[cpos+1]+1
            
        selection[0] = clamp 0 @s.lines[selection[1]].length selection[0]
        selection[2] = clamp 0 @s.lines[selection[3]].length selection[2]
        
        @s = @s.set 'selections' selections
            
        true
        
    # 00     00  00000000  00000000    0000000   00000000  
    # 000   000  000       000   000  000        000       
    # 000000000  0000000   0000000    000  0000  0000000   
    # 000 0 000  000       000   000  000   000  000       
    # 000   000  00000000  000   000   0000000   00000000  
    
    mergeSelections: sels ->
        
        ⮐ [] if empty sels
        
        sels = sels.map (a) -> if a[1] > a[3] ➜ [a[2] a[3] a[0] a[1]] else a
        sels = sels.map (a) -> if a[1] == a[3] and a[0] > a[2] ➜ [a[2] a[1] a[0] a[3]] else a
        sels.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        sels = sels.filter (a) -> a[0] != a[2] or a[1] != a[3]
        
        mrgd = []
        for s,i in sels
            if empty mrgd or s[1] > mrgd[mrgd.length-1][3] or s[0] > mrgd[mrgd.length-1][2]
                mrgd.push s
            else if s[3] > mrgd[mrgd.length-1][3] or s[2] > mrgd[mrgd.length-1][2]
                mrgd[mrgd.length-1][2] = s[2] 
                mrgd[mrgd.length-1][3] = s[3] 

        # lf.write noon mrgd
        mrgd
        
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    select: from to =>
        
        selections = []
        
        @setCursor to[0] to[1]
        
        if from[1] > to[1]
            [from to] = [to from]
        else if from[1] == to[1] and from[0] > to[0]
            [from to] = [to from]

        to[0] = clamp 0 @s.lines[to[1]].length to[0]
        from[0] = clamp 0 @s.lines[from[1]].length from[0]
                
        selections.push [from[0] from[1] to[0] to[1]]
        
        @s = @s.set 'selections' selections
        
        true
        
    selectChunk: x y =>
        
        line = @s.lines[y]
        
        [rs re] = kstr.rangeOfClosestChunk line x
        if rs >= 0 and re >= 0
            @select [rs y] [re+1 y]

    selectWord: x y =>
        
        line = @s.lines[y]
        
        [rs re] = kstr.rangeOfClosestWord line x
        if rs >= 0 and re >= 0
            @select [rs y] [re+1 y]
            
    isSelectedLine: y =>
        
        for selection in @s.selections
            if selection[3] == y and selection[2] == 0
                continue
            if selection[1] <= y <= selection[3]
                ⮐ true
        false
            
    selectLine: y =>
        
        @select [0 y] [@s.lines[y].length y]
        
    deselect: =>
        
        if valid @s.selections
            @s = @s.set 'selections' []
            ⮐ true
                        
    # 0000000    00000000    0000000   000   000  
    # 000   000  000   000  000   000  000 0 000  
    # 000   000  0000000    000000000  000000000  
    # 000   000  000   000  000   000  000   000  
    # 0000000    000   000  000   000  00     00  
    
    draw: =>
        
        for row in 0...@cells.t.rows()-1
            
            y = row+@s.view[1]
            line = @s.lines[y]
            
            for x in 0...@cells.t.cols()-@s.gutter
                if x+@s.gutter < @cells.t.cols() and x+@s.view[0] < line.length
                    @cells.c[row][x+@s.gutter].fg   = color.text
                    @cells.c[row][x+@s.gutter].char = line[x+@s.view[0]]

            if y < @s.lines.length
                linel = line.length - @s.view[0]
                if y == @s.cursor[1]
                    if linel > 0
                        @cells.bg_rect @s.gutter row @s.gutter+linel row color.cursor_main
                    @cells.bg_rect max(@s.gutter @s.gutter+linel) row -1 row color.cursor_empty
                else
                    if linel > 0
                        @cells.bg_rect @s.gutter row @s.gutter+linel row color.editor
                    @cells.bg_rect max(@s.gutter @s.gutter+linel) row -1 row color.editor_empty
                    
        for selection in @s.selections
            
            for li in selection[1]..selection[3]
                
                y  = li-@s.view[1]
                
                if @s.view[1] <= li < @s.view[1] + @cells.t.rows() - 1
                    
                    if li == selection[1]
                        xs = selection[0]
                    else
                        xs = 0
                        
                    if li == selection[3]
                        xe = selection[2]
                    else
                        xe = @s.lines[li].length
                        
                    for x in xs...xe
                        if @s.gutter <= x-@s.view[0]+@s.gutter < @cells.t.cols()
                            @cells.c[y][x-@s.view[0]+@s.gutter].bg = color.selection

export state