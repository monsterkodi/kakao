###
000   000  000000000  000  000    
000   000     000     000  000    
000   000     000     000  000    
000   000     000     000  000    
 0000000      000     000  0000000
###

use ../../kxk ▪ kstr

class util
    
    #  0000000  00000000  000      000       0000000  
    # 000       000       000      000      000       
    # 000       0000000   000      000      0000000   
    # 000       000       000      000           000  
    #  0000000  00000000  0000000  0000000  0000000   
    
    @cells: rows cols ->
    
        lines = []
        for l in 0...rows
            cells = []
            for c in 0...cols
                cells.push bg:null fg:null char:' '
            lines.push cells
        lines
    
    # 00000000    0000000    0000000
    # 000   000  000   000  000     
    # 00000000   000   000  0000000 
    # 000        000   000       000
    # 000         0000000   0000000 

    @pos: x y -> (x is arr and empty y) ? x : [x y]
    
    @samePos: a b -> a[0] == b[0] and a[1] == b[1]
    
    @normalizePositions: posl maxY ->
        
        ⮐ [] if empty posl 
        
        posl = posl.map (a) -> [max(0 a[0]) clamp(0 maxY a[1])]
        posl = util.sortPositions posl
        posl = util.removeDuplicatePositions posl
        
    @sortPositions: posl -> posl.sort (a b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]
        
    @removeDuplicatePositions: posl ->
        
        ⮐ posl if posl.length <= 1
        
        for i in posl.length-1..1
            if util.samePos posl[i] posl[i-1]
                posl.splice i 1
        posl
        
    @indexOfPosInPositions: pos posl ->
        
        ⮐ -1 if empty posl
        posl.findIndex (p) -> pos eql p
        
    @lineIndicesForPositions: posl ->
        
        set = new Set()
        for pos in posl
            set.add pos[1]
        Array.from set
        
    @positionInDirection: pos dir ->
        
        [x y] = pos
        
        switch dir
            'up'    ➜ [x y-1]
            'down'  ➜ [x y+1]
            'left'  ➜ [x-1 y]
            'right' ➜ [x+1 y]
            
    @traversePositionsInDirection: posl pos dir ->

        while next = util.neighborPositionInDirection posl pos dir
            pos = next
        pos
        
    @neighborPositionInDirection: posl pos dir ->
        
        nbp = util.positionInDirection pos dir
        if util.positionsContain posl nbp
            posl[util.indexOfPosInPositions nbp posl]

    @positionsContain: posl pos ->
        
        for p in posl
            ⮐ true if p eql pos
        false
        
    @positionsOutsideRange: posl rng ->
        
        posl.filter (p) -> util.isPosOutsideRange(p rng)
                
    # 00000000    0000000   000   000   0000000   00000000  
    # 000   000  000   000  0000  000  000        000       
    # 0000000    000000000  000 0 000  000  0000  0000000   
    # 000   000  000   000  000  0000  000   000  000       
    # 000   000  000   000  000   000   0000000   00000000  
    
    @isPosInsideRange: pos rng ->
        
        ⮐ false if util.isPosBeforeRange pos rng 
        ⮐ false if util.isPosAfterRange pos rng 
        true
        
    @isPosOutsideRange: pos rng -> not util.isPosInsideRange pos rng

    @isPosBeforeRange: pos rng ->
    
        pos[1] < rng[1] or (pos[1] == rng[1] and pos[0] < rng[0])
    
    @isPosAfterRange: pos rng ->
    
        pos[1] > rng[3] or (pos[1] == rng[3] and pos[0] >= rng[2])
        
    @isPosTouchingRange: pos rng ->
        
        ⮐ true if util.isPosInsideRange pos rng
        ⮐ true if pos eql util.endOfRange rng
        ⮐ true if pos eql util.startOfRange rng
        false

    @rangeContainsPos: rng pos -> util.isPosInsideRange pos rng
    @rangeTouchesPos:  rng pos -> util.isPosTouchingRange pos rng
        
    @rangeForSpan: span -> [span[0] span[1] span[2] span[1]]
    @rangeFromStartToEnd: start end -> [start[0] start[1] end[0] end[1]]
    
    @isEmptyRange: rng -> rng[0] == rng[2] and rng[1] == rng[3]
    @isRangeEmpty: rng -> rng[0] == rng[2] and rng[1] == rng[3]

    @startOfRange: rng -> [rng[0] rng[1]]
    @endOfRange:   rng -> [rng[2] rng[3]]
        
    #  0000000  00000000    0000000   000   000  
    # 000       000   000  000   000  0000  000  
    # 0000000   00000000   000000000  000 0 000  
    #      000  000        000   000  000  0000  
    # 0000000   000        000   000  000   000  
 
    @isSameSpan:  a b -> a eql b
    @isSameRange: a b -> a eql b
    
    @isPosInsideSpan: pos span ->

        ⮐ false if util.isPosBeforeSpan pos span
        ⮐ false if util.isPosAfterSpan pos span
        true
        
    @isPosBeforeSpan: pos span ->
        
        pos[1] < span[1] or (pos[1] == span[1] and pos[0] < span[0])

    @isPosAfterSpan: pos span ->
        
        pos[1] > span[1] or (pos[1] == span[1] and pos[0] >= span[2])
        
    @isPosBeforeOrInsideSpan: pos span ->
        
        util.isPosBeforeSpan(pos span) or util.isPosInsideSpan(pos span)

    @startOfSpan: s -> [s[0] s[1]]
    @endOfSpan:   s -> [s[2] s[1]]
    
    @nextSpanAfterPos: spans pos ->
        
        ⮐ if empty spans
        
        pos = [0 0] if util.isPosAfterSpan pos spans[-1]
        
        ⮐ spans[0] if util.isPosBeforeSpan pos spans[0]
            
        for span,index in spans
            if util.isPosAfterSpan pos span
                if index+1 < spans.length and util.isPosBeforeOrInsideSpan pos spans[index+1]
                    ⮐ spans[index+1]

    @prevSpanBeforePos: spans pos ->
        
        ⮐ if empty spans
        ⮐ spans[-1] if util.isPosBeforeSpan pos spans[0]
        ⮐ spans[-1] if util.isPosInsideSpan pos spans[0]
            
        for index in spans.length-1..0
            span = spans[index]
            if util.isPosAfterSpan pos span
                ⮐ span
                    
    @normalizeSpans: spans ->
        
        ⮐ [] if empty spans
        
        spans = spans.map (a) -> if a[0] > a[2] ➜ [a[2] a[1] a[0]] else a
        spans.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        spans = spans.filter (a) -> a[0] != a[2]
        
    # 00000000    0000000   000   000   0000000   00000000   0000000  
    # 000   000  000   000  0000  000  000        000       000       
    # 0000000    000000000  000 0 000  000  0000  0000000   0000000   
    # 000   000  000   000  000  0000  000   000  000            000  
    # 000   000  000   000  000   000   0000000   00000000  0000000   
    
    @rangesContainLine: rngs lineIndex -> 
        
        for rng in rngs
            ⮐ true if rng[1] <= lineIndex <= rng[3]
        false
        
    @rangesContainSpan: rngs span -> @rangesContainRange rngs util.rangeForSpan(span)
    @rangesContainRange: rngs range -> 
        
        for rng in rngs
            ⮐ true if rng eql range
        false
                
    @normalizeRanges: rngs ->
        
        ⮐ [] if empty rngs or not rngs is arr
        
        rngs = rngs.map (a) -> if a[1] > a[3] ➜ [a[2] a[3] a[0] a[1]] else a
        rngs = rngs.map (a) -> if a[1] == a[3] and a[0] > a[2] ➜ [a[2] a[1] a[0] a[3]] else a
        rngs.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        
    @startPositionsOfRanges: rngs -> rngs.map (r) -> util.startOfRange r
    @endPositionsOfRanges:   rngs -> rngs.map (r) -> util.endOfRange r
        
    @removeTrailingEmptyRange: rngs ->
        
        if util.isEmptyRange rngs[-1]
            rngs[0..-2]
        else
            rngs
            
    @rangesForLinePositions: lines posl ->
        
        ⮐ [] if empty posl
        rngs = [[0 0 posl[0][0] posl[0][1]]]
        for pos,idx in posl
            rngs.push [posl[idx-1][0] posl[idx-1][1] pos[0] pos[1]] if idx > 0            
        rngs.push [posl[-1][0] posl[-1][1] lines[-1].length lines.length-1]
        rngs
        
    @rangeInRangesContainingPos: rngs pos ->
        
        for rng in rngs
            if util.rangeContainsPos rng pos
                ⮐ rng

    @rangeInRangesTouchingPos: rngs pos ->
        
        for rng in rngs
            if util.rangeTouchesPos rng pos
                ⮐ rng   

    @lineIndicesForRangesOrPositions: rngs posl ->

        indices = util.lineIndicesForRanges rngs
        indices = util.lineIndicesForPositions posl if empty indices
        indices
                
    # 00     00  00000000  00000000    0000000   00000000  
    # 000   000  000       000   000  000        000       
    # 000000000  0000000   0000000    000  0000  0000000   
    # 000 0 000  000       000   000  000   000  000       
    # 000   000  00000000  000   000   0000000   00000000  
    
    @mergeLineRanges: lines rngs ->
        
        ⮐ [] if empty rngs or not rngs is arr
        
        rngs = util.normalizeRanges rngs
        
        mrgd = []
        for s,i in rngs
            if empty mrgd or 
                s[1] > tail[3]+1 or 
                s[1] == tail[3] and s[0] > tail[2] or 
                s[1] == tail[3]+1 and (s[0] > 0 or tail[2] < lines[tail[3]].length)
                    mrgd.push s
                    tail = s
            else if s[3] > tail[3] or s[3] == tail[3] and s[2] > tail[2]
                tail[2] = s[2] 
                tail[3] = s[3]

        mrgd

    # 000000000  00000000  000   000  000000000  
    #    000     000        000 000      000     
    #    000     0000000     00000       000     
    #    000     000        000 000      000     
    #    000     00000000  000   000     000     
    
    @linesForText: text -> 
        
        text = text.replace /\x1b/g, '▪'
    
        text.split /\r?\n/
    
    @textForLineRange: lines rng ->
        
        ⮐ '' if empty lines or empty rng
        
        l = []
        
        for y in rng[1]..rng[3]
            continue if util.isInvalidLineIndex lines y
            if
                y == rng[1]
                    if 
                        y == rng[3] ➜ l.push lines[y][rng[0]...rng[2]]
                                    ➜ l.push lines[y][rng[0]..]
                y == rng[3] ➜ l.push lines[y][0...rng[2]]
                            ➜ l.push lines[y]
        
        l.join '\n'
        
    @textForLineRanges: lines rngs ->
        
        ⮐ '' if empty lines
        
        text = ''
        for rng in rngs
            text += util.textForLineRange lines rng
            text += '\n'
        text[0...-1]
        
    @lineSpansForText: lines text ->
        
        spans = []
        
        for line,y in lines
            x2 = 0
            while true
                x1 = line.indexOf text x2
                break if x1 < 0
                x2 = x1+text.length
                spans.push [x1 y x2]
        
        spans
        
    @textFromBolToPos: lines pos -> lines[pos[1]][0...pos[0]]
    
    @isOnlyWhitespace: text -> /^\s+$/.test text
    
    @numIndent: str ->
 
        if m = str.match /^\s+/
            ⮐ String(m).length
        0
        
    @splitLineIndent: str ->
        
        i = util.numIndent str
        [str[0...i] str[i..]]
        
    # 000      000  000   000  00000000   0000000  
    # 000      000  0000  000  000       000       
    # 000      000  000 0 000  0000000   0000000   
    # 000      000  000  0000  000            000  
    # 0000000  000  000   000  00000000  0000000   
    
    @lineRangeAtPos: lines pos ->

        [0 pos[1] lines[pos[1]].length pos[1]]

    @lineRangesForPositions: lines posl append=false->
        
        rngs = util.lineIndicesForPositions(posl).map (y) -> [0 y lines[y].length y]
        if valid rngs and append
            rngs[-1][2]  = 0 
            rngs[-1][3] += 1
        rngs        

    @lineIndentAtPos: lines pos -> 

        [x y] = pos

        util.numIndent lines[y]
            
    @lineIndicesForRange: rng ->
        
        indices = []
        
        for li in rng[1]..rng[3]
            if li != rng[3] or rng[2] > 0
                indices.push li
        
        indices
        
    @lineIndicesForRanges: rngs ->
        
        indices = []
        
        for rng in rngs
            indices = indices.concat @lineIndicesForRange(rng)
            
        indices
        
    @numFullLinesInRange: lines rng ->
        
        d = rng[3] - rng[1]
        
        if d == 0 
            ⮐ rng[0] == 0 and rng[2] == lines[rng[1]].length ? 1 : 0
        
        n = 0
        n += 1   if rng[0] == 0 
        n += d-2 if d > 1
        n += 1   if rng[2] == lines[rng[3]].length
        n
        
    @numLinesInRange: rng -> rng[3] - rng[1] + 1
    
    @isEmptyLineAtPos: lines pos -> lines[pos[1]].length <= 0
        
    @lineRangesInRange: lines rng ->
        
        rngs = []
        for ln in 0...util.numLinesInRange(rng)
            rngs.push util.lineRangeAtPos(lines [0 rng[1]+ln])
        rngs
        
    @linesForLineRange: lines rng ->

        util.splitLineRange(lines rng).map (r) -> util.textForLineRange lines r

    @splitLineRange: lines rng includeEmpty=true -> # split multi-line-range into list of single-line-ranges
        
        nl = util.numLinesInRange rng 
        ⮐ [rng] if nl == 1
        
        split = []
        
        split.push [rng[0] rng[1] lines[rng[1]].length rng[1]]
        
        if nl > 2
            for i in 1..nl-2
                split.push [0 rng[1]+i lines[rng[1]+i].length rng[1]+i]
        
        split.push [0 rng[3] rng[2] rng[3]] if includeEmpty or rng[2] > 0

        split
                            
    @splitLineRanges: lines rngs includeEmpty=true -> # split list of multi-line-ranges into list of single-line-ranges
        
        split = []        
        for rng in rngs
            split = split.concat util.splitLineRange(lines rng includeEmpty)
        split
        
    @isLinesPosInside:  lines pos -> pos[1] < lines.length and 0 <= pos[0] <= lines[pos[1]].length
    @isLinesPosOutside: lines pos -> not util.isLinesPosInside lines pos 
    
    @isValidLineIndex:   lines li -> 0 <= li < lines.length
    @isInvalidLineIndex: lines li -> not util.isValidLineIndex lines li
    
    @isFullLineRange:    lines rng -> 
        
        ⮐ true if rng[1] != rng[3]
    
        rng[1] == rng[3] and 0 <= rng[1] < lines.length and rng[0] == 0 and rng[2] >= lines[rng[1]].length
        
    @rangeOfLine: lines y -> [0 y lines[y].length y]
    
    @numIndentOfLines: lines ->
        
        for line in lines
            continue if empty trim line
            ⮐ util.numIndent line
        0

    #  0000000  000   000  000   000  000   000  000   000  
    # 000       000   000  000   000  0000  000  000  000   
    # 000       000000000  000   000  000 0 000  0000000    
    # 000       000   000  000   000  000  0000  000  000   
    #  0000000  000   000   0000000   000   000  000   000  
    
    @rangeOfClosestChunkToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if util.isInvalidLineIndex lines y
         
        if r = kstr.rangeOfClosestChunk lines[y] x
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]
        
    # 000   000   0000000   00000000   0000000    
    # 000 0 000  000   000  000   000  000   000  
    # 000000000  000   000  0000000    000   000  
    # 000   000  000   000  000   000  000   000  
    # 00     00   0000000   000   000  0000000    
    
    @rangeOfClosestWordToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if util.isInvalidLineIndex lines y
         
        if r = kstr.rangeOfClosestWord lines[y] x
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]

    @rangeOfWordOrWhitespaceLeftToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if x <= 0 or util.isInvalidLineIndex lines y
        
        if r = kstr.rangeOfClosestWord lines[y][0...x] x
            if r[1] < x
                ⮐ [r[1] y x y]
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]
            
        [0 y x y]   

    @rangeOfWordOrWhitespaceRightToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if x < 0 or util.isInvalidLineIndex lines y
        
        if r = kstr.rangeOfClosestWord lines[y][x..] 0
            if 0 == r[0] < r[1]
                ⮐ [x y r[1]+x y]
            if r[0] > 0 
                ⮐ [x y r[0]+x y]
            
        [x y lines[y].length y]   
        
    @lineChar: line x -> line[x] if 0 <= x < line.length
        
    @categoryForChar: char -> 
        
        if 
            empty char      ➜ ⮐ 'empty'
            /\s+/.test char ➜ ⮐ 'ws'
            /\w+/.test char ➜ ⮐ 'word'
            
        'punct'
        
    @jumpDelta: line px dx jump ->
        
        if dx > 0
            ci = px
            if nc = cat = util.categoryForChar util.lineChar(line ci)
                ⮐ dx if cat not in jump
                while true
                    ci += dx
                    nc = util.categoryForChar util.lineChar(line ci)
                    break if nc != cat
                    break if ci <= 0
                    ⮐ 1 if nc == 'empty'
            ci - px
        else
            ci = px - 1
            ⮐ 0 if ci < 0
            if ci >= line.length and 'empty' in jump ➜ ⮐ line.length - ci - 1
            cat = util.categoryForChar util.lineChar(line ci)
            ⮐ dx if cat not in jump
            while 0 <= ci < line.length and util.categoryForChar(util.lineChar(line ci)) == cat
                ci += dx
            min dx ci - px + 1

    @numCharsFromPosToWordOrPunctInDirection: lines pos dir opt ->
        
        dx = dir == 'left' ? -1 : 1
        
        if opt?.jump ➜ ⮐ util.jumpDelta(lines[pos[1]] pos[0] dx opt.jump)
            
        ⮐ 0 if pos[0] + dx < 0
        dx
        
    # 0000000    00000000  000      00000000  000000000  00000000  
    # 000   000  000       000      000          000     000       
    # 000   000  0000000   000      0000000      000     0000000   
    # 000   000  000       000      000          000     000       
    # 0000000    00000000  0000000  00000000     000     00000000  
    
    @deleteLineRangesAndAdjustPositions: lines rngs posl ->
        
        lines = copy lines
        posl  = clone posl
        
        for ri in rngs.length-1..0
            rng = rngs[ri]
            
            posl = util.adjustPositionsForDeletedLineRange posl lines rng
            
            if rng[1] == rng[3] # single line range
                if rng[0] == 0 and rng[2] == lines[rng[1]].length
                    lines.splice rng[1] 1
                else
                    lines.splice rng[1] 1 kstr.splice(lines[rng[1]] rng[0] rng[2]-rng[0])
            else # range spans multiple lines
                if rng[2] == lines[rng[3]].length # range ends at end of last line
                    lines.splice rng[3] 1 
                else
                    lines.splice rng[3] 1 lines[rng[3]][rng[2]..]
                    partialLast = true
                    
                if rng[3]-rng[1] >= 2 # more than 2 lines in range
                    lines.splice rng[1]+1 rng[3]-rng[1]-1 # remove middle lines
                    
                if rng[0] == 0 # range starts at start of first line
                    lines.splice rng[1] 1
                else
                    lines.splice rng[1] 1 lines[rng[1]][0...rng[0]]
                    
                    if partialLast
                        lines.splice rng[1] 2 lines[rng[1]] + lines[rng[1]+1]
               
        [lines posl]
        
    @adjustPositionsForDeletedLineRange: posl lines rng ->
        
        for pi in posl.length-1..0
            pos = posl[pi]
            
            if util.isPosTouchingRange pos rng
                pos[0] = rng[0] 
                pos[1] = rng[1]
            else if util.isPosAfterRange pos rng
                if pos[1] == rng[3] # pos in last line of range
                    pos[0] -= rng[2] - rng[0]
                    if rng[1] < rng[3] # multi line range
                        pos[1] -= rng[3] - rng[1]
                else
                    pos[1] -= util.numFullLinesInRange(lines rng)
            else
                break
                    
        util.removeDuplicatePositions posl
        
    @moveCursorsInSameLineBy: cursors cursor delta ->
    
        ci = cursors.indexOf cursor
    
        while true
            
            cursors[ci][0] += delta
            ci++
            
            ⮐ if ci >= cursors.length
            ⮐ if cursors[ci][1] > cursor[1]
            
    #  0000000   0000000    0000000          00000000    0000000   000   000   0000000   00000000   0000000  
    # 000   000  000   000  000   000        000   000  000   000  0000  000  000        000       000       
    # 000000000  000   000  000   000        0000000    000000000  000 0 000  000  0000  0000000   0000000   
    # 000   000  000   000  000   000        000   000  000   000  000  0000  000   000  000            000  
    # 000   000  0000000    0000000          000   000  000   000  000   000   0000000   00000000  0000000   
    
    @addLinesBelowPositionsToRanges: lines posl rngs ->
    
        newp = []
        newr = copy rngs
    
        addLineAtIndex = c i ->
            range = util.rangeOfLine lines i
            range[1] += 1 if util.isEmptyRange range
            newr.push range
            newp.push util.endOfRange(range)
            
        for c in posl
            if not util.rangesContainLine(rngs c[1])
                addLineAtIndex c c[1]
            else
                addLineAtIndex c c[1]+1 if c[1] < lines.length-1
    
        [newp newr]
    
    # 00000000   00000000  00     00   0000000   000   000  00000000     00000000   000   000   0000000    0000000    
    # 000   000  000       000   000  000   000  000   000  000          000   000  0000  000  000        000         
    # 0000000    0000000   000000000  000   000   000 000   0000000      0000000    000 0 000  000  0000  0000000     
    # 000   000  000       000 0 000  000   000     000     000          000   000  000  0000  000   000       000    
    # 000   000  00000000  000   000   0000000       0      00000000     000   000  000   000   0000000   0000000     
    
    @removeLinesAtPositionsFromRanges: lines posl rngs ->
        
        newp = []
        newr = util.splitLineRanges lines rngs
        
        for pos in posl
            if rng = util.rangeInRangesTouchingPos newr pos
                idx = newr.indexOf rng
                if idx > 0
                    newp.push util.endOfRange(newr[idx-1])
                else
                    newp.push util.endOfRange(newr[idx])
                newr.splice idx 1
            else
                newp.push pos
        [newp newr]

    # 0000000    00000000   00000000   0000000   000   000      000      000  000   000  00000000   0000000  
    # 000   000  000   000  000       000   000  000  000       000      000  0000  000  000       000       
    # 0000000    0000000    0000000   000000000  0000000        000      000  000 0 000  0000000   0000000   
    # 000   000  000   000  000       000   000  000  000       000      000  000  0000  000            000  
    # 0000000    000   000  00000000  000   000  000   000      0000000  000  000   000  00000000  0000000   
    
    @breakLinesAtPositions: lines posl ->
        
        newls = []
        newpl = []
        for rng,idx in util.rangesForLinePositions lines posl
            ls = util.linesForLineRange lines rng
            if idx > 0
                if posl[idx-1][0]
                    indent = util.numIndent last newls
                    indent = max indent util.numIndentOfLines(ls[1..]) if ls.length>1 and posl[idx-1][0] > indent
                else indent = 0
                newpl.push [indent newls.length] 
            ls[0] = lpad(indent) + ls[0] if indent
            newls = newls.concat ls
        [newls newpl]
        
    # 000  000   000   0000000  00000000  00000000   000000000        000000000  00000000  000   000  000000000  
    # 000  0000  000  000       000       000   000     000              000     000        000 000      000     
    # 000  000 0 000  0000000   0000000   0000000       000              000     0000000     00000       000     
    # 000  000  0000       000  000       000   000     000              000     000        000 000      000     
    # 000  000   000  0000000   00000000  000   000     000              000     00000000  000   000     000     
    
    @insertTextAtPositions: lines text posl ->
        
        if text == '\t'
            pos  = posl[0]
            text = lpad 4-pos[0]%4 ' '
        text = kstr.detab text
        
        txtls = util.linesForText text
        newls = []
        newpl = []
        rngs = util.rangesForLinePositions lines posl
        
        for idx in 0...rngs.length
            
            rng   = rngs[idx]
            after = util.linesForLineRange lines rng
            
            if idx > 0
                
                [x y] = posl[idx-1]
                
                if valid before ➜ line = before.pop()
                else              line = newls.pop()
                    
                # fill line at end with spaces if pos is behind end of line
                if x > line.length ➜ line += lpad x-line.length
                                        
                if txtls.length > 1
                    
                    mod = (idx-1) % txtls.length
                    txt = txtls[mod]
                    
                    if idx == rngs.length-1 and posl.length == 1
                        while mod < txtls.length-1
                            before.push line+txt
                            mod++
                            txt  = txtls[mod]
                            line = ''
                else                    
                    txt = txtls[0]
                
                line += txt
                    
                px = line.length
                line += after.shift()
                before.push line
                
                newls = newls.concat before
                newpl.push [px newls.length-1]
                
            before = after
            
        newls = newls.concat before
            
        [newls newpl]      
        
    @rangeForJoiningLine: lines idx -> [lines[idx].length idx 0 idx+1]
        
    @rangesForJoiningLines: lines idxs -> idxs.map (idx) -> util.rangeForJoiningLine lines idx
    
    # 00     00   0000000   000   000  00000000         000      000  000   000  00000000   0000000  
    # 000   000  000   000  000   000  000              000      000  0000  000  000       000       
    # 000000000  000   000   000 000   0000000          000      000  000 0 000  0000000   0000000   
    # 000 0 000  000   000     000     000              000      000  000  0000  000            000  
    # 000   000   0000000       0      00000000         0000000  000  000   000  00000000  0000000   
    
    @moveLineRangesAndPositionsAtIndicesInDirection: lines rngs posl indices dir ->
        
        if empty indices or dir == 'down' and indices[-1] >= lines.length-1 or dir == 'up' and indices[0] <= 0
            ⮐ [lines rngs posl]
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        [rs re] = switch dir
            'down' ➜ [indices.length-1 0]
            'up'   ➜ [0 indices.length-1]
        
        for ii in rs..re
            index = indices[ii]
            
            switch dir 
                'down' ➜ newLines.splice index   2 newLines[index+1] newLines[index] 
                'up'   ➜ newLines.splice index-1 2 newLines[index]   newLines[index-1]
                
            for pos in newPosl
                if pos[1] == index 
                    pos[1] += switch dir                     
                        'down' ➜ 1
                        'up'   ➜ -1

            for rng in newRngs
                if rng[1] == index 
                    d = switch dir                     
                        'down' ➜ 1
                        'up'   ➜ -1
                    rng[1] += d
                    rng[3] += d
        
        [newLines newRngs newPosl]
                  
    #  0000000   0000000   00     00  00     00  00000000  000   000  000000000   0000000  
    # 000       000   000  000   000  000   000  000       0000  000     000     000       
    # 000       000   000  000000000  000000000  0000000   000 0 000     000     0000000   
    # 000       000   000  000 0 000  000 0 000  000       000  0000     000          000  
    #  0000000   0000000   000   000  000   000  00000000  000   000     000     0000000   
    
    @toggleCommentsInLineRangesAtIndices: lines rngs posl indices ->
        
        ⮐ [lines rngs posl] if empty indices
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        comStart = '#'
        minIndent = Infinity
             
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
            if not line.startsWith comStart
                comment = comStart
                minIndent = min indent.length minIndent
            
        comIndent = lpad minIndent if comment
                
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
            if comment
                indent = indent.length > minIndent ? lpad(indent.length-minIndent) : ''
                newLine = comIndent + comment + indent + ' ' + line
            else
                d = line[comStart.length] == ' ' ? 1 : 0
                newLine = indent + line[comStart.length+d..]
            newLines.splice index 1 newLine
        
        [newLines newRngs newPosl]      
        
    # 0000000    00000000  000  000   000  0000000    00000000  000   000  000000000  
    # 000   000  000       000  0000  000  000   000  000       0000  000     000     
    # 000   000  0000000   000  000 0 000  000   000  0000000   000 0 000     000     
    # 000   000  000       000  000  0000  000   000  000       000  0000     000     
    # 0000000    00000000  000  000   000  0000000    00000000  000   000     000     
    
    @deindentLineRangesAndPositionsAtIndices: lines rngs posl indices ->
        
        ⮐ [lines rngs posl] if empty indices  
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
        
            if indent.length
                
                sc = min 4 indent.length
                newLines.splice index 1 indent[sc..] + line
                
                for pos in newPosl
                    if pos[1] == index 
                        pos[0] = max 0 pos[0] - sc
                        
                for rng in newRngs
                    if rng[1] == index 
                        rng[0] = max 0 rng[0] - sc
                        rng[2] = max 0 rng[2] - sc
        
        [newLines newRngs newPosl]

    # 000  000   000  0000000    00000000  000   000  000000000  
    # 000  0000  000  000   000  000       0000  000     000     
    # 000  000 0 000  000   000  0000000   000 0 000     000     
    # 000  000  0000  000   000  000       000  0000     000     
    # 000  000   000  0000000    00000000  000   000     000     
    
    @indentLineRangesAndPositionsAtIndices: lines rngs posl indices ->
        
        ⮐ [lines rngs posl] if empty indices  
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
        
            newLines[index] = lpad(4 ' ') + newLines[index]
            
            for pos in newPosl
                if pos[1] == index 
                    pos[0] += 4
                    
            for rng in newRngs
                if rng[1] == index 
                    rng[0] += 4
                    rng[2] += 4
        
        [newLines newRngs newPosl]
        
    # 00000000  000   000  000000000  00000000  000   000  0000000          00000000   000   000   0000000    0000000  
    # 000        000 000      000     000       0000  000  000   000        000   000  0000  000  000        000       
    # 0000000     00000       000     0000000   000 0 000  000   000        0000000    000 0 000  000  0000  0000000   
    # 000        000 000      000     000       000  0000  000   000        000   000  000  0000  000   000       000  
    # 00000000  000   000     000     00000000  000   000  0000000          000   000  000   000   0000000   0000000   
    
    @extendLineRangesFromPositionToPosition: lines rngs start pos ->

        if empty rngs ➜ ⮐ [util.rangeFromStartToEnd(start pos)]

        newRngs = copy rngs
        
        if rng = util.rangeInRangesTouchingPos newRngs start
            if util.isPosAfterRange pos rng
                rng[2] = pos[0]
                rng[3] = pos[1]
            else if util.isPosBeforeRange pos rng
                rng[0] = pos[0]
                rng[1] = pos[1]
        else
            newRngs.push util.rangeFromStartToEnd(start pos)

        newRngs
    
    @extendLineRangesByMovingPositionsInDirection: lines rngs posl dir ->
        
        newRngs = copy rngs
        newPosl = copy posl
        
        for pos in newPosl
            
            line = lines[pos[1]]
            rng = [pos[0] pos[1] pos[0] pos[1]]
            newRngs.push rng
            
            switch dir
                'left'  
                'right'     ➜ pos[0] += util.numCharsFromPosToWordOrPunctInDirection(lines pos dir)
                'up'        ➜ pos[1] -= 1
                'down'      ➜ pos[1] += 1
                'eol'       ➜ pos[0] = line.length
                'bol'       ➜ pos[0] = 0
                'bof'       ➜ pos[0] = 0; pos[1] = 0
                'eof'       ➜ pos[1] = lines.length-1; pos[0] = lines[lines.length-1].length

                'ind_bol'   ➜ ind = util.numIndent(line); pos[0] = pos[0] > ind ? ind : 0
                'ind_eol'   ➜ ind = util.numIndent(line); pos[0] = pos[0] < ind ? ind : line.length
                
            switch dir
                'left'      ➜ rng[0] = rng[0]-1
                'right'     ➜ rng[2] = rng[2]+1
                'up'        ➜ rng[1] = max 0 rng[1]-1
                'down'      ➜ rng[3] = min lines.length-1 rng[3]+1
                'eol'       ➜ rng[2] = Infinity
                'bol'       ➜ rng[0] = 0
                'bof'       ➜ rng[1] = rng[0] = 0
                'eof'       ➜ rng[3] = lines.length-1; rng[2] = lines[lines.length-1].length

                'ind_bol'   ➜ ind = util.numIndent(line); rng[0] = rng[0] > ind ? ind : 0
                'ind_eol'   ➜ ind = util.numIndent(line); rng[2] = rng[2] < ind ? ind : line.length
                
            rng[0] = clamp 0 lines[rng[1]].length rng[0] if rng[1] < lines.length
            rng[2] = clamp 0 lines[rng[3]].length rng[2] if rng[3] < lines.length
        
        [newRngs newPosl]
        
export util
