# ███   ███  ███  ██     ██
# ███  ███   ███  ███   ███
# ███████    ███  █████████
# ███  ███   ███  ███ █ ███
# ███   ███  ███  ███   ███

use std ▪ monotimes logging os osproc sequtils tables terminal times strformat strutils parseopt random pegs osproc streams asyncdispatch asyncfile posix
use kommon trans rndr greet

var optParser = initOptParser()
var params    ◇ seq[string]
var files     ◇ seq[string] 
var outdir    = ""
var tests     = false
var verbose   = false
var transpile = false

var testFiles = walkDir(currentSourcePath().splitFile()[0] / "test").toSeq().map(◇tuple r ➜string -> r.path)

randomize()

verb = ◇string msg -> 

    if verbose
        log msg 

#  ███████   ████████  █████████         ███████   ████████   █████████
# ███        ███          ███           ███   ███  ███   ███     ███   
# ███  ████  ███████      ███           ███   ███  ████████      ███   
# ███   ███  ███          ███           ███   ███  ███           ███   
#  ███████   ████████     ███            ███████   ███           ███   

for kind key val in optParser.getopt()
    switch kind
        cmdArgument
            params.add key
            files.add(key)
        cmdLongOption cmdShortOption
            params.add '-' & key
            switch key
                'test'
                    tests = true
                'verbose' "v"
                    verbose = true
                'outdir' "o"
                    outdir = val
                'transpile' "t"
                    transpile = true
                'help' "h"
                    log "usage: " getAppFilename().extractFilename " [options] [file.kim ...]"
                    log ""
                    log "      transpiles kim files to nim"
                    log "      watches cwd if no files are given"
                    log ""
                    log "options:"
                    log "  -o --outdir:DIR  output directory"
                    log "  -t --transpile   log transpilat"
                    log "     --test        run tests"
                    log "  -v --verbose     verbose output"
                    quit(1)
                ➜ 
                    log "unknown option: " key
                    quit(1)
        cmdEnd
            discard
                        
# ████████   ████████   ███████  █████████   ███████   ████████   █████████
# ███   ███  ███       ███          ███     ███   ███  ███   ███     ███   
# ███████    ███████   ███████      ███     █████████  ███████       ███   
# ███   ███  ███            ███     ███     ███   ███  ███   ███     ███   
# ███   ███  ████████  ███████      ███     ███   ███  ███   ███     ███   
            
when defined(posix)
    use posix
    restart = () ->
        args = allocCStringArray(@[getAppFilename()] & params)
        discard execv(getAppFilename().cstring, args)
        quit(1) # only reaches here if execve fails
    
# ███       ███████    ███████   ████████  ███  ███      ████████
# ███      ███   ███  ███        ███       ███  ███      ███     
# ███      ███   ███  ███  ████  ██████    ███  ███      ███████ 
# ███      ███   ███  ███   ███  ███       ███  ███      ███     
# ███████   ███████    ███████   ███       ███  ███████  ████████

logFile = ◇string f prefix="" ->

    ⮐  if not verbose
    let (dir name ext) = f.relativePath(getCurrentDir()).splitFile()
    d = if dir.len ➜ dir & "/" ➜ ""
    icon  = if ext == ".kim" ➜ "  " ➜ "  "
    color = if ext == ".kim" ➜ fgGreen ➜ fgMagenta
    
    styledEcho color prefix styleDim icon resetStyle color styleBright d styleBright name resetStyle # styleDim ext resetStyle
        
#  ███████   ███████   ██     ██  ████████   ███  ███      ████████
# ███       ███   ███  ███   ███  ███   ███  ███  ███      ███     
# ███       ███   ███  █████████  ████████   ███  ███      ███████ 
# ███       ███   ███  ███ █ ███  ███        ███  ███      ███     
#  ███████   ███████   ███   ███  ███        ███  ███████  ████████

compile = ◇string file outDir="bin" ➜ bool ->
    profileScope 'comp'       
    let cmd = "nim c --outDir:#{outdir} --stackTrace:on --lineTrace:on #{file}"
    let (output exitCode) = execCmdEx(cmd)
        
    if exitCode != 0
        styledEcho fgRed "✘ " "#{cmd}"
        log output
        false
    else
        if verbose ➜ styledEcho fgGreen "✔ " fgWhite cmd
        true

# █████████  ████████   ███████  █████████   ███████
#    ███     ███       ███          ███     ███     
#    ███     ███████   ███████      ███     ███████ 
#    ███     ███            ███     ███          ███
#    ███     ████████  ███████      ███     ███████ 

runTests = ->
    profileScope 'test'
    for f in testFiles
        let cmd = "nim r --colors:on #{f}"
        let p = startProcess(command = "nim", args = ["r", f], options = {poStdErrToStdOut, poUsePath})
        let startTime = getMonoTime()
        var output = ""
        
        var fd = p.outputHandle
        var flags = fcntl fd F_GETFL 0
        discard fcntl(fd F_SETFL flags or O_NONBLOCK)
        
        while true
            let elapsed = (getMonoTime() - startTime).inMilliseconds
            if elapsed >= 2000
                output.add("test killed after #{elapsed} ms!!")
                p.terminate()
                sleep(50)
                if p.running
                    p.kill()
                break
                            
            var line = newString 1024*10
            let bytesRead = read fd addr(line[0]) line.len
            if 
                bytesRead > 0
                    output.add(line & "\n")
                errno == EAGAIN
                    discard poll(nil, 0, 50)
                # bytesRead == 0
                #     break
                # not p.running
                #     break
                else
                    break
        
        let exitCode = p.waitForExit()
        
        if exitCode != 0 or verbose
            styledEcho output.replace("[Suite]" ansiForegroundColorCode(fgYellow) & "▸")
                             .replace("[OK]" ansiForegroundColorCode(fgGreen) & "✔\x1b[0m")
                             .replace("[FAILED]" ansiForegroundColorCode(fgRed) & "✘\x1b[0m")
        else
            okCount = output.count("[OK]")
            styledEcho output.replace("[Suite]" ansiForegroundColorCode(fgYellow) & "▸")
                             .replace(peg"'[OK]' .+" "#{ansiStyleCode styleDim} ✔ #{okCount}")
            
        if exitCode != 0
            styledEcho fgRed "✘ " "#{cmd}"
    echo ""

if files.len

    let transpiled = if transpile ➜ rndr.files(files) ➜ trans.pile(files)
    quit transpiled.len - files.len

if tests
    runTests()
    quit(0)
 
# ███   ███   ███████   █████████   ███████  ███   ███
# ███ █ ███  ███   ███     ███     ███       ███   ███
# █████████  █████████     ███     ███       █████████
# ███   ███  ███   ███     ███     ███       ███   ███
# ██     ██  ███   ███     ███      ███████  ███   ███

watch = ◆seq[string] paths ->

    addHandler(newConsoleLogger(fmtStr = "▸ ", useStderr = true))
    
    setControlCHook(() ->  {.noconv.}
        
        styledEcho ''
        styledEcho fgGreen farewells[rand(farewells.high)]
        quit 0
        )
    
    var modTimes ◇Table[string,times.Time]
    
    styledEcho ''
    styledEcho fgGreen, greetings[rand(greetings.high)]
    styledEcho ''
    
    for p in paths
        let (dir name ext) = p.splitFile()
        styledEcho fgBlue styleDim "● " resetStyle styleBright fgBlue dir " " resetStyle styleBright fgYellow name styleDim ext resetStyle
    
    var firstLoop = true
    
    while true
    
        var doBuild = false
        var toTranspile ◇seq[string] 
        var kimFiles    ◇seq[string] 
        var nimFiles    ◇seq[string] 
        
        for path in paths
        
            if not dirExists(path)
            
                continue
                
            for f in walkDirRec(path)
            
                let (dir name ext) = f.splitFile()
                
                switch ext
                    ".kim"  ➜ kimFiles.add(f)
                    ".nim"  ➜ nimFiles.add(f)
                            ➜ continue
                
                let modTime = getFileInfo(f).lastWriteTime
                
                if not modTimes.hasKey(f)
                    modTimes[f] = modTime
                    continue
                  
                if modTimes[f] == modTime
                    continue
        
                modTimes[f] = modTime
                if ext == ".nim" and not testFiles.contains(f)
                    doBuild = true
                elif ext == ".kim"
                    toTranspile.add f
                
        if firstLoop
                                    
            firstLoop = false
            for f in kimFiles ➜ logFile f
            for f in nimFiles ➜ logFile f
                
        if toTranspile
            verb "toTranspile: #{toTranspile}"
            for f in trans.pile(toTranspile)
                verb "transpiled #{f}"    
                logFile f, "✔ "
            runTests()
            
        if doBuild
            if compile("nim/kim.nim", "bin")
                for f in kimFiles
                    logFile trans.trans(f), "✔ "
                restart()
        sleep 200

watch @[getCurrentDir()]
