###
000000000  000000000  000   0000000   
   000        000     000  000   000  
   000        000     000  000   000  
   000        000     000  000   000  
   000        000     000   0000000   
###

use ../kxk ◆ events

function TTIO extends events

    @: ->
        
        @store()
        
        if process.stdin.isTTY ➜ process.stdin.setRawMode true

        @write '\x1b[?1000h'    # mouse events
        @write '\x1b[?1002h'    # cell motion tracking
        @write '\x1b[?1003h'    # mouse move events
        @write '\x1b[?1004h'    # focus events
        @write '\x1b[?1006h'    # mouse SGR mode
        @write '\x1b[?1049h'    # alternate screen buffer
        @write '\x1b[?2004h'    # bracketed paste mode
        @write '\x1b[>1u'       # kitty keyboard protocol
        @write '\x1b[=31;1u'    # 1 disambiguate escape codes
                                # 2 event types
                                # 4 alternate keys
                                # 8 all keys as escape codes
                                # 16 associated text
        
        process.stdout.on 'resize' @onResize
        process.stdin.on  'data'   @onData
        
    write: str => process.stdout.write str
    
    quit: =>
        
        @clear()
        @write '\x1b[?1049l' # scrollback screen buffer
        @write '\x1b[<u'     # end kitty keyboard protocol
        @showCursor()
        @restore()
        process.exit 0
    
    clear: =>
        @write '\x1b[2J' # clear screen
        @write '\x1b[H'  # cursor home

    cols: => process.stdout.columns
    rows: => process.stdout.rows
        
    #  0000000  000   000  00000000    0000000   0000000   00000000   
    # 000       000   000  000   000  000       000   000  000   000  
    # 000       000   000  0000000    0000000   000   000  0000000    
    # 000       000   000  000   000       000  000   000  000   000  
    #  0000000   0000000   000   000  0000000    0000000   000   000  
    
    setCursor: x y => @write "\x1b[#{y+1};#{x+1}H"
    hideCursor: => @write '\x1b[?25l'
    showCursor: show=true => 
        if show
            @write '\x1b[?25h'
        else
            @hideCursor()
            
    store:   => @write '\x1b7'
    restore: => @write '\x1b8'

    onResize: => @emit 'resize' @cols() @rows()
    
    emitMousePress: col row button mods='' =>
        
        @lastClick ?= 
            row:    row
            col:    col
            count:  0
            time:   process.hrtime()
        
        if @lastClick.col == col and @lastClick.row == row
            diff = process.hrtime(@lastClick.time)
            @lastClick.time = process.hrtime()
            if diff[0] < 1 and diff[1] < 500000000
                @lastClick.count += 1
            else    
                @lastClick.count = 1
        else
           @lastClick.col   = col 
           @lastClick.row   = row
           @lastClick.count = 1
           @lastClick.time  = process.hrtime()
                
        @emit 'mouse' 'press' col row button mods @lastClick.count
        
    # 000   000  000  000000000  000000000  000   000  
    # 000  000   000     000        000      000 000   
    # 0000000    000     000        000       00000    
    # 000  000   000     000        000        000     
    # 000   000  000     000        000        000     
    
    parseKittyEvent: csi ->
                
        ⮐ if csi[-1] not in 'uABCD'
        
        key = switch csi[-1]
            'A' ➜ 'up'    
            'B' ➜ 'down'  
            'D' ➜ 'left'  
            'C' ➜ 'right'
            
        char = ''
            
        if csi[-1] == 'u'
            code = parseInt csi                
            key = switch code
                9       ➜ 'tab'
                27      ➜ 'esc'
                13      ➜ 'return'
                127     ➜ 'delete'
                57441   ➜ 'shift'
                57442   ➜ 'ctrl'
                57443   ➜ 'alt'
                57444   ➜ 'cmd'
                        ➜ String.fromCodePoint code
                        
            char = switch key
                'tab'    ➜ '\t'
                'return' ➜ '\n'
                         ➜ ''
                    
        mods = []
        type = 'press'
        
        splt = csi[0..-2].split ';'
        
        if splt.length > 1
            
            type = 'repeat'  if splt[1].endsWith ':2'
            type = 'release' if splt[1].endsWith ':3'
            
            if splt.length > 2
                char = String.fromCodePoint parseInt(splt[2])
            
            mbit = parseInt(splt[1])-1
            if mbit & 0x1 ➜ mods.push 'shift'
            if mbit & 0x4 ➜ mods.push 'ctrl'
            if mbit & 0x2 ➜ mods.push 'alt'
            if mbit & 0x8 ➜ mods.push 'cmd'
                
        if key not in mods
            mods.push key
        combo = mods.join '+'
                    
        key:    key
        combo:  combo
        type:   type
        char:   char
        
    # 0000000     0000000   000000000   0000000   
    # 000   000  000   000     000     000   000  
    # 000   000  000000000     000     000000000  
    # 000   000  000   000     000     000   000  
    # 0000000    000   000     000     000   000  
    
    onData: data =>
        
        if data[0] == 0x1b and data[1] == 0x5b
            csi = data[2..].toString 'utf8'
        else if data[0] == 0x1b
            esc = data[1..].toString 'utf8'
            lf 'esc' esc
        else
            lf 'dta' data
        
        # lf 'data' data[1..]
            
        if @pasteBuffer?
            
            @pasteBuffer += data.toString 'utf8'
            
            if @pasteBuffer.endsWith '\x1b[201~'
                
                @pasteBuffer = @pasteBuffer[0...-6]
                @emit 'paste' @pasteBuffer
                delete @pasteBuffer
            ⮐ 
        
        if csi
            
            if event = @parseKittyEvent csi
                if event.type == 'release'
                    ⮐ @emit 'release' event.combo event
                else 
                    # lf '▸' noon(event)
                    ⮐ @emit 'key' event.combo event
                                
            if csi.startsWith '200~'
                @pasteBuffer = ''
                if csi.endsWith '\x1b[201~'
                    @onData data[6..]
                ⮐
                            
            if csi.startsWith '<'
                
                [code col row] = csi[1..-2].split(';').map (s) -> parseInt s
                x = col-1
                y = row-1
                if csi.endsWith 'M'
                    # lfc code
                    switch code
                        0  ➜ ⮐ @emitMousePress x y 'left' 
                        2  ➜ ⮐ @emitMousePress x y 'right'
                        4  ➜ ⮐ @emitMousePress x y 'left' 'shift'
                        8  ➜ ⮐ @emitMousePress x y 'left' 'alt'
                        16 ➜ ⮐ @emitMousePress x y 'left' 'ctrl'
                        24 ➜ ⮐ @emitMousePress x y 'left' 'ctrl+alt'
                        
                        32 ➜ ⮐ @emit 'mouse' 'drag'  x y 'left'  
                        34 ➜ ⮐ @emit 'mouse' 'drag'  x y 'right' 
                        36 ➜ ⮐ @emit 'mouse' 'drag'  x y 'left'  'shift'
                        40 ➜ ⮐ @emit 'mouse' 'drag'  x y 'left'  'alt'
                        48 ➜ ⮐ @emit 'mouse' 'drag'  x y 'left'  'ctrl'
                        
                        35 ➜ ⮐ @emit 'mouse' 'move'  x y '' 
                        39 ➜ ⮐ @emit 'mouse' 'move'  x y '' 'shift'
                        51 ➜ ⮐ @emit 'mouse' 'move'  x y '' 'ctrl'
                        43 ➜ ⮐ @emit 'mouse' 'move'  x y '' 'alt'
                        47 ➜ ⮐ @emit 'mouse' 'move'  x y '' 'shift+alt'
                        55 ➜ ⮐ @emit 'mouse' 'move'  x y '' 'shift+ctrl'
                        59 ➜ ⮐ @emit 'mouse' 'move'  x y '' 'ctrl+alt'
                        63 ➜ ⮐ @emit 'mouse' 'move'  x y '' 'shift+ctrl+alt'
                        
                        64 ➜ ⮐ @emit 'wheel' x y  'up'   
                        68 ➜ ⮐ @emit 'wheel' x y  'up' 'shift'  
                        72 ➜ ⮐ @emit 'wheel' x y  'up' 'alt'  
                        76 ➜ ⮐ @emit 'wheel' x y  'up' 'shift+alt'  
                        84 ➜ ⮐ @emit 'wheel' x y  'up' 'shift+ctrl'  
                        88 ➜ ⮐ @emit 'wheel' x y  'up' 'ctrl+alt'  
                        92 ➜ ⮐ @emit 'wheel' x y  'up' 'shift+ctrl+alt'
                        
                        65 ➜ ⮐ @emit 'wheel' x y  'down' 
                        69 ➜ ⮐ @emit 'wheel' x y  'down' 'shift'  
                        73 ➜ ⮐ @emit 'wheel' x y  'down' 'alt'  
                        77 ➜ ⮐ @emit 'wheel' x y  'down' 'shift+alt'  
                        85 ➜ ⮐ @emit 'wheel' x y  'down' 'shift+ctrl'  
                        89 ➜ ⮐ @emit 'wheel' x y  'down' 'ctrl+alt'  
                        93 ➜ ⮐ @emit 'wheel' x y  'down' 'shift+ctrl+alt'
                        
                        66 ➜ ⮐ @emit 'wheel' x y  'left' 
                        70 ➜ ⮐ @emit 'wheel' x y  'left' 'shift'  
                        74 ➜ ⮐ @emit 'wheel' x y  'left' 'alt'  
                        78 ➜ ⮐ @emit 'wheel' x y  'left' 'shift+alt'  
                        86 ➜ ⮐ @emit 'wheel' x y  'left' 'shift+ctrl'  
                        90 ➜ ⮐ @emit 'wheel' x y  'left' 'ctrl+alt'  
                        94 ➜ ⮐ @emit 'wheel' x y  'left' 'shift+ctrl+alt'
                        
                        67 ➜ ⮐ @emit 'wheel' x y  'right'
                        71 ➜ ⮐ @emit 'wheel' x y  'right' 'shift'  
                        75 ➜ ⮐ @emit 'wheel' x y  'right' 'alt'   
                        79 ➜ ⮐ @emit 'wheel' x y  'right' 'shift+alt'   
                        87 ➜ ⮐ @emit 'wheel' x y  'right' 'shift+ctrl'   
                        91 ➜ ⮐ @emit 'wheel' x y  'right' 'ctrl+alt'  
                        95 ➜ ⮐ @emit 'wheel' x y  'right' 'shift+ctrl+alt'
                        
                    lfc 'mouse press?' csi
                    ⮐ 
                else if csi.endsWith 'm'
                    switch code
                        0  ➜ ⮐ @emit 'mouse' 'release' x y 'left'
                        2  ➜ ⮐ @emit 'mouse' 'release' x y 'right'
                        4  ➜ ⮐ @emit 'mouse' 'release' x y 'left' 'shift'
                        8  ➜ ⮐ @emit 'mouse' 'release' x y 'left' 'alt'
                        16 ➜ ⮐ @emit 'mouse' 'release' x y 'left' 'ctrl'
                        24 ➜ ⮐ @emit 'mouse' 'release' x y 'left' 'ctrl+alt'
                        
                    lfc 'mouse release?' csi
                    ⮐ 
                
        else if esc
            
            lfc 'esc' esc
                
        else # not a csi or esc sequence
            
            text = data.toString 'utf8'
            
            if text.length > 1
                lfc 'paste?' data[0]==0x1b data[1..] text.length text
                ⮐ @emit 'paste' text
                        
            lfc 'unhandled?' data data.length data[0] data[1..]
                
export TTIO
