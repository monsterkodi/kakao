###
000   000  000000000  000  000    
000   000     000     000  000    
000   000     000     000  000    
000   000     000     000  000    
 0000000      000     000  0000000
###

use ../../kxk ▪ kstr

class util
    
    #  0000000  00000000  000      000       0000000  
    # 000       000       000      000      000       
    # 000       0000000   000      000      0000000   
    # 000       000       000      000           000  
    #  0000000  00000000  0000000  0000000  0000000   
    
    @cells: rows cols ->
    
        lines = []
        for l in 0...rows
            cells = []
            for c in 0...cols
                cells.push bg:null fg:null char:' '
            lines.push cells
        lines
    
    # 00000000    0000000    0000000
    # 000   000  000   000  000     
    # 00000000   000   000  0000000 
    # 000        000   000       000
    # 000         0000000   0000000 

    @pos: x y -> (x is arr and empty y) ? x : [x y]
    
    @samePos: a b -> a[0] == b[0] and a[1] == b[1]
    
    @normalizePositions: posl maxY ->
        
        ⮐ [] if empty posl 
        
        posl = posl.map (a) -> [max(0 a[0]) clamp(0 maxY a[1])]
        posl = util.sortPositions posl
        posl = util.removeDuplicatePositions posl
        
    @sortPositions: posl -> posl.sort (a b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]
        
    @removeDuplicatePositions: posl ->
        
        ⮐ posl if posl.length <= 1
        
        for i in posl.length-1..1
            if util.samePos posl[i] posl[i-1]
                posl.splice i 1
        posl
        
    @indexOfPosInPositions: pos posl ->
        
        ⮐ -1 if empty posl
        posl.findIndex (p) -> pos eql p
        
    @lineIndicesForPositions: posl ->
        
        set = new Set()
        for pos in posl
            set.add pos[1]
        Array.from set
        
    # 00000000    0000000   000   000   0000000   00000000  
    # 000   000  000   000  0000  000  000        000       
    # 0000000    000000000  000 0 000  000  0000  0000000   
    # 000   000  000   000  000  0000  000   000  000       
    # 000   000  000   000  000   000   0000000   00000000  
    
    @isPosInsideRange: pos rng ->
        
        ⮐ false if util.isPosBeforeRange pos rng 
        ⮐ false if util.isPosAfterRange pos rng 
        true

    @isPosBeforeRange: pos rng ->
    
        pos[1] < rng[1] or (pos[1] == rng[1] and pos[0] < rng[0])
    
    @isPosAfterRange:  pos rng ->
    
        pos[1] > rng[3] or (pos[1] == rng[3] and pos[0] >= rng[2])
        
    @rangeForSpan: span -> [span[0] span[1] span[2] span[1]]
    
    @isEmptyRange: rng -> rng[0] == rng[2] and rng[1] == rng[3]
    @isRangeEmpty: rng -> rng[0] == rng[2] and rng[1] == rng[3]

    @startOfRange: rng -> [rng[0] rng[1]]
    @endOfRange:   rng -> [rng[2] rng[3]]
        
    #  0000000  00000000    0000000   000   000  
    # 000       000   000  000   000  0000  000  
    # 0000000   00000000   000000000  000 0 000  
    #      000  000        000   000  000  0000  
    # 0000000   000        000   000  000   000  
 
    @isSameSpan:  a b -> a eql b
    @isSameRange: a b -> a eql b
    
    @isPosInsideSpan: pos span ->

        ⮐ false if util.isPosBeforeSpan pos span
        ⮐ false if util.isPosAfterSpan pos span
        true
        
    @isPosBeforeSpan: pos span ->
        
        pos[1] < span[1] or (pos[1] == span[1] and pos[0] < span[0])

    @isPosAfterSpan: pos span ->
        
        pos[1] > span[1] or (pos[1] == span[1] and pos[0] >= span[2])
        
    @isPosBeforeOrInsideSpan: pos span ->
        
        util.isPosBeforeSpan(pos span) or util.isPosInsideSpan(pos span)

    @startOfSpan: s -> [s[0] s[1]]
    @endOfSpan:   s -> [s[2] s[1]]
    
    @nextSpanAfterPos: spans pos ->
        
        ⮐ if empty spans
        
        pos = [0 0] if util.isPosAfterSpan pos spans[-1]
        
        ⮐ spans[0] if util.isPosBeforeSpan pos spans[0]
            
        for span,index in spans
            if util.isPosAfterSpan pos span
                if index+1 < spans.length and util.isPosBeforeOrInsideSpan pos spans[index+1]
                    ⮐ spans[index+1]

    @prevSpanBeforePos: spans pos ->
        
        ⮐ if empty spans
        ⮐ spans[-1] if util.isPosBeforeSpan pos spans[0]
        ⮐ spans[-1] if util.isPosInsideSpan pos spans[0]
            
        for index in spans.length-1..0
            span = spans[index]
            if util.isPosAfterSpan pos span
                ⮐ span
                    
    @normalizeSpans: spans ->
        
        ⮐ [] if empty spans
        
        spans = spans.map (a) -> if a[0] > a[2] ➜ [a[2] a[1] a[0]] else a
        spans.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        spans = spans.filter (a) -> a[0] != a[2]
        
    # 00000000    0000000   000   000   0000000   00000000   0000000  
    # 000   000  000   000  0000  000  000        000       000       
    # 0000000    000000000  000 0 000  000  0000  0000000   0000000   
    # 000   000  000   000  000  0000  000   000  000            000  
    # 000   000  000   000  000   000   0000000   00000000  0000000   
    
    @rangesContainLine: rngs lineIndex -> 
        
        for rng in rngs
            ⮐ true if rng[1] <= lineIndex <= rng[3]
        false
        
    @rangesContainSpan: rngs span -> @rangesContainRange rngs util.rangeForSpan(span)
    @rangesContainRange: rngs range -> 
        
        for rng in rngs
            ⮐ true if rng eql range
        false
                
    @normalizeRanges: rngs ->
        
        ⮐ [] if empty rngs
        
        rngs = rngs.map (a) -> if a[1] > a[3] ➜ [a[2] a[3] a[0] a[1]] else a
        rngs = rngs.map (a) -> if a[1] == a[3] and a[0] > a[2] ➜ [a[2] a[1] a[0] a[3]] else a
        rngs.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        rngs = rngs.filter (a) -> a[0] != a[2] or a[1] != a[3]
        
    @endPositionsOfRanges: rngs ->
        
        rngs.map (r) -> util.endOfRange r
        
    @removeTrailingEmptyRange: rngs ->
        
        if util.isEmptyRange rngs[-1]
            rngs[0..-2]
        else
            rngs
        
    # 00     00  00000000  00000000    0000000   00000000  
    # 000   000  000       000   000  000        000       
    # 000000000  0000000   0000000    000  0000  0000000   
    # 000 0 000  000       000   000  000   000  000       
    # 000   000  00000000  000   000   0000000   00000000  
    
    @mergeLineRanges: lines rngs ->
        
        ⮐ [] if empty rngs
        
        rngs = util.normalizeRanges rngs
        
        mrgd = []
        for s,i in rngs
            if  empty mrgd or 
                s[1] > tail[3]+1 or 
                s[1] == tail[3] and s[0] > tail[2] or 
                s[1] == tail[3]+1 and (s[0] > 0 or tail[2] < lines[tail[3]].length)
                    mrgd.push s
                    tail = s
            else if s[3] > tail[3] or s[3] == tail[3] and s[2] > tail[2]
                tail[2] = s[2] 
                tail[3] = s[3]

        mrgd

    # 000000000  00000000  000   000  000000000  
    #    000     000        000 000      000     
    #    000     0000000     00000       000     
    #    000     000        000 000      000     
    #    000     00000000  000   000     000     
    
    @textForLinesRange: lines rng ->
        
        ⮐ '' if empty lines or empty rng
        
        l = []
        
        for y in rng[1]..rng[3]
            continue if util.isInvalidLineIndex lines y
            if
                y == rng[1]
                    if 
                        y == rng[3] ➜ l.push lines[y][rng[0]...rng[2]]
                                    ➜ l.push lines[y][rng[0]..]
                y == rng[3] ➜ l.push lines[y][0...rng[2]]
                            ➜ l.push lines[y]
        
        l.join '\n'
        
    @textForLinesRanges: lines rngs ->
        
        ⮐ '' if empty lines
        
        text = ''
        for rng in rngs
            text += util.textForLinesRange lines rng
            text += '\n'
        text[0...-1]
        
    @lineSpansForText: lines text ->
        
        spans = []
        
        for line,y in lines
            x2 = 0
            while true
                x1 = line.indexOf text x2
                break if x1 < 0
                x2 = x1+text.length
                spans.push [x1 y x2]
        
        spans
        
    @textFromBolToPos: lines pos -> lines[pos[1]][0...pos[0]]
    
    @isOnlyWhitespace: text -> /^\s+$/.test text
    
    @numIndent: str ->
 
        if m = str.match /^\s+/
            ⮐ String(m).length
        0
        
    # 000      000  000   000  00000000   0000000  
    # 000      000  0000  000  000       000       
    # 000      000  000 0 000  0000000   0000000   
    # 000      000  000  0000  000            000  
    # 0000000  000  000   000  00000000  0000000   
    
    @lineRangeAtPos: lines pos ->

        [x y] = pos
    
        [0 y lines[y].length y]

    @lineIndentAtPos: lines pos -> 

        [x y] = pos

        util.numIndent lines[y]
            
    @lineIndicesForRange: rng ->
        
        indices = []
        
        for li in rng[1]..rng[3]
            if li != rng[3] or rng[2] > 0
                indices.push li
        
        indices
        
    @lineIndicesForRanges: rngs ->
        
        indices = []
        
        for rng in rngs
            indices = indices.concat @lineIndicesForRange(rng)
            
        indices
        
    @numFullLinesInRange: lines rng ->
        
        d = rng[3] - rng[1]
        
        if d == 0 
            ⮐ rng[0] == 0 and rng[2] == lines[rng[1]].length ? 1 : 0
        
        n = 0
        n += 1   if rng[0] == 0 
        n += d-2 if d > 1
        n += 1   if rng[2] == lines[rng[3]].length
        n
        
    @numLinesInRange: rng -> rng[3] - rng[1] + 1
    
    @isEmptyLineAtPos: lines pos -> lines[pos[1]].length <= 0
        
    @lineRangesInRange: lines rng ->
        
        rngs = []
        for ln in 0...util.numLinesInRange(rng)
            rngs.push util.lineRangeAtPos(lines [0 rng[1]+ln])
        rngs
        
    @splitLineRange: lines rng ->
        
        nl = util.numLinesInRange rng 
        ⮐ [rng] if nl == 1
        
        split = []
        
        split.push [rng[0] rng[1] lines[rng[1]].length rng[1]]
        
        if nl > 2
            for i in 1..nl-2
                split.push [0 rng[1]+i lines[rng[1]+i].length rng[1]+i]
        
        split.push [0 rng[3] rng[2] rng[3]] if rng[2] > 0 # don't include empty last range!

        split
        
    @splitLineRanges: lines rngs ->
        
        split = []        
        for rng in rngs
            split = split.concat util.splitLineRange(lines rng)        
        split
                
    @isLinesPosInside:  lines pos -> pos[1] < lines.length and 0 <= pos[0] <= lines[pos[1]].length
    @isLinesPosOutside: lines pos -> not util.isLinesPosInside lines pos 
    
    @isValidLineIndex:   lines li -> 0 <= li < lines.length
    @isInvalidLineIndex: lines li -> not util.isValidLineIndex lines li
    
    @isFullLineRange:    lines rng -> 
        
        ⮐ true if rng[1] != rng[3]
    
        rng[1] == rng[3] and 0 <= rng[1] < lines.length and rng[0] == 0 and rng[2] >= lines[rng[1]].length
        
    @rangeOfLine: lines y -> [0 y lines[y].length y]

    #  0000000  000   000  000   000  000   000  000   000  
    # 000       000   000  000   000  0000  000  000  000   
    # 000       000000000  000   000  000 0 000  0000000    
    # 000       000   000  000   000  000  0000  000  000   
    #  0000000  000   000   0000000   000   000  000   000  
    
    @rangeOfClosestChunkToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if util.isInvalidLineIndex lines y
         
        if r = kstr.rangeOfClosestChunk lines[y] x
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]
        
    # 000   000   0000000   00000000   0000000    
    # 000 0 000  000   000  000   000  000   000  
    # 000000000  000   000  0000000    000   000  
    # 000   000  000   000  000   000  000   000  
    # 00     00   0000000   000   000  0000000    
    
    @rangeOfClosestWordToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if util.isInvalidLineIndex lines y
         
        if r = kstr.rangeOfClosestWord lines[y] x
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]

    @rangeOfWordOrWhitespaceLeftToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if x <= 0 or util.isInvalidLineIndex lines y
        
        if r = kstr.rangeOfClosestWord lines[y][0...x] x
            if r[1] < x
                ⮐ [r[1] y x y]
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]
            
        [0 y x y]   
                                
    # 0000000    00000000  000      00000000  000000000  00000000  
    # 000   000  000       000      000          000     000       
    # 000   000  0000000   000      0000000      000     0000000   
    # 000   000  000       000      000          000     000       
    # 0000000    00000000  0000000  00000000     000     00000000  
    
    @deleteLineRangesAndAdjustPositions: lines rngs posl ->
        
        for ri in rngs.length-1..0
            rng = rngs[ri]
            
            posl = util.adjustPositionsForDeletedLineRange posl lines rng
            
            if rng[1] == rng[3] # single line range
                if rng[0] == 0 and rng[2] == lines[rng[1]].length
                    lines.splice rng[1] 1
                else
                    lines.splice rng[1] 1 kstr.splice(lines[rng[1]] rng[0] rng[2]-rng[0])
            else # range spans multiple lines
                if rng[2] == lines[rng[3]].length # range ends at end of last line
                    lines.splice rng[3] 1 
                else
                    lines.splice rng[3] 1 lines[rng[3]][rng[2]..]
                    partialLast = true
                    
                if rng[3]-rng[1] >= 2 # more than 2 lines in range
                    lines.splice rng[1]+1 rng[3]-rng[1]-1 # remove middle lines
                    
                if rng[0] == 0 # range starts at start of first line
                    lines.splice rng[1] 1
                else
                    lines.splice rng[1] 1 lines[rng[1]][0...rng[0]]
                    
                    if partialLast
                        lines.splice rng[1] 2 lines[rng[1]] + lines[rng[1]+1]
               
        [lines posl]
        
    @adjustPositionsForDeletedLineRange: posl lines rng ->
        
        for pi in posl.length-1..0
            pos = posl[pi]
            
            if util.isPosInsideRange pos rng
                pos[0] = rng[0] 
                pos[1] = rng[1]
            else if util.isPosAfterRange pos rng
                if pos[1] == rng[3]
                    if rng[1] == rng[3]
                        pos[0] -= rng[2] - rng[0]
                    else
                        pos[0] = rng[0]
                        pos[1] -= rng[3] - rng[1]
                else
                    pos[1] -= util.numFullLinesInRange lines rng
            else
                break
                    
        util.removeDuplicatePositions posl
        
    @moveCursorsInSameLineBy: cursors cursor delta ->
    
        ci = cursors.indexOf cursor
    
        while true
            
            cursors[ci][0] += delta
            ci++
            
            ⮐ if ci >= cursors.length
            ⮐ if cursors[ci][1] > cursor[1]
                
export util
