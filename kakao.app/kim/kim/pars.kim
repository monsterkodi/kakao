# ████████    ███████   ████████    ███████
# ███   ███  ███   ███  ███   ███  ███     
# ████████   █████████  ███████    ███████ 
# ███        ███   ███  ███   ███       ███
# ███        ███   ███  ███   ███  ███████ 

use node

export node

{.experimental: "codeReordering".}

type RHS = proc(p: Parser): Node
type LHS = proc(p: Parser, left: Node): Node

EOF = tkn(◂eof)
    
type Pratt = object
    rhs         : RHS
    lhs         : LHS
    precedence  : int
         
class Parser*

    tokens*     : seq[Token]
    pratts*     : seq[Pratt]
    blocks*     : seq[Node]
    pos*        : int
    explicit    : int
    listless    : int
    inlinecall  : int
    returning   : bool
    typeless    : bool
    failed      : bool
    text        : string # used in `$` for debugging. should be removed eventually 

    current: ➜Token ->
    
        if @pos < @tokens.len
            ⮐  @tokens[@pos]
            
        tkn(◂eof)
    
    tok: ➜tok -> @current.tok

    peek: ahead=1 ➜Token ->
    
        if @pos + ahead < @tokens.len
            @tokens[@pos + ahead]
        else
            EOF

    # ████████   ████████   ███  ███   ███  █████████  
    # ███   ███  ███   ███  ███  ████  ███     ███     
    # ████████   ███████    ███  ███ █ ███     ███     
    # ███        ███   ███  ███  ███  ████     ███     
    # ███        ███   ███  ███  ███   ███     ███     

    $: ➜string ->
    
        s = ""
        if @tok != ◂eof
            s = "▪▪▪ #{@current} #{@pos}"
            l = @text.split("\n")[@current.line]
            s &= "\n#{@current.line}: #{l}"
        else
            s = @text
        s

    error: ◇string msg token=EOF ➜Node ->
    
        styledEcho fgRed, styleDim, "△ ", resetStyle, fgYellow, msg
        if token.tok != ◂eof
            line = @text.split("\n")[token.line]
            styledEcho fgWhite, styleDim, "#{token.line}", resetStyle, fgGreen, $line
        elif @tok != ◂eof
            line = @text.split("\n")[@current.line]
            styledEcho fgWhite, styleDim, "#{@current.line}", resetStyle, fgGreen, $line
        @failed = true    
        nil
    
    #  ███████   ███████   ███   ███   ███████  ███   ███  ██     ██  ████████
    # ███       ███   ███  ████  ███  ███       ███   ███  ███   ███  ███     
    # ███       ███   ███  ███ █ ███  ███████   ███   ███  █████████  ███████ 
    # ███       ███   ███  ███  ████       ███  ███   ███  ███ █ ███  ███     
    #  ███████   ███████   ███   ███  ███████    ███████   ███   ███  ████████
    
    consume: ➜Token ->
    
        t = @current
        if @pos < @tokens.len
            @pos += 1
        t
    
    swallow: ->
    
        discard @consume()
    
    swallow: ◇tok tok ->
    
        if @tok == tok
            @swallow()
            
    swallowError: ◇tok tok ◇string err ->
    
        if @tok != tok
            discard @error("Expected #{tok} to swallow, but found #{@tok} instead")
            discard @error(err)
            ⮐  
        @swallow()
                
    swallowSameIndent: ◇int indent ➜bool ->
    
        if @tok == ◂indent and @current.str.len == indent
            @swallow()
            ⮐  true
        false
    
    atIndent: ➜bool ->  
    
        @current.col == 0 or @peek(-1).tok == ◂indent
            
    atEnd: ➜bool ->  
    
        @pos >= @tokens.len
    
    isDedent: ◇int indent ➜bool ->  
    
        if @tok == ◂indent
            @current.str.len < indent
        else
            @current.col < indent
            
    isNextLineIndented: ◇Token token ➜bool -> 
    
        n = 0
        while @peek(n).tok != ◂indent
            n += 1
            if @peek(n).tok == ◂eof
                ⮐  false
            
        idt = if token.tok == ◂indent ➜ token.str.len ➜ token.col
        ⮐  @peek(n).str.len > idt
    
    isTokAhead: ◇tok tokAhead ➜bool ->
    
        n = 0
        c = @current
        line = c.line
        
        # log "isTokAhead #{tokAhead} #{line}"
        
        while c.tok != ◂eof
            if c.line > line
                ⮐  false
            if c.tok == tokAhead
                ⮐  true
            n += 1
            c = @peek n
        false    

    firstLineToken: ➜Token ->
    
        line = @current.line
        tpos = @tokens.len
        while tpos > 0
            if @tokens[tpos-1].line < line
                break
            tpos -= 1
        @tokens[tpos]
        
    lineIndent: ◇int line ➜int ->
    
        tpos = @tokens.len
        while tpos > 0
            if @tokens[tpos-1].line < line
                break
            tpos -= 1
    
        if @tokens[tpos].tok == ◂indent
            @tokens[tpos].str.len
        else
            @tokens[tpos].col
    
    isThenlessIf: ◇Token token ➜bool ->
    
        if @isNextLineIndented(token)
            ⮐  false
    
        not @isTokAhead ◂then
        
    getPrecedence: ◇Token token ➜int ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].precedence
        0
        
    rightHandSide: ◇Token token ➜RHS ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].rhs
    
    leftHandSide: ◇Token token ➜LHS ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].lhs
    
    expression: precedenceRight=0 ➜Node ->
    
    expression: ◇Token tokenRight ➜Node ->
    
        @expression @getPrecedence(tokenRight)
    
    value: ➜Node ->
    
        @expression(-2)

    # ███████    ███       ███████    ███████  ███   ███
    # ███   ███  ███      ███   ███  ███       ███  ███ 
    # ███████    ███      ███   ███  ███       ███████  
    # ███   ███  ███      ███   ███  ███       ███  ███ 
    # ███████    ███████   ███████    ███████  ███   ███
    
    parseBlock: ◇Node bn=nil ➜Node ->
    
        token        ◇ Token
        block_indent ◇ int
        
        while @tok == ◂indent
            token = @consume() 
            block_indent = @current.col
        
        bn = bn
        if bn == nil
            bn = nod(●block, token, [])
            
        expr = @expression()
        
        while expr != nil
        
            if expr.kind == ●func and bn.expressions.len
                prevExpr = bn.expressions[^1]
                if prevExpr.token.line == expr.token.line and prevExpr.token.tok == ◂assign
                    prevExpr = bn.expressions.pop()
                    if prevExpr.operand_right.kind == ●operation
                        argtoken = prevExpr.operand_right.operand_left.token
                        argtoken.tok = ◂val_type
                        argnode = nod(●arg argtoken nil prevExpr.operand_right.operand_left prevExpr.operand_right.operand_right)
                        expr.func_signature.sig_args.list_values.unshift(argnode)
                    else
                        expr.func_signature.sig_args.list_values.unshift(prevExpr.operand_right)
                    prevExpr.operand_right = expr
                    expr = prevExpr
                    
            bn.expressions.add expr
            if @tok == ◂indent
                ind = @current.str.len
                if ind < block_indent
                    break
                elif ind > block_indent
                    @blocks.add bn
                    expr = @parseBlock()
                    bn = @blocks.pop()
                    continue
                else
                    @swallow()
                    
            if @atEnd() or @current.col < block_indent
                break
                
            expr = @expression()
        bn
    
    expressionOrIndentedBlock: ◇Token token ◇int col ➜Node ->
    
        if @tok == ◂indent
            if @current.str.len > col
                ⮐  @parseBlock()
        else
            ⮐  @expression(token)
            
    #  ███████   ███████   ███      ███       ███████   ████████    ███████    ███████
    # ███       ███   ███  ███      ███      ███   ███  ███   ███  ███        ███     
    # ███       █████████  ███      ███      █████████  ███████    ███  ████  ███████ 
    # ███       ███   ███  ███      ███      ███   ███  ███   ███  ███   ███       ███
    #  ███████  ███   ███  ███████  ███████  ███   ███  ███   ███   ███████   ███████ 
    
    swallowIndent: ◇int col ➜bool ->
    
        @swallow ◂comma
        if @tok == ◂indent
            if @current.str.len > col
                @swallow()
            else
                ⮐  true
        false
        
    parseCallArgs: ◇int col ➜seq[Node] ->
    
        @explicit += 1
        @listless += 1
        list ◇ seq[Node]
        line = @current.line
        expr = @expression()
        while expr != nil
            list.add expr
            if @inlinecall and @tok == ◂indent
                break
            if @swallowIndent(col)
                break
            # if @tok in {◂comment_start, ◂then, ◂paren_close}
            if @tok in {◂comment_start, ◂then}
                break
            expr = @expression()
        @listless -= 1
        @explicit -= 1
        list
        
    # █████████  ███   ███  ████████   ████████
    #    ███      ███ ███   ███   ███  ███     
    #    ███       █████    ████████   ███████ 
    #    ███        ███     ███        ███     
    #    ███        ███     ███        ████████
    
    parseType: ➜Node ->
        
        token = @consume()
        token.tok = ◂type
        
        if @tok == ◂square_open
            opened = 0
            while @tok notin {◂eof}
                t = @consume()
                token.str &= t.str
                if t.tok == ◂square_open
                    opened += 1
                elif t.tok == ◂square_close
                    opened -= 1
                    if opened == 0
                        break
        
        nod(●type token)
        
    parseVar: ➜Node ->
    
        token     = @current()
        var_name  = @value()
        var_value ◇ Node
        var_type  ◇ Node
        
        if @tok == ◂assign
            @swallow()
            var_value = @thenBlock()
        elif @tok in {◂val_type, ◂var_type}
            token = @consume()
            var_type = @parseType()
            if @tok == ◂assign
                @swallow()
                var_value = @expression()
        
        nod(●var token var_name var_type var_value)
        
    parseModule: ➜Node ->
    
        line = @current.line
        s = ""
        while @current.str notin ["▪" "◆"]
            e = @current.col + @current.str.len
            s &= @consume().str
            if @atEnd() or @current.line != line
                break 
            if @current.col > e and @current.str notin ["▪" "◆"] 
                s &= " "
            
        Node(token:Token(str:s))    

    # ███      ███   ███████  █████████
    # ███      ███  ███          ███   
    # ███      ███  ███████      ███   
    # ███      ███       ███     ███   
    # ███████  ███  ███████      ███   
    
    parseParenList: ➜seq[Node] ->
    
        token = @consume() # (
        args  ◇ seq[Node]
        
        @explicit += 1
        while @tok != ◂paren_close and @tok != ◂eof
            args.add @expression()
            @swallow ◂comma
        @swallowError(◂paren_close, "Missing closing parenthesis")
        @explicit -= 1
        if args.len == 1 and args[0].kind == ●list
            ⮐  args[0].list_values
        args
        
    parseDelimitedList: ◇tok open ◇tok close ➜seq[Node] ->
    
        token = @consume()
        args  ◇ seq[Node]
        
        @explicit += 1
        while true
            discard @swallowIndent(-1)
            if @tok != close and @tok != ◂eof
                args.add @expression()
            else
                break
        @swallowError(close, "Missing closing bracket")
        @explicit -= 1
        
        if args.len == 1 and args[0].kind == ●list
            ⮐  args[0].list_values
        args
        
    parseNames: ➜seq[Node] -> 
    
        list ◇ seq[Node]
        line = @current.line
        @explicit += 1
        expr = @rSymbol()
        while expr != nil
            list.add expr        
            if @current.line != line
                break
            @swallow ◂comma
            expr = @rSymbol()
        @explicit -= 1
        list
    
    parseNamesUntil: ◇tok stop ➜Node -> 
    
        token = @current
                                    
        list_values ◇ seq[Node]
        @explicit += 1
        while @tok != stop
            if @tok == ◂eof
                ⮐  @error("Missing 'in' for 'for' loop (eof detected)!", token)
            if @current.line != token.line
                ⮐  @error("Missing 'in' for 'for' loop (linebreak detected)!", token)
            list_values.add @rSymbol()
            @swallow ◂comma
        @explicit -= 1
        if list_values.len == 1
            list_values[0]
        else
            nod(●list token list_values)
    
    # █████████  ███   ███  ████████  ███   ███
    #    ███     ███   ███  ███       ████  ███
    #    ███     █████████  ███████   ███ █ ███
    #    ███     ███   ███  ███       ███  ████
    #    ███     ███   ███  ████████  ███   ███
    
    thenBlock: ➜Node ->
    
        if @tok == ◂then
            @swallow ◂then
            
        if @tok == ◂indent
            @parseBlock()
        else
            @expression()
            
    thenIndented: ◇Token token ➜Node ->
    
        if @tok == ◂then
            @swallow ◂then
            
        if @tok == ◂indent
            if @isNextLineIndented(token)
                ⮐  @parseBlock()
            ⮐  nil
        else
            ⮐  @expression()
            
    #  ███████   ███████   ███      ███    
    # ███       ███   ███  ███      ███    
    # ███       █████████  ███      ███    
    # ███       ███   ███  ███      ███    
    #  ███████  ███   ███  ███████  ███████
    
    lCall: ◇Node callee ➜Node ->
    
        token = @consume() # (
        args = @parseCallArgs(callee.token.col)
        @swallowError(◂paren_close, "Missing closing paren for call arguments")    
        Node(token:token, kind:●call, callee:callee, callargs:args)
    
    # ███  ██     ██  ████████   ███      ███   ███████  ███  █████████
    # ███  ███   ███  ███   ███  ███      ███  ███       ███     ███   
    # ███  █████████  ████████   ███      ███  ███       ███     ███   
    # ███  ███ █ ███  ███        ███      ███  ███       ███     ███   
    # ███  ███   ███  ███        ███████  ███   ███████  ███     ███   
    
    isImplicitCallPossible: ➜bool ->
    
        ⮐  false if @explicit
    
        currt = @peek(0)
        
        optoks = { 
            ◂indent, ◂eof,
            ◂then, ◂else, ◂elif, ◂test, ◂val_type, ◂var_type, ◂colon,
            ◂plus, ◂minus, ◂divide, ◂multiply, ◂and, ◂or, ◂ampersand, ◂is, ◂in, ◂notin, ◂not,
            ◂equal, ◂not_equal, ◂greater_equal, ◂less_equal, ◂greater, ◂less, ◂match, ◂comment_start,
            ◂assign, ◂divide_assign, ◂multiply_assign, ◂plus_assign, ◂minus_assign, ◂ampersand_assign }
            
        ⮐  false if currt.tok in optoks  
        
        prevt = @peek(-1)
        
        ⮐  false if currt.col <= prevt.col+ksegWidth(prevt.str)
        ⮐  false if @isTokAhead(◂func)
        true
        
    rSymbol: ➜Node ->
    
        token = @consume()
        
        if token.str in ["peg" "re" "r"] and @tok == ◂string_start and token.col + token.str.len == @current.col
            n = @rString()
            n.string_prefix = nod ●literal token
            ⮐  n
    
        if @isImplicitCallPossible()
            let args = this.parseCallArgs(token.col)
            ⮐  Node(token:token, kind:●call, callee:nod(●literal token), callargs:args)
    
        nod ●literal token
            
    # ███  ████████                             ███  ████████                               ███  ████████  
    # ███  ███                                  ███  ███                                    ███  ███       
    # ███  ██████                               ███  ██████                                 ███  ██████    
    # ███  ███                                  ███  ███                                    ███  ███       
    # ███  ███                                  ███  ███                                    ███  ███       
    
    inline: ➜Node ->
    
        @inlinecall += 1
        e = @expression()
        @inlinecall -= 1
        e
    
    rIf: ➜Node ->
    
        token     = @consume() # if or when
        condThens ◇ seq[Node]
        ifIndent  = token.col
        condIndt  = ifIndent
        
        if @tok == ◂indent
            condIndt = @current.str.len
            if condIndt <= ifIndent
                ⮐  @error "Expected indentation after 'if' without condition"
            @swallow ◂indent # block indentation
        
        condition = @inline() # initial condition
        then_branch = @thenBlock()
        
        condThens.add nod(●condThen condition.token condition then_branch)
        
        outdent = false
        
        while @tok in {◂elif, ◂indent}
        
            if @tok == ◂indent            
                if @current.str.len < ifIndent
                    outdent = true
                    break
                if ifIndent < condIndt 
                    if @current.str.len < condIndt
                        break
                if @peek(1).tok != ◂elif and @current.str.len == ifIndent
                    break
                @swallow ◂indent
                if @tok == ◂comment_start
                    @swallow()
                    @swallow ◂comment
                if @tok == ◂indent
                    continue
                    
            @swallow(◂elif)
            if @tok in {◂then, ◂else}
                break # then without condition -> else
            
            condition = @inline()
            @swallow ◂comment
            then_branch = @thenBlock()
            
            condThens.add nod(●condThen condition.token condition then_branch)
            
        else_branch ◇ Node
    
        if not outdent    
            @swallow(◂indent)
            
            if @tok in {◂else, ◂then}
                @swallow() # else or then without condition
                else_branch = @thenBlock()
        
        Node(token:token, kind:●if, cond_thens:condThens, else_branch:else_branch)
    
    # █████████   ███████   ███  ███         ███  ████████
    #    ███     ███   ███  ███  ███         ███  ███     
    #    ███     █████████  ███  ███         ███  ██████  
    #    ███     ███   ███  ███  ███         ███  ███     
    #    ███     ███   ███  ███  ███████     ███  ███     
    
    lTailIf: ◇Node left ➜Node ->
    
        ⮐  if @returning
        ⮐  if left.token.line != @current.line
            
        token = @consume()
        condition = @expression()
        condThen = nod ●condThen condition.token condition left
    
        Node(token:token, kind:●if, cond_thens: [condThen])
            
    # ████████   ███████   ████████ 
    # ███       ███   ███  ███   ███
    # ██████    ███   ███  ███████  
    # ███       ███   ███  ███   ███
    # ███        ███████   ███   ███
    
    rFor: ➜Node ->
    
        token = @consume()
        for_value = @parseNamesUntil ◂in
        @swallowError(◂in, "Expected 'in' after for value")
        for_range = @expression()
        for_body  = @thenBlock()
    
        nod ●for token for_value for_range for_body
    
    rWhile: ➜Node ->
    
        nod ●while @consume() @expression() @thenBlock()
    
    #  ███████  ███   ███  ███  █████████   ███████  ███   ███
    # ███       ███ █ ███  ███     ███     ███       ███   ███
    # ███████   █████████  ███     ███     ███       █████████
    #      ███  ███   ███  ███     ███     ███       ███   ███
    # ███████   ██     ██  ███     ███      ███████  ███   ███
    
    switchCase: ◇int baseIndent ➜Node ->
    
        case_when ◇ seq[Node]
        token     = @current
        first     = @firstLineToken()
        
        while true
        
            if @tok == ◂indent
                if case_when.len == 0 and @peek(1).tok == ◂then
                    @swallow()
                    ⮐  # indent followed by a ➜ is else
                if not @swallowSameIndent baseIndent
                    break
    
            ⮐  if @tok in {◂else, ◂eof} or @isDedent(baseIndent)
    
            break if @tok == ◂then
        
            @explicit += 1
            case_when.add @value()
            @explicit -= 1
            @swallow ◂comma
        
        ⮐  if @isDedent baseIndent
    
        case_then = @thenIndented first
                    
        if case_then == nil
            ⮐  @error("Expected case body after match(es)", token)
        
        Node(token:token, kind:●switchCase, case_when:case_when, case_then:case_then)
    
    rSwitch: ➜Node ->
    
        token = @consume()
        switch_value = @expression()
        
        if switch_value == nil
            ⮐  @error("Expected value after switch keyword", token)
        
        baseIndent = @current.str.len 
        
        @swallowError(◂indent, "Expected indentation after switch statement")
        
        switch_cases ◇ seq[Node]
        
        while true 
    
            switch_case = @switchCase(baseIndent)
            if switch_case
                switch_cases.add switch_case
            else
                break
        
        switch_default ◇ Node
        
        if @tok in {◂else, ◂then}
            @swallow()
            switch_default = @thenBlock()
            if switch_default == nil
                ⮐  @error("Expected default value", token)
        
        Node(token:token, kind:●switch, switch_value:switch_value, switch_cases:switch_cases, switch_default:switch_default)
                    
    lArrayAccess: ◇Node array_owner ➜Node ->
    
        ⮐  if @peek(-1).col + @peek(-1).str.len < @current.col
        
        token = @current()
        array_indices = @parseDelimitedList ◂square_open ◂square_close
        array_index = 
            switch array_indices.len
                0 ➜ nil
                1 ➜ array_indices[0]
                  ➜ nod ●list token array_indices
            
        nod ●arrayAccess token array_owner array_index
    
    lPropertyAccess: ◇Node owner ➜Node ->
    
        token = @consume()
        property = @rLiteral()
        
        n = nod ●propertyAccess token owner property
        
        if @isImplicitCallPossible()
            ⮐  Node(token:token, kind:●call, callee:n, callargs:@parseCallArgs(token.col))
        n
    
    rLiteral   : ➜Node -> nod(●literal   @consume())
    rKeyword   : ➜Node -> nod(●keyword   @consume())
    rImport    : ➜Node -> nod(●import    @consume())
    rProc      : ➜Node -> nod(●proc      @consume())
    rTypeDef   : ➜Node -> nod(●typeDef   @consume())
    rMacro     : ➜Node -> nod(●macro     @consume())
    rTemplate  : ➜Node -> nod(●template  @consume())
    rConverter : ➜Node -> nod(●converter @consume())
    rLet       : ➜Node -> nod(●let       @consume() @parseVar())
    rReturnType: ➜Node -> nod(●signature @consume() nil @parseType())
    rQuote     : ➜Node -> nod(●quote     @consume() @thenBlock())
    
    #  ███████  █████████  ████████   ███  ███   ███   ███████ 
    # ███          ███     ███   ███  ███  ████  ███  ███      
    # ███████      ███     ███████    ███  ███ █ ███  ███  ████
    #      ███     ███     ███   ███  ███  ███  ████  ███   ███
    # ███████      ███     ███   ███  ███  ███   ███   ███████ 
    
    rString: ➜Node ->
    
        token = @consume() # string start
    
        if @tok == ◂string_end
            @swallow()
            Node(token:token, kind:●string, string_content:nod(●literal tkn(◂string)))
        else
            string_content ◇ Node 
            if @tok != ◂stripol_start
                string_content = nod ●literal @consume()
            else
                string_content = nod ●literal tkn(◂string "" @current.line @current.col)
                
            string_stripols ◇ seq[Node]
            while @tok notin {◂string_end, ◂eof}
            
                @swallowError(◂stripol_start, "Expected string interpolation start")
                
                stripol = Node(token:@current, kind:●stripol)
                
                stripol_xprssns ◇ seq[Node]
                while @tok notin {◂stripol_end, ◂eof}
                    xpr = @expression()
                    stripol_xprssns.add xpr
                    
                stripol.stripol_xprssns = stripol_xprssns
                
                @swallowError(◂stripol_end, "Expected string interpolation end")
                if @tok notin {◂stripol_start, ◂string_end, ◂eof}
                    stripol.stripol_content = nod ●literal @consume()
                elif @tok == ◂stripol_start
                    stripol.stripol_content = nod ●literal tkn(◂string @current.line @current.col)
                
                string_stripols.add stripol
                
            @swallowError(◂string_end, "Expected closing string delimiter")
            Node(token:token, kind:●string, string_content:string_content, string_stripols:string_stripols)
    
    rUse: ➜Node ->
    
        token = @consume()
        @explicit += 1
        use_module = @parseModule()
        if not @atEnd() and @current.line == token.line
            use_kind = @rSymbol()
            use_items  = @parseNames()
            @explicit -= 1
            Node(token:token, kind:●use, use_module:use_module, use_kind:use_kind, use_items:use_items) 
        else
            @explicit -= 1
            Node(token:token, kind:●use, use_module:use_module) 
            
    rComment: ➜Node ->
    
        n = nod ●comment @consume() Node(token:@consume())
        @swallow ◂comment_end
        n
        
    lReturnType: ◇Node left ➜Node ->
    
        ⮐  if not @isTokAhead(◂func) and not @isTokAhead(◂method)
    
        if left.kind in {●list, ●arg, ●operation}
            if left.kind == ●operation 
                if left.token.tok == ◂assign
                    sig = @rReturnType()
                    argtoken = tkn(◂val_type "" left.token.line left.token.col)
                    argNode  = nod ●arg argtoken nil left.operand_left left.operand_right
                    sig.sig_args = nod ●list left.token [argNode]
                    ⮐  sig
            elif left.kind == ●list
                sig = @rReturnType()
                sig.sig_args = left
                ⮐  sig
            elif left.kind == ●arg
                sig = @rReturnType()
                sig.sig_args = nod ●list left.token [left]
                ⮐  sig
                        
    rArg: ➜Node ->
    
        token = @consume() # ◆ or ◇
        
        if @typeless
            nameToken = @consume()
            nameToken.tok = ◂name
            nameToken.str = token.str & nameToken.str
            nameToken.col = token.col
            ⮐  nod ●literal nameToken
    
        arg_type  = @parseType()
        arg_name  = @value()
        arg_value ◇ Node
        
        if @tok == ◂assign
            t = @consume() # =
            arg_value = @expression() 
        
        nod ●arg token arg_type arg_name arg_value
    
    lVar: ◇Node left ➜Node ->
    
        ⮐  if left.token.tok != ◂name
            
        token     = @consume() # ◆ or ◇
        var_type  = @parseType()
        var_value ◇ Node
        
        if @tok == ◂assign
            t = @consume() # =
            var_value = @expression() 
        nod ●var token left var_type var_value
    
    lSymbolList: ◇Node left ➜Node ->
    
        ⮐  if @listless
    
        switch left.kind 
            ●list
                list_values = left.list_values
                # todo: check if all list items are symbols?
                list_values.add @rSymbol()
                ⮐  nod ●list left.token list_values
            ●literal
                if left.token.tok != ◂name
                    ⮐  
                list_values ◇ seq[Node]
                list_values.add left
                list_values.add @rSymbol()
                ⮐  nod ●list left.token list_values
            ➜ 
                discard
    
    lArgList: ◇Node left ➜Node ->
        
        switch left.kind 
            ●list
                var list_values = left.list_values
                list_values.add @rArg()
                ⮐  nod ●list left.token list_values
            ●arg
                list_values ◇ seq[Node]
                list_values.add left
                list_values.add @rArg()
                ⮐  nod ●list left.token list_values
            ●literal
                if left.token.tok == ◂name
                    ⮐  @lVar left
            ➜ 
                discard

    # ████████  ███   ███  ███   ███   ███████
    # ███       ███   ███  ████  ███  ███     
    # ██████    ███   ███  ███ █ ███  ███     
    # ███       ███   ███  ███  ████  ███     
    # ███        ███████   ███   ███   ███████
    
    lFunc: ◇Node left ➜Node ->
    
        ⮐  if left.kind notin {●signature ●list ●arg ●operation}
            
        func_signature ◇ Node
        
        if left.kind == ●operation
        
            # log "lfunc op #{left}"
            
            ⮐  if left.token.tok != ◂assign
                
            ⮐  if left.operand_left.token.tok != ◂name
                
            if left.operand_left.token.col == 0 
                left = left
                argtoken = tkn(◂val_type left.operand_right.token.line left.operand_right.token.col)
                left.operand_right = @lFunc(nod(●arg argtoken nil left.operand_right nil))
                ⮐  left
                
            vartoken = tkn(◂val_type left.operand_left.token.line left.operand_left.token.col)
            varNode  = nod ●arg vartoken nil left.operand_left left.operand_right
            sig_args = nod ●list vartoken [varNode]
            func_signature = nod ●signature left.token sig_args nil
            
        elif left.kind == ●list
        
            # log "lfunc list"
            
            sig_args = left
            for i a in sig_args.list_values
                if a.kind == ●operation and a.token.tok == ◂assign
                    argtoken = tkn(◂val_type a.operand_left.token.line a.operand_left.token.col)
                    sig_args.list_values[i] = nod ●arg argtoken nil a.operand_left a.operand_right
                elif a.kind == ●literal and a.token.tok == ◂name
                    argtoken = tkn(◂val_type a.token.line a.token.col)
                    sig_args.list_values[i] = nod ●arg argtoken nil a nil
            func_signature = nod ●signature left.token sig_args nil
            
        elif left.kind == ●arg
        
            # log "lfunc arg"
            
            sig_args = nod ●list left.token [left]
            func_signature = nod ●signature left.token sig_args nil
            
        elif left.kind == ●signature
            func_signature = left
        
        firstToken = @firstLineToken()
        token = @consume()
        
        func_mod ◇Node
        if @tok == ◂mod
            func_mod = @rLiteral()
        
        func_body = @thenIndented firstToken
        
        nod ●func token func_signature func_mod func_body
    
    rFunc: ➜Node ->
    
        firstToken = @firstLineToken()
        token = @consume()
        
        func_mod ◇ Node
        if @tok == ◂mod
            func_mod = @rLiteral()
        
        func_body = @thenIndented firstToken
        
        nod ●func token nil nil func_body
    
    parseSignature: ➜Node ->
    
        sig_args = nod ●list @current() []
        sig_type ◇ Node
        
        parens = false
        if @tok == ◂paren_open
            @swallow()
            parens = true
        
        while true
            
            token    = @current()
            arg_type ◇ Node = nil
            
            if @tok in {◂var_type, ◂val_type}
            
                @swallow() # ◆ or ◇
                arg_type  = @parseType()
                            
            if @tok != ◂name
                break
                    
            arg_name  = @value()
            arg_value ◇ Node
    
            if @tok == ◂assign
                @swallow() # =
                @listless += 1
                @explicit += 1
                arg_value = @expression()
                @explicit -= 1
                @listless -= 1
                
            @swallow ◂comma
            
            sig_args.list_values.add nod(●arg token arg_type arg_name arg_value)
        
        if parens 
            ⮐  if @tok != ◂paren_close
            @swallow()
    
        if @tok == ◂then
            @swallow()
            sig_type = @parseType()
    
        if @tok notin {◂func ◂method}
            ⮐  
            
        nod ●signature sig_args.token sig_args sig_type
    
    funcOrExpression: ◇Token token ➜Node ->
    
        col = @lineIndent token.line
    
        if @isTokAhead(◂func) or @isTokAhead(◂method) 
            startPos = @pos
            func_signature ◇ Node
            if @tok notin {◂func ◂method}
                func_signature = @parseSignature()
            if @tok in {◂func ◂method}
                ftoken = @consume()
                func_mod = if @tok == ◂mod ➜ @rLiteral() ➜ nil
                func_body = @expressionOrIndentedBlock tkn(◂null) col
                ⮐  nod ●func ftoken func_signature func_mod func_body
            else
                @pos = startPos
        
        @expressionOrIndentedBlock(token, col)
    
    rReturn: ➜Node ->
    
        token = @consume()
        
        if @tok == ◂if and @isThenlessIf(token)
            nod ●return token nil
        else
            @returning = true
    
            right ◇ Node 
            if @tok != ◂indent or @isNextLineIndented(token)
                right = @expression(token)
            
            @returning = false
            nod ●return token right
    
    rDiscard: ➜Node ->
    
        token = @consume()
        if @isDedent token.col
            nod ●discard token nil
        else
            nod ●discard token @value()
        
    #  ███████   ████████   ████████  ████████    ███████   █████████  ███   ███████   ███   ███
    # ███   ███  ███   ███  ███       ███   ███  ███   ███     ███     ███  ███   ███  ████  ███
    # ███   ███  ████████   ███████   ███████    █████████     ███     ███  ███   ███  ███ █ ███
    # ███   ███  ███        ███       ███   ███  ███   ███     ███     ███  ███   ███  ███  ████
    #  ███████   ███        ████████  ███   ███  ███   ███     ███     ███   ███████   ███   ███
    
    lOperation: ◇Node left ➜Node ->
    
        token = @consume()
        right = @expression(token)
        nod ●operation token left right
        
    lNotIn: ◇Node left ➜Node ->
    
        if @peek(1).tok == ◂in
            token = @consume()
            token.str = "notin"
            token.tok = ◂notin
            @swallow()
            right = @expression(token)
            ⮐  nod ●operation token left right
    
    lPostOp: ◇Node left ➜Node ->
    
        nod ●postOp @consume() left
    
    rPreOp: ➜Node ->
    
        token = @consume()
        right = @expression(token)
        nod ●preOp token right
        
    rDollar: ➜Node ->
    
        if @current.str.len > 1
            token = @consume()
            token.tok = ◂name
            ⮐  nod ●literal token
        if @peek(1).tok in {◂assign, ◂colon}
            token = @consume()
            token.tok = ◂name
            ⮐  nod ●literal token
        @rPreOp()
    
    lAssign: ◇Node left ➜Node ->
    
        token = @consume()
        right = @funcOrExpression(token)
        nod ●operation token left right
    
    lRange: ◇Node left ➜Node ->
    
        token = @consume()
        right = @expression(token)
        nod ●range token left right
            
    rParenExpr: ➜Node ->
    
        nod ●list @current @parseParenList()
    
    rCurly: ➜Node ->
    
        nod ●curly @current @parseDelimitedList(◂bracket_open, ◂bracket_close)
    
    rSquarely: ➜Node ->
    
        nod ●squarely @current @parseDelimitedList(◂square_open, ◂square_close)
    
    rEnum: ➜Node ->
    
        token = @consume()
        enum_name = @value()
        enum_body ◇ Node
        if @isNextLineIndented token
            @typeless = true
            enum_body = @parseBlock()
            @typeless = false
        nod ●enum token enum_name enum_body
        
    rClass: ➜Node ->
    
        @explicit += 1
        token = @consume()
        name  = @value()
        parent ◇ Node
        if @current.str == "extends"
            @swallow()
            parent = @value()
        @explicit -= 1
        nod ●class token name parent @parseBlock()

    rStruct: ➜Node ->

        token = @consume()
        name  = @value()
        parent ◇ Node
        if @current.str == "extends"
            @swallow()
            parent = @value()
    
        nod ●struct token name parent @parseBlock()
        
    lMember: ◇Node left ➜Node ->
    
        token = @consume()
        right = @funcOrExpression(token)
        nod ●member token left right
        
    lTestCase: ◇Node left ➜Node ->
    
        token = @consume() # ▸
        @swallow(◂indent) # todo: check if indent is larger than that of the test expression
        right = @expression()
        nod ●testCase token left right
    
    rTestSuite: ➜Node ->
    
        token = @consume() # ▸
        test_block = @thenBlock()
        if token.col == 0
            nod ●testSuite token test_block
        else
            nod ●testSection token test_block

    # ████████  ███   ███  ████████   ████████   ████████   ███████   ███████  ███   ███████   ███   ███
    # ███        ███ ███   ███   ███  ███   ███  ███       ███       ███       ███  ███   ███  ████  ███
    # ███████     █████    ████████   ███████    ███████   ███████   ███████   ███  ███   ███  ███ █ ███
    # ███        ███ ███   ███        ███   ███  ███            ███       ███  ███  ███   ███  ███  ████
    # ████████  ███   ███  ███        ███   ███  ████████  ███████   ███████   ███   ███████   ███   ███
    
    ###
       ◂R      ◂LR     ◂L      ◂R      ◂L      ◂LR     ◂R 
       │       │       │       │       │       │ 
       ◂R➜●    │       │       ◂R➜●    │       │ 
          │    │       │          │    │       │
          ╰───●◂L➜●───●◂L➜●       ╰───●◂L➜●───●◂L➜●
                          │                       │
                          ▾                       ▾
    ###
    
    expression: precedenceRight=0 ➜Node ->
    
        token = @current
        if token.tok in {◂eof, ◂stripol_end, ◂paren_close}
            ⮐  nil
    
        rhs = @rightHandSide(token)
        
        if rhs == nil
            ⮐  @error(&"Expected expression but found {token.str} {token}", token)
            
        node = @rhs()
        
        if precedenceRight < -1
            ⮐  node
    
        while not @atEnd()
            
            token = @current
            precedence = @getPrecedence(token)
            
            if token.tok in {◂assign, ◂test}
                precedence += 1
            
            lhs = @leftHandSide(token)
            
            if precedenceRight >= precedence
                break
        
            if lhs == nil
                break
                
            lhn = @lhs(node)
            
            if lhn != nil
                node = lhn
            else
                break 
                
            if @tok == ◂indent and @peek(1).tok in {◂dot}
                 @swallow()
                 node = @lPropertyAccess node
        node
                
    # ████████   ████████    ███████   █████████  █████████
    # ███   ███  ███   ███  ███   ███     ███        ███   
    # ████████   ███████    █████████     ███        ███   
    # ███        ███   ███  ███   ███     ███        ███   
    # ███        ███   ███  ███   ███     ███        ███   
    
    pratt: ◇tok t ◇LHS lhs ◇RHS rhs ◇int precedence ->
    
        if @pratts.len <= t.ord
            @pratts.setLen(t.ord + 1)
        
        @pratts[t.ord] = Pratt(lhs:lhs, rhs:rhs, precedence:precedence)
    
    #  ███████  ████████  █████████  ███   ███  ████████ 
    # ███       ███          ███     ███   ███  ███   ███
    # ███████   ███████      ███     ███   ███  ████████ 
    #      ███  ███          ███     ███   ███  ███      
    # ███████   ████████     ███      ███████   ███      
    
    setup: ->
    
        @pratt ◂true              nil               rLiteral        0
        @pratt ◂false             nil               rLiteral        0
        @pratt ◂mod               nil               rLiteral        0
        @pratt ◂null              nil               rLiteral        0
        @pratt ◂number            nil               rLiteral        0
        @pratt ◂string_start      nil               rString         0
        @pratt ◂comment_start     nil               rComment        0
        @pratt ◂name              lSymbolList       rSymbol        13 # higher than assign
        @pratt ◂import            nil               rImport         0
        @pratt ◂macro             nil               rMacro          0
        @pratt ◂template          nil               rTemplate       0
        @pratt ◂converter         nil               rConverter      0
        @pratt ◂proc              nil               rProc           0
        @pratt ◂type              nil               rTypeDef        0
        @pratt ◂use               nil               rUse            0
        @pratt ◂let               nil               rLet            0
        @pratt ◂var               nil               rLet            0
        @pratt ◂return            nil               rReturn         0
        @pratt ◂discard           nil               rDiscard        0
        @pratt ◂quote             nil               rQuote          0
        @pratt ◂test              lTestCase         rTestSuite      0
        
        @pratt ◂class             nil               rClass          0
        @pratt ◂struct            nil               rStruct         0
        @pratt ◂enum              nil               rEnum           0
        @pratt ◂colon             lMember           nil            10
        
        @pratt ◂continue          nil               rKeyword        0
        @pratt ◂break             nil               rKeyword        0
                                                                        
        @pratt ◂assign            lAssign           nil            10
        @pratt ◂plus_assign       lAssign           nil            10
        @pratt ◂minus_assign      lAssign           nil            10
        @pratt ◂divide_assign     lAssign           nil            10
        @pratt ◂multiply_assign   lAssign           nil            10
        @pratt ◂ampersand_assign  lAssign           nil            10
    
        @pratt ◂if                lTailIf           rIf            20
        @pratt ◂when              nil               rIf            20
        @pratt ◂for               nil               rFor           20
        @pratt ◂switch            nil               rSwitch        20
        @pratt ◂while             nil               rWhile         20
        @pratt ◂func              lFunc             rFunc          20
        @pratt ◂method            lFunc             rFunc          20
        
        @pratt ◂or                lOperation        nil            30
        @pratt ◂and               lOperation        nil            31
        
        @pratt ◂is                lOperation        nil            32
        @pratt ◂in                lOperation        nil            33
        @pratt ◂notin             lOperation        nil            34
        
    
        @pratt ◂equal             lOperation        nil            40
        @pratt ◂not_equal         lOperation        nil            40
        @pratt ◂greater_equal     lOperation        nil            40
        @pratt ◂less_equal        lOperation        nil            40
        @pratt ◂less              lOperation        nil            40
        @pratt ◂greater           lOperation        nil            40
        @pratt ◂match             lOperation        nil            40
        
        @pratt ◂doubledot         lRange            nil            40
        @pratt ◂tripledot         lRange            nil            40
        
        @pratt ◂dollar            nil               rDollar        41
        @pratt ◂ampersand         lOperation        nil            42
        
        @pratt ◂plus              lOperation        nil            50
        @pratt ◂minus             lOperation        rPreOp         50
                                                       
        @pratt ◂multiply          lOperation        nil            60
        @pratt ◂divide            lOperation        nil            60
    
        @pratt ◂not               lNotIn            rPreOp         70
    
        @pratt ◂increment         lPostOp           nil            80
        @pratt ◂decrement         lPostOp           nil            80
    
        @pratt ◂square_open       lArrayAccess      rSquarely      90
        @pratt ◂paren_open        lCall             rParenExpr     90
        @pratt ◂bracket_open      nil               rCurly         90
        @pratt ◂then              lReturnType       rReturnType    99
        @pratt ◂val_type          lArgList          rArg          100
        @pratt ◂var_type          lArgList          rArg          100
        @pratt ◂dot               lPropertyAccess   nil           102
    
#  ███████    ███████  █████████
# ███   ███  ███          ███   
# █████████  ███████      ███   
# ███   ███       ███     ███   
# ███   ███  ███████      ███   

ast* = ◇string text ➜Node ->

    # profileStart 'tknz'
    tokens = tokenize text
    # profileStop 'tknz'
    # log &"ast* {tokens}"
    # profileStart 'pars'
    p = Parser(tokens:tokens, pos:0, text:text)
    p.setup()
    b = p.parseBlock()
    # profileStop 'pars'
    ⮐  nil if p.failed
    b
    
    