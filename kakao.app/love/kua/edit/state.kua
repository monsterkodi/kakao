###
     ███████  █████████   ███████   █████████  ████████  
    ███          ███     ███   ███     ███     ███       
    ███████      ███     █████████     ███     ███████   
         ███     ███     ███   ███     ███     ███       
    ███████      ███     ███   ███     ███     ████████  

    handles basic text editing for the editor
    wraps text and editor state like cursors and selections 
        in an immutable to simplify undo
    delegates almost all text manipulation to pure functions
        in tool▸belt to simplify testing
###

use util.syntax

class state extends events

    @: cells name ->
    
        @cells = cells
        @name  = name & '.state'

        @allowedModes = {}

        @syntax   = syntax @name & '.syntax'
        @hasFocus = false

        @clearSingle()
        
    $: -> @name

    handleKey: key event ->
    
        ⮐  if 'unhandled' != mode.handleKey(@ key event)
        
        switch key                  
                         
            'up'                                ➜ ⮐  @moveCursors 'up'   
            'down'                              ➜ ⮐  @moveCursors 'down' 
            'left'                              ➜ ⮐  @moveCursors 'left' 
            'right'                             ➜ ⮐  @moveCursors 'right'
                                                     
            'ctrl+alt+up'                       ➜ ⮐  @singleCursorPage 'up'  
            'ctrl+alt+down'                     ➜ ⮐  @singleCursorPage 'down'
            'shift+ctrl+alt+up'                 ➜ ⮐  @moveCursors 'up'    {count:16}
            'shift+ctrl+alt+down'               ➜ ⮐  @moveCursors 'down'  {count:16}
                
                                                     
            'cmd+left'  'ctrl+left'             ➜ ⮐  @moveCursors ['bos' 'ind_bol']
            'cmd+right' 'ctrl+right'            ➜ ⮐  @moveCursors ['eos' 'ind_eol']
                                                     
            'alt+left'                          ➜ ⮐  @moveCursors 'left'  {jump:['ws' 'word' 'empty' 'punct']}
            'alt+right'                         ➜ ⮐  @moveCursors 'right' {jump:['ws' 'word' 'empty' 'punct']}
                                                     
            'shift+alt+right'                   ➜ ⮐  @moveCursorsAndSelect 'right' {jump:['ws' 'word' 'empty' 'punct']}
            'shift+alt+left'                    ➜ ⮐  @moveCursorsAndSelect 'left'  {jump:['ws' 'word' 'empty' 'punct']}
            'shift+up'                          ➜ ⮐  @moveCursorsAndSelect 'up'
            'shift+down'                        ➜ ⮐  @moveCursorsAndSelect 'down'
            'shift+left'                        ➜ ⮐  @moveCursorsAndSelect 'left'
            'shift+right'                       ➜ ⮐  @moveCursorsAndSelect 'right'
            'shift+cmd+right'                   ➜ ⮐  @moveCursorsAndSelect 'ind_eol'
            'shift+cmd+left'                    ➜ ⮐  @moveCursorsAndSelect 'ind_bol'
            'shift+ctrl+h'                      ➜ ⮐  @moveCursorsAndSelect 'bof'
            'shift+ctrl+j'                      ➜ ⮐  @moveCursorsAndSelect 'eof'
                                                     
            'shift+alt+cmd+up'                  ➜ ⮐  @moveMainCursorInDirection 'up'    {keep:true} # 'paint' cursors
            'shift+alt+cmd+down'                ➜ ⮐  @moveMainCursorInDirection 'down'  {keep:true} # 'paint' cursors
            'shift+alt+cmd+left'                ➜ ⮐  @moveMainCursorInDirection 'left'  {keep:true} # 'paint' cursors
            'shift+alt+cmd+right'               ➜ ⮐  @moveMainCursorInDirection 'right' {keep:true} # 'paint' cursors
                                                     
            'alt+up'                            ➜ ⮐  @moveSelectionOrCursorLines 'up'
            'alt+down'                          ➜ ⮐  @moveSelectionOrCursorLines 'down'
            'shift+alt+up'                      ➜ ⮐  @cloneSelectionAndCursorLines 'up'
            'shift+alt+down'                    ➜ ⮐  @cloneSelectionAndCursorLines 'down'
                                                     
            'cmd+up'   'ctrl+up'                ➜ ⮐  @expandCursors   'up'
            'cmd+down' 'ctrl+down'              ➜ ⮐  @expandCursors   'down'
            'shift+cmd+up'   'shift+ctrl+up'    ➜ ⮐  @contractCursors 'up'
            'shift+cmd+down' 'shift+ctrl+down'  ➜ ⮐  @contractCursors 'down'
                                                     
            'pageup'                            ➜ ⮐  @singleCursorPage 'up'
            'pagedown'                          ➜ ⮐  @singleCursorPage 'down'
                                                     
            'home'                              ➜ ⮐  @singleCursorAtIndentOrStartOfLine()
            'end'                               ➜ ⮐  @singleCursorAtEndOfLine()
                                                     
            'ctrl+h'                            ➜ ⮐  @setMainCursor 0 0
            'ctrl+j'                            ➜ ⮐  @setMainCursor @s.lines[@s.lines.length-1].length @s.lines.length-1
                                                     
            'alt+d'                             ➜ ⮐  @delete 'next' true
            'shift+ctrl+k' 'entf'               ➜ ⮐  @delete 'next'
            'ctrl+k'                            ➜ ⮐  @delete 'eol'
            'delete'                            ➜ ⮐  @delete 'back'
            'ctrl+delete'                       ➜ ⮐  @delete 'back' true
            'cmd+delete'                        ➜ ⮐  @delete 'back' true
                                                     
            'shift+tab'                         ➜ ⮐  @deindentSelectedOrCursorLines()
            'tab'                               ➜ ⮐  @insert '\t'
                                                     
            'alt+x' 'cmd+x' 'ctrl+x'            ➜ ⮐  @cut()     
            'alt+c' 'cmd+c' 'ctrl+c'            ➜ ⮐  @copy()        
            'alt+v' 'cmd+v' 'ctrl+v'            ➜ ⮐  @paste()
                                                     
            'cmd+z' 'ctrl+z'                    ➜ ⮐  @undo()
            'shift+cmd+z'                            
            'cmd+y' 'ctrl+y'                    ➜ ⮐  @redo()
                                                     
            'cmd+a'       'ctrl+a'              ➜ ⮐  @selectAllLines()
            'cmd+j'       'ctrl+j'              ➜ ⮐  @joinLines()
            'cmd+l'       'ctrl+l'              ➜ ⮐  @selectMoreLines()
            'shift+cmd+l' 'shift+ctrl+l'        ➜ ⮐  @selectLessLines()
                                                     
            'cmd+e' 'ctrl+e'                    ➜ ⮐  @highlightWordAtCursor_deselectCursorHighlight_moveCursorToNextHighlight()
            'cmd+d' 'ctrl+d'                    ➜ ⮐  @selectWordAtCursor_highlightSelection_addNextHighlightToSelection()
            'cmd+g' 'ctrl+g'                    ➜ ⮐  @selectWordAtCursor_highlightSelection_selectNextHighlight()
                                                     
            'shift+cmd+e' 'shift+ctrl+e'        ➜ ⮐  @highlightWordAtCursor_deselectCursorHighlight_moveCursorToPrevHighlight()
            'shift+cmd+d' 'shift+ctrl+d'        ➜ ⮐  @selectWordAtCursor_highlightSelection_addPrevHighlightToSelection()
            'shift+cmd+g' 'shift+ctrl+g'        ➜ ⮐  @selectWordAtCursor_highlightSelection_selectPrevHighlight()
                                                     
            'alt+y'                             ➜ ⮐  @toggleMode 'unype'
            'alt+r'                             ➜ ⮐  @toggleMode 'record'
            'alt+u'                             ➜ ⮐  @toggleMode 'uniko'
            'alt+;'                             ➜ ⮐  @toggleMode 'vimple'
            'alt+3'                             ➜ ⮐  @toggleMode 'salter'
                                                     
            'cmd+3' 'ctrl+3'                    ➜ ⮐  @insertAsciiHeaderForSelectionOrWordAtCursor()
            'alt+cmd+d' 'alt+ctrl+d'            ➜ ⮐  @selectWordAtCursor_highlightSelection_selectAllHighlights()
                                                     
            'cmd+/' 'ctrl+/'                    ➜ ⮐  @toggleCommentAtSelectionOrCursorLines()
            'alt+cmd+/' 'ctrl+alt+/'            ➜ ⮐  @toggleCommentTypeAtSelectionOrCursorLines()
                                                     
            'esc'                               ➜ ⮐  @clearCursorsHighlightsAndSelections()
        
        'unhandled'

    toggleMode: name -> mode.toggle(@ name) if @allowedModes[name]
    startMode:  name -> mode.start(@ name) if @allowedModes[name]
    stopMode:   name -> mode.stop(@ name) if @allowedModes[name]
        
    owner: -> 
        
        if kstr.endsWith @name '.state'
            string.sub @name 1 -6
        else
            @name
        
    clearHistory: ->
    
        @h = [@s] # undo states (history)
        @r = []   # redo states

    #  0000000  00000000  000000000
    # 000       000          000
    # 0000000   0000000      000
    #      000  000          000
    # 0000000   00000000     000

    set: item arg ->

        # @s = @s.set item arg
        @s[item] = arg
        @swapState()
        @

    setSelections: selections -> @set 'selections' belt.mergeLineRanges(@s.lines selections)
    setHighlights: highlights -> @set 'highlights' belt.normalizeSpans(highlights)

    #  0000000  000   000  00000000    0000000   0000000   00000000    0000000
    # 000       000   000  000   000  000       000   000  000   000  000
    # 000       000   000  0000000    0000000   000   000  0000000    0000000
    # 000       000   000  000   000       000  000   000  000   000       000
    #  0000000   0000000   000   000  0000000    0000000   000   000  0000000

    setCursors: cursors opt ->
        
        opt ?= {}
        opt.mc ?= @mainCursor()
        
        main = opt.main

        if main is array ➜ main = belt.indexOfPosInPositions main cursors
        if main is "number" and main < 0 ➜ main = cursors.len+main-1

        mainCursor = @mainCursor()
        if main
            mainCursor = cursors[clamp(1, cursors.length, main)]
            # mainCursor = copy cursors[clamp 0 cursors.length-1 main]
        
        cursors = belt.normalizePositions cursors @s.lines.len
        # @s = @s.set 'cursors' cursors
        @s.cursors = cursors

        main = -1
        for idx cur in ipairs cursors
            if cur == mainCursor
                main = idx
                break

        if main < 1 ➜ main = @s.main 
        main = clamp 1 @s.cursors.length main

        # @s = @s.set 'main' main
        @s.main = main
        
        @adjustViewForMainCursor opt
        
        @swapState()
        
        mode.cursorsSet @
        @emit 'cursorsSet'
        log 'cursorsSet' @s.cursors, @s.main
        @
            
    textOfSelectionOrWordAtCursor: -> 
        
        if @s.selections.length
            ⮐  @textOfSelection()
        else
            ⮐  @wordAtCursor()

    # 000      000  000   000  00000000   0000000
    # 000      000  0000  000  000       000
    # 000      000  000 0 000  0000000   0000000
    # 000      000  000  0000  000            000
    # 0000000  000  000   000  00000000  0000000

    setLines: lines ->
        
        if empty lines ➜ lines = ['']
        
        @setSegls kseg.segls(lines)
        
    setSegls: segls ->
    
        @segls = segls
        
        if empty @segls ➜ @segls = [[]]
        
        @syntax∙setSegls @segls
                    
        @changeLinesSegls()
        
        @r = []
        
        @maxLineWidth = belt.widthOfLines @s.lines
        
        @pushState()
        
    loadLines: lines -> 
    
        if valid(lines) and not (lines[1] is "string")
            error "#{@name}.loadLines - first line not a string?" lines
        
        @loadSegls kseg.segls(lines)
    
    loadSegls: segls ->
    
        @clearEmpty()
        @setSegls segls

    clearSingle: -> @clearSegls [[]]
    clearEmpty:  -> @clearSegls [  ]
    clearSegls: segls ->
    
        @segls = segls
    
        # @s = immutable {
        @s = {
            lines:       @segls
            selections:  []
            highlights:  []
            cursors:     [[1 1]]
            main:        1
            view:        [1 1]
            }
            
        @syntax∙clear()
        
        @h = []
        @r = []
        
    addLine: line ext ->

        segl = kseg line
        @syntax.addSegl segl ext
        @segls ?= []
        @segls.push segl

        @changeLinesSegls()
        
    appendLines: lines ext ->

        segls = kseg.segls lines
        @syntax.appendSegls segls ext
        @segls ?= []
        @segls = @segls.concat segls

        @changeLinesSegls()
        
    #  ███████  ███   ███   ███████   ███   ███   ███████   ████████        ███      ███  ███   ███  ████████   ███████
    # ███       ███   ███  ███   ███  ████  ███  ███        ███             ███      ███  ████  ███  ███       ███     
    # ███       █████████  █████████  ███ █ ███  ███  ████  ███████         ███      ███  ███ █ ███  ███████   ███████ 
    # ███       ███   ███  ███   ███  ███  ████  ███   ███  ███             ███      ███  ███  ████  ███            ███
    #  ███████  ███   ███  ███   ███  ███   ███   ███████   ████████        ███████  ███  ███   ███  ████████  ███████ 

    changeLinesSegls: ->
    
         #oldLines = @s.lines
         #
         # @s = @s.set 'lines' @segls
         @s.lines = @segls
         #
         #if oldLines != @s.lines
         #    diff = belt.diffLines oldLines @s.lines            
         #    @emit 'lines.changed' diff

    linesInView: -> @s.lines∙slice(@s.view[1] @s.view[1]+@cells.rows)

    clearLines: ->

        @setSegls [[]]
        @setMainCursor 1 1

    isValidLineIndex:   li -> 0 <= li < @s.lines.length
    isInvalidLineIndex: li -> not @isValidLineIndex li

    # 000   000  000   000  0000000     0000000
    # 000   000  0000  000  000   000  000   000
    # 000   000  000 0 000  000   000  000   000
    # 000   000  000  0000  000   000  000   000
    #  0000000   000   000  0000000     0000000

    undo: ->

        ⮐  if @h.len <= 1
        @r∙push @h∙pop()
        @s = @h[^1]
        @syntax∙setSegls @s.lines

    redo: ->

        ⮐  if empty @r
        @h.push @r.pop()
        @s = @h[^1]
        @syntax.setSegls @s.lines

    begin: -> @beginIndex = @h.len

    ende: ->

        if valid @beginIndex

            @h.splice @beginIndex @h.len-@beginIndex-1
            @beginIndex = nil
        @

    pushState: -> 
        @h∙push @s  
        @
        
    swapState: -> 
    
        @h∙pop()  
        @pushState()

    isDirty: -> @h.len > 1
    hasRedo: -> @r.len > 0

    gutterWidth: -> math.max 4 2 + math.ceil(math.log10(@s.lines.length+1))

    #  0000000  000   000  000000000
    # 000       000   000     000
    # 000       000   000     000
    # 000       000   000     000
    #  0000000   0000000      000

    cut: ->

        @copy {deselect:false}
        if empty @s.selections
            @selectCursorLines()
        @deleteSelection()

    #  0000000   0000000   00000000   000   000
    # 000       000   000  000   000   000 000
    # 000       000   000  00000000     00000
    # 000       000   000  000           000
    #  0000000   0000000   000           000

    copy: opt ->
    
        opt ?= {}

        switch os.platform()

            'darwin'

                prcs = child_process.spawn 'pbcopy'
                prcs.stdin.write @textOfSelectionOrCursorLines()
                prcs.stdin.close()

            'linux'

                prcs = child_process.spawn("xsel", {"-i", "--clipboard"})
                prcs.stdin.write @textOfSelectionOrCursorLines()
                prcs.stdin.close()

            'win32'

                prcs = child_process.spawn "#{slash.cwd()}/../../bin/utf8clip.exe"
                prcs.stdin.write @textOfSelectionOrCursorLines()
                prcs.stdin.close()
                
        @deselect() if opt.deselect != false

    # 00000000    0000000    0000000  000000000  00000000
    # 000   000  000   000  000          000     000
    # 00000000   000000000  0000000      000     0000000
    # 000        000   000       000     000     000
    # 000        000   000  0000000      000     00000000

    paste: ->

        switch os.platform()

            'darwin'

                @insert child_process.execSync('pbpaste').toString("utf8")

            'linux'

                text = child_process.execSync('xsel -o --clipboard')

                log 'paste\n' noon(text.toString("utf8"))

                @insert text.toString("utf8")

            'win32'

                @insert child_process.execSync("#{slash.cwd()}/../../bin/utf8clip.exe").toString("utf8")

    #  0000000   0000000  00000000    0000000   000      000          000   000  000  00000000  000   000  
    # 000       000       000   000  000   000  000      000          000   000  000  000       000 0 000  
    # 0000000   000       0000000    000   000  000      000           000 000   000  0000000   000000000  
    #      000  000       000   000  000   000  000      000             000     000  000       000   000  
    # 0000000    0000000  000   000   0000000   0000000  0000000          0      000  00000000  00     00  

    scrollView: dir steps=1 ->

        sx = 1 
        sy = 1

        switch dir
            'left'  ➜ sx = -1
            'right' ➜ sx =  1
            'up'    ➜ sy = -steps
            'down'  ➜ sy =  steps

        view = @s.view #.asMutable()

        view[1] += sx
        view[2] += sy

        view[2] = clamp 1 math.max(1 @s.lines.length-@cells.rows) view[2]

        maxOffsetX = math.max 1 @maxLineWidth-@cells.cols+2
        maxOffsetX = math.max maxOffsetX @mainCursor()[1]-@cells.cols+2
        view[1] = clamp 1 maxOffsetX view[1]
        
        ⮐  if view == @s.view

        @setView view

    #  0000000   0000000          000  000   000   0000000  000000000       000   000  000  00000000  000   000  
    # 000   000  000   000        000  000   000  000          000          000   000  000  000       000 0 000  
    # 000000000  000   000        000  000   000  0000000      000           000 000   000  0000000   000000000  
    # 000   000  000   000  000   000  000   000       000     000             000     000  000       000   000  
    # 000   000  0000000     0000000    0000000   0000000      000              0      000  00000000  00     00  
    
    adjustViewForMainCursor: opt ->
        
        opt ?= {}
        
        ⮐  if @cells.cols <= 0 or @cells.rows <= 0
        
        ⮐  if opt.adjust == false

        mc = @mainCursor()
        x = mc[1]
        y = mc[2]

        view = @s.view #.asMutable()

        topBotDelta = 7
        topDelta = 7
        botDelta = max topDelta floor(@cells.rows/2)
        
        if opt.adjust == 'topDelta'

            view[2] = y - topDelta
            
        elif opt.adjust == 'topBotDeltaGrow' and opt.mc
        
            dtt = y-view[2]
            dtb = y-(view[2]+@cells.rows)
            if dtt < 0 
                view[2] = y - topDelta
            elif dtb > 0
                view[2] = y - (@cells.rows-botDelta)
            else
                dir = y - opt.mc[2]
                if dtt < topDelta and dir < 0  or -dtb < botDelta and dir > 0
                    view[2] += dir
        else        
            if opt.adjust != 'topBotDelta'
                topBotDelta = 0
    
            if y >= view[2] + @cells.rows - 1 - topBotDelta
                view[2] = y - @cells.rows + 1 + topBotDelta
            elif y < view[2] + topBotDelta
                view[2] = y - topBotDelta

        if view[2] > 1 and @s.lines.length <= @cells.rows
            view[2] = 1

        if not @skipAdjustViewForMainCursor
            view[1] = math.max 1 x - @cells.cols + 2 # adding one for wide graphemes
        
        ⮐  if view == @s.view
        
        @setView view

    initView: ->

        # view = @s.view.asMutable()
        view = @s.view
        
        view[2] = clamp 1 math.max(1 @s.lines.len-@cells.rows) view[2]
        view[1] = math.max 1 view[1] or 1

        @setView view

    setView: view ->
        
        ⮐  if @s.view == view
        @set 'view' view
        @emit 'view.changed' @s.view
        @

    rangeForVisibleLines: ->

        [@s.view[1] @s.view[2] @s.view[1]+@cells.cols-1 @s.view[2]+@cells.rows-1]

    setMain: m -> 
    
        mc = @mainCursor()
        # @s = @s.set 'main' clamp(1 @s.cursors.length m)
        @s.main = clamp(1 @s.cursors.length m)
        @adjustViewForMainCursor {adjust:'topBotDeltaGrow' mc:mc}
        
    mainCursor: -> 
        #.asMutable()        
        mc = @s.cursors[@s.main]
        if not mc
            # error "no mainCursor!"
            ⮐  [1 1]
        mc
    
    #  ███████  ████████  █████████
    # ███       ███          ███   
    # ███████   ███████      ███   
    #      ███  ███          ███   
    # ███████   ████████     ███   

    setMainCursor: x y ->

        (x y) = belt.pos x y
        y = clamp 1 @s.lines.len y
        x = max 1 x
        @setCursors [[x y]]
        
    # ██     ██   ███████   ███   ███  ████████
    # ███   ███  ███   ███  ███   ███  ███     
    # █████████  ███   ███   ███ ███   ███████ 
    # ███ █ ███  ███   ███     ███     ███     
    # ███   ███   ███████       █      ████████

    moveMainCursorInDirection: dir opt={} ->
        
        mc = belt.positionInDirection @mainCursor() dir
        
        if opt.keep
            @addCursor mc
        else
            @moveMainCursor mc
                        
    moveMainCursor: x y ->
                
        (x y) = belt.pos x y
        
        y = clamp 1 @s.lines.length y
        x = max 1 x
        
        mainCursor = @mainCursor()
        
        ⮐  if mainCursor == [x y]

        cursors = @allCursors()

        cursors∙splice belt.indexOfPosInPositions(mainCursor cursors) 1
        
        main = belt.indexOfPosInPositions [x y] cursors
        if main < 1
            cursors∙push [x y]
            main = cursors.len
        
        @setCursors cursors {main:main}
                
    # ████████   ███████    ███    
    # ███       ███   ███   ███    
    # ███████   ███   ███   ███    
    # ███       ███   ███   ███    
    # ████████   ███████    ███████

    singleCursorAtEndOfLine: ->
        
        rng = belt.lineRangeAtPos @s.lines @mainCursor()
        mc  = belt.endOfRange rng
        
        @deselect()
        @setCursors [mc]
        
    # ███  ███   ███  ███████            ███████     ███████   ███      
    # ███  ████  ███  ███   ███          ███   ███  ███   ███  ███      
    # ███  ███ █ ███  ███   ███          ███████    ███   ███  ███      
    # ███  ███  ████  ███   ███          ███   ███  ███   ███  ███      
    # ███  ███   ███  ███████    ██████  ███████     ███████   ███████  

    singleCursorAtIndentOrStartOfLine: ->
        
        lines = @s.lines
        mc    = @mainCursor()
        
        rng   = belt.lineRangeAtPos  lines mc
        ind   = belt.lineIndentAtPos lines mc
        
        if ind < mc[1]
            mc[1] = ind
        else
            mc  = belt.startOfRange rng
        
        @deselect()
        @setCursors [mc]

    # ████████    ███████    ███████   ████████
    # ███   ███  ███   ███  ███        ███     
    # ████████   █████████  ███  ████  ███████ 
    # ███        ███   ███  ███   ███  ███     
    # ███        ███   ███   ███████   ████████

    singleCursorPage: dir ->

        mc = @mainCursor()
        
        switch dir
            'up'   ➜  mc[2] -= @cells.rows
            'down' ➜  mc[2] += @cells.rows

        @deselect()
        @setCursors [mc]
                                    
    wordAtCursor:      -> belt.wordAtPos      @s.lines @mainCursor()
    chunkBeforeCursor: -> belt.chunkBeforePos @s.lines @mainCursor()
    chunkAfterCursor:  -> belt.chunkAfterPos  @s.lines @mainCursor()
        
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    setMainCursorAndSelect: x y ->
        
        @setSelections belt.extendLineRangesFromPositionToPosition @s.lines @allSelections() @mainCursor() [x y]
        @setCursors [[x y]] {adjust:'topBotDelta'}

    #  0000000   000      000      
    # 000   000  000      000      
    # 000000000  000      000      
    # 000   000  000      000      
    # 000   000  0000000  0000000  
    
    allCursors: -> 
        #.asMutable()
        @s.cursors
    
    # 00000000  000   000  00000000    0000000   000   000  0000000    
    # 000        000 000   000   000  000   000  0000  000  000   000  
    # 0000000     00000    00000000   000000000  000 0 000  000   000  
    # 000        000 000   000        000   000  000  0000  000   000  
    # 00000000  000   000  000        000   000  000   000  0000000    
    
    expandCursors: dir ->
        
        cursors = @allCursors()
        dy = if dir == 'up' ➜ -1 ➜ 1
        
        newCursors = []
        for c in cursors
            newCursors∙push c
            newCursors∙push [c[1] c[2]+dy]
        mc = belt.traversePositionsInDirection newCursors @mainCursor() dir
        @setCursors newCursors {main:mc adjust:'topBotDelta'}
        
    contractCursors: dir ->
        
        cursors = @allCursors()
        newCursors = []
        for ci c in ipairs cursors
            nbup = belt.positionsContain cursors belt.positionInDirection(c 'down')
            nbdn = belt.positionsContain cursors belt.positionInDirection(c 'up')
            solo = not (nbup or nbdn)
            add = switch dir
                'up'   ➜ nbup or solo
                'down' ➜ nbdn or solo
            
            if add
                newCursors∙push c 
        @setCursors newCursors
        
    #  0000000   0000000    0000000    
    # 000   000  000   000  000   000  
    # 000000000  000   000  000   000  
    # 000   000  000   000  000   000  
    # 000   000  0000000    0000000    
    
    addCursor: x y ->
        
        pos = belt.pos x y
        cursors = @allCursors()
        cursors∙push pos
        @setCursors cursors {main:-1}
        
    addCursors: cursors ->
        
        @setCursors @allCursors().concat(cursors)
        
    delCursorsInRange: rng ->
        
        outside = belt.positionsOutsideRange @allCursors() rng
        outside∙push belt.endOfRange(rng)
        @setCursors outside {main:-1}
        
    # 00     00   0000000   000   000  00000000  
    # 000   000  000   000  000   000  000       
    # 000000000  000   000   000 000   0000000   
    # 000 0 000  000   000     000     000       
    # 000   000   0000000       0      00000000  
    
    moveCursors: dir opt ->
        if dir is array
            switch dir[0]
                'bos' ➜ 
                    if @moveCursorsToStartOfSelections() ➜ ⮐  
                    dir = dir∙slice(1)
                'eos' ➜ 
                    if @moveCursorsToEndOfSelections() ➜ ⮐     
                    dir = dir∙slice(1)
                    
            dir = dir[0]
        
        opt ?= {}
        opt.count ?= 1
        opt.jumpWords ?= false
        
        if @s.highlights.len > 0
            @deselect()
        
        cursors = @allCursors()
        lines   = @s.lines
        for ci c in ipairs cursors
            
            line = lines[c[2]]
            
            switch dir
                'left'  
                'right'     ➜ c[1] += belt.numCharsFromPosToWordOrPunctInDirection(lines c dir opt)
                'up'        ➜ c[2] -= opt.count
                'down'      ➜ c[2] += opt.count
                'eol'       ➜ c[1] = kseg.width(@s.lines[c[2]])
                'bol'       ➜ c[1] = 0
                'bof'       ➜ c[1] = 0; c[2] = 0
                'eof'       ➜ c[2] = @s.lines.length-1; c[1] = kseg.width(line)
                'ind'       ➜ c[1] = belt.numIndent(line)
                'ind_eol'   ➜ ind  = belt.numIndent(line); c[1] = if c[1] < ind ➜  ind ➜  kseg.width(line)
                'ind_bol'   ➜ ind  = belt.numIndent(line); c[1] = if c[1] > ind ➜  ind ➜  1
        main   = @s.main
        adjust = opt.adjust or 'topBotDelta'
        
        switch dir
            'up' 'down' 'left' 'right'                 
                main = belt.indexOfExtremePositionInDirection cursors dir main
                adjust = 'topBotDeltaGrow'
                
        @setCursors cursors {main:main adjust:adjust}
        
        true
        
    moveCursorsToStartOfSelections: ->
        
        selections = @allSelections()
        
        ⮐  if empty selections
        
        rngs = belt.splitLineRanges @s.lines selections false
        @setCursors belt.startPositionsOfRanges(rngs)
        
        true
        
    moveCursorsToEndOfSelections: ->
        
        selections = @allSelections()
         
        ⮐  if empty selections
         
        rngs = belt.splitLineRanges @s.lines selections false
        @setCursors belt.endPositionsOfRanges(rngs)
        
        true
        
    moveCursorsToEndOfLines: ->
        
        cursors = @allCursors()
        
        for i cur in ipairs cursors
            cur[2] = belt.lineRangeAtPos(@s.lines cur)[3]
        
        @setCursors cursors
        
        true
                
    isAnyCursorInLine: y ->
        
        for i c in ipairs @allCursors()
            ⮐  true if c[2] == y
            
    #  0000000  000   000  000   000  000   000   0000000  0000000    00000000  00000000   0000000   00000000   00000000  
    # 000       000   000  0000  000  000  000   000       000   000  000       000       000   000  000   000  000       
    # 000       000000000  000 0 000  0000000    0000000   0000000    0000000   000000    000   000  0000000    0000000   
    # 000       000   000  000  0000  000  000        000  000   000  000       000       000   000  000   000  000       
    #  0000000  000   000  000   000  000   000  0000000   0000000    00000000  000        0000000   000   000  00000000  
    
    chunksBeforeCursors: -> @s.cursors∙map((c) -> belt.chunkBeforePos(@s.lines c))
            
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    moveCursorsAndSelect: dir opt ->
        
        (selections cursors) = belt.extendLineRangesByMovingPositionsInDirection @s.lines @s.selections @s.cursors dir opt
        
        @setSelections selections
        @setCursors cursors {adjust:'topBotDelta'}

    select: from to ->
        
        selections = []
        
        @setMainCursor to[1] to[2]
        
        if from[2] > to[2] or from[2] == to[2] and from[1] > to[1]
            (from to) = (to from)

        to[2]   = clamp 0 @s.lines.len-1 to[2]
        from[2] = clamp 0 @s.lines.len-1 from[2]
            
        to[1]   = clamp 0 @s.lines[to[2]].len to[1]
        from[1] = clamp 0 @s.lines[from[2]].len from[1]
        
        selections.push [from[1] from[2] to[1] to[2]]
        
        @setSelections selections
        
    allSelections: -> @s.selections.asMutable()
    allHighlights: -> @s.highlights.asMutable()
        
    # 000   000  000   0000000   000   000  000      000   0000000   000   000  000000000  
    # 000   000  000  000        000   000  000      000  000        000   000     000     
    # 000000000  000  000  0000  000000000  000      000  000  0000  000000000     000     
    # 000   000  000  000   000  000   000  000      000  000   000  000   000     000     
    # 000   000  000   0000000   000   000  0000000  000   0000000   000   000     000     
    
    selectWordAtCursor_highlightSelection_selectAllHighlights: ->
        # alt+cmd+d alt+ctrl+d
        if valid @s.highlights 
            pos = @mainCursor()
            if @s.selections.len < @s.highlights.len
                @selectAllHighlights()
            else
                @addNextHighlightToSelection()
            ⮐ 
        
        @selectWordAtCursor_highlightSelection()
        @selectAllHighlights()
    
    highlightWordAtCursor_deselectCursorHighlight_moveCursorToNextHighlight: ->
        # cmd+e ctrl+e
        if valid @s.highlights 
            if not @deselectCursorHighlight()
                @moveCursorToNextHighlight()
            ⮐ 
            
        @selectWordAtCursor_highlightSelection()
        @deselectCursorHighlight()
    
    selectWordAtCursor_highlightSelection_addNextHighlightToSelection: ->
        # cmd+d ctrl+d
        if valid @s.highlights ➜ ⮐  @addCurrentOrNextHighlightToSelection()
            
        @selectWordAtCursor_highlightSelection()
        
    selectWordAtCursor_highlightSelection_selectNextHighlight: ->
        # cmd+g ctrl+g
        if valid @s.highlights 
            @clearCursors()
            @selectNextHighlight()
            
        @selectWordAtCursor_highlightSelection()
        
    highlightWordAtCursor_deselectCursorHighlight_moveCursorToPrevHighlight: ->
        # shift+cmd+e shift+ctrl+e
        if valid @s.highlights 
            if not @deselectCursorHighlight()
                @moveCursorToPrevHighlight()
            ⮐ 
            
        @selectWordAtCursor_highlightSelection()
        @deselectCursorHighlight()
    
    selectWordAtCursor_highlightSelection_addPrevHighlightToSelection: ->
        # shift+cmd+d shift+ctrl+d
        if valid @s.highlights ➜ ⮐  @addCurrentOrPrevHighlightToSelection()
            
        @selectWordAtCursor_highlightSelection()
        
    selectWordAtCursor_highlightSelection_selectPrevHighlight: ->
        # shift+cmd+g shift+ctrl+g
        if valid @s.highlights 
            @clearCursors()
            @selectPrevHighlight()
            
        @selectWordAtCursor_highlightSelection()
        
    selectWordAtCursor_highlightSelection: ->
        
        if empty @s.selections
            @selectWord @mainCursor() 
        
        @highlightSelection()
    
    highlightSelection: ->
        
        ⮐  if empty @s.selections
        
        spans = []
        for ri rng in ipairs @allSelections()
            if rng[2] == rng[4]
                text  = belt.textForLineRange @s.lines rng
                spans += belt.lineSpansForText(@s.lines text)
        
        @setHighlights spans
        
    highlightText: text ->
        
        ⮐  if empty text
        
        @setHighlights belt.lineSpansForText(@s.lines text)
    
    deselectCursorHighlight: ->
        
        ⮐  if empty @s.highlights
        ⮐  if empty @s.selections
        prev = belt.prevSpanBeforePos @s.highlights @mainCursor()
        if prev
            @deselectSpan prev

    selectAllHighlights: ->
        
        ⮐  if empty @s.highlights
        
        selections = []
        cursors = []
        for si span in ipairs @s.highlights
            selections∙push belt.rangeForSpan(span)
            cursors∙push belt.endOfSpan(span)
            
        @addCursors cursors        
        @setSelections selections
                    
    selectNextHighlight: ->
        
        ⮐  if empty @s.highlights
        next = belt.nextSpanAfterPos @s.highlights @mainCursor()
        if next
            @selectSpan next
            @setMainCursor belt.endOfSpan(next)

    selectPrevHighlight: ->
        
        ⮐  if empty @s.highlights
        
        pos = @mainCursor()
        prev = belt.prevSpanBeforePos @s.highlights pos
        if prev
            if belt.endOfSpan(prev) == pos
                prev = belt.prevSpanBeforePos @s.highlights belt.startOfSpan(prev)
            if prev
                @selectSpan prev
                @setMainCursor belt.endOfSpan(prev)
            
    addCurrentOrNextHighlightToSelection: ->            
        prev = belt.prevSpanBeforePos @s.highlights @mainCursor()
        if prev
            if not belt.rangesContainSpan @s.selections prev
                @addSpanToSelection prev
                @addCursor belt.endOfSpan(prev)
                ⮐ 
                
        @addNextHighlightToSelection()

    addCurrentOrPrevHighlightToSelection: ->            
        prev = belt.prevSpanBeforePos @s.highlights @mainCursor()
        if prev
            if not belt.rangesContainSpan @s.selections prev
                @addSpanToSelection prev
                @addCursor belt.endOfSpan(prev)
                ⮐ 
                
        @addPrevHighlightToSelection()
        
    addNextHighlightToSelection: ->
        
        ⮐  if empty @s.highlights
        next = belt.nextSpanAfterPos @s.highlights @mainCursor()
        if next
            @addSpanToSelection next
            @addCursor belt.endOfSpan(next)

    addPrevHighlightToSelection: ->
        
        ⮐  if empty @s.highlights
        
        pos = @mainCursor()
        prev = belt.prevSpanBeforePos @s.highlights pos
        if prev
            if belt.endOfSpan(prev) == pos
                prev = belt.prevSpanBeforePos @s.highlights belt.startOfSpan(prev)
            if prev
                @addSpanToSelection prev
                @addCursor belt.endOfSpan(prev)
            
    moveCursorToNextHighlight: pos ->
        
        ⮐  if empty @s.highlights
        
        pos ?= @mainCursor()
        next = belt.nextSpanAfterPos @s.highlights pos
        if next
            @moveMainCursor belt.endOfSpan(next)

    moveCursorToPrevHighlight: pos ->
        
        ⮐  if empty @s.highlights
        
        pos ?= @mainCursor()
        prev = belt.prevSpanBeforePos @s.highlights pos
        if prev
            if belt.endOfSpan(prev) == pos
                prev = belt.prevSpanBeforePos @s.highlights belt.startOfSpan(prev)
            if prev
                @moveMainCursor belt.endOfSpan(prev)
            
    selectSpan: span ->
        
        @setSelections [belt.rangeForSpan(span)]
        
    deselectSpan: span ->
        
        rng = belt.rangeForSpan span
        
        selections = @allSelections()
        for index selection in ipairs selections
            if belt.isSameRange selection rng
                selections∙splice index 1
                @setSelections selections
                ⮐  true
        false
        
    addRangeToSelectionWithMainCursorAtEnd: rng ->
        
        @addRangeToSelection rng
        @delCursorsInRange rng
        
    addRangeToSelection: rng ->
        
        selections = @allSelections()
        
        selections∙push rng
        
        @setSelections selections
                    
    addSpanToSelection: span -> @addRangeToSelection belt.rangeForSpan(span)
                
    #  0000000  000   000  000   000  000   000  000   000  
    # 000       000   000  000   000  0000  000  000  000   
    # 000       000000000  000   000  000 0 000  0000000    
    # 000       000   000  000   000  000  0000  000  000   
    #  0000000  000   000   0000000   000   000  000   000  
    
    selectChunk: x y ->
        rng = belt.rangeOfClosestChunkToPos @s.lines belt.pos(x y)
        if rng
            @addRangeToSelectionWithMainCursorAtEnd rng
        @

    # 000   000   0000000   00000000   0000000    
    # 000 0 000  000   000  000   000  000   000  
    # 000000000  000   000  0000000    000   000  
    # 000   000  000   000  000   000  000   000  
    # 00     00   0000000   000   000  0000000    
    
    selectWord: x y ->
        rng = belt.rangeOfClosestWordToPos @s.lines belt.pos(x y)
        if rng
            @addRangeToSelectionWithMainCursorAtEnd rng
        @
                
    # 000      000  000   000  00000000  
    # 000      000  0000  000  000       
    # 000      000  000 0 000  0000000   
    # 000      000  000  0000  000       
    # 0000000  000  000   000  00000000  
    
    selectLine: y ->
        
        y ?= @mainCursor()[2]
        if 1 <= y and y <= @s.lines.len
            @select [1 y] [@s.lines[y].len y]
        @
        
    selectPrevLine: y ->
        
        y ?= @mainCursor()[2]
        @selectLine y-1
        
    selectNextLine: y ->
        
        y ?= @mainCursor()[2]
        @selectLine y+1
        
    selectCursorLines: ->
                    
        selections = belt.lineRangesForPositions(@s.lines @s.cursors)
        
        ▴ selections.length == @s.cursors.length
                    
        @setSelections selections
        
    selectAllLines: ->
        
        allsel = [[1 1 kseg.width(@s.lines[@s.lines.length]) @s.lines.length]]
        
        if allsel == @s.selections
            @deselect()
        else
            @setSelections allsel
        
    # 00     00   0000000   00000000   00000000  
    # 000   000  000   000  000   000  000       
    # 000000000  000   000  0000000    0000000   
    # 000 0 000  000   000  000   000  000       
    # 000   000   0000000   000   000  00000000  
    
    selectMoreLines: ->
        
        (cursors selections) = belt.addLinesBelowPositionsToRanges @s.lines @s.cursors @s.selections
        
        @setSelections selections
        @setCursors cursors {main:-1}

    # 000      00000000   0000000   0000000  
    # 000      000       000       000       
    # 000      0000000   0000000   0000000   
    # 000      000            000       000  
    # 0000000  00000000  0000000   0000000   
    
    selectLessLines: ->
        
        (cursors selections) = belt.removeLinesAtPositionsFromRanges @s.lines @s.cursors @s.selections
        
        @setSelections selections
        @setCursors cursors {main:-1}
                
    # 000000000  00000000  000   000  000000000  
    #    000     000        000 000      000     
    #    000     0000000     00000       000     
    #    000     000        000 000      000     
    #    000     00000000  000   000     000     
    
    textOfSelection: -> belt.textForLineRanges @s.lines @s.selections
    selectedText:    -> belt.textForLineRanges @s.lines @s.selections
    
    selectionsOrCursorLineRanges: -> @s.selections or belt.lineRangesForPositions(@s.lines @s.cursors true)
    
    textOfSelectionOrCursorLines: -> 
        
        belt.textForLineRanges @s.lines @selectionsOrCursorLineRanges()

    isSingleLineSelected: ->
        
        @s.selections.len == 1 and @s.selections[1][2] == @s.selections[1][4]
        
    isSelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if not (selection[4] == y and selection[3] == 0)
                if selection[2] <= y and y <= selection[4]
                    ⮐  true
        false
        
    isFullySelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if selection[2] <= y and y <= selection[4]
                ⮐  belt.isFullLineRange(@s.lines selection)
        false
        
    isPartiallySelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if selection[2] <= y and y <= selection[4]
                ⮐  not belt.isFullLineRange(@s.lines selection)
        false
        
    isSpanSelectedLine: y ->
        
        for si selection in ipairs @s.selections
            if selection[2] <= y and y <= selection[4]
                span = belt.isSpanLineRange(@s.lines selection)
                if span
                    ⮐  true 
            ⮐  false if selection[2] > y
        false
        
    isHighlightedLine: y ->

        for hi highlight in ipairs @s.highlights
            ⮐  true if highlight[2] == y
                
        false
        
    # 0000000    00000000   0000000  00000000  000      00000000   0000000  000000000  
    # 000   000  000       000       000       000      000       000          000     
    # 000   000  0000000   0000000   0000000   000      0000000   000          000     
    # 000   000  000            000  000       000      000       000          000     
    # 0000000    00000000  0000000   00000000  0000000  00000000   0000000     000     
    
    deselect: ->
        
        if valid @s.selections
            @setSelections []
            
    clearHighlights: ->

        if valid @s.highlights
            @setHighlights []
            
    clearCursors: ->
            
        if @s.cursors.length > 1
            @setCursors [@mainCursor()]
            
    clearCursorsHighlightsAndSelections: ->
        
        @pushState() if @s.cursors.length>1 or valid @s.selections
        @clearCursors()
        @clearHighlights()
        @deselect()

    # █████████  ████████  ███   ███  █████████
    #    ███     ███        ███ ███      ███   
    #    ███     ███████     █████       ███   
    #    ███     ███        ███ ███      ███   
    #    ███     ████████  ███   ███     ███   
    
    insert: text ->
    
        text = mode.insert @ text
        
        if valid @s.selections
            ⮐  @indentSelectedLines() if text == '\t'
            @deleteSelection()
            
        (lines cursors) = belt.insertTextAtPositions @s.lines text @s.cursors
        
        @clearHighlights()
        @setLines   lines
        @setCursors cursors
        
        mode.postInsert @
        
    # ███   ███  ████████   ███████   ███████    ████████  ████████ 
    # ███   ███  ███       ███   ███  ███   ███  ███       ███   ███
    # █████████  ███████   █████████  ███   ███  ███████   ███████  
    # ███   ███  ███       ███   ███  ███   ███  ███       ███   ███
    # ███   ███  ████████  ███   ███  ███████    ████████  ███   ███
    
    insertAsciiHeaderForSelectionOrWordAtCursor: ->
    
        (lines cursors selections) = belt.insertAsciiHeaderForPositionsAndRanges @s.lines @s.cursors @s.selections
        
        @clearHighlights()
        @setLines      lines
        @setSelections selections
        @setCursors    cursors
        
    #  ███████  ███   ███  ████████   ████████    ███████   ███   ███  ███   ███  ███████  
    # ███       ███   ███  ███   ███  ███   ███  ███   ███  ███   ███  ████  ███  ███   ███
    # ███████   ███   ███  ███████    ███████    ███   ███  ███   ███  ███ █ ███  ███   ███
    #      ███  ███   ███  ███   ███  ███   ███  ███   ███  ███   ███  ███  ████  ███   ███
    # ███████    ███████   ███   ███  ███   ███   ███████    ███████   ███   ███  ███████  
    
    surroundSelection: trigger pair ->
        
        (lines posl) = belt.insertSurroundAtRanges @s.lines @s.selections trigger pair
        @setLines      lines
        @setSelections []
        @setCursors    posl

    # 000      000  000   000  00000000   0000000  
    # 000      000  0000  000  000       000       
    # 000      000  000 0 000  0000000   0000000   
    # 000      000  000  0000  000            000  
    # 0000000  000  000   000  00000000  0000000   
    
    joinLines: ->
        
        @moveCursorsToEndOfLines()
        
        idxs = belt.lineIndicesForPositions @s.cursors
        rngs = belt.rangesForJoiningLines @s.lines idxs

        @deleteRanges rngs @allCursors()
        
    # ██     ██   ███████   ███   ███  ████████
    # ███   ███  ███   ███  ███   ███  ███     
    # █████████  ███   ███   ███ ███   ███████ 
    # ███ █ ███  ███   ███     ███     ███     
    # ███   ███   ███████       █      ████████

    moveSelectionOrCursorLines: dir ->
        
        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors
        
        (lines selections cursors) = belt.moveLineRangesAndPositionsAtIndicesInDirection @s.lines @s.selections @s.cursors indices dir
        
        @setLines lines
        @setSelections selections
        @setCursors cursors
        
    #  ███████  ███       ███████   ███   ███  ████████
    # ███       ███      ███   ███  ████  ███  ███     
    # ███       ███      ███   ███  ███ █ ███  ███████ 
    # ███       ███      ███   ███  ███  ████  ███     
    #  ███████  ███████   ███████   ███   ███  ████████

    cloneSelectionAndCursorLines: dir ->
        
        blocks = belt.blockRangesForRangesAndPositions @s.lines @s.selections @s.cursors
        
        (lines selections cursors) = belt.cloneLineBlockRangesAndMoveRangesAndPositionsInDirection @s.lines blocks @s.selections @s.cursors dir
        
        @setLines lines
        @setSelections selections
        @setCursors cursors
        
    #  ███████   ███████   ██     ██  ██     ██  ████████  ███   ███  █████████
    # ███       ███   ███  ███   ███  ███   ███  ███       ████  ███     ███   
    # ███       ███   ███  █████████  █████████  ███████   ███ █ ███     ███   
    # ███       ███   ███  ███ █ ███  ███ █ ███  ███       ███  ████     ███   
    #  ███████   ███████   ███   ███  ███   ███  ████████  ███   ███     ███   

    toggleCommentAtSelectionOrCursorLines: ->

        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors

        (lines selections cursors) = belt.toggleCommentsInLineRangesAtIndices @s.lines @s.selections @s.cursors indices
                
        @setLines lines        
        @setSelections selections
        @setCursors cursors

    toggleCommentTypeAtSelectionOrCursorLines: ->

        indices = belt.lineIndicesForRangesOrPositions @s.selections @s.cursors

        (lines selections cursors) = belt.toggleCommentTypesInLineRangesAtIndices @s.lines @s.selections @s.cursors indices
                
        @setLines lines        
        @setSelections selections
        @setCursors cursors
        
⮐  state
