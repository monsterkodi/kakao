###
    ███   ███   ███████   ████████    ███████
    ███   ███  ███   ███  ███   ███  ███     
     ███ ███   █████████  ███████    ███████ 
       ███     ███   ███  ███   ███       ███
        █      ███   ███  ███   ███  ███████ 

    inserts var keywords for assignment operations
###

use kommon tknz pars

class Scoper*
    vars* : seq[Table[string,bool]]

$* = ◇Scoper v ➜string ->

    s = ""
    s &= $v.vars
    s

exp   = ◇Scoper s ◇Node body ◇int i ◇Node e ->
scope = ◇Scoper s ◇Node body ➜Node ->

# 00000000  000   000  00000000   
# 000        000 000   000   000  
# 0000000     00000    00000000   
# 000        000 000   000        
# 00000000  000   000  000        
    
exp = ◇Scoper s ◇Node body ◇int i ◇Node e ->
    
    ⮐  if e == nil
        
    proc insert(name:string, expr:Node) =
        
        for map in s.vars
            ⮐  if map.hasKey name
            
        var let_expr = Node(token:Token(tok:◂let, str:"var", line:expr.token.line), kind:●let, let_expr:expr)

        body.expressions[i] = let_expr

        s.vars[^1][name] = true
    
    if e.kind == ●operation
        if e.operand_right.kind == ●func
            discard s.scope e.operand_right.func_body
        elif e.token.tok == ◂assign
            let lhs = e.operand_left
            if lhs.kind == ●literal
                insert lhs.token.str, e
    elif e.kind == ●var
        insert e.var_name.token.str, e
                    
#  0000000   0000000   0000000   00000000   00000000  
# 000       000       000   000  000   000  000       
# 0000000   000       000   000  00000000   0000000   
#      000  000       000   000  000        000       
# 0000000    0000000   0000000   000        00000000  
    
scope = ◇Scoper s ◇Node body ➜Node ->
    
    if body == nil or body.kind != ●block or body.expressions.len == 0
        ⮐  body

    s.vars.push initTable[string,bool]()

    for i e in body.expressions
        s.exp body i e 

    s.vars.pops()
    body
    
variables* = ◇Node body ➜Node ->

    Scoper().scope body
