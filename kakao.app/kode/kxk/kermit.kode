###
000   000  00000000  00000000   00     00  000  000000000
000  000   000       000   000  000   000  000     000   
0000000    0000000   0000000    000000000  000     000   
000  000   000       000   000  000 0 000  000     000   
000   000  00000000  000   000  000   000  000     000   
###

use ◆ kstr

pattern = (kmt) ->
    
    p = []
    lines = kmt.split '\n'
    while line = lines.shift()
        lpt = trim(line).split /\s+/
        if lpt[0][0] == '■'
            while child = lines.shift()
                cpt = child.split /\s+/
                if empty cpt[0]
                    p.push [cpt[1..], lpt[0]]
                else
                    lines.unshift child
                    break
        else
            p.push [lpt, null]
    p
    
stackTopOrLast = (ctx) ->
    
    lr = last ctx.result
    if valid ctx.stack
        lr = lr[last(ctx.stack)[1..]]
        lr.push {}
        lr = last lr
    lr
    
wrapIndex = (ctx,offset) -> (ctx.pind+offset) % ctx.ptn.length
    
strongMatchAhead = (lr, cp, ci, cpt, splt, ctx) ->
    
    if splt[0] == ctx.ptn[wrapIndex(ctx,1)][0][0]
        return true
    false
    
addMatch = (cpt, splt, ctx) ->
    
    strongMatch = false
    varMatch = false
    
    lr = stackTopOrLast ctx
    
    for cp,ci in cpt
        if cp?[0] in '●'
            if ci == 0 and strongMatchAhead lr, cp, ci, cpt, splt, ctx
                ctx.pind = wrapIndex ctx, 1
                if valid ctx.stack
                    last(ctx.result)[last(ctx.stack)[1..]].pop()
                ctx.stack = []
                cptn = ctx.ptn[ctx.pind]
                ctx.result.push {}
                return addMatch cptn[0], splt, ctx
            else
                varMatch = true
                lr[cp[1..]] = splt[ci]
                if empty cpt[ci+1..] and valid splt[ci+1..]
                    lr[cp[1..]] += ' ' + splt[ci+1..].join ' '
        else if cp == splt[ci]
            strongMatch = true
            continue
        else
            log 'bail?'
            return false
    if empty ctx.stack and (strongMatch or varMatch)
        ctx.pind = wrapIndex ctx, 1
        if ctx.pind == 0 ➜ ctx.result.push {}
        # log 'wrapIndex' strongMatch, varMatch, ctx.pind
    true
    
traverse = (lines, ctx) ->
    
    while line = lines.shift()
        
        splt = trim(line).split /\s+/
        cptn = ctx.ptn[ctx.pind]
        
        # log y2('▸'), y5(line), ctx.pind, m5(cptn)
    
        if empty cptn
            log 'empty pattern at index' ctx.pind
            ctx.pind = 0
            ctx.result.push {}
            cptn = ctx.ptn[ctx.pind]
            
        if cptn[1]
            if last ctx.stack == cptn[1]
                1
            else
                lr = stackTopOrLast ctx
                ctx.stack.push cptn[1]
                lr[cptn[1][1..]] = []
        else if valid ctx.stack
            ctx.pind = wrapIndex ctx, 1
            ctx.stack = []
        
        if addMatch cptn[0], splt, ctx
        else
            log b4('no match'), cptn[0], splt
            
    if empty last ctx.result ➜ ctx.result.pop()
                
kermit = (kmt, str) ->

    lines = str.split '\n'
    lines = lines.filter (l) -> valid trim l

    ctx = result:[{}], stack:[], pind:0 ptn:pattern kmt
    traverse lines, ctx
    ctx.result

export kermit
