###
000000000  000000000  000   0000000   
   000        000     000  000   000  
   000        000     000  000   000  
   000        000     000  000   000  
   000        000     000   0000000   
###

use ../kxk ◆ events

function TTIO extends events

    @: ->
        
        if process.stdin.isTTY ➜ process.stdin.setRawMode true

        @write '\x1b[?45h'   # origin mode (no wrap?)
        @write '\x1b[?1000h' # mouse events
        @write '\x1b[?1001h' # highlight tracking
        @write '\x1b[?1003h' # mouse move events
        @write '\x1b[?1004h' # focus
        @write '\x1b[?1006h' # mouse SGR mode
        @write '\x1b[?1049h' # aletrnate screen buffer
        @write '\x1b[>4;2m'  # modify other keys
        @write '\x1b[5 q'    # cursor blinking bar
        
        process.stdout.on 'resize' @onResize
        process.stdin.on  'data'   @onData
        
    write: str => process.stdout.write str
    
    clear: =>
        @write '\x1b[2J' # clear screen
        @write '\x1b[H'  # cursor home
        
    hideCursor: => @write '\x1b[?25l'
    showCursor: => @write '\x1b[?25h'
        
    cols: => process.stdout.columns
    rows: => process.stdout.rows
    
    store:   => @write '\x1b7'
    restore: => @write '\x1b8'
    
    moveCursor: dir =>
        
        switch dir
            'up'    ➜ ⮐ @write '\x1b[A'
            'down'  ➜ ⮐ @write '\x1b[B'
            'left'  ➜ ⮐ @write '\x1b[D'
            'right' ➜ ⮐ @write '\x1b[C'
            
    setCursor: x y => @write "\x1b[#{y+1};#{x+1}H"
        
    onResize: => @emit 'resize' @cols() @rows()
        
    onData: data =>
        
        if data[0] == 0x1b
            seq = data[1..].toString 'utf8'
            
            if seq.startsWith '[<'
                [code col row] = seq[2..-2].split(';').map (s) -> parseInt s
                if seq.endsWith 'M'
                    switch code
                        0  ➜ ⮐ @emit 'mouse' 'press' col row 'left' 
                        2  ➜ ⮐ @emit 'mouse' 'press' col row 'right'
                        32 ➜ ⮐ @emit 'mouse' 'drag'  col row 'left'  
                        34 ➜ ⮐ @emit 'mouse' 'drag'  col row 'right' 
                        35 ➜ ⮐ @emit 'mouse' 'move'  col row ''
                        64 ➜ ⮐ @emit 'wheel' 'up'   
                        65 ➜ ⮐ @emit 'wheel' 'down' 
                        66 ➜ ⮐ @emit 'wheel' 'left' 
                        67 ➜ ⮐ @emit 'wheel' 'right'
                    log 'mouse press?' seq
                    ⮐ 
                else if seq.endsWith 'm'
                    switch code
                        0  ➜ ⮐ @emit 'mouse' 'release' col row 'left'
                        2  ➜ ⮐ @emit 'mouse' 'release' col row 'right'
                    log 'mouse release?' seq
                    ⮐ 
            else if seq.startsWith '['
                
                switch seq[1]
                    'O' ➜ ⮐ @emit 'blur'
                    'I' ➜ ⮐ @emit 'focus'
                    'A' ➜ ⮐ @emit 'key' 'up'    
                    'B' ➜ ⮐ @emit 'key' 'down'  
                    'D' ➜ ⮐ @emit 'key' 'left'  
                    'C' ➜ ⮐ @emit 'key' 'right' 
                    
                switch seq[0..]
                    '[1;3A' ➜ ⮐ @emit 'key' 'alt+up'
                    '[1;3B' ➜ ⮐ @emit 'key' 'alt+down'
                    '[1;2A' ➜ ⮐ @emit 'key' 'shift+up'
                    '[1;2B' ➜ ⮐ @emit 'key' 'shift+down'
                    '[1;2C' ➜ ⮐ @emit 'key' 'shift+right'
                    '[1;2D' ➜ ⮐ @emit 'key' 'shift+left'
                    '[1;4A' ➜ ⮐ @emit 'key' 'shift+alt+up'
                    '[1;4B' ➜ ⮐ @emit 'key' 'shift+alt+down'
                    '[1;4C' ➜ ⮐ @emit 'key' 'shift+alt+right'
                    '[1;4D' ➜ ⮐ @emit 'key' 'shift+alt+left'
                    '[1;5A' ➜ ⮐ @emit 'key' 'ctrl+up'
                    '[1;5B' ➜ ⮐ @emit 'key' 'ctrl+down'
                    '[1;5C' ➜ ⮐ @emit 'key' 'ctrl+right'
                    '[1;5D' ➜ ⮐ @emit 'key' 'ctrl+left'
                    '[1;6A' ➜ ⮐ @emit 'key' 'shift+ctrl+up'
                    '[1;6B' ➜ ⮐ @emit 'key' 'shift+ctrl+down'
                    '[1;6C' ➜ ⮐ @emit 'key' 'shift+ctrl+right'
                    '[1;6D' ➜ ⮐ @emit 'key' 'shift+ctrl+left'
                    '[1;7A' ➜ ⮐ @emit 'key' 'ctrl+alt+up'
                    '[1;7B' ➜ ⮐ @emit 'key' 'ctrl+alt+down'
                    '[1;7C' ➜ ⮐ @emit 'key' 'ctrl+alt+right'
                    '[1;7D' ➜ ⮐ @emit 'key' 'ctrl+alt+left'
                    '[1;8A' ➜ ⮐ @emit 'key' 'shift+ctrl+alt+up'
                    '[1;8B' ➜ ⮐ @emit 'key' 'shift+ctrl+alt+down'
                    '[1;8C' ➜ ⮐ @emit 'key' 'shift+ctrl+alt+right'
                    '[1;8D' ➜ ⮐ @emit 'key' 'shift+ctrl+alt+left'
                    '[1;15A' ➜ ⮐ @emit 'key' 'ctrl+alt+cmd+up'
                    '[1;15B' ➜ ⮐ @emit 'key' 'ctrl+alt+cmd+down'
                    '[1;15C' ➜ ⮐ @emit 'key' 'ctrl+alt+cmd+right'
                    '[1;15D' ➜ ⮐ @emit 'key' 'ctrl+alt+cmd+left'
                    '[27;9;122~' ➜ ⮐ @emit 'key' 'cmd+z'
                    
                log 'DATA' data, seq, seq[1..]
                ⮐ 
            else if data.length == 1
                ⮐ emit 'key' 'esc'  
            else
                switch seq[0]
                    'b' ➜ ⮐ @emit 'key' 'alt+left'
                    'f' ➜ ⮐ @emit 'key' 'alt+right'
                    
                log 'seq?' seq, data
        else
            switch data[0]
                0x01 ➜ ⮐ @emit 'key' 'ctrl+a'
                0x03 ➜ ⮐ @emit 'key' 'ctrl+c'
                0x05 ➜ ⮐ @emit 'key' 'ctrl+e'
                0x11 ➜ ⮐ @emit 'key' 'ctrl+q'
                0x08 ➜ ⮐ @emit 'key' 'ctrl+h'
                0x0b ➜ ⮐ @emit 'key' 'ctrl+k' 
                0x0d ➜ ⮐ @emit 'key' 'return' 
                0x7f ➜ ⮐ @emit 'key' 'delete' 
                0x20 ➜ ⮐ @emit 'key' 'space'
                0x09 ➜ ⮐ @emit 'key' 'tab'
                
            key = data.toString 'utf8'
                
            if key and data[0] >= 0x21
                @emit 'key' key
            else
                log 'key>' key, data, data.length, data[0]
                
export TTIO
