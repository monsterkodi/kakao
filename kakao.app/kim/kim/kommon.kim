###
    ███   ███   ███████   ██     ██  ██     ██   ███████   ███   ███
    ███  ███   ███   ███  ███   ███  ███   ███  ███   ███  ████  ███
    ███████    ███   ███  █████████  █████████  ███   ███  ███ █ ███
    ███  ███   ███   ███  ███ █ ███  ███ █ ███  ███   ███  ███  ████
    ███   ███   ███████   ███   ███  ███   ███   ███████   ███   ███
###

import std/[monotimes, times, sequtils, paths, tables, typetraits, strformat, strutils, unicode, pegs, unittest, macros, terminal, enumutils, sets]

export monotimes, times
export sequtils,  tables,    typetraits
export enumutils, sets
export strutils,  strformat, unicode,    pegs
export unittest,  macros
export terminal

type lineInfo* = tuple[filename: string, line: int, column: int]

proc testCmp*(a:string, r:auto, b:auto, l:lineInfo) = 

    if r != b
        echo ""
        styledEcho fgWhite, $l.line, fgWhite, styleDim, ":",  l.filename.split(".")[0]
        styledEcho fgBlue,    &"    {a}"
        styledEcho fgMagenta, "|>"
        styledEcho fgGreen,   &"    {b}"
        # styledEcho fgRed,     "!="
        styledEcho fgYellow,  &"    {r}"
        styledEcho fgRed, styleDim, "<|"
        fail()

converter toBool*(x: int): bool = x != 0
converter toBool*[T](x: seq[T]): bool = x.len > 0

proc swapLastPathComponentAndExt*(file: string, src: string, tgt: string): string =

    let (dir, _, _) = splitFile(file.Path)
    
    var dirParts = dir.string.split(DirSep)
    
    if dirParts[0] == "" and dirParts.len == 1
        dirParts.delete 0..0
    
    for i in countdown(dirParts.high, 0)
        if dirParts[i] == src
            dirParts[i] = tgt
            break
            
    # echo "dirParts ", dirParts 
    dirParts.add file.Path.changeFileExt("." & tgt).splitPath[1].string
    dirParts.join "/"
    
# ████████   ████████    ███████   ████████  ███  ███      ████████
# ███   ███  ███   ███  ███   ███  ███       ███  ███      ███     
# ████████   ███████    ███   ███  ██████    ███  ███      ███████ 
# ███        ███   ███  ███   ███  ███       ███  ███      ███     
# ███        ███   ███   ███████   ███       ███  ███████  ████████

var
    timers {.threadvar.}: Table[string, MonoTime]  # Thread-local storage for nesting
    
proc profileStart*(msg: string) =
    if not timers.contains(msg):
        timers[msg] = getMonoTime()
    else:
        stderr.writeLine &"[WARNING] Duplicate profileStart for '{msg}'"

proc profileStop*(msg: string) =
    if not timers.contains(msg):
        stderr.writeLine &"[ERROR] profileStop for unknown label '{msg}'"
        return

    let elapsed = getMonoTime() - timers[msg]
    timers.del(msg)

    if elapsed.inMicroseconds < 1000:
        styledEcho fgBlue, msg, fgGreen, &" {elapsed.inMicroseconds} ", styleDim, "µs", resetStyle
    else:
        styledEcho fgBlue, msg, fgYellow, &" {elapsed.inMilliseconds} ", styleDim, "ms", resetStyle
    
macro profileScope*(msg: string): untyped =
    quote do:
        profileStart(`msg`)
        defer:
            profileStop(`msg`)
    
# ████████   ███   ███   ███████  ███   ███          ████████    ███████   ████████ 
# ███   ███  ███   ███  ███       ███   ███    ██    ███   ███  ███   ███  ███   ███
# ████████   ███   ███  ███████   █████████  ██████  ████████   ███   ███  ████████ 
# ███        ███   ███       ███  ███   ███    ██    ███        ███   ███  ███      
# ███         ███████   ███████   ███   ███          ███         ███████   ███      

proc pops*[T](s: var seq[T]): seq[T] {. discardable .} =

    if s.len > 0:
        s.setLen(s.len - 1)
    s

proc push*[T](s: var seq[T], item: T): seq[T] {. discardable .} =

    s.add item
    s
        
proc shift*[T](s: var seq[T]): seq[T] {. discardable .} =
    if s.len > 0:
        s.delete 1
    s
        
proc unshift*[T](s: var seq[T], item: T): seq[T] {. discardable .} =
    s.insert @[item]
    s
    
# ███   ███   ███████  ████████   ███████ 
# ███  ███   ███       ███       ███      
# ███████    ███████   ███████   ███  ████
# ███  ███        ███  ███       ███   ███
# ███   ███  ███████   ████████   ███████ 

# Splits a string into grapheme clusters (user-perceived characters)

proc kseg*(s:string) : seq[string] =
  
    var i = 0
    while i < s.len:
        let clusterSize = graphemeLen(s, i)
        result.add(s.substr(i, i + clusterSize - 1))
        i += clusterSize
    
# ████████   ███████   ███   ███   ███████   ███    
# ███       ███   ███  ███   ███  ███   ███  ███    
# ███████   ███ ██ ██  ███   ███  █████████  ███    
# ███       ███ ████   ███   ███  ███   ███  ███    
# ████████   █████ ██   ███████   ███   ███  ███████

proc deepEqual*[T](a, b: T): bool =

    # log "deepEqual ", a, " ", b

    when T is (seq or array)
        if a.len != b.len
            echo &"{a.len} != {b.len} length differs"
            ⮐  false
        for i in 0..<a.len
            if not deepEqual(a[i], b[i])
                echo &"{a[i]} != {b[i]}"
                ⮐  false
    elif T is (Table or TableRef or OrderedTable)
        if a.len != b.len
            echo &"{a.len} != {b.len} length differs"
            ⮐  false
        for (key, valA) in a.pairs
            if not b.hasKey(key)
                echo &"{key} not in {b}"
                ⮐  false
            if not deepEqual(valA, b[key])
                echo &"{valA} != {b[key]}"
                ⮐  false
    elif T is object
        if a != b
            echo &"{a} != {b}"
            ⮐  false
    elif T is tuple
        if a != b
            echo &"{a} != {b}"
            ⮐  false
    else
        if a != b
            echo &"{a} != {b}"
            ⮐  false
    true
    
# ███████    ███████     ███████ 
# ███   ███  ███   ███  ███      
# ███   ███  ███████    ███  ████
# ███   ███  ███   ███  ███   ███
# ███████    ███████     ███████ 

macro dbg*(args: varargs[untyped]): untyped =
    
    result = newStmtList()
    
    let lineInfo = args[0].lineInfoObj
    
    result.add quote do:
        styledEcho bgBlue, styleBright, `lineInfo`.filename, styleDim, ":", $`lineInfo`.line, resetStyle
    
    for arg in args:
        result.add quote do:
            styledEcho fgYellow, styleBright, "  ", `arg`.astToStr(), resetStyle,
                styleDim, " = ", resetStyle,
                fgGreen, $`arg`, resetStyle,
                fgBlue, " ", $typeof(`arg`), resetStyle

    

