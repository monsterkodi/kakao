###
 0000000  000000000   0000000   000000000  00000000  
000          000     000   000     000     000       
0000000      000     000000000     000     0000000   
     000     000     000   000     000     000       
0000000      000     000   000     000     00000000  
###

use ../kxk ◆ immutable kstr
use ◆ color syntax
use child_process

function state

    @: @cells -> 
        
        @syntax = new syntax
    
        @s = immutable
            lines:       ['']
            selections:  []
            cursor:      [0 0]
            view:        [0 0]
            gutter:      @calcGutter(1)
            
        @setCursor 0 0
    
    #  0000000  00000000  000000000  000      000  000   000  00000000   0000000  
    # 000       000          000     000      000  0000  000  000       000       
    # 0000000   0000000      000     000      000  000 0 000  0000000   0000000   
    #      000  000          000     000      000  000  0000  000            000  
    # 0000000   00000000     000     0000000  000  000   000  00000000  0000000   
    
    setLines: lines =>
        
        @syntax.setLines lines
        @s = @s.set 'gutter' @calcGutter(lines.length)
        @s = @s.set 'lines' lines        
        
    calcGutter: numLines =>
        
        2 + Math.ceil(Math.log10(numLines))
        
    #  0000000  000   000  000000000  
    # 000       000   000     000     
    # 000       000   000     000     
    # 000       000   000     000     
    #  0000000   0000000      000     
    
    cut: =>
        
        if empty @s.selections
            @selectLine()
            @cut() if valid @s.selections
            ⮐ 
        @copy()
        @deleteSelection()
        
    #  0000000   0000000   00000000   000   000  
    # 000       000   000  000   000   000 000   
    # 000       000   000  00000000     00000    
    # 000       000   000  000           000     
    #  0000000   0000000   000           000     
    
    copy: =>
        
        ⮐ if empty @s.selections
            
        proc = child_process.spawn 'pbcopy'
        proc.stdin.write @textForSelection()
        proc.stdin.end()
            
    # 00000000    0000000    0000000  000000000  00000000  
    # 000   000  000   000  000          000     000       
    # 00000000   000000000  0000000      000     0000000   
    # 000        000   000       000     000     000       
    # 000        000   000  0000000      000     00000000  
    
    paste: =>
        
        text = child_process.execSync('pbpaste').toString("utf8")
        @insert text
        
    # 000  000   000   0000000  00000000  00000000   000000000  
    # 000  0000  000  000       000       000   000     000     
    # 000  000 0 000  0000000   0000000   0000000       000     
    # 000  000  0000       000  000       000   000     000     
    # 000  000   000  0000000   00000000  000   000     000     
    
    insert: text =>
        
        split = text.split /\r?\n/
        if split.length > 1
            for s,i in split
                @insert s
                if i < split.length-1 or text != '\n'
                    @insertNewline()            
            ⮐ 
        
        x = @s.cursor[0]
        y = @s.cursor[1]
    
        lines = @s.lines.asMutable()
        line  = lines[y]
        
        line = kstr.splice line x 0 text
        
        lines.splice y 1 line
                
        @s = @s.set 'lines' lines
        
        x += text.length
        
        @setCursor x y
        
    insertNewline: =>
        
        x = @s.cursor[0]
        y = @s.cursor[1]
    
        lines = @s.lines.asMutable()
        line  = lines[y]
        
        before = line[0...x]
        after  = line[x..]
        
        lines.splice y 1 before
        lines.splice y+1 0 after
                
        @s = @s.set 'lines' lines
        
        y = y + 1
        x = 0
        
        @setCursor x y
        
    # 0000000    00000000  000      00000000  000000000  00000000  
    # 000   000  000       000      000          000     000       
    # 000   000  0000000   000      0000000      000     0000000   
    # 000   000  000       000      000          000     000       
    # 0000000    00000000  0000000  00000000     000     00000000  
    
    delete: type =>

        x = @s.cursor[0]
        y = @s.cursor[1]
        
        lines = @s.lines.asMutable()
        line  = lines[y]
        
        switch type
            'eol'       ➜ line = line[0...x]
            'back'      ➜ line = kstr.splice line x-1 1
            
        lines.splice y 1 line
            
        @s = @s.set 'lines' lines

        switch type
            'back' 
                x -= 1
                @setCursor x y
        @
                
    deleteSelection: =>
        
        cursor = @s.cursor.asMutable()
        lines = @s.lines.asMutable()
        for si in @s.selections.length-1..0
            sel = @s.selections[si]
            
            if @isPosInsideRange cursor sel
                cursor = [sel[0] sel[1]]
            else if @isPosAfterRange cursor sel
                if cursor[1] == sel[3]
                    if sel[1] == sel[3]
                        cursor[0] = sel[0]
                    else
                        cursor[0] = 0
                else
                    cursor[1] -= @numFullLinesInRange lines sel
            
            if sel[1] == sel[3]
                if sel[0] == 0 and sel[2] == lines[sel[1]].length
                    lines.splice sel[1] 1
                else
                    lines.splice sel[1] 1 kstr.splice(lines[sel[1]] sel[0] sel[2]-sel[0])
            else
                if sel[2] == lines[sel[3]].length
                    lines.splice sel[3] 1
                else
                    lines.splice sel[3] 1 lines[sel[3]][sel[2]..]
                    
                if sel[3]-sel[1] > 1
                    lines.splice sel[1]+1 sel[3]-sel[1]-1
                    
                if sel[0] == 0
                    lines.splice sel[1] 1
                else
                    lines.splice sel[1] 1 lines[sel[1]][0...sel[0]]
        
        @s = @s.set 'selections' []
        @setLines lines
        @setCursor cursor[0] cursor[1]
        @
        
    isPosInsideRange: pos rng ->
                
        ⮐ false if @isPosBeforeRange pos rng 
        ⮐ false if @isPosAfterRange pos rng 
        true

    isPosBeforeRange:  pos rng ->
        
        # ⮐ true if pos[1] < rng[1]
        # ⮐ true if pos[1] == rng[1] and pos[0] < rng[0]
        # false
        
        pos[1] < rng[1] or (pos[1] == rng[1] and pos[0] < rng[0])
        
    isPosAfterRange:  pos rng ->
        
        # ⮐ true if pos[1] > rng[3]
        # ⮐ true if pos[1] == rng[3] and pos[0] > rng[2]
        # false
        
        pos[1] > rng[3] or (pos[1] == rng[3] and pos[0] >= rng[2])
        
    numFullLinesInRange: lines rng -> 
        
        d = rng[3] - rng[1]
        
        if d == 0 
            ⮐ rng[0] == 0 and rng[2] == lines[rng[1]].length ? 1 : 0
        
        n = 0
        n += 1   if rng[0] == 0 
        n += d-2 if d > 1
        n += 1   if rng[2] == lines[rng[3]].length
        n
            
    #  0000000  000   000  00000000    0000000   0000000   00000000   
    # 000       000   000  000   000  000       000   000  000   000  
    # 000       000   000  0000000    0000000   000   000  0000000    
    # 000       000   000  000   000       000  000   000  000   000  
    #  0000000   0000000   000   000  0000000    0000000   000   000  
    
    setCursor: x y =>
        
        y = clamp 0 @s.lines.length-1 y
        x = max 0 x
                        
        @s = @s.set 'cursor' [x y]
        
        view = @s.view.asMutable()
        
        if y >= view[1] + @cells.rows - 1
            view[1] = y - @cells.rows + 2
        else if y < view[1]
            view[1] = y

        view[0] = max 0 x - @cells.cols + @s.gutter + 1
            
        @s = @s.set 'view' view
            
        @cells.t.setCursor x+@s.gutter y-@s.view[1]
        
    moveCursor: dir steps=1 merge=true =>
        
        c = @s.cursor.asMutable() 
        
        switch dir
            'left'  ➜ c[0] -= 1
            'right' ➜ c[0] += 1
            'up'    ➜ c[1] -= steps
            'down'  ➜ c[1] += steps 
            'eol'   ➜ c[0] = @s.lines[c[1]].length
            'bol'   ➜ c[0] = 0
        
        if merge
            @s = @s.set 'selections' @mergeSelections(@s.selections.asMutable())
        
        @setCursor c[0] c[1]
        
    moveCursorAndSelect: dir =>
        
        selections = @s.selections.asMutable()
        selection = [@s.cursor[0] @s.cursor[1] @s.cursor[0] @s.cursor[1]]
        selections.push selection 
        
        @moveCursor dir 1 false
        
        switch dir
            'left'  ➜ selection[0] = selection[0]-1
            'right' ➜ selection[2] = selection[2]+1
            'up'    ➜ selection[1] = max 0 selection[1]-1
            'down'  ➜ selection[3] = min @s.lines.length-1 selection[3]+1
            'eol'   ➜ selection[2] = Infinity
            'bol'   ➜ selection[0] = 0
            
        selection[0] = clamp 0 @s.lines[selection[1]].length selection[0]
        selection[2] = clamp 0 @s.lines[selection[3]].length selection[2]
        
        # @s = @s.set 'selections' selections
        @s = @s.set 'selections' @mergeSelections(selections)
                    
        true
        
    # 00     00  00000000  00000000    0000000   00000000  
    # 000   000  000       000   000  000        000       
    # 000000000  0000000   0000000    000  0000  0000000   
    # 000 0 000  000       000   000  000   000  000       
    # 000   000  00000000  000   000   0000000   00000000  
    
    mergeSelections: sels ->
        
        ⮐ [] if empty sels
        
        sels = sels.map (a) -> if a[1] > a[3] ➜ [a[2] a[3] a[0] a[1]] else a
        sels = sels.map (a) -> if a[1] == a[3] and a[0] > a[2] ➜ [a[2] a[1] a[0] a[3]] else a
        sels.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        sels = sels.filter (a) -> a[0] != a[2] or a[1] != a[3]
        
        mrgd = []
        for s,i in sels
            lastmrgd = valid mrgd ? mrgd[mrgd.length-1] : []
            if empty mrgd or s[1] > lastmrgd[3] or s[1] == lastmrgd[3] and s[0] > lastmrgd[2]
                mrgd.push s
            else if s[3] > lastmrgd[3] or s[3] == lastmrgd[3] and s[2] > lastmrgd[2]
                lastmrgd[2] = s[2] 
                lastmrgd[3] = s[3]

        # lf 'mrgd' noon(mrgd)
        mrgd
        
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    select: from to =>
        
        selections = []
        
        @setCursor to[0] to[1]
        
        if from[1] > to[1]
            [from to] = [to from]
        else if from[1] == to[1] and from[0] > to[0]
            [from to] = [to from]

        to[0] = clamp 0 @s.lines[to[1]].length to[0]
        from[0] = clamp 0 @s.lines[from[1]].length from[0]
                
        selections.push [from[0] from[1] to[0] to[1]]
        
        @s = @s.set 'selections' selections
        
        true
        
    selectChunk: x y =>
        
        line = @s.lines[y]
        
        [rs re] = kstr.rangeOfClosestChunk line x
        if rs >= 0 and re >= 0
            @select [rs y] [re+1 y]

    selectWord: x y =>
        
        line = @s.lines[y]
        
        [rs re] = kstr.rangeOfClosestWord line x
        if rs >= 0 and re >= 0
            @select [rs y] [re+1 y]
                        
    selectLine: y=@s.cursor[1] =>
        
        if 0 <= y < @s.lines.length
            @select [0 y] [@s.lines[y].length y]

    isSelectedLine: y =>
        
        for selection in @s.selections
            if selection[3] == y and selection[2] == 0
                continue
            if selection[1] <= y <= selection[3]
                ⮐ true
        false
            
    # 0000000    00000000   0000000  00000000  000      00000000   0000000  000000000  
    # 000   000  000       000       000       000      000       000          000     
    # 000   000  0000000   0000000   0000000   000      0000000   000          000     
    # 000   000  000            000  000       000      000       000          000     
    # 0000000    00000000  0000000   00000000  0000000  00000000   0000000     000     
    
    deselect: =>
        
        if valid @s.selections
            @s = @s.set 'selections' []
            ⮐ true
        false
            
    # 000000000  00000000  000   000  000000000     00000000   0000000   00000000 
    #    000     000        000 000      000        000       000   000  000   000
    #    000     0000000     00000       000        000000    000   000  0000000  
    #    000     000        000 000      000        000       000   000  000   000
    #    000     00000000  000   000     000        000        0000000   000   000
    
    textForRange: r =>
        
        lines = @s.lines.asMutable()
        
        l = []
        
        for y in r[1]..r[3]
            if 0 <= y < lines.length
                if y == r[1]
                    if y == r[3]
                        l.push lines[y][r[0]...r[2]]
                    else
                        l.push lines[y][r[0]..]
                else if y == r[3]
                    l.push lines[y][0...r[2]]
                else
                    l.push lines[y]
        
        l.join '\n'
    
    textForSelection: =>
        
        text = ''
        for s in @s.selections
            text += @textForRange s
            text += '\n'
        text[0...-1]
        
    fullySelectedLineIndices: =>
        
        l = []
        for s in @s.selections
            if s[1] == s[3] and s[0] == 0 and s[2] == @s.lines[s[1]].length
                l.push s[1]
            else if s[1] < s[3]
                if s[0] == 0
                    l.push s[1]
                for i in s[1]+1...s[3]
                    l.push i
                if s[2] == @s.lines[s[3]].length
                    l.push s[3]
        l
                            
export state
