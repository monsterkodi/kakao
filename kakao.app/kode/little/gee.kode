###
 0000000   00000000  00000000  
000        000       000       
000  0000  0000000   0000000   
000   000  000       000       
 0000000   00000000  00000000  
###

use ../kxk ▪ randInt randRange elem post
use ./geell

function gee extends geell

    @: @main ->
        
    addNumber: px py sz number color=[1 1 1 1] layer=0 =>
        
        n = Math.ceil Math.log10 number
        for ni in 0..n
            @addQuad px+ni*sz, py, 1, 1, color, @numberUV[1], 0 layer, sz
        
    addPipe: x1 y1 x2 y2 sz color layer=0 =>
        
        @addCircle x1, y1, sz, color, layer
        @addCircle x2, y2, sz, color, layer
        if y1 == y2
            @addRect x1, y1-sz/2, x2, y2+sz/2, color, layer
            
    addTube: px py ti tt color layer=0 scale=1 =>
        
        @addQuad px, py, 1 1 color, @tubeUV[ti][tt], 0 layer, scale
            
    addTubeRect: x1 y1 x2 y2 ti color layer=0 =>
        
        [x1, x2] = [min(x1, x2), max(x1, x2)]
        [y1, y2] = [min(y1, y2), max(y1, y2)]
        
        @addTube x2, y2, ti, 1 color, layer
        @addTube x2, y1, ti, 3 color, layer
        @addTube x1, y1, ti, 4 color, layer
        @addTube x1, y2, ti, 5 color, layer
        
        @addQuad (x1+x2)/2 y1, x2-x1-1 1 color, @tubeUV[ti][0], 0 layer
        @addQuad (x1+x2)/2 y2, x2-x1-1 1 color, @tubeUV[ti][0], 0 layer

        @addQuad x1, (y1+y2)/2 1 y2-y1-1 color, @tubeUV[ti][2], 0 layer
        @addQuad x2, (y1+y2)/2 1 y2-y1-1 color, @tubeUV[ti][2], 0 layer
        
    addRoundedFrame: x1 y1 x2 y2 color layer=0 radius=1 ti=4 =>
        
        scale = 1/radius
        
        [x1, x2] = [min(x1, x2), max(x1, x2)]
        [y1, y2] = [min(y1, y2), max(y1, y2)]
        
        @addTube x2, y2, ti, 1 color, layer, radius
        @addTube x2, y1, ti, 3 color, layer, radius
        @addTube x1, y1, ti, 4 color, layer, radius
        @addTube x1, y2, ti, 5 color, layer, radius
        
        @addQuad (x1+x2)/2 y1, (x2-x1-radius)*scale, 1 color, @tubeUV[ti][0], 0 layer, radius
        @addQuad (x1+x2)/2 y2, (x2-x1-radius)*scale, 1 color, @tubeUV[ti][0], 0 layer, radius

        @addQuad x1, (y1+y2)/2 1 (y2-y1-radius)*scale, color, @tubeUV[ti][2], 0 layer, radius
        @addQuad x2, (y1+y2)/2 1 (y2-y1-radius)*scale, color, @tubeUV[ti][2], 0 layer, radius
        
    addRect: x1 y1 x2 y2 color layer=0 =>
        
        [x1, x2] = [min(x1, x2), max(x1, x2)]
        [y1, y2] = [min(y1, y2), max(y1, y2)]
        cx = (x1+x2)/2
        cy = (y1+y2)/2
        sx = x2-x1
        sy = y2-y1
        
        @addQuad cx, cy, sx, sy, color, @quadUV, 0 layer

    addCircle: px py sz color layer=0 =>     
        
        @addQuad px, py, sz, sz, color, @circleUV, 0 layer

    addQuad: px py sx sy color uv rot=0 layer=0 scale=1 => 
        
        ⮐ if @numQuads[layer] >= @quadsPerLayer
        
        p = (@layerStart[layer]+@numQuads[layer])*@quadDataLength
        
        @data[p++]  = px # position
        @data[p++]  = py
        @data[p++]  = scale*sx # scale 
        @data[p++]  = scale*sy 
                
        @data[p++]  = color[0]  # color
        @data[p++]  = color[1]
        @data[p++]  = color[2]
        @data[p++]  = color[3]

        @data[p++]  = uv[0] # uv
        @data[p++]  = uv[1]
        @data[p++]  = uv[2]
        @data[p++]  = uv[3]
        
        @data[p++]  = rot # rotation
                        
        @numQuads[layer]++
        
        # log @numQuads, px, py, sx, sy, r, g, b, a, u0, v0, u1, v1, rot
                                                                        
export gee
