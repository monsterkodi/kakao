import {createRequire} from "node:module";
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = createRequire(import.meta.url);

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/token.js
var require_token = __commonJS((exports, module) => {
  /*!
   * Stylus - Token
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var inspect = __require("util").inspect;
  var Token = exports = module.exports = function Token(type, val) {
    this.type = type;
    this.val = val;
  };
  Token.prototype.inspect = function() {
    var val = " " + inspect(this.val);
    return "[Token:" + this.lineno + ":" + this.column + " " + "\x1B[32m" + this.type + "\x1B[0m" + "\x1B[33m" + (this.val ? val : "") + "\x1B[0m" + "]";
  };
  Token.prototype.toString = function() {
    return (this.val === undefined ? this.type : this.val).toString();
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/visitor/index.js
var require_visitor = __commonJS((exports, module) => {
  /*!
   * Stylus - Visitor
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Visitor = module.exports = function Visitor(root) {
    this.root = root;
  };
  Visitor.prototype.visit = function(node, fn) {
    var method = "visit" + node.constructor.name;
    if (this[method])
      return this[method](node);
    return node;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/units.js
var require_units = __commonJS((exports, module) => {
  /*!
   * Stylus - units
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  module.exports = [
    "em",
    "ex",
    "ch",
    "rem",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "cm",
    "mm",
    "in",
    "pt",
    "pc",
    "px",
    "deg",
    "grad",
    "rad",
    "turn",
    "s",
    "ms",
    "Hz",
    "kHz",
    "dpi",
    "dpcm",
    "dppx",
    "x",
    "%",
    "fr"
  ];
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/stack/index.js
var require_stack = __commonJS((exports, module) => {
  /*!
   * Stylus - Stack
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Stack = module.exports = function Stack() {
    Array.apply(this, arguments);
  };
  Stack.prototype.__proto__ = Array.prototype;
  Stack.prototype.push = function(frame) {
    frame.stack = this;
    frame.parent = this.currentFrame;
    return [].push.apply(this, arguments);
  };
  Stack.prototype.__defineGetter__("currentFrame", function() {
    return this[this.length - 1];
  });
  Stack.prototype.getBlockFrame = function(block) {
    for (var i = 0;i < this.length; ++i) {
      if (block == this[i].block) {
        return this[i];
      }
    }
  };
  Stack.prototype.lookup = function(name) {
    var block = this.currentFrame.block, val, ret;
    do {
      var frame = this.getBlockFrame(block);
      if (frame && (val = frame.lookup(name))) {
        return val;
      }
    } while (block = block.parent);
  };
  Stack.prototype.inspect = function() {
    return this.reverse().map(function(frame) {
      return frame.inspect();
    }).join("\n");
  };
  Stack.prototype.toString = function() {
    var block, node, buf = [], location, len = this.length;
    while (len--) {
      block = this[len].block;
      if (node = block.node) {
        location = "(" + node.filename + ":" + (node.lineno + 1) + ":" + node.column + ")";
        switch (node.nodeName) {
          case "function":
            buf.push("    at " + node.name + "() " + location);
            break;
          case "group":
            buf.push('    at "' + node.nodes[0].val + '" ' + location);
            break;
        }
      }
    }
    return buf.join("\n");
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/stack/scope.js
var require_scope = __commonJS((exports, module) => {
  var hasOwnProperty = function(obj, propName) {
    return Object.prototype.hasOwnProperty.call(obj, propName);
  };
  /*!
   * Stylus - stack - Scope
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Scope = module.exports = function Scope() {
    this.locals = {};
  };
  Scope.prototype.add = function(ident) {
    this.locals[ident.name] = ident.val;
  };
  Scope.prototype.lookup = function(name) {
    return hasOwnProperty(this.locals, name) ? this.locals[name] : undefined;
  };
  Scope.prototype.inspect = function() {
    var keys = Object.keys(this.locals).map(function(key) {
      return "@" + key;
    });
    return "[Scope" + (keys.length ? " " + keys.join(", ") : "") + "]";
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/stack/frame.js
var require_frame = __commonJS((exports, module) => {
  /*!
   * Stylus - stack - Frame
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Scope = require_scope();
  var Frame = module.exports = function Frame(block) {
    this._scope = block.scope === false ? null : new Scope;
    this.block = block;
  };
  Frame.prototype.__defineGetter__("scope", function() {
    return this._scope || this.parent.scope;
  });
  Frame.prototype.lookup = function(name) {
    return this.scope.lookup(name);
  };
  Frame.prototype.inspect = function() {
    return "[Frame " + (this.block.scope === false ? "scope-less" : this.scope.inspect()) + "]";
  };
});

// node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
var require_old = __commonJS((exports) => {
  var rethrow = function() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error;
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  };
  var maybeCallback = function(cb) {
    return typeof cb === "function" ? cb : rethrow();
  };
  var pathModule = __require("path");
  var isWindows = process.platform === "win32";
  var fs = __require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  var normalize = pathModule.normalize;
  if (isWindows) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs.statSync(base);
          linkTarget = fs.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs.readlink(base, function(err3, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/glob@7.2.3/node_modules/fs.realpath/index.js
var require_fs = __commonJS((exports, module) => {
  var newError = function(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  };
  var realpath = function(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  };
  var realpathSync = function(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  };
  var monkeypatch = function() {
    fs.realpath = realpath;
    fs.realpathSync = realpathSync;
  };
  var unmonkeypatch = function() {
    fs.realpath = origRealpath;
    fs.realpathSync = origRealpathSync;
  };
  module.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs = __require("fs");
  var origRealpath = fs.realpath;
  var origRealpathSync = fs.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = require_old();
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/brace-expansion@1.1.11/node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports, module) => {
  module.exports = function(xs, fn) {
    var res = [];
    for (var i = 0;i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/brace-expansion@1.1.11/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  var balanced = function(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  };
  var maybeMatch = function(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  };
  var range = function(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  };
  module.exports = balanced;
  balanced.range = range;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/minimatch@3.1.2/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var numeric = function(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  };
  var escapeBraces = function(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  };
  var unescapeBraces = function(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  };
  var parseCommaParts = function(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  };
  var expandTop = function(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  };
  var embrace = function(str) {
    return "{" + str + "}";
  };
  var isPadded = function(el) {
    return /^-?0\d/.test(el);
  };
  var lte = function(i, y) {
    return i <= y;
  };
  var gte = function(i, y) {
    return i >= y;
  };
  var expand = function(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x;test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0;j < N.length; j++) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  };
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/glob@7.2.3/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  var charSet = function(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  };
  var filter = function(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  };
  var ext = function(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  };
  var minimatch = function(p, pattern, options) {
    assertValidPattern(pattern);
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  var Minimatch = function(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    assertValidPattern(pattern);
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (!options.allowWindowsEscape && path.sep !== "/") {
      pattern = pattern.split(path.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.make();
  };
  var make = function() {
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = function debug() {
        console.error.apply(console, arguments);
      };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  };
  var parseNegate = function() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length;i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  };
  var braceExpand = function(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  };
  var parse = function(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options;
    if (pattern === "**") {
      if (!options.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c;i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s\t%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1;n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0;i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  };
  var makeRe = function() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  };
  var globUnescape = function(s) {
    return s.replace(/\\(.)/g, "$1");
  };
  var regExpEscape = function(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  };
  module.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path = function() {
    try {
      return __require("path");
    } catch (e) {
    }
  }() || {
    sep: "/"
  };
  minimatch.sep = path.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m = function minimatch(p, pattern, options) {
      return orig(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    m.Minimatch.defaults = function defaults(options) {
      return orig.defaults(ext(def, options)).Minimatch;
    };
    m.filter = function filter(pattern, options) {
      return orig.filter(pattern, ext(def, options));
    };
    m.defaults = function defaults(options) {
      return orig.defaults(ext(def, options));
    };
    m.makeRe = function makeRe(pattern, options) {
      return orig.makeRe(pattern, ext(def, options));
    };
    m.braceExpand = function braceExpand(pattern, options) {
      return orig.braceExpand(pattern, ext(def, options));
    };
    m.match = function(list, pattern, options) {
      return orig.match(list, pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  Minimatch.prototype.parseNegate = parseNegate;
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === "undefined")
      partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path.sep !== "/") {
      f = f.split(path.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1;i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0;i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", { this: this, file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/glob@7.2.3/node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/glob@7.2.3/node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS((exports, module) => {
  var posix = function(path) {
    return path.charAt(0) === "/";
  };
  var win32 = function(path) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  };
  module.exports = process.platform === "win32" ? win32 : posix;
  module.exports.posix = posix;
  module.exports.win32 = win32;
});

// node_modules/.pnpm/glob@7.2.3/node_modules/glob/common.js
var require_common = __commonJS((exports) => {
  var ownProp = function(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  };
  var alphasort = function(a, b) {
    return a.localeCompare(b, "en");
  };
  var setupIgnores = function(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  };
  var ignoreMap = function(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, { dot: true });
    }
    return {
      matcher: new Minimatch(pattern, { dot: true }),
      gmatcher
    };
  };
  var setopts = function(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.fs = options.fs || fs;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || Object.create(null);
    self2.statCache = options.statCache || Object.create(null);
    self2.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path.resolve(self2.cwd, "/");
    self2.root = path.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    options.allowWindowsEscape = false;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  };
  var finish = function(self2) {
    var nou = self2.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l = self2.matches.length;i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m = Object.keys(matches);
        if (nou)
          all.push.apply(all, m);
        else
          m.forEach(function(m2) {
            all[m2] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self2.nosort)
      all = all.sort(alphasort);
    if (self2.mark) {
      for (var i = 0;i < all.length; i++) {
        all[i] = self2._mark(all[i]);
      }
      if (self2.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all = all.filter(function(m2) {
        return !isIgnored(self2, m2);
      });
    self2.found = all;
  };
  var mark = function(self2, p) {
    var abs = makeAbs(self2, p);
    var c = self2.cache[abs];
    var m = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m += "/";
      else if (!isDir && slash)
        m = m.slice(0, -1);
      if (m !== p) {
        var mabs = makeAbs(self2, m);
        self2.statCache[mabs] = self2.statCache[abs];
        self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m;
  };
  var makeAbs = function(self2, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs = f;
    } else if (self2.changedCwd) {
      abs = path.resolve(self2.cwd, f);
    } else {
      abs = path.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  };
  var isIgnored = function(self2, path2) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
    });
  };
  var childrenIgnored = function(self2, path2) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path2));
    });
  };
  exports.setopts = setopts;
  exports.ownProp = ownProp;
  exports.makeAbs = makeAbs;
  exports.finish = finish;
  exports.mark = mark;
  exports.isIgnored = isIgnored;
  exports.childrenIgnored = childrenIgnored;
  var fs = __require("fs");
  var path = __require("path");
  var minimatch = require_minimatch();
  var isAbsolute = require_path_is_absolute();
  var Minimatch = minimatch.Minimatch;
});

// node_modules/.pnpm/glob@7.2.3/node_modules/glob/sync.js
var require_sync = __commonJS((exports, module) => {
  var globSync = function(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  };
  var GlobSync = function(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0;i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  };
  module.exports = globSync;
  globSync.GlobSync = GlobSync;
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var Glob = require_glob().Glob;
  var util = __require("util");
  var path = __require("path");
  var assert = __require("assert");
  var isAbsolute = require_path_is_absolute();
  var common = require_common();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  GlobSync.prototype._finish = function() {
    assert.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set = self2.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert.ok(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0;i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0;i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0;i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0;i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0;i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path.join(this.root, prefix);
      } else {
        prefix = path.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = this.fs.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/once@1.4.0/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports, module) => {
  var wrappy = function(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  };
  module.exports = wrappy;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/glob@7.2.3/node_modules/once/once.js
var require_once = __commonJS((exports, module) => {
  var once = function(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  };
  var onceStrict = function(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  };
  var wrappy = require_wrappy();
  module.exports = wrappy(once);
  module.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/glob@7.2.3/node_modules/inflight/inflight.js
var require_inflight = __commonJS((exports, module) => {
  var inflight = function(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  };
  var makeres = function(key) {
    return once(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0;i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  };
  var slice = function(args) {
    var length = args.length;
    var array = [];
    for (var i = 0;i < length; i++)
      array[i] = args[i];
    return array;
  };
  var wrappy = require_wrappy();
  var reqs = Object.create(null);
  var once = require_once();
  module.exports = wrappy(inflight);
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/glob/glob.js
var require_glob = __commonJS((exports, module) => {
  var glob = function(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  };
  var extend = function(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  };
  var Glob = function(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync = true;
    for (var i = 0;i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  };
  var readdirCb = function(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  };
  module.exports = glob;
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var inherits = require_inherits();
  var EE = __require("events").EventEmitter;
  var path = __require("path");
  var assert = __require("assert");
  var isAbsolute = require_path_is_absolute();
  var globSync = require_sync();
  var common = require_common();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = require_inflight();
  var util = __require("util");
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = require_once();
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0;j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits(Glob, EE);
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0;i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0;i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0;i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0;i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0;i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0;i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    self2.fs.readdir(abs, readdirCb(this, abs, cb));
  };
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0;i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit("error", error);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0;i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path.join(this.root, prefix);
      } else {
        prefix = path.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== undefined) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return self2.fs.stat(abs, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/selector-parser.js
var require_selector_parser = __commonJS((exports, module) => {
  /*!
   * Stylus - Selector Parser
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var COMBINATORS = [">", "+", "~"];
  var SelectorParser = module.exports = function SelectorParser(str, stack, parts) {
    this.str = str;
    this.stack = stack || [];
    this.parts = parts || [];
    this.pos = 0;
    this.level = 2;
    this.nested = true;
    this.ignore = false;
  };
  SelectorParser.prototype.skip = function(len) {
    this.str = this.str.substr(len);
    this.pos += len;
  };
  SelectorParser.prototype.skipSpaces = function() {
    while (this.str[0] == " ")
      this.skip(1);
  };
  SelectorParser.prototype.advance = function() {
    return this.root() || this.relative() || this.initial() || this.escaped() || this.parent() || this.partial() || this.char();
  };
  SelectorParser.prototype.root = function() {
    if (!this.pos && this.str[0] == "/" && this.str.slice(1, 5) != "deep") {
      this.nested = false;
      this.skip(1);
    }
  };
  SelectorParser.prototype.relative = function(multi) {
    if ((!this.pos || multi) && this.str.slice(0, 3) == "../") {
      this.nested = false;
      this.skip(3);
      while (this.relative(true))
        this.level++;
      if (!this.raw) {
        var ret = this.stack[this.stack.length - this.level];
        if (ret) {
          return ret;
        } else {
          this.ignore = true;
        }
      }
    }
  };
  SelectorParser.prototype.initial = function() {
    if (!this.pos && this.str[0] == "~" && this.str[1] == "/") {
      this.nested = false;
      this.skip(2);
      return this.stack[0];
    }
  };
  SelectorParser.prototype.escaped = function() {
    if (this.str[0] == "\\") {
      var char = this.str[1];
      if (char == "&" || char == "^") {
        this.skip(2);
        return char;
      }
    }
  };
  SelectorParser.prototype.parent = function() {
    if (this.str[0] == "&") {
      this.nested = false;
      if (!this.pos && (!this.stack.length || this.raw)) {
        var i = 0;
        while (this.str[++i] == " ")
          ;
        if (~COMBINATORS.indexOf(this.str[i])) {
          this.skip(i + 1);
          return;
        }
      }
      this.skip(1);
      if (!this.raw)
        return this.stack[this.stack.length - 1];
    }
  };
  SelectorParser.prototype.partial = function() {
    if (this.str[0] == "^" && this.str[1] == "[") {
      this.skip(2);
      this.skipSpaces();
      var ret = this.range();
      this.skipSpaces();
      if (this.str[0] != "]")
        return "^[";
      this.nested = false;
      this.skip(1);
      if (ret) {
        return ret;
      } else {
        this.ignore = true;
      }
    }
  };
  SelectorParser.prototype.number = function() {
    var i = 0, ret = "";
    if (this.str[i] == "-")
      ret += this.str[i++];
    while (this.str.charCodeAt(i) >= 48 && this.str.charCodeAt(i) <= 57)
      ret += this.str[i++];
    if (ret) {
      this.skip(i);
      return Number(ret);
    }
  };
  SelectorParser.prototype.range = function() {
    var start = this.number(), ret;
    if (this.str.slice(0, 2) == "..") {
      this.skip(2);
      var end = this.number(), len = this.parts.length;
      if (start < 0)
        start = len + start - 1;
      if (end < 0)
        end = len + end - 1;
      if (start > end) {
        var tmp = start;
        start = end;
        end = tmp;
      }
      if (end < len - 1) {
        ret = this.parts.slice(start, end + 1).map(function(part) {
          var selector = new SelectorParser(part, this.stack, this.parts);
          selector.raw = true;
          return selector.parse();
        }, this).map(function(selector) {
          return (selector.nested ? " " : "") + selector.val;
        }).join("").trim();
      }
    } else {
      ret = this.stack[start < 0 ? this.stack.length + start - 1 : start];
    }
    if (ret) {
      return ret;
    } else {
      this.ignore = true;
    }
  };
  SelectorParser.prototype.char = function() {
    var char = this.str[0];
    this.skip(1);
    return char;
  };
  SelectorParser.prototype.parse = function() {
    var val = "";
    while (this.str.length) {
      val += this.advance() || "";
      if (this.ignore) {
        val = "";
        break;
      }
    }
    return { val: val.trimRight(), nested: this.nested };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/utils.js
var require_utils = __commonJS((exports) => {
  var __dirname = "/Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib";
  /*!
   * Stylus - utils
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var nodes = require_nodes();
  var basename = __require("path").basename;
  var relative = __require("path").relative;
  var join = __require("path").join;
  var isAbsolute = __require("path").isAbsolute;
  var glob = require_glob();
  var fs = __require("fs");
  exports.absolute = isAbsolute || function(path) {
    return path.substr(0, 2) == "\\\\" || path.charAt(0) === "/" || /^[a-z]:[\\\/]/i.test(path);
  };
  exports.lookup = function(path, paths, ignore) {
    var lookup, i = paths.length;
    if (exports.absolute(path)) {
      try {
        fs.statSync(path);
        return path;
      } catch (err) {
      }
    }
    while (i--) {
      try {
        lookup = join(paths[i], path);
        if (ignore == lookup)
          continue;
        fs.statSync(lookup);
        return lookup;
      } catch (err) {
      }
    }
  };
  exports.find = function(path, paths, ignore) {
    var lookup, found, i = paths.length;
    if (exports.absolute(path)) {
      if ((found = glob.sync(path)).length) {
        return found;
      }
    }
    while (i--) {
      lookup = join(paths[i], path);
      if (ignore == lookup)
        continue;
      if ((found = glob.sync(lookup)).length) {
        return found;
      }
    }
  };
  exports.lookupIndex = function(name, paths, filename) {
    var found = exports.find(join(name, "index.styl"), paths, filename);
    if (!found) {
      found = exports.find(join(name, basename(name).replace(/\.styl/i, "") + ".styl"), paths, filename);
    }
    if (!found && !~name.indexOf("node_modules")) {
      found = lookupPackage(join("node_modules", name));
    }
    return found;
    function lookupPackage(dir) {
      var pkg = exports.lookup(join(dir, "package.json"), paths, filename);
      if (!pkg) {
        return /\.styl$/i.test(dir) ? exports.lookupIndex(dir, paths, filename) : lookupPackage(dir + ".styl");
      }
      var main = __require(relative(__dirname, pkg)).main;
      if (main) {
        found = exports.find(join(dir, main), paths, filename);
      } else {
        found = exports.lookupIndex(dir, paths, filename);
      }
      return found;
    }
  };
  exports.formatException = function(err, options) {
    var { lineno, column, filename, input: str } = options, context = options.context || 8, context = context / 2, lines = ("\n" + str).split("\n"), start = Math.max(lineno - context, 1), end = Math.min(lines.length, lineno + context), pad = end.toString().length;
    var context = lines.slice(start, end).map(function(line, i) {
      var curr = i + start;
      return "   " + Array(pad - curr.toString().length + 1).join(" ") + curr + "| " + line + (curr == lineno ? "\n" + Array(curr.toString().length + 5 + column).join("-") + "^" : "");
    }).join("\n");
    err.message = filename + ":" + lineno + ":" + column + "\n" + context + "\n\n" + err.message + "\n" + (err.stylusStack ? err.stylusStack + "\n" : "");
    if (err.fromStylus)
      err.stack = "Error: " + err.message;
    return err;
  };
  exports.assertType = function(node, type, param) {
    exports.assertPresent(node, param);
    if (node.nodeName == type)
      return;
    var actual = node.nodeName, msg = "expected " + (param ? '"' + param + '" to be a ' : "") + type + ", but got " + actual + ":" + node;
    throw new Error("TypeError: " + msg);
  };
  exports.assertString = function(node, param) {
    exports.assertPresent(node, param);
    switch (node.nodeName) {
      case "string":
      case "ident":
      case "literal":
        return;
      default:
        var actual = node.nodeName, msg = "expected string, ident or literal, but got " + actual + ":" + node;
        throw new Error("TypeError: " + msg);
    }
  };
  exports.assertColor = function(node, param) {
    exports.assertPresent(node, param);
    switch (node.nodeName) {
      case "rgba":
      case "hsla":
        return;
      default:
        var actual = node.nodeName, msg = "expected rgba or hsla, but got " + actual + ":" + node;
        throw new Error("TypeError: " + msg);
    }
  };
  exports.assertPresent = function(node, name) {
    if (node)
      return;
    if (name)
      throw new Error('"' + name + '" argument required');
    throw new Error("argument missing");
  };
  exports.unwrap = function(expr) {
    if (expr.preserve)
      return expr;
    if (expr.nodeName != "arguments" && expr.nodeName != "expression")
      return expr;
    if (expr.nodes.length != 1)
      return expr;
    if (expr.nodes[0].nodeName != "arguments" && expr.nodes[0].nodeName != "expression")
      return expr;
    return exports.unwrap(expr.nodes[0]);
  };
  exports.coerce = function(val, raw) {
    switch (typeof val) {
      case "function":
        return val;
      case "string":
        return new nodes.String(val);
      case "boolean":
        return new nodes.Boolean(val);
      case "number":
        return new nodes.Unit(val);
      default:
        if (val == null)
          return nodes.null;
        if (Array.isArray(val))
          return exports.coerceArray(val, raw);
        if (val.nodeName)
          return val;
        return exports.coerceObject(val, raw);
    }
  };
  exports.coerceArray = function(val, raw) {
    var expr = new nodes.Expression;
    val.forEach(function(val2) {
      expr.push(exports.coerce(val2, raw));
    });
    return expr;
  };
  exports.coerceObject = function(obj, raw) {
    var node = raw ? new nodes.Object : new nodes.Expression, val;
    for (var key in obj) {
      val = exports.coerce(obj[key], raw);
      key = new nodes.Ident(key);
      if (raw) {
        node.set(key, val);
      } else {
        node.push(exports.coerceArray([key, val]));
      }
    }
    return node;
  };
  exports.params = function(fn) {
    return fn.toString().match(/\(([^)]*)\)/)[1].split(/ *, */);
  };
  exports.merge = function(a, b, deep) {
    for (var k in b) {
      if (deep && a[k]) {
        var nodeA = exports.unwrap(a[k]).first, nodeB = exports.unwrap(b[k]).first;
        if (nodeA.nodeName == "object" && nodeB.nodeName == "object") {
          a[k].first.vals = exports.merge(nodeA.vals, nodeB.vals, deep);
        } else {
          a[k] = b[k];
        }
      } else {
        a[k] = b[k];
      }
    }
    return a;
  };
  exports.uniq = function(arr) {
    var obj = {}, ret = [];
    for (var i = 0, len = arr.length;i < len; ++i) {
      if (arr[i] in obj)
        continue;
      obj[arr[i]] = true;
      ret.push(arr[i]);
    }
    return ret;
  };
  exports.compileSelectors = function(arr, leaveHidden) {
    var selectors = [], Parser = require_selector_parser(), indent = this.indent || "", buf = [];
    function parse(selector, buf2) {
      var parts = [selector.val], str = new Parser(parts[0], parents, parts).parse().val, parents = [];
      if (buf2.length) {
        for (var i = 0, len = buf2.length;i < len; ++i) {
          parts.push(buf2[i]);
          parents.push(str);
          var child = new Parser(buf2[i], parents, parts).parse();
          if (child.nested) {
            str += " " + child.val;
          } else {
            str = child.val;
          }
        }
      }
      return str.trim();
    }
    function compile(arr2, i) {
      if (i) {
        arr2[i].forEach(function(selector) {
          if (!leaveHidden && selector.isPlaceholder)
            return;
          if (selector.inherits) {
            buf.unshift(selector.val);
            compile(arr2, i - 1);
            buf.shift();
          } else {
            selectors.push(indent + parse(selector, buf));
          }
        });
      } else {
        arr2[0].forEach(function(selector) {
          if (!leaveHidden && selector.isPlaceholder)
            return;
          var str = parse(selector, buf);
          if (str)
            selectors.push(indent + str);
        });
      }
    }
    compile(arr, arr.length - 1);
    return exports.uniq(selectors);
  };
  exports.parseString = function(str) {
    var Parser = require_parser(), parser, ret;
    try {
      parser = new Parser(str);
      ret = parser.list();
    } catch (e) {
      ret = new nodes.Literal(str);
    }
    return ret;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/add-property.js
var require_add_property = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  (module.exports = function addProperty(name, expr) {
    utils.assertType(name, "expression", "name");
    name = utils.unwrap(name).first;
    utils.assertString(name, "name");
    utils.assertType(expr, "expression", "expr");
    var prop = new nodes.Property([name], expr);
    var block = this.closestBlock;
    var len = block.nodes.length, head = block.nodes.slice(0, block.index), tail = block.nodes.slice(block.index++, len);
    head.push(prop);
    block.nodes = head.concat(tail);
    return prop;
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/adjust.js
var require_adjust = __commonJS((exports, module) => {
  var adjust = function(color, prop, amount) {
    utils.assertColor(color, "color");
    utils.assertString(prop, "prop");
    utils.assertType(amount, "unit", "amount");
    var hsl = color.hsla.clone();
    prop = { hue: "h", saturation: "s", lightness: "l" }[prop.string];
    if (!prop)
      throw new Error("invalid adjustment property");
    var val = amount.val;
    if (amount.type == "%") {
      val = prop == "l" && val > 0 ? (100 - hsl[prop]) * val / 100 : hsl[prop] * (val / 100);
    }
    hsl[prop] += val;
    return hsl.rgba;
  };
  var utils = require_utils();
  adjust.params = ["color", "prop", "amount"];
  module.exports = adjust;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/rgba.js
var require_rgba = __commonJS((exports, module) => {
  var rgba = function(red, green, blue, alpha) {
    switch (arguments.length) {
      case 1:
        utils.assertColor(red);
        return red.rgba;
      case 2:
        utils.assertColor(red);
        var color = red.rgba;
        utils.assertType(green, "unit", "alpha");
        alpha = green.clone();
        if (alpha.type == "%")
          alpha.val /= 100;
        return new nodes.RGBA(color.r, color.g, color.b, alpha.val);
      default:
        utils.assertType(red, "unit", "red");
        utils.assertType(green, "unit", "green");
        utils.assertType(blue, "unit", "blue");
        utils.assertType(alpha, "unit", "alpha");
        var r = red.type == "%" ? Math.round(red.val * 2.55) : red.val, g = green.type == "%" ? Math.round(green.val * 2.55) : green.val, b = blue.type == "%" ? Math.round(blue.val * 2.55) : blue.val;
        alpha = alpha.clone();
        if (alpha && alpha.type == "%")
          alpha.val /= 100;
        return new nodes.RGBA(r, g, b, alpha.val);
    }
  };
  var utils = require_utils();
  var nodes = require_nodes();
  rgba.params = ["red", "green", "blue", "alpha"];
  module.exports = rgba;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/alpha.js
var require_alpha = __commonJS((exports, module) => {
  var alpha = function(color, value) {
    color = color.rgba;
    if (value) {
      return rgba(new nodes.Unit(color.r), new nodes.Unit(color.g), new nodes.Unit(color.b), value);
    }
    return new nodes.Unit(color.a, "");
  };
  var nodes = require_nodes();
  var rgba = require_rgba();
  alpha.params = ["color", "value"];
  module.exports = alpha;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/base-convert.js
var require_base_convert = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  (module.exports = function(num, base, width) {
    utils.assertPresent(num, "number");
    utils.assertPresent(base, "base");
    num = utils.unwrap(num).nodes[0].val;
    base = utils.unwrap(base).nodes[0].val;
    width = width && utils.unwrap(width).nodes[0].val || 2;
    var result = Number(num).toString(base);
    while (result.length < width) {
      result = "0" + result;
    }
    return new nodes.Literal(result);
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/basename.js
var require_basename = __commonJS((exports, module) => {
  var basename = function(p, ext) {
    utils.assertString(p, "path");
    return path.basename(p.val, ext && ext.val);
  };
  var utils = require_utils();
  var path = __require("path");
  basename.params = ["p", "ext"];
  module.exports = basename;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/blend.js
var require_blend = __commonJS((exports, module) => {
  var blend = function(top, bottom) {
    utils.assertColor(top);
    top = top.rgba;
    bottom = bottom || new nodes.RGBA(255, 255, 255, 1);
    utils.assertColor(bottom);
    bottom = bottom.rgba;
    return new nodes.RGBA(top.r * top.a + bottom.r * (1 - top.a), top.g * top.a + bottom.g * (1 - top.a), top.b * top.a + bottom.b * (1 - top.a), top.a + bottom.a - top.a * bottom.a);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  blend.params = ["top", "bottom"];
  module.exports = blend;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/blue.js
var require_blue = __commonJS((exports, module) => {
  var blue = function(color, value) {
    color = color.rgba;
    if (value) {
      return rgba(new nodes.Unit(color.r), new nodes.Unit(color.g), value, new nodes.Unit(color.a));
    }
    return new nodes.Unit(color.b, "");
  };
  var nodes = require_nodes();
  var rgba = require_rgba();
  blue.params = ["color", "value"];
  module.exports = blue;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/clone.js
var require_clone = __commonJS((exports, module) => {
  var utils = require_utils();
  (module.exports = function clone(expr) {
    utils.assertPresent(expr, "expr");
    return expr.clone();
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/component.js
var require_component = __commonJS((exports, module) => {
  var component = function(color, name) {
    utils.assertColor(color, "color");
    utils.assertString(name, "name");
    var name = name.string, unit = unitMap[name], type = typeMap[name], name = componentMap[name];
    if (!name)
      throw new Error('invalid color component "' + name + '"');
    return new nodes.Unit(color[type][name], unit);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  var componentMap = {
    red: "r",
    green: "g",
    blue: "b",
    alpha: "a",
    hue: "h",
    saturation: "s",
    lightness: "l"
  };
  var unitMap = {
    hue: "deg",
    saturation: "%",
    lightness: "%"
  };
  var typeMap = {
    red: "rgba",
    blue: "rgba",
    green: "rgba",
    alpha: "rgba",
    hue: "hsla",
    saturation: "hsla",
    lightness: "hsla"
  };
  component.params = ["color", "name"];
  module.exports = component;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/luminosity.js
var require_luminosity = __commonJS((exports, module) => {
  var luminosity = function(color) {
    utils.assertColor(color);
    color = color.rgba;
    function processChannel(channel) {
      channel = channel / 255;
      return 0.03928 > channel ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
    }
    return new nodes.Unit(0.2126 * processChannel(color.r) + 0.7152 * processChannel(color.g) + 0.0722 * processChannel(color.b));
  };
  var utils = require_utils();
  var nodes = require_nodes();
  luminosity.params = ["color"];
  module.exports = luminosity;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/contrast.js
var require_contrast = __commonJS((exports, module) => {
  var contrast = function(top, bottom) {
    if (top.nodeName != "rgba" && top.nodeName != "hsla") {
      return new nodes.Literal("contrast(" + (top.isNull ? "" : top.toString()) + ")");
    }
    var result = new nodes.Object;
    top = top.rgba;
    bottom = bottom || new nodes.RGBA(255, 255, 255, 1);
    utils.assertColor(bottom);
    bottom = bottom.rgba;
    function contrast2(top2, bottom2) {
      if (1 > top2.a) {
        top2 = blend(top2, bottom2);
      }
      var l1 = luminosity(bottom2).val + 0.05, l2 = luminosity(top2).val + 0.05, ratio = l1 / l2;
      if (l2 > l1) {
        ratio = 1 / ratio;
      }
      return Math.round(ratio * 10) / 10;
    }
    if (1 <= bottom.a) {
      var resultRatio = new nodes.Unit(contrast2(top, bottom));
      result.set("ratio", resultRatio);
      result.set("error", new nodes.Unit(0));
      result.set("min", resultRatio);
      result.set("max", resultRatio);
    } else {
      let processChannel2 = function(topChannel, bottomChannel) {
        return Math.min(Math.max(0, (topChannel - bottomChannel * bottom.a) / (1 - bottom.a)), 255);
      };
      var processChannel = processChannel2;
      var onBlack = contrast2(top, blend(bottom, new nodes.RGBA(0, 0, 0, 1))), onWhite = contrast2(top, blend(bottom, new nodes.RGBA(255, 255, 255, 1))), max = Math.max(onBlack, onWhite);
      var closest = new nodes.RGBA(processChannel2(top.r, bottom.r), processChannel2(top.g, bottom.g), processChannel2(top.b, bottom.b), 1);
      var min = contrast2(top, blend(bottom, closest));
      result.set("ratio", new nodes.Unit(Math.round((min + max) * 50) / 100));
      result.set("error", new nodes.Unit(Math.round((max - min) * 50) / 100));
      result.set("min", new nodes.Unit(min));
      result.set("max", new nodes.Unit(max));
    }
    return result;
  };
  var utils = require_utils();
  var nodes = require_nodes();
  var blend = require_blend();
  var luminosity = require_luminosity();
  contrast.params = ["top", "bottom"];
  module.exports = contrast;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/convert.js
var require_convert = __commonJS((exports, module) => {
  var convert = function(str) {
    utils.assertString(str, "str");
    return utils.parseString(str.string);
  };
  var utils = require_utils();
  convert.params = ["str"];
  module.exports = convert;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/current-media.js
var require_current_media = __commonJS((exports, module) => {
  var nodes = require_nodes();
  module.exports = function currentMedia() {
    var self2 = this;
    return new nodes.String(lookForMedia(this.closestBlock.node) || "");
    function lookForMedia(node) {
      if (node.nodeName == "media") {
        node.val = self2.visit(node.val);
        return node.toString();
      } else if (node.block.parent.node) {
        return lookForMedia(node.block.parent.node);
      }
    }
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/define.js
var require_define = __commonJS((exports, module) => {
  var define2 = function(name, expr, global) {
    utils.assertType(name, "string", "name");
    expr = utils.unwrap(expr);
    var scope = this.currentScope;
    if (global && global.toBoolean().isTrue) {
      scope = this.global.scope;
    }
    var node = new nodes.Ident(name.val, expr);
    scope.add(node);
    return nodes.null;
  };
  var utils = require_utils();
  var nodes = require_nodes();
  define2.params = ["name", "expr", "global"];
  module.exports = define2;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/dirname.js
var require_dirname = __commonJS((exports, module) => {
  var dirname = function(p) {
    utils.assertString(p, "path");
    return path.dirname(p.val).replace(/\\/g, "/");
  };
  var utils = require_utils();
  var path = __require("path");
  dirname.params = ["p"];
  module.exports = dirname;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/error.js
var require_error = __commonJS((exports, module) => {
  var error = function(msg) {
    utils.assertType(msg, "string", "msg");
    var err = new Error(msg.val);
    err.fromStylus = true;
    throw err;
  };
  var utils = require_utils();
  error.params = ["msg"];
  module.exports = error;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/extname.js
var require_extname = __commonJS((exports, module) => {
  var extname = function(p) {
    utils.assertString(p, "path");
    return path.extname(p.val);
  };
  var utils = require_utils();
  var path = __require("path");
  extname.params = ["p"];
  module.exports = extname;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/green.js
var require_green = __commonJS((exports, module) => {
  var green = function(color, value) {
    color = color.rgba;
    if (value) {
      return rgba(new nodes.Unit(color.r), value, new nodes.Unit(color.b), new nodes.Unit(color.a));
    }
    return new nodes.Unit(color.g, "");
  };
  var nodes = require_nodes();
  var rgba = require_rgba();
  green.params = ["color", "value"];
  module.exports = green;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/hsla.js
var require_hsla = __commonJS((exports, module) => {
  var hsla = function(hue, saturation, lightness, alpha) {
    switch (arguments.length) {
      case 1:
        utils.assertColor(hue);
        return hue.hsla;
      case 2:
        utils.assertColor(hue);
        var color = hue.hsla;
        utils.assertType(saturation, "unit", "alpha");
        var alpha = saturation.clone();
        if (alpha.type == "%")
          alpha.val /= 100;
        return new nodes.HSLA(color.h, color.s, color.l, alpha.val);
      default:
        utils.assertType(hue, "unit", "hue");
        utils.assertType(saturation, "unit", "saturation");
        utils.assertType(lightness, "unit", "lightness");
        utils.assertType(alpha, "unit", "alpha");
        var alpha = alpha.clone();
        if (alpha && alpha.type == "%")
          alpha.val /= 100;
        return new nodes.HSLA(hue.val, saturation.val, lightness.val, alpha.val);
    }
  };
  var utils = require_utils();
  var nodes = require_nodes();
  hsla.params = ["hue", "saturation", "lightness", "alpha"];
  module.exports = hsla;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/hsl.js
var require_hsl = __commonJS((exports, module) => {
  var hsl = function(hue, saturation, lightness) {
    if (arguments.length == 1) {
      utils.assertColor(hue, "color");
      return hue.hsla;
    } else {
      return hsla(hue, saturation, lightness, new nodes.Unit(1));
    }
  };
  var utils = require_utils();
  var nodes = require_nodes();
  var hsla = require_hsla();
  hsl.params = ["hue", "saturation", "lightness"];
  module.exports = hsl;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/hue.js
var require_hue = __commonJS((exports, module) => {
  var hue = function(color, value) {
    if (value) {
      var hslaColor = color.hsla;
      return hsla(value, new nodes.Unit(hslaColor.s), new nodes.Unit(hslaColor.l), new nodes.Unit(hslaColor.a));
    }
    return component(color, new nodes.String("hue"));
  };
  var nodes = require_nodes();
  var hsla = require_hsla();
  var component = require_component();
  hue.params = ["color", "value"];
  module.exports = hue;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/sax/lib/sax.js
var require_sax = __commonJS((exports) => {
  (function(sax) {
    sax.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F;
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o)
          if (o.hasOwnProperty(i))
            a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length;i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length;i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream;
    try {
      Stream = __require("stream").Stream;
    } catch (ex) {
      Stream = function() {
      };
    }
    var streamWraps = sax.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = __require("string_decoder").StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === " " || c === "\n" || c === "\r" || c === "\t";
    }
    function isQuote(c) {
      return c === '"' || c === "\'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
      var e = sax.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s2;
    });
    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    }
    S = sax.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length;i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c)) {
            } else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              parser[buffer] += parseEntity(parser);
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(typeof exports === "undefined" ? exports.sax = {} : exports);
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/image.js
var require_image = __commonJS((exports, module) => {
  /*!
   * Stylus - plugin - url
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var utils = require_utils();
  var nodes = require_nodes();
  var Buffer2 = require_safer().Buffer;
  var fs = __require("fs");
  var path = __require("path");
  var sax = require_sax();
  var Image = module.exports = function Image(ctx, path2) {
    this.ctx = ctx;
    this.path = utils.lookup(path2, ctx.paths);
    if (!this.path)
      throw new Error("failed to locate file " + path2);
  };
  Image.prototype.open = function() {
    this.fd = fs.openSync(this.path, "r");
    this.length = fs.fstatSync(this.fd).size;
    this.extname = path.extname(this.path).slice(1);
  };
  Image.prototype.close = function() {
    if (this.fd)
      fs.closeSync(this.fd);
  };
  Image.prototype.type = function() {
    var type, buf = Buffer2.alloc(4);
    fs.readSync(this.fd, buf, 0, 4, 0);
    if (buf[0] == 71 && buf[1] == 73 && buf[2] == 70)
      type = "gif";
    else if (buf[1] == 80 && buf[2] == 78 && buf[3] == 71)
      type = "png";
    else if (buf[0] == 255 && buf[1] == 216)
      type = "jpeg";
    else if (this.extname == "svg")
      type = this.extname;
    return type;
  };
  Image.prototype.size = function() {
    var type = this.type(), width, height, buf, offset, blockSize, parser;
    function uint16(b) {
      return b[1] << 8 | b[0];
    }
    function uint32(b) {
      return b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3];
    }
    switch (type) {
      case "jpeg":
        buf = Buffer2.alloc(this.length);
        fs.readSync(this.fd, buf, 0, this.length, 0);
        offset = 4;
        blockSize = buf[offset] << 8 | buf[offset + 1];
        while (offset < this.length) {
          offset += blockSize;
          if (offset >= this.length || buf[offset] != 255)
            break;
          if (buf[offset + 1] == 192 || buf[offset + 1] == 194) {
            height = buf[offset + 5] << 8 | buf[offset + 6];
            width = buf[offset + 7] << 8 | buf[offset + 8];
          } else {
            offset += 2;
            blockSize = buf[offset] << 8 | buf[offset + 1];
          }
        }
        break;
      case "png":
        buf = Buffer2.alloc(8);
        fs.readSync(this.fd, buf, 0, 8, 16);
        width = uint32(buf);
        height = uint32(buf.slice(4, 8));
        break;
      case "gif":
        buf = Buffer2.alloc(4);
        fs.readSync(this.fd, buf, 0, 4, 6);
        width = uint16(buf);
        height = uint16(buf.slice(2, 4));
        break;
      case "svg":
        offset = Math.min(this.length, 1024);
        buf = Buffer2.alloc(offset);
        fs.readSync(this.fd, buf, 0, offset, 0);
        buf = buf.toString("utf8");
        parser = sax.parser(true);
        parser.onopentag = function(node) {
          if (node.name == "svg" && node.attributes.width && node.attributes.height) {
            width = parseInt(node.attributes.width, 10);
            height = parseInt(node.attributes.height, 10);
          }
        };
        parser.write(buf).close();
        break;
    }
    if (typeof width != "number")
      throw new Error('failed to find width of "' + this.path + '"');
    if (typeof height != "number")
      throw new Error('failed to find height of "' + this.path + '"');
    return [width, height];
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/image-size.js
var require_image_size = __commonJS((exports, module) => {
  var imageSize = function(img, ignoreErr) {
    utils.assertType(img, "string", "img");
    try {
      var img = new Image(this, img.string);
    } catch (err) {
      if (ignoreErr) {
        return [new nodes.Unit(0), new nodes.Unit(0)];
      } else {
        throw err;
      }
    }
    img.open();
    var size = img.size();
    img.close();
    var expr = [];
    expr.push(new nodes.Unit(size[0], "px"));
    expr.push(new nodes.Unit(size[1], "px"));
    return expr;
  };
  var utils = require_utils();
  var nodes = require_nodes();
  var Image = require_image();
  imageSize.params = ["img", "ignoreErr"];
  module.exports = imageSize;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/json.js
var require_json = __commonJS((exports, module) => {
  var json = function(path, local, namePrefix) {
    utils.assertString(path, "path");
    path = path.string;
    var found = utils.lookup(path, this.options.paths, this.options.filename), options = local && local.nodeName == "object" && local;
    if (!found) {
      if (options && options.get("optional").toBoolean().isTrue) {
        return nodes.null;
      }
      throw new Error("failed to locate .json file " + path);
    }
    var json2 = JSON.parse(readFile(found, "utf8"));
    if (options) {
      return convert(json2, options);
    } else {
      oldJson.call(this, json2, local, namePrefix);
    }
    function convert(obj, options2) {
      var ret = new nodes.Object, leaveStrings = options2.get("leave-strings").toBoolean();
      for (var key in obj) {
        var val = obj[key];
        if (typeof val == "object") {
          ret.set(key, convert(val, options2));
        } else {
          val = utils.coerce(val);
          if (val.nodeName == "string" && leaveStrings.isFalse) {
            val = utils.parseString(val.string);
          }
          ret.set(key, val);
        }
      }
      return ret;
    }
  };
  var oldJson = function(json2, local, namePrefix) {
    if (namePrefix) {
      utils.assertString(namePrefix, "namePrefix");
      namePrefix = namePrefix.val;
    } else {
      namePrefix = "";
    }
    local = local ? local.toBoolean() : new nodes.Boolean(local);
    var scope = local.isTrue ? this.currentScope : this.global.scope;
    convert(json2);
    return;
    function convert(obj, prefix) {
      prefix = prefix ? prefix + "-" : "";
      for (var key in obj) {
        var val = obj[key];
        var name = prefix + key;
        if (typeof val == "object") {
          convert(val, name);
        } else {
          val = utils.coerce(val);
          if (val.nodeName == "string")
            val = utils.parseString(val.string);
          scope.add({ name: namePrefix + name, val });
        }
      }
    }
  };
  var utils = require_utils();
  var nodes = require_nodes();
  var readFile = __require("fs").readFileSync;
  json.params = ["path", "local", "namePrefix"];
  module.exports = json;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/length.js
var require_length = __commonJS((exports, module) => {
  var utils = require_utils();
  (module.exports = function length(expr) {
    if (expr) {
      if (expr.nodes) {
        var nodes = utils.unwrap(expr).nodes;
        if (nodes.length == 1 && nodes[0].nodeName == "object") {
          return nodes[0].length;
        } else if (nodes.length == 1 && nodes[0].nodeName == "string") {
          return nodes[0].val.length;
        } else {
          return nodes.length;
        }
      } else {
        return 1;
      }
    }
    return 0;
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/lightness.js
var require_lightness = __commonJS((exports, module) => {
  var lightness = function(color, value) {
    if (value) {
      var hslaColor = color.hsla;
      return hsla(new nodes.Unit(hslaColor.h), new nodes.Unit(hslaColor.s), value, new nodes.Unit(hslaColor.a));
    }
    return component(color, new nodes.String("lightness"));
  };
  var nodes = require_nodes();
  var hsla = require_hsla();
  var component = require_component();
  lightness.params = ["color", "value"];
  module.exports = lightness;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/list-separator.js
var require_list_separator = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  (module.exports = function listSeparator(list) {
    list = utils.unwrap(list);
    return new nodes.String(list.isList ? "," : " ");
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/lookup.js
var require_lookup = __commonJS((exports, module) => {
  var lookup = function(name) {
    utils.assertType(name, "string", "name");
    var node = this.lookup(name.val);
    if (!node)
      return nodes.null;
    return this.visit(node);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  lookup.params = ["name"];
  module.exports = lookup;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/match.js
var require_match = __commonJS((exports, module) => {
  var match = function(pattern, val, flags) {
    utils.assertType(pattern, "string", "pattern");
    utils.assertString(val, "val");
    var re = new RegExp(pattern.val, validateFlags(flags) ? flags.string : "");
    return val.string.match(re);
  };
  var validateFlags = function(flags) {
    flags = flags && flags.string;
    if (flags) {
      return flags.split("").every(function(flag) {
        return ~VALID_FLAGS.indexOf(flag);
      });
    }
    return false;
  };
  var utils = require_utils();
  var nodes = require_nodes();
  var VALID_FLAGS = "igm";
  match.params = ["pattern", "val", "flags"];
  module.exports = match;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/math.js
var require_math = __commonJS((exports, module) => {
  var math = function(n, fn) {
    utils.assertType(n, "unit", "n");
    utils.assertString(fn, "fn");
    return new nodes.Unit(Math[fn.string](n.val), n.type);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  math.params = ["n", "fn"];
  module.exports = math;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/merge.js
var require_merge = __commonJS((exports, module) => {
  var utils = require_utils();
  (module.exports = function merge(dest) {
    utils.assertPresent(dest, "dest");
    dest = utils.unwrap(dest).first;
    utils.assertType(dest, "object", "dest");
    var last = utils.unwrap(arguments[arguments.length - 1]).first, deep = last.val === true;
    for (var i = 1, len = arguments.length - deep;i < len; ++i) {
      utils.merge(dest.vals, utils.unwrap(arguments[i]).first.vals, deep);
    }
    return dest;
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/operate.js
var require_operate = __commonJS((exports, module) => {
  var operate = function(op, left, right) {
    utils.assertType(op, "string", "op");
    utils.assertPresent(left, "left");
    utils.assertPresent(right, "right");
    return left.operate(op.val, right);
  };
  var utils = require_utils();
  operate.params = ["op", "left", "right"];
  module.exports = operate;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/opposite-position.js
var require_opposite_position = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  (module.exports = function oppositePosition(positions) {
    var expr = [];
    utils.unwrap(positions).nodes.forEach(function(pos, i) {
      utils.assertString(pos, "position " + i);
      pos = function() {
        switch (pos.string) {
          case "top":
            return "bottom";
          case "bottom":
            return "top";
          case "left":
            return "right";
          case "right":
            return "left";
          case "center":
            return "center";
          default:
            throw new Error("invalid position " + pos);
        }
      }();
      expr.push(new nodes.Literal(pos));
    });
    return expr;
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/p.js
var require_p = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  (module.exports = function p() {
    [].slice.call(arguments).forEach(function(expr) {
      expr = utils.unwrap(expr);
      if (!expr.nodes.length)
        return;
      console.log("\x1B[90minspect:\x1B[0m %s", expr.toString().replace(/^\(|\)$/g, ""));
    });
    return nodes.null;
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/pathjoin.js
var require_pathjoin = __commonJS((exports, module) => {
  var path = __require("path");
  (module.exports = function pathjoin() {
    var paths = [].slice.call(arguments).map(function(path2) {
      return path2.first.string;
    });
    return path.join.apply(null, paths).replace(/\\/g, "/");
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/pop.js
var require_pop = __commonJS((exports, module) => {
  var utils = require_utils();
  (module.exports = function pop(expr) {
    expr = utils.unwrap(expr);
    return expr.nodes.pop();
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/push.js
var require_push = __commonJS((exports, module) => {
  var utils = require_utils();
  (module.exports = function(expr) {
    expr = utils.unwrap(expr);
    for (var i = 1, len = arguments.length;i < len; ++i) {
      expr.nodes.push(utils.unwrap(arguments[i]).clone());
    }
    return expr.nodes.length;
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/range.js
var require_range = __commonJS((exports, module) => {
  var range = function(start, stop, step) {
    utils.assertType(start, "unit", "start");
    utils.assertType(stop, "unit", "stop");
    if (step) {
      utils.assertType(step, "unit", "step");
      if (step.val == 0) {
        throw new Error('ArgumentError: "step" argument must not be zero');
      }
    } else {
      step = new nodes.Unit(1);
    }
    var list = new nodes.Expression;
    for (var i = start.val;i <= stop.val; i += step.val) {
      list.push(new nodes.Unit(i, start.type));
    }
    return list;
  };
  var utils = require_utils();
  var nodes = require_nodes();
  range.params = ["start", "stop", "step"];
  module.exports = range;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/red.js
var require_red = __commonJS((exports, module) => {
  var red = function(color, value) {
    color = color.rgba;
    if (value) {
      return rgba(value, new nodes.Unit(color.g), new nodes.Unit(color.b), new nodes.Unit(color.a));
    }
    return new nodes.Unit(color.r, "");
  };
  var nodes = require_nodes();
  var rgba = require_rgba();
  red.params = ["color", "value"];
  module.exports = red;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/remove.js
var require_remove = __commonJS((exports, module) => {
  var remove = function(object, key) {
    utils.assertType(object, "object", "object");
    utils.assertString(key, "key");
    delete object.vals[key.string];
    return object;
  };
  var utils = require_utils();
  remove.params = ["object", "key"];
  module.exports = remove;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/replace.js
var require_replace = __commonJS((exports, module) => {
  var replace = function(pattern, replacement, val) {
    utils.assertString(pattern, "pattern");
    utils.assertString(replacement, "replacement");
    utils.assertString(val, "val");
    pattern = new RegExp(pattern.string, "g");
    var res = val.string.replace(pattern, replacement.string);
    return val instanceof nodes.Ident ? new nodes.Ident(res) : new nodes.String(res);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  replace.params = ["pattern", "replacement", "val"];
  module.exports = replace;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/rgb.js
var require_rgb = __commonJS((exports, module) => {
  var rgb = function(red, green, blue) {
    switch (arguments.length) {
      case 1:
        utils.assertColor(red);
        var color = red.rgba;
        return new nodes.RGBA(color.r, color.g, color.b, 1);
      default:
        return rgba(red, green, blue, new nodes.Unit(1));
    }
  };
  var utils = require_utils();
  var nodes = require_nodes();
  var rgba = require_rgba();
  rgb.params = ["red", "green", "blue"];
  module.exports = rgb;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/convert-angle.js
var require_convert_angle = __commonJS((exports, module) => {
  module.exports = function convertAngle(value, unitName) {
    var factors = {
      rad: 1,
      deg: 180 / Math.PI,
      turn: 0.5 / Math.PI,
      grad: 200 / Math.PI
    };
    return value * factors[unitName];
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/atan.js
var require_atan = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  var convert = require_convert_angle();
  module.exports = function atan(trigValue, output) {
    var output = typeof output !== "undefined" ? output : "deg";
    var value = Math.atan(trigValue);
    var m = Math.pow(10, 9);
    var convertedValue = convert(value, output);
    convertedValue = Math.round(convertedValue * m) / m;
    return new nodes.Unit(convertedValue, output);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/asin.js
var require_asin = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  var convert = require_convert_angle();
  module.exports = function atan(trigValue, output) {
    var output = typeof output !== "undefined" ? output : "deg";
    var m = Math.pow(10, 9);
    var value = Math.asin(trigValue);
    var convertedValue = convert(value, output);
    convertedValue = Math.round(convertedValue * m) / m;
    return new nodes.Unit(convertedValue, output);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/acos.js
var require_acos = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  var convert = require_convert_angle();
  var asin = require_asin();
  module.exports = function acos(trigValue, output) {
    var output = typeof output !== "undefined" ? output : "deg";
    var convertedValue = convert(Math.PI / 2, output) - asin(trigValue, output).val;
    var m = Math.pow(10, 9);
    convertedValue = Math.round(convertedValue * m) / m;
    return new nodes.Unit(convertedValue, output);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/visitor/compiler.js
var require_compiler = __commonJS((exports, module) => {
  /*!
   * Stylus - Compiler
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Visitor = require_visitor();
  var utils = require_utils();
  var fs = __require("fs");
  var Compiler = module.exports = function Compiler(root, options) {
    options = options || {};
    this.compress = options.compress;
    this.firebug = options.firebug;
    this.linenos = options.linenos;
    this.spaces = options["indent spaces"] || 2;
    this.indents = 1;
    Visitor.call(this, root);
    this.stack = [];
  };
  Compiler.prototype.__proto__ = Visitor.prototype;
  Compiler.prototype.compile = function() {
    return this.visit(this.root);
  };
  Compiler.prototype.out = function(str, node) {
    return str;
  };
  Compiler.prototype.__defineGetter__("indent", function() {
    if (this.compress)
      return "";
    return new Array(this.indents).join(Array(this.spaces + 1).join(" "));
  });
  Compiler.prototype.needBrackets = function(node) {
    return this.indents == 1 || node.nodeName != "atrule" || node.hasOnlyProperties;
  };
  Compiler.prototype.visitRoot = function(block) {
    this.buf = "";
    for (var i = 0, len = block.nodes.length;i < len; ++i) {
      var node = block.nodes[i];
      if (this.linenos || this.firebug)
        this.debugInfo(node);
      var ret = this.visit(node);
      if (ret)
        this.buf += this.out(ret + "\n", node);
    }
    return this.buf;
  };
  Compiler.prototype.visitBlock = function(block) {
    var node, separator = this.compress ? "" : "\n", needBrackets, lastPropertyIndex;
    if (block.hasProperties && !block.lacksRenderedSelectors) {
      needBrackets = this.needBrackets(block.node);
      if (this.compress) {
        for (var i = block.nodes.length - 1;i >= 0; --i) {
          if (block.nodes[i].nodeName === "property") {
            lastPropertyIndex = i;
            break;
          }
        }
      }
      if (needBrackets) {
        this.buf += this.out(this.compress ? "{" : " {\n");
        ++this.indents;
      }
      for (var i = 0, len = block.nodes.length;i < len; ++i) {
        this.last = lastPropertyIndex === i;
        node = block.nodes[i];
        switch (node.nodeName) {
          case "null":
          case "expression":
          case "function":
          case "group":
          case "block":
          case "unit":
          case "media":
          case "keyframes":
          case "atrule":
          case "supports":
            continue;
          case (!this.compress && node.inline && "comment"):
            this.buf = this.buf.slice(0, -1);
            this.buf += this.out(" " + this.visit(node) + "\n", node);
            break;
          case "property":
            var ret = this.visit(node) + separator;
            this.buf += this.compress ? ret : this.out(ret, node);
            break;
          default:
            this.buf += this.out(this.visit(node) + separator, node);
        }
      }
      if (needBrackets) {
        --this.indents;
        this.buf += this.out(this.indent + "}" + separator);
      }
    }
    for (var i = 0, len = block.nodes.length;i < len; ++i) {
      node = block.nodes[i];
      switch (node.nodeName) {
        case "group":
        case "block":
        case "keyframes":
          if (this.linenos || this.firebug)
            this.debugInfo(node);
          this.visit(node);
          break;
        case "media":
        case "import":
        case "atrule":
        case "supports":
          this.visit(node);
          break;
        case "comment":
          if (!node.suppress) {
            this.buf += this.out(this.indent + this.visit(node) + "\n", node);
          }
          break;
        case "charset":
        case "literal":
        case "namespace":
          this.buf += this.out(this.visit(node) + "\n", node);
          break;
      }
    }
  };
  Compiler.prototype.visitKeyframes = function(node) {
    if (!node.frames)
      return;
    var prefix = node.prefix == "official" ? "" : "-" + node.prefix + "-";
    this.buf += this.out("@" + prefix + "keyframes " + this.visit(node.val) + (this.compress ? "{" : " {\n"), node);
    this.keyframe = true;
    ++this.indents;
    this.visit(node.block);
    --this.indents;
    this.keyframe = false;
    this.buf += this.out("}" + (this.compress ? "" : "\n"));
  };
  Compiler.prototype.visitMedia = function(media) {
    var val = media.val;
    if (!media.hasOutput || !val.nodes.length)
      return;
    this.buf += this.out("@media ", media);
    this.visit(val);
    this.buf += this.out(this.compress ? "{" : " {\n");
    ++this.indents;
    this.visit(media.block);
    --this.indents;
    this.buf += this.out("}" + (this.compress ? "" : "\n"));
  };
  Compiler.prototype.visitQueryList = function(queries) {
    for (var i = 0, len = queries.nodes.length;i < len; ++i) {
      this.visit(queries.nodes[i]);
      if (len - 1 != i)
        this.buf += this.out("," + (this.compress ? "" : " "));
    }
  };
  Compiler.prototype.visitQuery = function(node) {
    var len = node.nodes.length;
    if (node.predicate)
      this.buf += this.out(node.predicate + " ");
    if (node.type)
      this.buf += this.out(node.type + (len ? " and " : ""));
    for (var i = 0;i < len; ++i) {
      this.buf += this.out(this.visit(node.nodes[i]));
      if (len - 1 != i)
        this.buf += this.out(" and ");
    }
  };
  Compiler.prototype.visitFeature = function(node) {
    if (!node.expr) {
      return node.name;
    } else if (node.expr.isEmpty) {
      return "(" + node.name + ")";
    } else {
      return "(" + node.name + ":" + (this.compress ? "" : " ") + this.visit(node.expr) + ")";
    }
  };
  Compiler.prototype.visitImport = function(imported) {
    this.buf += this.out("@import " + this.visit(imported.path) + ";\n", imported);
  };
  Compiler.prototype.visitAtrule = function(atrule) {
    var newline = this.compress ? "" : "\n";
    this.buf += this.out(this.indent + "@" + atrule.type, atrule);
    if (atrule.val)
      this.buf += this.out(" " + atrule.val.trim());
    if (atrule.block) {
      if (atrule.block.isEmpty) {
        this.buf += this.out((this.compress ? "" : " ") + "{}" + newline);
      } else if (atrule.hasOnlyProperties) {
        this.visit(atrule.block);
      } else {
        this.buf += this.out(this.compress ? "{" : " {\n");
        ++this.indents;
        this.visit(atrule.block);
        --this.indents;
        this.buf += this.out(this.indent + "}" + newline);
      }
    } else {
      this.buf += this.out(";" + newline);
    }
  };
  Compiler.prototype.visitSupports = function(node) {
    if (!node.hasOutput)
      return;
    this.buf += this.out(this.indent + "@supports ", node);
    this.isCondition = true;
    this.buf += this.out(this.visit(node.condition));
    this.isCondition = false;
    this.buf += this.out(this.compress ? "{" : " {\n");
    ++this.indents;
    this.visit(node.block);
    --this.indents;
    this.buf += this.out(this.indent + "}" + (this.compress ? "" : "\n"));
  }, Compiler.prototype.visitComment = function(comment) {
    return this.compress ? comment.suppress ? "" : comment.str : comment.str;
  };
  Compiler.prototype.visitFunction = function(fn) {
    return fn.name;
  };
  Compiler.prototype.visitCharset = function(charset) {
    return "@charset " + this.visit(charset.val) + ";";
  };
  Compiler.prototype.visitNamespace = function(namespace) {
    return "@namespace " + (namespace.prefix ? this.visit(namespace.prefix) + " " : "") + this.visit(namespace.val) + ";";
  };
  Compiler.prototype.visitLiteral = function(lit) {
    var val = lit.val;
    if (lit.css)
      val = val.replace(/^  /gm, "");
    return val;
  };
  Compiler.prototype.visitBoolean = function(bool) {
    return bool.toString();
  };
  Compiler.prototype.visitRGBA = function(rgba) {
    return rgba.toString();
  };
  Compiler.prototype.visitHSLA = function(hsla) {
    return hsla.rgba.toString();
  };
  Compiler.prototype.visitUnit = function(unit) {
    var type = unit.type || "", n = unit.val, float = n != (n | 0);
    if (this.compress) {
      if (!["%", "s", "ms", "deg", "fr"].includes(type) && n == 0)
        return "0";
      if (float && n < 1 && n > -1) {
        return n.toString().replace("0.", ".") + type;
      }
    }
    return (float ? parseFloat(n.toFixed(15)) : n).toString() + type;
  };
  Compiler.prototype.visitGroup = function(group) {
    var stack = this.keyframe ? [] : this.stack, comma = this.compress ? "," : ",\n";
    stack.push(group.nodes);
    if (group.block.hasProperties) {
      var selectors = utils.compileSelectors.call(this, stack), len = selectors.length;
      if (len) {
        if (this.keyframe)
          comma = this.compress ? "," : ", ";
        for (var i = 0;i < len; ++i) {
          var selector = selectors[i], last = i == len - 1;
          if (this.keyframe)
            selector = i ? selector.trim() : selector;
          this.buf += this.out(selector + (last ? "" : comma), group.nodes[i]);
        }
      } else {
        group.block.lacksRenderedSelectors = true;
      }
    }
    this.visit(group.block);
    stack.pop();
  };
  Compiler.prototype.visitIdent = function(ident) {
    return ident.name;
  };
  Compiler.prototype.visitString = function(string) {
    return this.isURL ? string.val : string.toString();
  };
  Compiler.prototype.visitNull = function(node) {
    return "";
  };
  Compiler.prototype.visitCall = function(call) {
    this.isURL = call.name == "url";
    var args = call.args.nodes.map(function(arg) {
      return this.visit(arg);
    }, this).join(this.compress ? "," : ", ");
    if (this.isURL)
      args = '"' + args + '"';
    this.isURL = false;
    return call.name + "(" + args + ")";
  };
  Compiler.prototype.visitExpression = function(expr) {
    var buf = [], self2 = this, len = expr.nodes.length, nodes = expr.nodes.map(function(node) {
      return self2.visit(node);
    });
    nodes.forEach(function(node, i) {
      var last = i == len - 1;
      buf.push(node);
      if (nodes[i + 1] == "/" || node == "/")
        return;
      if (last)
        return;
      var space = self2.isURL || self2.isCondition && (nodes[i + 1] == ")" || node == "(") ? "" : " ";
      buf.push(expr.isList ? self2.compress ? "," : ", " : space);
    });
    return buf.join("");
  };
  Compiler.prototype.visitArguments = Compiler.prototype.visitExpression;
  Compiler.prototype.visitProperty = function(prop) {
    var val = this.visit(prop.expr).trim(), name = prop.name || prop.segments.join(""), arr = [];
    if (name === "@apply") {
      arr.push(this.out(this.indent), this.out(name + " ", prop), this.out(val, prop.expr), this.out(this.compress ? this.last ? "" : ";" : ";"));
      return arr.join("");
    }
    arr.push(this.out(this.indent), this.out(name + (this.compress ? ":" : ": "), prop), this.out(val, prop.expr), this.out(this.compress ? this.last ? "" : ";" : ";"));
    return arr.join("");
  };
  Compiler.prototype.debugInfo = function(node) {
    var path = node.filename == "stdin" ? "stdin" : fs.realpathSync(node.filename), line = (node.nodes && node.nodes.length ? node.nodes[0].lineno : node.lineno) || 1;
    if (this.linenos) {
      this.buf += "\n/* line " + line + " : " + path + " */\n";
    }
    if (this.firebug) {
      path = "file\\:\\/\\/" + path.replace(/([.:/\\])/g, function(m) {
        return "\\" + (m === "\\" ? "/" : m);
      });
      line = "\\00003" + line;
      this.buf += "\n@media -stylus-debug-info{filename{font-family:" + path + "}line{font-family:" + line + "}}\n";
    }
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/s.js
var require_s = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  var Compiler = require_compiler();
  (module.exports = function s(fmt) {
    fmt = utils.unwrap(fmt).nodes[0];
    utils.assertString(fmt);
    var self2 = this, str = fmt.string, args = arguments, i = 1;
    str = str.replace(/%(s|d)/g, function(_, specifier) {
      var arg = args[i++] || nodes.null;
      switch (specifier) {
        case "s":
          return new Compiler(arg, self2.options).compile();
        case "d":
          arg = utils.unwrap(arg).first;
          if (arg.nodeName != "unit")
            throw new Error("%d requires a unit");
          return arg.val;
      }
    });
    return new nodes.Literal(str);
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/saturation.js
var require_saturation = __commonJS((exports, module) => {
  var saturation = function(color, value) {
    if (value) {
      var hslaColor = color.hsla;
      return hsla(new nodes.Unit(hslaColor.h), value, new nodes.Unit(hslaColor.l), new nodes.Unit(hslaColor.a));
    }
    return component(color, new nodes.String("saturation"));
  };
  var nodes = require_nodes();
  var hsla = require_hsla();
  var component = require_component();
  saturation.params = ["color", "value"];
  module.exports = saturation;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/visitor/normalizer.js
var require_normalizer = __commonJS((exports, module) => {
  /*!
   * Stylus - Normalizer
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Visitor = require_visitor();
  var nodes = require_nodes();
  var utils = require_utils();
  var Normalizer = module.exports = function Normalizer(root, options) {
    options = options || {};
    Visitor.call(this, root);
    this.hoist = options["hoist atrules"];
    this.stack = [];
    this.map = {};
    this.imports = [];
  };
  Normalizer.prototype.__proto__ = Visitor.prototype;
  Normalizer.prototype.normalize = function() {
    var ret = this.visit(this.root);
    if (this.hoist) {
      if (this.imports.length)
        ret.nodes = this.imports.concat(ret.nodes);
      if (this.charset)
        ret.nodes = [this.charset].concat(ret.nodes);
    }
    return ret;
  };
  Normalizer.prototype.bubble = function(node) {
    var props = [], other = [], self2 = this;
    function filterProps(block2) {
      block2.nodes.forEach(function(node2) {
        node2 = self2.visit(node2);
        switch (node2.nodeName) {
          case "property":
            props.push(node2);
            break;
          case "block":
            filterProps(node2);
            break;
          default:
            other.push(node2);
        }
      });
    }
    filterProps(node.block);
    if (props.length) {
      var selector = new nodes.Selector([new nodes.Literal("&")]);
      selector.lineno = node.lineno;
      selector.column = node.column;
      selector.filename = node.filename;
      selector.val = "&";
      var group = new nodes.Group;
      group.lineno = node.lineno;
      group.column = node.column;
      group.filename = node.filename;
      var block = new nodes.Block(node.block, group);
      block.lineno = node.lineno;
      block.column = node.column;
      block.filename = node.filename;
      props.forEach(function(prop) {
        block.push(prop);
      });
      group.push(selector);
      group.block = block;
      node.block.nodes = [];
      node.block.push(group);
      other.forEach(function(n) {
        node.block.push(n);
      });
      var group = this.closestGroup(node.block);
      if (group)
        node.group = group.clone();
      node.bubbled = true;
    }
  };
  Normalizer.prototype.closestGroup = function(block) {
    var parent = block.parent, node;
    while (parent && (node = parent.node)) {
      if (node.nodeName == "group")
        return node;
      parent = node.block && node.block.parent;
    }
  };
  Normalizer.prototype.visitRoot = function(block) {
    var ret = new nodes.Root, node;
    for (var i = 0;i < block.nodes.length; ++i) {
      node = block.nodes[i];
      switch (node.nodeName) {
        case "null":
        case "expression":
        case "function":
        case "unit":
        case "atblock":
          continue;
        default:
          this.rootIndex = i;
          ret.push(this.visit(node));
      }
    }
    return ret;
  };
  Normalizer.prototype.visitProperty = function(prop) {
    this.visit(prop.expr);
    return prop;
  };
  Normalizer.prototype.visitExpression = function(expr) {
    expr.nodes = expr.nodes.map(function(node) {
      if (node.nodeName == "block") {
        var literal = new nodes.Literal("block");
        literal.lineno = expr.lineno;
        literal.column = expr.column;
        return literal;
      }
      return node;
    });
    return expr;
  };
  Normalizer.prototype.visitBlock = function(block) {
    var node;
    if (block.hasProperties) {
      for (var i = 0, len = block.nodes.length;i < len; ++i) {
        node = block.nodes[i];
        switch (node.nodeName) {
          case "null":
          case "expression":
          case "function":
          case "group":
          case "unit":
          case "atblock":
            continue;
          default:
            block.nodes[i] = this.visit(node);
        }
      }
    }
    for (var i = 0, len = block.nodes.length;i < len; ++i) {
      node = block.nodes[i];
      block.nodes[i] = this.visit(node);
    }
    return block;
  };
  Normalizer.prototype.visitGroup = function(group) {
    var stack = this.stack, map = this.map, parts;
    group.nodes.forEach(function(selector, i) {
      if (!~selector.val.indexOf(","))
        return;
      if (~selector.val.indexOf("\\,")) {
        selector.val = selector.val.replace(/\\,/g, ",");
        return;
      }
      parts = selector.val.split(",");
      var root = selector.val.charAt(0) == "/", part, s;
      for (var k = 0, len = parts.length;k < len; ++k) {
        part = parts[k].trim();
        if (root && k > 0 && !~part.indexOf("&")) {
          part = "/" + part;
        }
        s = new nodes.Selector([new nodes.Literal(part)]);
        s.val = part;
        s.block = group.block;
        group.nodes[i++] = s;
      }
    });
    stack.push(group.nodes);
    var selectors = utils.compileSelectors(stack, true);
    selectors.forEach(function(selector) {
      map[selector] = map[selector] || [];
      map[selector].push(group);
    });
    this.extend(group, selectors);
    stack.pop();
    return group;
  };
  Normalizer.prototype.visitFunction = function() {
    return nodes.null;
  };
  Normalizer.prototype.visitMedia = function(media) {
    var medias = [], group = this.closestGroup(media.block), parent;
    function mergeQueries(block) {
      block.nodes.forEach(function(node, i) {
        switch (node.nodeName) {
          case "media":
            node.val = media.val.merge(node.val);
            medias.push(node);
            block.nodes[i] = nodes.null;
            break;
          case "block":
            mergeQueries(node);
            break;
          default:
            if (node.block && node.block.nodes)
              mergeQueries(node.block);
        }
      });
    }
    mergeQueries(media.block);
    this.bubble(media);
    if (medias.length) {
      medias.forEach(function(node) {
        if (group) {
          group.block.push(node);
        } else {
          this.root.nodes.splice(++this.rootIndex, 0, node);
        }
        node = this.visit(node);
        parent = node.block.parent;
        if (node.bubbled && (!group || parent.node.nodeName == "group")) {
          node.group.block = node.block.nodes[0].block;
          node.block.nodes[0] = node.group;
        }
      }, this);
    }
    return media;
  };
  Normalizer.prototype.visitSupports = function(node) {
    this.bubble(node);
    return node;
  };
  Normalizer.prototype.visitAtrule = function(node) {
    if (node.block)
      node.block = this.visit(node.block);
    return node;
  };
  Normalizer.prototype.visitKeyframes = function(node) {
    var frames = node.block.nodes.filter(function(frame) {
      return frame.block && frame.block.hasProperties;
    });
    node.frames = frames.length;
    return node;
  };
  Normalizer.prototype.visitImport = function(node) {
    this.imports.push(node);
    return this.hoist ? nodes.null : node;
  };
  Normalizer.prototype.visitCharset = function(node) {
    this.charset = node;
    return this.hoist ? nodes.null : node;
  };
  Normalizer.prototype.extend = function(group, selectors) {
    var map = this.map, self2 = this, parent = this.closestGroup(group.block);
    group.extends.forEach(function(extend) {
      var groups = map[extend.selector];
      if (!groups) {
        if (extend.optional)
          return;
        groups = self2._checkForPrefixedGroups(extend.selector);
        if (!groups) {
          var err = new Error('Failed to @extend "' + extend.selector + '"');
          err.lineno = extend.lineno;
          err.column = extend.column;
          throw err;
        }
      }
      selectors.forEach(function(selector) {
        var node = new nodes.Selector;
        node.val = selector;
        node.inherits = false;
        groups.forEach(function(group2) {
          if (!parent || parent != group2)
            self2.extend(group2, selectors);
          group2.push(node);
        });
      });
    });
    group.block = this.visit(group.block);
  };
  Normalizer.prototype._checkForPrefixedGroups = function(selector) {
    var prefix = [];
    var map = this.map;
    var result = null;
    for (var i = 0;i < this.stack.length; i++) {
      var stackElementArray = this.stack[i];
      var stackElement = stackElementArray[0];
      prefix.push(stackElement.val);
      var fullSelector = prefix.join(" ") + " " + selector;
      result = map[fullSelector];
      if (result)
        break;
    }
    return result;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/selector-exists.js
var require_selector_exists = __commonJS((exports, module) => {
  var selectorExists = function(sel) {
    utils.assertString(sel, "selector");
    if (!this.__selectorsMap__) {
      var Normalizer = require_normalizer(), visitor = new Normalizer(this.root.clone());
      visitor.visit(visitor.root);
      this.__selectorsMap__ = visitor.map;
    }
    return sel.string in this.__selectorsMap__;
  };
  var utils = require_utils();
  selectorExists.params = ["sel"];
  module.exports = selectorExists;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/selector.js
var require_selector = __commonJS((exports, module) => {
  var pushToStack = function(selectors, stack) {
    selectors.forEach(function(sel) {
      sel = sel.first;
      utils.assertString(sel, "selector");
      stack.push(parse(sel.string));
    });
  };
  var parse = function(selector) {
    var Parser = new __require("../parser"), parser = new Parser(selector), nodes;
    parser.state.push("selector-parts");
    nodes = parser.selector();
    nodes.forEach(function(node) {
      node.val = node.segments.map(function(seg) {
        return seg.toString();
      }).join("");
    });
    return nodes;
  };
  var utils = require_utils();
  (module.exports = function selector() {
    var stack = this.selectorStack, args = [].slice.call(arguments);
    if (args.length == 1) {
      var expr = utils.unwrap(args[0]), len = expr.nodes.length;
      if (len == 1) {
        utils.assertString(expr.first, "selector");
        var SelectorParser = require_selector_parser(), val = expr.first.string, parsed = new SelectorParser(val).parse().val;
        if (parsed == val)
          return val;
        stack.push(parse(val));
      } else if (len > 1) {
        if (expr.isList) {
          pushToStack(expr.nodes, stack);
        } else {
          stack.push(parse(expr.nodes.map(function(node) {
            utils.assertString(node, "selector");
            return node.string;
          }).join(" ")));
        }
      }
    } else if (args.length > 1) {
      pushToStack(args, stack);
    }
    return stack.length ? utils.compileSelectors(stack).join(",") : "&";
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/selectors.js
var require_selectors = __commonJS((exports, module) => {
  var nodes = require_nodes();
  var Parser = require_selector_parser();
  module.exports = function selectors() {
    var stack = this.selectorStack, expr = new nodes.Expression(true);
    if (stack.length) {
      for (var i = 0;i < stack.length; i++) {
        var group = stack[i], nested;
        if (group.length > 1) {
          expr.push(new nodes.String(group.map(function(selector2) {
            nested = new Parser(selector2.val).parse().nested;
            return (nested && i ? "& " : "") + selector2.val;
          }).join(",")));
        } else {
          var selector = group[0].val;
          nested = new Parser(selector).parse().nested;
          expr.push(new nodes.String((nested && i ? "& " : "") + selector));
        }
      }
    } else {
      expr.push(new nodes.String("&"));
    }
    return expr;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/shift.js
var require_shift = __commonJS((exports, module) => {
  var utils = require_utils();
  (module.exports = function(expr) {
    expr = utils.unwrap(expr);
    return expr.nodes.shift();
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/split.js
var require_split = __commonJS((exports, module) => {
  var split = function(delim, val) {
    utils.assertString(delim, "delimiter");
    utils.assertString(val, "val");
    var splitted = val.string.split(delim.string);
    var expr = new nodes.Expression;
    var ItemNode = val instanceof nodes.Ident ? nodes.Ident : nodes.String;
    for (var i = 0, len = splitted.length;i < len; ++i) {
      expr.nodes.push(new ItemNode(splitted[i]));
    }
    return expr;
  };
  var utils = require_utils();
  var nodes = require_nodes();
  split.params = ["delim", "val"];
  module.exports = split;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/substr.js
var require_substr = __commonJS((exports, module) => {
  var substr = function(val, start, length) {
    utils.assertString(val, "val");
    utils.assertType(start, "unit", "start");
    length = length && length.val;
    var res = val.string.substr(start.val, length);
    return val instanceof nodes.Ident ? new nodes.Ident(res) : new nodes.String(res);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  substr.params = ["val", "start", "length"];
  module.exports = substr;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/slice.js
var require_slice = __commonJS((exports, module) => {
  var utils = require_utils();
  var nodes = require_nodes();
  (module.exports = function slice(val, start, end) {
    start = start && start.nodes[0].val;
    end = end && end.nodes[0].val;
    val = utils.unwrap(val).nodes;
    if (val.length > 1) {
      return utils.coerce(val.slice(start, end), true);
    }
    var result = val[0].string.slice(start, end);
    return val[0] instanceof nodes.Ident ? new nodes.Ident(result) : new nodes.String(result);
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/tan.js
var require_tan = __commonJS((exports, module) => {
  var tan = function(angle) {
    utils.assertType(angle, "unit", "angle");
    var radians = angle.val;
    if (angle.type === "deg") {
      radians *= Math.PI / 180;
    }
    var m = Math.pow(10, 9);
    var sin = Math.round(Math.sin(radians) * m) / m, cos = Math.round(Math.cos(radians) * m) / m, tan2 = Math.round(m * sin / cos) / m;
    return new nodes.Unit(tan2, "");
  };
  var utils = require_utils();
  var nodes = require_nodes();
  tan.params = ["angle"];
  module.exports = tan;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/trace.js
var require_trace = __commonJS((exports, module) => {
  var nodes = require_nodes();
  module.exports = function trace() {
    console.log(this.stack);
    return nodes.null;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/transparentify.js
var require_transparentify = __commonJS((exports, module) => {
  var transparentify = function(top, bottom, alpha) {
    utils.assertColor(top);
    top = top.rgba;
    bottom = bottom || new nodes.RGBA(255, 255, 255, 1);
    if (!alpha && bottom && !bottom.rgba) {
      alpha = bottom;
      bottom = new nodes.RGBA(255, 255, 255, 1);
    }
    utils.assertColor(bottom);
    bottom = bottom.rgba;
    var bestAlpha = ["r", "g", "b"].map(function(channel) {
      return (top[channel] - bottom[channel]) / ((0 < top[channel] - bottom[channel] ? 255 : 0) - bottom[channel]);
    }).sort(function(a, b) {
      return b - a;
    })[0];
    if (alpha) {
      utils.assertType(alpha, "unit", "alpha");
      if (alpha.type == "%") {
        bestAlpha = alpha.val / 100;
      } else if (!alpha.type) {
        bestAlpha = alpha = alpha.val;
      }
    }
    bestAlpha = Math.max(Math.min(bestAlpha, 1), 0);
    function processChannel(channel) {
      if (bestAlpha == 0) {
        return bottom[channel];
      } else {
        return bottom[channel] + (top[channel] - bottom[channel]) / bestAlpha;
      }
    }
    return new nodes.RGBA(processChannel("r"), processChannel("g"), processChannel("b"), Math.round(bestAlpha * 100) / 100);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  transparentify.params = ["top", "bottom", "alpha"];
  module.exports = transparentify;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/type.js
var require_type = __commonJS((exports, module) => {
  var type = function(node) {
    utils.assertPresent(node, "expression");
    return node.nodeName;
  };
  var utils = require_utils();
  type.params = ["node"];
  module.exports = type;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/unit.js
var require_unit = __commonJS((exports, module) => {
  var unit = function(unit2, type) {
    utils.assertType(unit2, "unit", "unit");
    if (type) {
      utils.assertString(type, "type");
      return new nodes.Unit(unit2.val, type.string);
    } else {
      return unit2.type || "";
    }
  };
  var utils = require_utils();
  var nodes = require_nodes();
  unit.params = ["unit", "type"];
  module.exports = unit;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/unquote.js
var require_unquote = __commonJS((exports, module) => {
  var unquote = function(string) {
    utils.assertString(string, "string");
    return new nodes.Literal(string.string);
  };
  var utils = require_utils();
  var nodes = require_nodes();
  unquote.params = ["string"];
  module.exports = unquote;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/unshift.js
var require_unshift = __commonJS((exports, module) => {
  var utils = require_utils();
  (module.exports = function(expr) {
    expr = utils.unwrap(expr);
    for (var i = 1, len = arguments.length;i < len; ++i) {
      expr.nodes.unshift(utils.unwrap(arguments[i]));
    }
    return expr.nodes.length;
  }).raw = true;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/use.js
var require_use = __commonJS((exports, module) => {
  var use = function(plugin, options) {
    utils.assertString(plugin, "plugin");
    if (options) {
      utils.assertType(options, "object", "options");
      options = parseObject(options);
    }
    plugin = plugin.string;
    var found = utils.lookup(plugin, this.options.paths, this.options.filename);
    if (!found)
      throw new Error('failed to locate plugin file "' + plugin + '"');
    var fn = __require(path.resolve(found));
    if (typeof fn != "function") {
      throw new Error('plugin "' + plugin + '" does not export a function');
    }
    this.renderer.use(fn(options || this.options));
  };
  var parseObject = function(obj) {
    obj = obj.vals;
    for (var key in obj) {
      var nodes = obj[key].nodes[0].nodes;
      if (nodes && nodes.length) {
        obj[key] = [];
        for (var i = 0, len = nodes.length;i < len; ++i) {
          obj[key].push(convert(nodes[i]));
        }
      } else {
        obj[key] = convert(obj[key].first);
      }
    }
    return obj;
    function convert(node) {
      switch (node.nodeName) {
        case "object":
          return parseObject(node);
        case "boolean":
          return node.isTrue;
        case "unit":
          return node.type ? node.toString() : +node.val;
        case "string":
        case "literal":
          return node.val;
        default:
          return node.toString();
      }
    }
  };
  var utils = require_utils();
  var path = __require("path");
  use.params = ["plugin", "options"];
  module.exports = use;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/warn.js
var require_warn = __commonJS((exports, module) => {
  var warn = function(msg) {
    utils.assertType(msg, "string", "msg");
    console.warn("Warning: %s", msg.val);
    return nodes.null;
  };
  var utils = require_utils();
  var nodes = require_nodes();
  warn.params = ["msg"];
  module.exports = warn;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/math-prop.js
var require_math_prop = __commonJS((exports, module) => {
  var math = function(prop) {
    return new nodes.Unit(Math[prop.string]);
  };
  var nodes = require_nodes();
  math.params = ["prop"];
  module.exports = math;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/prefix-classes.js
var require_prefix_classes = __commonJS((exports, module) => {
  var prefixClasses = function(prefix, block) {
    utils.assertString(prefix, "prefix");
    utils.assertType(block, "block", "block");
    var _prefix = this.prefix;
    this.options.prefix = this.prefix = prefix.string;
    block = this.visit(block);
    this.options.prefix = this.prefix = _prefix;
    return block;
  };
  var utils = require_utils();
  prefixClasses.params = ["prefix", "block"];
  module.exports = prefixClasses;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/index.js
var require_functions = __commonJS((exports) => {
  /*!
   * Stylus - Evaluator - built-in functions
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  exports["add-property"] = require_add_property();
  exports.adjust = require_adjust();
  exports.alpha = require_alpha();
  exports["base-convert"] = require_base_convert();
  exports.basename = require_basename();
  exports.blend = require_blend();
  exports.blue = require_blue();
  exports.clone = require_clone();
  exports.component = require_component();
  exports.contrast = require_contrast();
  exports.convert = require_convert();
  exports["current-media"] = require_current_media();
  exports.define = require_define();
  exports.dirname = require_dirname();
  exports.error = require_error();
  exports.extname = require_extname();
  exports.green = require_green();
  exports.hsl = require_hsl();
  exports.hsla = require_hsla();
  exports.hue = require_hue();
  exports["image-size"] = require_image_size();
  exports.json = require_json();
  exports.length = require_length();
  exports.lightness = require_lightness();
  exports["list-separator"] = require_list_separator();
  exports.lookup = require_lookup();
  exports.luminosity = require_luminosity();
  exports.match = require_match();
  exports.math = require_math();
  exports.merge = exports.extend = require_merge();
  exports.operate = require_operate();
  exports["opposite-position"] = require_opposite_position();
  exports.p = require_p();
  exports.pathjoin = require_pathjoin();
  exports.pop = require_pop();
  exports.push = exports.append = require_push();
  exports.range = require_range();
  exports.red = require_red();
  exports.remove = require_remove();
  exports.replace = require_replace();
  exports.rgb = require_rgb();
  exports.atan = require_atan();
  exports.asin = require_asin();
  exports.acos = require_acos();
  exports.rgba = require_rgba();
  exports.s = require_s();
  exports.saturation = require_saturation();
  exports["selector-exists"] = require_selector_exists();
  exports.selector = require_selector();
  exports.selectors = require_selectors();
  exports.shift = require_shift();
  exports.split = require_split();
  exports.substr = require_substr();
  exports.slice = require_slice();
  exports.tan = require_tan();
  exports.trace = require_trace();
  exports.transparentify = require_transparentify();
  exports.type = exports.typeof = exports["type-of"] = require_type();
  exports.unit = require_unit();
  exports.unquote = require_unquote();
  exports.unshift = exports.prepend = require_unshift();
  exports.use = require_use();
  exports.warn = require_warn();
  exports["-math-prop"] = require_math_prop();
  exports["-prefix-classes"] = require_prefix_classes();
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  /*!
   * Stylus - colors
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  module.exports = {
    aliceblue: [240, 248, 255, 1],
    antiquewhite: [250, 235, 215, 1],
    aqua: [0, 255, 255, 1],
    aquamarine: [127, 255, 212, 1],
    azure: [240, 255, 255, 1],
    beige: [245, 245, 220, 1],
    bisque: [255, 228, 196, 1],
    black: [0, 0, 0, 1],
    blanchedalmond: [255, 235, 205, 1],
    blue: [0, 0, 255, 1],
    blueviolet: [138, 43, 226, 1],
    brown: [165, 42, 42, 1],
    burlywood: [222, 184, 135, 1],
    cadetblue: [95, 158, 160, 1],
    chartreuse: [127, 255, 0, 1],
    chocolate: [210, 105, 30, 1],
    coral: [255, 127, 80, 1],
    cornflowerblue: [100, 149, 237, 1],
    cornsilk: [255, 248, 220, 1],
    crimson: [220, 20, 60, 1],
    cyan: [0, 255, 255, 1],
    darkblue: [0, 0, 139, 1],
    darkcyan: [0, 139, 139, 1],
    darkgoldenrod: [184, 134, 11, 1],
    darkgray: [169, 169, 169, 1],
    darkgreen: [0, 100, 0, 1],
    darkgrey: [169, 169, 169, 1],
    darkkhaki: [189, 183, 107, 1],
    darkmagenta: [139, 0, 139, 1],
    darkolivegreen: [85, 107, 47, 1],
    darkorange: [255, 140, 0, 1],
    darkorchid: [153, 50, 204, 1],
    darkred: [139, 0, 0, 1],
    darksalmon: [233, 150, 122, 1],
    darkseagreen: [143, 188, 143, 1],
    darkslateblue: [72, 61, 139, 1],
    darkslategray: [47, 79, 79, 1],
    darkslategrey: [47, 79, 79, 1],
    darkturquoise: [0, 206, 209, 1],
    darkviolet: [148, 0, 211, 1],
    deeppink: [255, 20, 147, 1],
    deepskyblue: [0, 191, 255, 1],
    dimgray: [105, 105, 105, 1],
    dimgrey: [105, 105, 105, 1],
    dodgerblue: [30, 144, 255, 1],
    firebrick: [178, 34, 34, 1],
    floralwhite: [255, 250, 240, 1],
    forestgreen: [34, 139, 34, 1],
    fuchsia: [255, 0, 255, 1],
    gainsboro: [220, 220, 220, 1],
    ghostwhite: [248, 248, 255, 1],
    gold: [255, 215, 0, 1],
    goldenrod: [218, 165, 32, 1],
    gray: [128, 128, 128, 1],
    green: [0, 128, 0, 1],
    greenyellow: [173, 255, 47, 1],
    grey: [128, 128, 128, 1],
    honeydew: [240, 255, 240, 1],
    hotpink: [255, 105, 180, 1],
    indianred: [205, 92, 92, 1],
    indigo: [75, 0, 130, 1],
    ivory: [255, 255, 240, 1],
    khaki: [240, 230, 140, 1],
    lavender: [230, 230, 250, 1],
    lavenderblush: [255, 240, 245, 1],
    lawngreen: [124, 252, 0, 1],
    lemonchiffon: [255, 250, 205, 1],
    lightblue: [173, 216, 230, 1],
    lightcoral: [240, 128, 128, 1],
    lightcyan: [224, 255, 255, 1],
    lightgoldenrodyellow: [250, 250, 210, 1],
    lightgray: [211, 211, 211, 1],
    lightgreen: [144, 238, 144, 1],
    lightgrey: [211, 211, 211, 1],
    lightpink: [255, 182, 193, 1],
    lightsalmon: [255, 160, 122, 1],
    lightseagreen: [32, 178, 170, 1],
    lightskyblue: [135, 206, 250, 1],
    lightslategray: [119, 136, 153, 1],
    lightslategrey: [119, 136, 153, 1],
    lightsteelblue: [176, 196, 222, 1],
    lightyellow: [255, 255, 224, 1],
    lime: [0, 255, 0, 1],
    limegreen: [50, 205, 50, 1],
    linen: [250, 240, 230, 1],
    magenta: [255, 0, 255, 1],
    maroon: [128, 0, 0, 1],
    mediumaquamarine: [102, 205, 170, 1],
    mediumblue: [0, 0, 205, 1],
    mediumorchid: [186, 85, 211, 1],
    mediumpurple: [147, 112, 219, 1],
    mediumseagreen: [60, 179, 113, 1],
    mediumslateblue: [123, 104, 238, 1],
    mediumspringgreen: [0, 250, 154, 1],
    mediumturquoise: [72, 209, 204, 1],
    mediumvioletred: [199, 21, 133, 1],
    midnightblue: [25, 25, 112, 1],
    mintcream: [245, 255, 250, 1],
    mistyrose: [255, 228, 225, 1],
    moccasin: [255, 228, 181, 1],
    navajowhite: [255, 222, 173, 1],
    navy: [0, 0, 128, 1],
    oldlace: [253, 245, 230, 1],
    olive: [128, 128, 0, 1],
    olivedrab: [107, 142, 35, 1],
    orange: [255, 165, 0, 1],
    orangered: [255, 69, 0, 1],
    orchid: [218, 112, 214, 1],
    palegoldenrod: [238, 232, 170, 1],
    palegreen: [152, 251, 152, 1],
    paleturquoise: [175, 238, 238, 1],
    palevioletred: [219, 112, 147, 1],
    papayawhip: [255, 239, 213, 1],
    peachpuff: [255, 218, 185, 1],
    peru: [205, 133, 63, 1],
    pink: [255, 192, 203, 1],
    plum: [221, 160, 221, 1],
    powderblue: [176, 224, 230, 1],
    purple: [128, 0, 128, 1],
    red: [255, 0, 0, 1],
    rosybrown: [188, 143, 143, 1],
    royalblue: [65, 105, 225, 1],
    saddlebrown: [139, 69, 19, 1],
    salmon: [250, 128, 114, 1],
    sandybrown: [244, 164, 96, 1],
    seagreen: [46, 139, 87, 1],
    seashell: [255, 245, 238, 1],
    sienna: [160, 82, 45, 1],
    silver: [192, 192, 192, 1],
    skyblue: [135, 206, 235, 1],
    slateblue: [106, 90, 205, 1],
    slategray: [112, 128, 144, 1],
    slategrey: [112, 128, 144, 1],
    snow: [255, 250, 250, 1],
    springgreen: [0, 255, 127, 1],
    steelblue: [70, 130, 180, 1],
    tan: [210, 180, 140, 1],
    teal: [0, 128, 128, 1],
    thistle: [216, 191, 216, 1],
    tomato: [255, 99, 71, 1],
    transparent: [0, 0, 0, 0],
    turquoise: [64, 224, 208, 1],
    violet: [238, 130, 238, 1],
    wheat: [245, 222, 179, 1],
    white: [255, 255, 255, 1],
    whitesmoke: [245, 245, 245, 1],
    yellow: [255, 255, 0, 1],
    yellowgreen: [154, 205, 50, 1],
    rebeccapurple: [102, 51, 153, 1]
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/debug@4.3.4/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common2 = __commonJS((exports, module) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error(`Cannot require module "supports-color"`);})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/url.js
var require_url = __commonJS((exports, module) => {
  /*!
   * Stylus - plugin - url
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Compiler = require_compiler();
  var events = require_renderer().events;
  var nodes = require_nodes();
  var parse = __require("url").parse;
  var extname = __require("path").extname;
  var utils = require_utils();
  var fs = __require("fs");
  var defaultMimes = {
    ".gif": "image/gif",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".svg": "image/svg+xml",
    ".webp": "image/webp",
    ".ttf": "application/x-font-ttf",
    ".eot": "application/vnd.ms-fontobject",
    ".woff": "application/font-woff",
    ".woff2": "application/font-woff2"
  };
  var encodingTypes = {
    BASE_64: "base64",
    UTF8: "charset=utf-8"
  };
  module.exports = function(options) {
    options = options || {};
    var _paths = options.paths || [];
    var sizeLimit = options.limit != null ? options.limit : 30000;
    var mimes = options.mimes || defaultMimes;
    function fn(url, enc) {
      var compiler = new Compiler(url), encoding = encodingTypes.BASE_64;
      compiler.isURL = true;
      url = url.nodes.map(function(node) {
        return compiler.visit(node);
      }).join("");
      url = parse(url);
      var ext = extname(url.pathname || ""), mime = mimes[ext], hash = url.hash || "", literal = new nodes.Literal('url("' + url.href + '")'), paths = _paths.concat(this.paths), buf, result;
      if (!mime)
        return literal;
      if (url.protocol)
        return literal;
      var found = utils.lookup(url.pathname, paths);
      if (!found) {
        events.emit("file not found", "File " + literal + " could not be found, literal url retained!");
        return literal;
      }
      buf = fs.readFileSync(found);
      if (sizeLimit !== false && buf.length > sizeLimit)
        return literal;
      if (enc && enc.first.val.toLowerCase() == "utf8") {
        encoding = encodingTypes.UTF8;
        result = buf.toString().replace(/\s+/g, " ").replace(/[{}\|\\\^~\[\]`"<>#%]/g, function(match) {
          return "%" + match[0].charCodeAt(0).toString(16).toUpperCase();
        }).trim();
      } else {
        result = buf.toString(encoding) + hash;
      }
      return new nodes.Literal('url("data:' + mime + ";" + encoding + "," + result + '")');
    }
    fn.raw = true;
    return fn;
  };
  module.exports.mimes = defaultMimes;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/visitor/evaluator.js
var require_evaluator = __commonJS((exports, module) => {
  var importFile = function(node, file, literal) {
    var importStack = this.importStack, Parser = require_parser(), stat;
    if (node.once) {
      if (this.requireHistory[file])
        return nodes.null;
      this.requireHistory[file] = true;
      if (literal && !this.includeCSS) {
        return node;
      }
    }
    if (~importStack.indexOf(file))
      throw new Error("import loop has been found");
    var str = fs.readFileSync(file, "utf8");
    if (!str.trim())
      return nodes.null;
    node.path = file;
    node.dirname = dirname(file);
    stat = fs.statSync(file);
    node.mtime = stat.mtime;
    this.paths.push(node.dirname);
    if (this.options._imports)
      this.options._imports.push(node.clone());
    importStack.push(file);
    nodes.filename = file;
    if (literal) {
      literal = new nodes.Literal(str.replace(/\r\n?/g, "\n"));
      literal.lineno = literal.column = 1;
      if (!this.resolveURL)
        return literal;
    }
    var block = new nodes.Block, parser = new Parser(str, utils.merge({ root: block }, this.options));
    try {
      block = parser.parse();
    } catch (err) {
      var line = parser.lexer.lineno, column = parser.lexer.column;
      if (literal && this.includeCSS && this.resolveURL) {
        this.warn("ParseError: " + file + ":" + line + ":" + column + ". This file included as-is");
        return literal;
      } else {
        err.filename = file;
        err.lineno = line;
        err.column = column;
        err.input = str;
        throw err;
      }
    }
    block = block.clone(this.currentBlock);
    block.parent = this.currentBlock;
    block.scope = false;
    var ret = this.visit(block);
    importStack.pop();
    if (!this.resolveURL || this.resolveURL.nocheck)
      this.paths.pop();
    return ret;
  };
  /*!
   * Stylus - Evaluator
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Visitor = require_visitor();
  var units = require_units();
  var nodes = require_nodes();
  var Stack = require_stack();
  var Frame = require_frame();
  var utils = require_utils();
  var bifs = require_functions();
  var dirname = __require("path").dirname;
  var colors = require_colors();
  var debug = require_src()("stylus:evaluator");
  var fs = __require("fs");
  var Evaluator = module.exports = function Evaluator(root, options) {
    options = options || {};
    Visitor.call(this, root);
    var functions = this.functions = options.functions || {};
    this.stack = new Stack;
    this.imports = options.imports || [];
    this.globals = options.globals || {};
    this.paths = options.paths || [];
    this.prefix = options.prefix || "";
    this.filename = options.filename;
    this.includeCSS = options["include css"];
    this.resolveURL = functions.url && functions.url.name == "resolver" && functions.url.options;
    this.paths.push(dirname(options.filename || "."));
    this.stack.push(this.global = new Frame(root));
    this.warnings = options.warn;
    this.options = options;
    this.calling = [];
    this.importStack = [];
    this.requireHistory = {};
    this.return = 0;
  };
  Evaluator.prototype.__proto__ = Visitor.prototype;
  var visit = Visitor.prototype.visit;
  Evaluator.prototype.visit = function(node) {
    try {
      return visit.call(this, node);
    } catch (err) {
      if (err.filename)
        throw err;
      err.lineno = node.lineno;
      err.column = node.column;
      err.filename = node.filename;
      err.stylusStack = this.stack.toString();
      try {
        err.input = fs.readFileSync(err.filename, "utf8");
      } catch (err2) {
      }
      throw err;
    }
  };
  Evaluator.prototype.setup = function() {
    var root = this.root;
    var imports = [];
    this.populateGlobalScope();
    this.imports.forEach(function(file) {
      var expr = new nodes.Expression;
      expr.push(new nodes.String(file));
      imports.push(new nodes.Import(expr));
    }, this);
    root.nodes = imports.concat(root.nodes);
  };
  Evaluator.prototype.populateGlobalScope = function() {
    var scope = this.global.scope;
    Object.keys(colors).forEach(function(name) {
      var color = colors[name], rgba = new nodes.RGBA(color[0], color[1], color[2], color[3]), node = new nodes.Ident(name, rgba);
      rgba.name = name;
      scope.add(node);
    });
    scope.add(new nodes.Ident("embedurl", new nodes.Function("embedurl", require_url()({
      limit: false
    }))));
    var globals = this.globals;
    Object.keys(globals).forEach(function(name) {
      var val = globals[name];
      if (!val.nodeName)
        val = new nodes.Literal(val);
      scope.add(new nodes.Ident(name, val));
    });
  };
  Evaluator.prototype.evaluate = function() {
    debug("eval %s", this.filename);
    this.setup();
    return this.visit(this.root);
  };
  Evaluator.prototype.visitGroup = function(group) {
    group.nodes = group.nodes.map(function(selector) {
      selector.val = this.interpolate(selector);
      debug("ruleset %s", selector.val);
      return selector;
    }, this);
    group.block = this.visit(group.block);
    return group;
  };
  Evaluator.prototype.visitReturn = function(ret) {
    ret.expr = this.visit(ret.expr);
    throw ret;
  };
  Evaluator.prototype.visitMedia = function(media) {
    media.block = this.visit(media.block);
    media.val = this.visit(media.val);
    return media;
  };
  Evaluator.prototype.visitQueryList = function(queries) {
    var val, query;
    queries.nodes.forEach(this.visit, this);
    if (queries.nodes.length == 1) {
      query = queries.nodes[0];
      if (val = this.lookup(query.type)) {
        val = val.first.string;
        if (!val)
          return queries;
        var Parser = require_parser(), parser = new Parser(val, this.options);
        queries = this.visit(parser.queries());
      }
    }
    return queries;
  };
  Evaluator.prototype.visitQuery = function(node) {
    node.predicate = this.visit(node.predicate);
    node.type = this.visit(node.type);
    node.nodes.forEach(this.visit, this);
    return node;
  };
  Evaluator.prototype.visitFeature = function(node) {
    node.name = this.interpolate(node);
    if (node.expr) {
      this.return++;
      node.expr = this.visit(node.expr);
      this.return--;
    }
    return node;
  };
  Evaluator.prototype.visitObject = function(obj) {
    for (var key in obj.vals) {
      obj.vals[key] = this.visit(obj.vals[key]);
    }
    return obj;
  };
  Evaluator.prototype.visitMember = function(node) {
    var { left, right } = node, obj = this.visit(left).first;
    if (obj.nodeName != "object") {
      throw new Error(left.toString() + " has no property ." + right);
    }
    if (node.val) {
      this.return++;
      obj.set(right.name, this.visit(node.val));
      this.return--;
    }
    return obj.get(right.name);
  };
  Evaluator.prototype.visitKeyframes = function(keyframes) {
    var val;
    if (keyframes.fabricated)
      return keyframes;
    keyframes.val = this.interpolate(keyframes).trim();
    if (val = this.lookup(keyframes.val)) {
      keyframes.val = val.first.string || val.first.name;
    }
    keyframes.block = this.visit(keyframes.block);
    if (keyframes.prefix != "official")
      return keyframes;
    this.vendors.forEach(function(prefix) {
      if (prefix == "ms")
        return;
      var node = keyframes.clone();
      node.val = keyframes.val;
      node.prefix = prefix;
      node.block = keyframes.block;
      node.fabricated = true;
      this.currentBlock.push(node);
    }, this);
    return nodes.null;
  };
  Evaluator.prototype.visitFunction = function(fn) {
    var local = this.stack.currentFrame.scope.lookup(fn.name);
    if (local)
      this.warn("local " + local.nodeName + ' "' + fn.name + '" previously defined in this scope');
    var user = this.functions[fn.name];
    if (user)
      this.warn('user-defined function "' + fn.name + '" is already defined');
    var bif = bifs[fn.name];
    if (bif)
      this.warn('built-in function "' + fn.name + '" is already defined');
    return fn;
  };
  Evaluator.prototype.visitEach = function(each) {
    this.return++;
    var expr = utils.unwrap(this.visit(each.expr)), len = expr.nodes.length, val = new nodes.Ident(each.val), key = new nodes.Ident(each.key || "__index__"), scope = this.currentScope, block = this.currentBlock, vals = [], self2 = this, body, obj;
    this.return--;
    each.block.scope = false;
    function visitBody(key2, val2) {
      scope.add(val2);
      scope.add(key2);
      body = self2.visit(each.block.clone());
      vals = vals.concat(body.nodes);
    }
    if (len == 1 && expr.nodes[0].nodeName == "object") {
      obj = expr.nodes[0];
      for (var prop in obj.vals) {
        val.val = new nodes.String(prop);
        key.val = obj.get(prop);
        visitBody(key, val);
      }
    } else {
      for (var i = 0;i < len; ++i) {
        val.val = expr.nodes[i];
        key.val = new nodes.Unit(i);
        visitBody(key, val);
      }
    }
    this.mixin(vals, block);
    return vals[vals.length - 1] || nodes.null;
  };
  Evaluator.prototype.visitCall = function(call) {
    debug("call %s", call);
    var fn = this.lookup(call.name), literal, ret;
    this.ignoreColors = call.name == "url";
    if (fn && fn.nodeName == "expression") {
      fn = fn.nodes[0];
    }
    if (fn && fn.nodeName != "function") {
      fn = this.lookupFunction(call.name);
    }
    if (!fn || fn.nodeName != "function") {
      debug("%s is undefined", call);
      if (this.unvendorize(call.name) == "calc") {
        literal = call.args.nodes && call.args.nodes[0];
        if (literal)
          ret = new nodes.Literal(call.name + literal);
      } else {
        ret = this.literalCall(call);
      }
      this.ignoreColors = false;
      return ret;
    }
    this.calling.push(call.name);
    if (this.calling.length > 200) {
      throw new RangeError("Maximum stylus call stack size exceeded");
    }
    if (fn.nodeName == "expression")
      fn = fn.first;
    this.return++;
    var args = this.visit(call.args);
    for (var key in args.map) {
      args.map[key] = this.visit(args.map[key].clone());
    }
    this.return--;
    if (fn.fn) {
      debug("%s is built-in", call);
      ret = this.invokeBuiltin(fn.fn, args);
    } else if (fn.nodeName == "function") {
      debug("%s is user-defined", call);
      if (call.block)
        call.block = this.visit(call.block);
      ret = this.invokeFunction(fn, args, call.block);
    }
    this.calling.pop();
    this.ignoreColors = false;
    return ret;
  };
  Evaluator.prototype.visitIdent = function(ident) {
    var prop;
    if (ident.property) {
      if (prop = this.lookupProperty(ident.name)) {
        return this.visit(prop.expr.clone());
      }
      return nodes.null;
    } else if (ident.val.isNull) {
      var val = this.lookup(ident.name);
      if (val && ident.mixin)
        this.mixinNode(val);
      return val ? this.visit(val) : ident;
    } else {
      this.return++;
      ident.val = this.visit(ident.val);
      this.return--;
      this.currentScope.add(ident);
      return ident.val;
    }
  };
  Evaluator.prototype.visitBinOp = function(binop) {
    if (binop.op == "is defined")
      return this.isDefined(binop.left);
    this.return++;
    var op = binop.op, left = this.visit(binop.left), right = op == "||" || op == "&&" ? binop.right : this.visit(binop.right);
    var val = binop.val ? this.visit(binop.val) : null;
    this.return--;
    try {
      return this.visit(left.operate(op, right, val));
    } catch (err) {
      if (err.name == "CoercionError") {
        switch (op) {
          case "==":
            return nodes.false;
          case "!=":
            return nodes.true;
        }
      }
      throw err;
    }
  };
  Evaluator.prototype.visitUnaryOp = function(unary) {
    var op = unary.op, node = this.visit(unary.expr);
    if (op != "!") {
      node = node.first.clone();
      utils.assertType(node, "unit");
    }
    switch (op) {
      case "-":
        node.val = -node.val;
        break;
      case "+":
        node.val = +node.val;
        break;
      case "~":
        node.val = ~node.val;
        break;
      case "!":
        return node.toBoolean().negate();
    }
    return node;
  };
  Evaluator.prototype.visitTernary = function(ternary) {
    var ok = this.visit(ternary.cond).toBoolean();
    return ok.isTrue ? this.visit(ternary.trueExpr) : this.visit(ternary.falseExpr);
  };
  Evaluator.prototype.visitExpression = function(expr) {
    for (var i = 0, len = expr.nodes.length;i < len; ++i) {
      expr.nodes[i] = this.visit(expr.nodes[i]);
    }
    if (this.castable(expr))
      expr = this.cast(expr);
    return expr;
  };
  Evaluator.prototype.visitArguments = Evaluator.prototype.visitExpression;
  Evaluator.prototype.visitProperty = function(prop) {
    var name = this.interpolate(prop), fn = this.lookup(name), call = fn && fn.first.nodeName == "function", literal = ~this.calling.indexOf(name), _prop = this.property;
    if (call && !literal && !prop.literal) {
      var args = nodes.Arguments.fromExpression(utils.unwrap(prop.expr.clone()));
      prop.name = name;
      this.property = prop;
      this.return++;
      this.property.expr = this.visit(prop.expr);
      this.return--;
      var ret = this.visit(new nodes.Call(name, args));
      this.property = _prop;
      return ret;
    } else {
      this.return++;
      prop.name = name;
      prop.literal = true;
      this.property = prop;
      prop.expr = this.visit(prop.expr);
      this.property = _prop;
      this.return--;
      return prop;
    }
  };
  Evaluator.prototype.visitRoot = function(block) {
    if (block != this.root) {
      block.constructor = nodes.Block;
      return this.visit(block);
    }
    for (var i = 0;i < block.nodes.length; ++i) {
      block.index = i;
      block.nodes[i] = this.visit(block.nodes[i]);
    }
    return block;
  };
  Evaluator.prototype.visitBlock = function(block) {
    this.stack.push(new Frame(block));
    for (block.index = 0;block.index < block.nodes.length; ++block.index) {
      try {
        block.nodes[block.index] = this.visit(block.nodes[block.index]);
      } catch (err) {
        if (err.nodeName == "return") {
          if (this.return) {
            this.stack.pop();
            throw err;
          } else {
            block.nodes[block.index] = err;
            break;
          }
        } else {
          throw err;
        }
      }
    }
    this.stack.pop();
    return block;
  };
  Evaluator.prototype.visitAtblock = function(atblock) {
    atblock.block = this.visit(atblock.block);
    return atblock;
  };
  Evaluator.prototype.visitAtrule = function(atrule) {
    atrule.val = this.interpolate(atrule);
    if (atrule.block)
      atrule.block = this.visit(atrule.block);
    return atrule;
  };
  Evaluator.prototype.visitSupports = function(node) {
    var condition = node.condition, val;
    this.return++;
    node.condition = this.visit(condition);
    this.return--;
    val = condition.first;
    if (condition.nodes.length == 1 && val.nodeName == "string") {
      node.condition = val.string;
    }
    node.block = this.visit(node.block);
    return node;
  };
  Evaluator.prototype.visitIf = function(node) {
    var ret, block = this.currentBlock, negate = node.negate;
    this.return++;
    var ok = this.visit(node.cond).first.toBoolean();
    this.return--;
    node.block.scope = node.block.hasMedia;
    if (negate) {
      if (ok.isFalse) {
        ret = this.visit(node.block);
      }
    } else {
      if (ok.isTrue) {
        ret = this.visit(node.block);
      } else if (node.elses.length) {
        var elses = node.elses, len = elses.length, cond;
        for (var i = 0;i < len; ++i) {
          if (elses[i].cond) {
            elses[i].block.scope = elses[i].block.hasMedia;
            this.return++;
            cond = this.visit(elses[i].cond).first.toBoolean();
            this.return--;
            if (cond.isTrue) {
              ret = this.visit(elses[i].block);
              break;
            }
          } else {
            elses[i].scope = elses[i].hasMedia;
            ret = this.visit(elses[i]);
          }
        }
      }
    }
    if (ret && !node.postfix && block.node && ~[
      "group",
      "atrule",
      "media",
      "supports",
      "keyframes"
    ].indexOf(block.node.nodeName)) {
      this.mixin(ret.nodes, block);
      return nodes.null;
    }
    return ret || nodes.null;
  };
  Evaluator.prototype.visitExtend = function(extend) {
    var block = this.currentBlock;
    if (block.node.nodeName != "group")
      block = this.closestGroup;
    extend.selectors.forEach(function(selector) {
      block.node.extends.push({
        selector: this.interpolate(selector.clone()).trim(),
        optional: selector.optional,
        lineno: selector.lineno,
        column: selector.column
      });
    }, this);
    return nodes.null;
  };
  Evaluator.prototype.visitImport = function(imported) {
    this.return++;
    var path = this.visit(imported.path).first, nodeName = imported.once ? "require" : "import", found, literal;
    this.return--;
    debug("import %s", path);
    if (path.name == "url") {
      if (imported.once)
        throw new Error("You cannot @require a url");
      return imported;
    }
    if (!path.string)
      throw new Error("@" + nodeName + " string expected");
    var name = path = path.string;
    if (/(?:url\s*\(\s*)?['"]?(?:#|(?:https?:)?\/\/)/i.test(path)) {
      if (imported.once)
        throw new Error("You cannot @require a url");
      return imported;
    }
    if (/\.css(?:"|$)/.test(path)) {
      literal = true;
      if (!imported.once && !this.includeCSS) {
        return imported;
      }
    }
    if (!literal && !/\.styl$/i.test(path))
      path += ".styl";
    found = utils.find(path, this.paths, this.filename);
    if (!found) {
      found = utils.lookupIndex(name, this.paths, this.filename);
    }
    if (!found)
      throw new Error("failed to locate @" + nodeName + " file " + path);
    var block = new nodes.Block;
    for (var i = 0, len = found.length;i < len; ++i) {
      block.push(importFile.call(this, imported, found[i], literal));
    }
    return block;
  };
  Evaluator.prototype.invokeFunction = function(fn, args, content) {
    var block = new nodes.Block(fn.block.parent);
    var body = fn.block.clone(block);
    var mixinBlock = this.stack.currentFrame.block;
    this.stack.push(new Frame(block));
    var scope = this.currentScope;
    if (args.nodeName != "arguments") {
      var expr = new nodes.Expression;
      expr.push(args);
      args = nodes.Arguments.fromExpression(expr);
    }
    scope.add(new nodes.Ident("arguments", args));
    scope.add(new nodes.Ident("mixin", this.return ? nodes.false : new nodes.String(mixinBlock.nodeName)));
    if (this.property) {
      var prop = this.propertyExpression(this.property, fn.name);
      scope.add(new nodes.Ident("current-property", prop));
    } else {
      scope.add(new nodes.Ident("current-property", nodes.null));
    }
    var expr = new nodes.Expression;
    for (var i = this.calling.length - 1;i--; ) {
      expr.push(new nodes.Literal(this.calling[i]));
    }
    scope.add(new nodes.Ident("called-from", expr));
    var i = 0, len = args.nodes.length;
    fn.params.nodes.forEach(function(node) {
      if (node.rest) {
        node.val = new nodes.Expression;
        for (;i < len; ++i)
          node.val.push(args.nodes[i]);
        node.val.preserve = true;
        node.val.isList = args.isList;
      } else {
        var arg = args.map[node.name] || args.nodes[i++];
        node = node.clone();
        if (arg) {
          arg.isEmpty ? args.nodes[i - 1] = this.visit(node) : node.val = arg;
        } else {
          args.push(node.val);
        }
        if (node.val.isNull) {
          throw new Error('argument "' + node + '" required for ' + fn);
        }
      }
      scope.add(node);
    }, this);
    if (content)
      scope.add(new nodes.Ident("block", content, true));
    return this.invoke(body, true, fn.filename);
  };
  Evaluator.prototype.invokeBuiltin = function(fn, args) {
    if (fn.raw) {
      args = args.nodes;
    } else {
      if (!fn.params) {
        fn.params = utils.params(fn);
      }
      args = fn.params.reduce(function(ret, param) {
        var arg = args.map[param] || args.nodes.shift();
        if (arg) {
          arg = utils.unwrap(arg);
          var len = arg.nodes.length;
          if (len > 1) {
            for (var i = 0;i < len; ++i) {
              ret.push(utils.unwrap(arg.nodes[i].first));
            }
          } else {
            ret.push(arg.first);
          }
        }
        return ret;
      }, []);
    }
    var body = utils.coerce(fn.apply(this, args));
    var expr = new nodes.Expression;
    expr.push(body);
    body = expr;
    return this.invoke(body);
  };
  Evaluator.prototype.invoke = function(body, stack, filename) {
    var self2 = this, ret;
    if (filename)
      this.paths.push(dirname(filename));
    if (this.return) {
      ret = this.eval(body.nodes);
      if (stack)
        this.stack.pop();
    } else {
      body = this.visit(body);
      if (stack)
        this.stack.pop();
      this.mixin(body.nodes, this.currentBlock);
      ret = nodes.null;
    }
    if (filename)
      this.paths.pop();
    return ret;
  };
  Evaluator.prototype.mixin = function(nodes2, block) {
    if (!nodes2.length)
      return;
    var len = block.nodes.length, head = block.nodes.slice(0, block.index), tail = block.nodes.slice(block.index + 1, len);
    this._mixin(nodes2, head, block);
    block.index = 0;
    block.nodes = head.concat(tail);
  };
  Evaluator.prototype._mixin = function(items, dest, block) {
    var node, len = items.length;
    for (var i = 0;i < len; ++i) {
      switch ((node = items[i]).nodeName) {
        case "return":
          return;
        case "block":
          this._mixin(node.nodes, dest, block);
          break;
        case "media":
          var parentNode = node.block.parent.node;
          if (parentNode && parentNode.nodeName != "call") {
            node.block.parent = block;
          }
        case "property":
          var val = node.expr;
          if (node.literal && val.first.name == "block") {
            val = utils.unwrap(val);
            val.nodes[0] = new nodes.Literal("block");
          }
        default:
          dest.push(node);
      }
    }
  };
  Evaluator.prototype.mixinNode = function(node) {
    node = this.visit(node.first);
    switch (node.nodeName) {
      case "object":
        this.mixinObject(node);
        return nodes.null;
      case "block":
      case "atblock":
        this.mixin(node.nodes, this.currentBlock);
        return nodes.null;
    }
  };
  Evaluator.prototype.mixinObject = function(object) {
    var Parser = require_parser(), root = this.root, str = "$block " + object.toBlock(), parser = new Parser(str, utils.merge({ root: block }, this.options)), block;
    try {
      block = parser.parse();
    } catch (err) {
      err.filename = this.filename;
      err.lineno = parser.lexer.lineno;
      err.column = parser.lexer.column;
      err.input = str;
      throw err;
    }
    block.parent = root;
    block.scope = false;
    var ret = this.visit(block), vals = ret.first.nodes;
    for (var i = 0, len = vals.length;i < len; ++i) {
      if (vals[i].block) {
        this.mixin(vals[i].block.nodes, this.currentBlock);
        break;
      }
    }
  };
  Evaluator.prototype.eval = function(vals) {
    if (!vals)
      return nodes.null;
    var len = vals.length, node = nodes.null;
    try {
      for (var i = 0;i < len; ++i) {
        node = vals[i];
        switch (node.nodeName) {
          case "if":
            if (node.block.nodeName != "block") {
              node = this.visit(node);
              break;
            }
          case "each":
          case "block":
            node = this.visit(node);
            if (node.nodes)
              node = this.eval(node.nodes);
            break;
          default:
            node = this.visit(node);
        }
      }
    } catch (err) {
      if (err.nodeName == "return") {
        return err.expr;
      } else {
        throw err;
      }
    }
    return node;
  };
  Evaluator.prototype.literalCall = function(call) {
    call.args = this.visit(call.args);
    return call;
  };
  Evaluator.prototype.lookupProperty = function(name) {
    var i = this.stack.length, index = this.currentBlock.index, top = i, nodes2, block, len, other;
    while (i--) {
      block = this.stack[i].block;
      if (!block.node)
        continue;
      switch (block.node.nodeName) {
        case "group":
        case "function":
        case "if":
        case "each":
        case "atrule":
        case "media":
        case "atblock":
        case "call":
          nodes2 = block.nodes;
          if (i + 1 == top) {
            while (index--) {
              if (this.property == nodes2[index])
                continue;
              other = this.interpolate(nodes2[index]);
              if (name == other)
                return nodes2[index].clone();
            }
          } else {
            len = nodes2.length;
            while (len--) {
              if (nodes2[len].nodeName != "property" || this.property == nodes2[len])
                continue;
              other = this.interpolate(nodes2[len]);
              if (name == other)
                return nodes2[len].clone();
            }
          }
          break;
      }
    }
    return nodes2.null;
  };
  Evaluator.prototype.__defineGetter__("closestBlock", function() {
    var i = this.stack.length, block;
    while (i--) {
      block = this.stack[i].block;
      if (block.node) {
        switch (block.node.nodeName) {
          case "group":
          case "keyframes":
          case "atrule":
          case "atblock":
          case "media":
          case "call":
            return block;
        }
      }
    }
  });
  Evaluator.prototype.__defineGetter__("closestGroup", function() {
    var i = this.stack.length, block;
    while (i--) {
      block = this.stack[i].block;
      if (block.node && block.node.nodeName == "group") {
        return block;
      }
    }
  });
  Evaluator.prototype.__defineGetter__("selectorStack", function() {
    var block, stack = [];
    for (var i = 0, len = this.stack.length;i < len; ++i) {
      block = this.stack[i].block;
      if (block.node && block.node.nodeName == "group") {
        block.node.nodes.forEach(function(selector) {
          if (!selector.val)
            selector.val = this.interpolate(selector);
        }, this);
        stack.push(block.node.nodes);
      }
    }
    return stack;
  });
  Evaluator.prototype.lookup = function(name) {
    var val;
    if (this.ignoreColors && name in colors)
      return;
    if (val = this.stack.lookup(name)) {
      return utils.unwrap(val);
    } else {
      return this.lookupFunction(name);
    }
  };
  Evaluator.prototype.interpolate = function(node) {
    var self2 = this, isSelector = node.nodeName == "selector";
    function toString(node2) {
      switch (node2.nodeName) {
        case "function":
        case "ident":
          return node2.name;
        case "literal":
        case "string":
          if (self2.prefix && !node2.prefixed && !node2.val.nodeName) {
            node2.val = node2.val.replace(/\.(?=[\w-])|^\.$/g, "." + self2.prefix);
            node2.prefixed = true;
          }
          return node2.val;
        case "unit":
          return node2.type == "%" ? node2.val + "%" : node2.val;
        case "member":
          return toString(self2.visit(node2));
        case "expression":
          if (self2.calling && ~self2.calling.indexOf("selector") && self2._selector)
            return self2._selector;
          self2.return++;
          var ret = toString(self2.visit(node2).first);
          self2.return--;
          if (isSelector)
            self2._selector = ret;
          return ret;
      }
    }
    if (node.segments) {
      return node.segments.map(toString).join("");
    } else {
      return toString(node);
    }
  };
  Evaluator.prototype.lookupFunction = function(name) {
    var fn = this.functions[name] || bifs[name];
    if (fn)
      return new nodes.Function(name, fn);
  };
  Evaluator.prototype.isDefined = function(node) {
    if (node.nodeName == "ident") {
      return nodes.Boolean(this.lookup(node.name));
    } else {
      throw new Error('invalid "is defined" check on non-variable ' + node);
    }
  };
  Evaluator.prototype.propertyExpression = function(prop, name) {
    var expr = new nodes.Expression, val = prop.expr.clone();
    expr.push(new nodes.String(prop.name));
    function replace(node) {
      if (node.nodeName == "call" && name == node.name) {
        return new nodes.Literal("__CALL__");
      }
      if (node.nodes)
        node.nodes = node.nodes.map(replace);
      return node;
    }
    replace(val);
    expr.push(val);
    return expr;
  };
  Evaluator.prototype.cast = function(expr) {
    return new nodes.Unit(expr.first.val, expr.nodes[1].name);
  };
  Evaluator.prototype.castable = function(expr) {
    return expr.nodes.length == 2 && expr.first.nodeName == "unit" && ~units.indexOf(expr.nodes[1].name);
  };
  Evaluator.prototype.warn = function(msg) {
    if (!this.warnings)
      return;
    console.warn("\x1B[33mWarning:\x1B[0m " + msg);
  };
  Evaluator.prototype.__defineGetter__("currentBlock", function() {
    return this.stack.currentFrame.block;
  });
  Evaluator.prototype.__defineGetter__("vendors", function() {
    return this.lookup("vendors").nodes.map(function(node) {
      return node.string;
    });
  });
  Evaluator.prototype.unvendorize = function(prop) {
    for (var i = 0, len = this.vendors.length;i < len; i++) {
      if (this.vendors[i] != "official") {
        var vendor = "-" + this.vendors[i] + "-";
        if (~prop.indexOf(vendor))
          return prop.replace(vendor, "");
      }
    }
    return prop;
  };
  Evaluator.prototype.__defineGetter__("currentScope", function() {
    return this.stack.currentFrame.scope;
  });
  Evaluator.prototype.__defineGetter__("currentFrame", function() {
    return this.stack.currentFrame;
  });
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/node.js
var require_node2 = __commonJS((exports, module) => {
  var CoercionError = function(msg) {
    this.name = "CoercionError";
    this.message = msg;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CoercionError);
    }
  };
  /*!
   * Stylus - Node
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Evaluator = require_evaluator();
  var utils = require_utils();
  var nodes = require_nodes();
  CoercionError.prototype.__proto__ = Error.prototype;
  var Node = module.exports = function Node() {
    this.lineno = nodes.lineno || 1;
    this.column = nodes.column || 1;
    this.filename = nodes.filename;
  };
  Node.prototype = {
    constructor: Node,
    get first() {
      return this;
    },
    get hash() {
      return this.val;
    },
    get nodeName() {
      return this.constructor.name.toLowerCase();
    },
    clone: function() {
      return this;
    },
    toJSON: function() {
      return {
        lineno: this.lineno,
        column: this.column,
        filename: this.filename
      };
    },
    eval: function() {
      return new Evaluator(this).evaluate();
    },
    toBoolean: function() {
      return nodes.true;
    },
    toExpression: function() {
      if (this.nodeName == "expression")
        return this;
      var expr = new nodes.Expression;
      expr.push(this);
      return expr;
    },
    shouldCoerce: function(op) {
      switch (op) {
        case "is a":
        case "in":
        case "||":
        case "&&":
          return false;
        default:
          return true;
      }
    },
    operate: function(op, right) {
      switch (op) {
        case "is a":
          if (right.first.nodeName == "string") {
            return nodes.Boolean(this.nodeName == right.val);
          } else {
            throw new Error('"is a" expects a string, got ' + right.toString());
          }
        case "==":
          return nodes.Boolean(this.hash == right.hash);
        case "!=":
          return nodes.Boolean(this.hash != right.hash);
        case ">=":
          return nodes.Boolean(this.hash >= right.hash);
        case "<=":
          return nodes.Boolean(this.hash <= right.hash);
        case ">":
          return nodes.Boolean(this.hash > right.hash);
        case "<":
          return nodes.Boolean(this.hash < right.hash);
        case "||":
          return this.toBoolean().isTrue ? this : right;
        case "in":
          var vals = utils.unwrap(right).nodes, len = vals && vals.length, hash = this.hash;
          if (!vals)
            throw new Error('"in" given invalid right-hand operand, expecting an expression');
          if (len == 1 && vals[0].nodeName == "object") {
            return nodes.Boolean(vals[0].has(this.hash));
          }
          for (var i = 0;i < len; ++i) {
            if (hash == vals[i].hash) {
              return nodes.true;
            }
          }
          return nodes.false;
        case "&&":
          var a = this.toBoolean(), b = right.toBoolean();
          return a.isTrue && b.isTrue ? right : a.isFalse ? this : right;
        default:
          if (op == "[]") {
            var msg = "cannot perform " + this + "[" + right + "]";
          } else {
            var msg = "cannot perform " + this + " " + op + " " + right;
          }
          throw new Error(msg);
      }
    },
    coerce: function(other) {
      if (other.nodeName == this.nodeName)
        return other;
      throw new CoercionError("cannot coerce " + other + " to " + this.nodeName);
    }
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/root.js
var require_root = __commonJS((exports, module) => {
  /*!
   * Stylus - Root
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Root = module.exports = function Root() {
    this.nodes = [];
  };
  Root.prototype.__proto__ = Node.prototype;
  Root.prototype.push = function(node) {
    this.nodes.push(node);
  };
  Root.prototype.unshift = function(node) {
    this.nodes.unshift(node);
  };
  Root.prototype.clone = function() {
    var clone = new Root;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    this.nodes.forEach(function(node) {
      clone.push(node.clone(clone, clone));
    });
    return clone;
  };
  Root.prototype.toString = function() {
    return "[Root]";
  };
  Root.prototype.toJSON = function() {
    return {
      __type: "Root",
      nodes: this.nodes,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/null.js
var require_null = __commonJS((exports, module) => {
  /*!
   * Stylus - Null
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var Null = module.exports = function Null() {
  };
  Null.prototype.__proto__ = Node.prototype;
  Null.prototype.inspect = Null.prototype.toString = function() {
    return "null";
  };
  Null.prototype.toBoolean = function() {
    return nodes.false;
  };
  Null.prototype.__defineGetter__("isNull", function() {
    return true;
  });
  Null.prototype.__defineGetter__("hash", function() {
    return null;
  });
  Null.prototype.toJSON = function() {
    return {
      __type: "Null",
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/each.js
var require_each = __commonJS((exports, module) => {
  /*!
   * Stylus - Each
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var Each = module.exports = function Each(val, key, expr, block) {
    Node.call(this);
    this.val = val;
    this.key = key;
    this.expr = expr;
    this.block = block;
  };
  Each.prototype.__proto__ = Node.prototype;
  Each.prototype.clone = function(parent) {
    var clone = new Each(this.val, this.key);
    clone.expr = this.expr.clone(parent, clone);
    clone.block = this.block.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Each.prototype.toJSON = function() {
    return {
      __type: "Each",
      val: this.val,
      key: this.key,
      expr: this.expr,
      block: this.block,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/if.js
var require_if = __commonJS((exports, module) => {
  /*!
   * Stylus - If
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var If = module.exports = function If(cond, negate) {
    Node.call(this);
    this.cond = cond;
    this.elses = [];
    if (negate && negate.nodeName) {
      this.block = negate;
    } else {
      this.negate = negate;
    }
  };
  If.prototype.__proto__ = Node.prototype;
  If.prototype.clone = function(parent) {
    var clone = new If;
    clone.cond = this.cond.clone(parent, clone);
    clone.block = this.block.clone(parent, clone);
    clone.elses = this.elses.map(function(node) {
      return node.clone(parent, clone);
    });
    clone.negate = this.negate;
    clone.postfix = this.postfix;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  If.prototype.toJSON = function() {
    return {
      __type: "If",
      cond: this.cond,
      block: this.block,
      elses: this.elses,
      negate: this.negate,
      postfix: this.postfix,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/call.js
var require_call = __commonJS((exports, module) => {
  /*!
   * Stylus - Call
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Call = module.exports = function Call(name, args) {
    Node.call(this);
    this.name = name;
    this.args = args;
  };
  Call.prototype.__proto__ = Node.prototype;
  Call.prototype.clone = function(parent) {
    var clone = new Call(this.name);
    clone.args = this.args.clone(parent, clone);
    if (this.block)
      clone.block = this.block.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Call.prototype.toString = function() {
    var args = this.args.nodes.map(function(node) {
      var str = node.toString();
      return str.slice(1, str.length - 1);
    }).join(", ");
    return this.name + "(" + args + ")";
  };
  Call.prototype.toJSON = function() {
    var json = {
      __type: "Call",
      name: this.name,
      args: this.args,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
    if (this.block)
      json.block = this.block;
    return json;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/unaryop.js
var require_unaryop = __commonJS((exports, module) => {
  /*!
   * Stylus - UnaryOp
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var UnaryOp = module.exports = function UnaryOp(op, expr) {
    Node.call(this);
    this.op = op;
    this.expr = expr;
  };
  UnaryOp.prototype.__proto__ = Node.prototype;
  UnaryOp.prototype.clone = function(parent) {
    var clone = new UnaryOp(this.op);
    clone.expr = this.expr.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  UnaryOp.prototype.toJSON = function() {
    return {
      __type: "UnaryOp",
      op: this.op,
      expr: this.expr,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/binop.js
var require_binop = __commonJS((exports, module) => {
  /*!
   * Stylus - BinOp
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var BinOp = module.exports = function BinOp(op, left, right) {
    Node.call(this);
    this.op = op;
    this.left = left;
    this.right = right;
  };
  BinOp.prototype.__proto__ = Node.prototype;
  BinOp.prototype.clone = function(parent) {
    var clone = new BinOp(this.op);
    clone.left = this.left.clone(parent, clone);
    clone.right = this.right && this.right.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    if (this.val)
      clone.val = this.val.clone(parent, clone);
    return clone;
  };
  BinOp.prototype.toString = function() {
    return this.left.toString() + " " + this.op + " " + this.right.toString();
  };
  BinOp.prototype.toJSON = function() {
    var json = {
      __type: "BinOp",
      left: this.left,
      right: this.right,
      op: this.op,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
    if (this.val)
      json.val = this.val;
    return json;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/ternary.js
var require_ternary = __commonJS((exports, module) => {
  /*!
   * Stylus - Ternary
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Ternary = module.exports = function Ternary(cond, trueExpr, falseExpr) {
    Node.call(this);
    this.cond = cond;
    this.trueExpr = trueExpr;
    this.falseExpr = falseExpr;
  };
  Ternary.prototype.__proto__ = Node.prototype;
  Ternary.prototype.clone = function(parent) {
    var clone = new Ternary;
    clone.cond = this.cond.clone(parent, clone);
    clone.trueExpr = this.trueExpr.clone(parent, clone);
    clone.falseExpr = this.falseExpr.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Ternary.prototype.toJSON = function() {
    return {
      __type: "Ternary",
      cond: this.cond,
      trueExpr: this.trueExpr,
      falseExpr: this.falseExpr,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/block.js
var require_block = __commonJS((exports, module) => {
  /*!
   * Stylus - Block
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Block = module.exports = function Block(parent, node) {
    Node.call(this);
    this.nodes = [];
    this.parent = parent;
    this.node = node;
    this.scope = true;
  };
  Block.prototype.__proto__ = Node.prototype;
  Block.prototype.__defineGetter__("hasProperties", function() {
    for (var i = 0, len = this.nodes.length;i < len; ++i) {
      if (this.nodes[i].nodeName == "property") {
        return true;
      }
    }
  });
  Block.prototype.__defineGetter__("hasMedia", function() {
    for (var i = 0, len = this.nodes.length;i < len; ++i) {
      var nodeName = this.nodes[i].nodeName;
      if (nodeName == "media") {
        return true;
      }
    }
    return false;
  });
  Block.prototype.__defineGetter__("isEmpty", function() {
    return !this.nodes.length || this.nodes.every(function(n) {
      return n.nodeName == "comment";
    });
  });
  Block.prototype.clone = function(parent, node) {
    parent = parent || this.parent;
    var clone = new Block(parent, node || this.node);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    clone.scope = this.scope;
    this.nodes.forEach(function(node2) {
      clone.push(node2.clone(clone, clone));
    });
    return clone;
  };
  Block.prototype.push = function(node) {
    this.nodes.push(node);
  };
  Block.prototype.toJSON = function() {
    return {
      __type: "Block",
      scope: this.scope,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename,
      nodes: this.nodes
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/unit.js
var require_unit2 = __commonJS((exports, module) => {
  /*!
   * Stylus - Unit
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var FACTOR_TABLE = {
    mm: { val: 1, label: "mm" },
    cm: { val: 10, label: "mm" },
    in: { val: 25.4, label: "mm" },
    pt: { val: 25.4 / 72, label: "mm" },
    ms: { val: 1, label: "ms" },
    s: { val: 1000, label: "ms" },
    Hz: { val: 1, label: "Hz" },
    kHz: { val: 1000, label: "Hz" }
  };
  var Unit = module.exports = function Unit(val, type) {
    Node.call(this);
    this.val = val;
    this.type = type;
  };
  Unit.prototype.__proto__ = Node.prototype;
  Unit.prototype.toBoolean = function() {
    return nodes.Boolean(this.type ? true : this.val);
  };
  Unit.prototype.toString = function() {
    return this.val + (this.type || "");
  };
  Unit.prototype.clone = function() {
    var clone = new Unit(this.val, this.type);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Unit.prototype.toJSON = function() {
    return {
      __type: "Unit",
      val: this.val,
      type: this.type,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  Unit.prototype.operate = function(op, right) {
    var type = this.type || right.first.type;
    if (right.nodeName == "rgba" || right.nodeName == "hsla") {
      return right.operate(op, this);
    }
    if (this.shouldCoerce(op)) {
      right = right.first;
      if (this.type != "%" && (op == "-" || op == "+") && right.type == "%") {
        right = new Unit(this.val * (right.val / 100), "%");
      } else {
        right = this.coerce(right);
      }
      switch (op) {
        case "-":
          return new Unit(this.val - right.val, type);
        case "+":
          type = type || right.type == "%" && right.type;
          return new Unit(this.val + right.val, type);
        case "/":
          return new Unit(this.val / right.val, type);
        case "*":
          return new Unit(this.val * right.val, type);
        case "%":
          return new Unit(this.val % right.val, type);
        case "**":
          return new Unit(Math.pow(this.val, right.val), type);
        case "..":
        case "...":
          var start = this.val, end = right.val, expr = new nodes.Expression, inclusive = op == "..";
          if (start < end) {
            do {
              expr.push(new nodes.Unit(start));
            } while (inclusive ? ++start <= end : ++start < end);
          } else {
            do {
              expr.push(new nodes.Unit(start));
            } while (inclusive ? --start >= end : --start > end);
          }
          return expr;
      }
    }
    return Node.prototype.operate.call(this, op, right);
  };
  Unit.prototype.coerce = function(other) {
    if (other.nodeName == "unit") {
      var a = this, b = other, factorA = FACTOR_TABLE[a.type], factorB = FACTOR_TABLE[b.type];
      if (factorA && factorB && factorA.label == factorB.label) {
        var bVal = b.val * (factorB.val / factorA.val);
        return new nodes.Unit(bVal, a.type);
      } else {
        return new nodes.Unit(b.val, a.type);
      }
    } else if (other.nodeName == "string") {
      if (other.val == "%")
        return new nodes.Unit(0, "%");
      var val = parseFloat(other.val);
      if (isNaN(val))
        Node.prototype.coerce.call(this, other);
      return new nodes.Unit(val);
    } else {
      return Node.prototype.coerce.call(this, other);
    }
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/string.js
var require_string = __commonJS((exports, module) => {
  /*!
   * Stylus - String
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var sprintf = require_functions().s;
  var utils = require_utils();
  var nodes = require_nodes();
  var String2 = module.exports = function String(val, quote) {
    Node.call(this);
    this.val = val;
    this.string = val;
    this.prefixed = false;
    if (typeof quote !== "string") {
      this.quote = "'";
    } else {
      this.quote = quote;
    }
  };
  String2.prototype.__proto__ = Node.prototype;
  String2.prototype.toString = function() {
    return this.quote + this.val + this.quote;
  };
  String2.prototype.clone = function() {
    var clone = new String2(this.val, this.quote);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  String2.prototype.toJSON = function() {
    return {
      __type: "String",
      val: this.val,
      quote: this.quote,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  String2.prototype.toBoolean = function() {
    return nodes.Boolean(this.val.length);
  };
  String2.prototype.coerce = function(other) {
    switch (other.nodeName) {
      case "string":
        return other;
      case "expression":
        return new String2(other.nodes.map(function(node) {
          return this.coerce(node).val;
        }, this).join(" "));
      default:
        return new String2(other.toString());
    }
  };
  String2.prototype.operate = function(op, right) {
    switch (op) {
      case "%":
        var expr = new nodes.Expression;
        expr.push(this);
        var args = right.nodeName == "expression" ? utils.unwrap(right).nodes : [right];
        return sprintf.apply(null, [expr].concat(args));
      case "+":
        var expr = new nodes.Expression;
        expr.push(new String2(this.val + this.coerce(right).val));
        return expr;
      default:
        return Node.prototype.operate.call(this, op, right);
    }
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/hsla.js
var require_hsla2 = __commonJS((exports, module) => {
  var clampDegrees = function(n) {
    n = n % 360;
    return n >= 0 ? n : 360 + n;
  };
  var clampPercentage = function(n) {
    return Math.max(0, Math.min(n, 100));
  };
  var clampAlpha = function(n) {
    return Math.max(0, Math.min(n, 1));
  };
  /*!
   * Stylus - HSLA
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var HSLA = exports = module.exports = function HSLA(h, s, l, a) {
    Node.call(this);
    this.h = clampDegrees(h);
    this.s = clampPercentage(s);
    this.l = clampPercentage(l);
    this.a = clampAlpha(a);
    this.hsla = this;
  };
  HSLA.prototype.__proto__ = Node.prototype;
  HSLA.prototype.toString = function() {
    return "hsla(" + this.h + "," + this.s.toFixed(0) + "%," + this.l.toFixed(0) + "%," + this.a + ")";
  };
  HSLA.prototype.clone = function(parent) {
    var clone = new HSLA(this.h, this.s, this.l, this.a);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  HSLA.prototype.toJSON = function() {
    return {
      __type: "HSLA",
      h: this.h,
      s: this.s,
      l: this.l,
      a: this.a,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  HSLA.prototype.__defineGetter__("rgba", function() {
    return nodes.RGBA.fromHSLA(this);
  });
  HSLA.prototype.__defineGetter__("hash", function() {
    return this.rgba.toString();
  });
  HSLA.prototype.add = function(h, s, l) {
    return new HSLA(this.h + h, this.s + s, this.l + l, this.a);
  };
  HSLA.prototype.sub = function(h, s, l) {
    return this.add(-h, -s, -l);
  };
  HSLA.prototype.operate = function(op, right) {
    switch (op) {
      case "==":
      case "!=":
      case "<=":
      case ">=":
      case "<":
      case ">":
      case "is a":
      case "||":
      case "&&":
        return this.rgba.operate(op, right);
      default:
        return this.rgba.operate(op, right).hsla;
    }
  };
  exports.fromRGBA = function(rgba) {
    var r = rgba.r / 255, g = rgba.g / 255, b = rgba.b / 255, a = rgba.a;
    var min = Math.min(r, g, b), max = Math.max(r, g, b), l = (max + min) / 2, d = max - min, h, s;
    switch (max) {
      case min:
        h = 0;
        break;
      case r:
        h = 60 * (g - b) / d;
        break;
      case g:
        h = 60 * (b - r) / d + 120;
        break;
      case b:
        h = 60 * (r - g) / d + 240;
        break;
    }
    if (max == min) {
      s = 0;
    } else if (l < 0.5) {
      s = d / (2 * l);
    } else {
      s = d / (2 - 2 * l);
    }
    h %= 360;
    s *= 100;
    l *= 100;
    return new HSLA(h, s, l, a);
  };
  HSLA.prototype.adjustLightness = function(percent) {
    this.l = clampPercentage(this.l + this.l * (percent / 100));
    return this;
  };
  HSLA.prototype.adjustHue = function(deg) {
    this.h = clampDegrees(this.h + deg);
    return this;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/rgba.js
var require_rgba2 = __commonJS((exports, module) => {
  var clamp = function(n) {
    return Math.max(0, Math.min(n.toFixed(0), 255));
  };
  var clampAlpha = function(n) {
    return Math.max(0, Math.min(n, 1));
  };
  /*!
   * Stylus - RGBA
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var HSLA = require_hsla2();
  var functions = require_functions();
  var adjust = functions.adjust;
  var nodes = require_nodes();
  var RGBA = exports = module.exports = function RGBA(r, g, b, a) {
    Node.call(this);
    this.r = clamp(r);
    this.g = clamp(g);
    this.b = clamp(b);
    this.a = clampAlpha(a);
    this.name = "";
    this.rgba = this;
  };
  RGBA.prototype.__proto__ = Node.prototype;
  RGBA.withoutClamping = function(r, g, b, a) {
    var rgba = new RGBA(0, 0, 0, 0);
    rgba.r = r;
    rgba.g = g;
    rgba.b = b;
    rgba.a = a;
    return rgba;
  };
  RGBA.prototype.clone = function() {
    var clone = new RGBA(this.r, this.g, this.b, this.a);
    clone.raw = this.raw;
    clone.name = this.name;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  RGBA.prototype.toJSON = function() {
    return {
      __type: "RGBA",
      r: this.r,
      g: this.g,
      b: this.b,
      a: this.a,
      raw: this.raw,
      name: this.name,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  RGBA.prototype.toBoolean = function() {
    return nodes.true;
  };
  RGBA.prototype.__defineGetter__("hsla", function() {
    return HSLA.fromRGBA(this);
  });
  RGBA.prototype.__defineGetter__("hash", function() {
    return this.toString();
  });
  RGBA.prototype.add = function(r, g, b, a) {
    return new RGBA(this.r + r, this.g + g, this.b + b, this.a + a);
  };
  RGBA.prototype.sub = function(r, g, b, a) {
    return new RGBA(this.r - r, this.g - g, this.b - b, a == 1 ? this.a : this.a - a);
  };
  RGBA.prototype.multiply = function(n) {
    return new RGBA(this.r * n, this.g * n, this.b * n, this.a);
  };
  RGBA.prototype.divide = function(n) {
    return new RGBA(this.r / n, this.g / n, this.b / n, this.a);
  };
  RGBA.prototype.operate = function(op, right) {
    if (op != "in")
      right = right.first;
    switch (op) {
      case "is a":
        if (right.nodeName == "string" && right.string == "color") {
          return nodes.true;
        }
        break;
      case "+":
        switch (right.nodeName) {
          case "unit":
            var n = right.val;
            switch (right.type) {
              case "%":
                return adjust(this, new nodes.String("lightness"), right);
              case "deg":
                return this.hsla.adjustHue(n).rgba;
              default:
                return this.add(n, n, n, 0);
            }
          case "rgba":
            return this.add(right.r, right.g, right.b, right.a);
          case "hsla":
            return this.hsla.add(right.h, right.s, right.l);
        }
        break;
      case "-":
        switch (right.nodeName) {
          case "unit":
            var n = right.val;
            switch (right.type) {
              case "%":
                return adjust(this, new nodes.String("lightness"), new nodes.Unit(-n, "%"));
              case "deg":
                return this.hsla.adjustHue(-n).rgba;
              default:
                return this.sub(n, n, n, 0);
            }
          case "rgba":
            return this.sub(right.r, right.g, right.b, right.a);
          case "hsla":
            return this.hsla.sub(right.h, right.s, right.l);
        }
        break;
      case "*":
        switch (right.nodeName) {
          case "unit":
            return this.multiply(right.val);
        }
        break;
      case "/":
        switch (right.nodeName) {
          case "unit":
            return this.divide(right.val);
        }
        break;
    }
    return Node.prototype.operate.call(this, op, right);
  };
  RGBA.prototype.toString = function() {
    function pad(n) {
      return n < 16 ? "0" + n.toString(16) : n.toString(16);
    }
    if (this.name == "transparent")
      return this.name;
    if (this.a == 1) {
      var r = pad(this.r), g = pad(this.g), b = pad(this.b);
      if (r[0] == r[1] && g[0] == g[1] && b[0] == b[1]) {
        return "#" + r[0] + g[0] + b[0];
      } else {
        return "#" + r + g + b;
      }
    } else {
      return "rgba(" + this.r + "," + this.g + "," + this.b + "," + +this.a.toFixed(3) + ")";
    }
  };
  exports.fromHSLA = function(hsla) {
    var h = hsla.h / 360, s = hsla.s / 100, l = hsla.l / 100, a = hsla.a;
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s, m1 = l * 2 - m2;
    var r = hue(h + 1 / 3) * 255, g = hue(h) * 255, b = hue(h - 1 / 3) * 255;
    function hue(h2) {
      if (h2 < 0)
        ++h2;
      if (h2 > 1)
        --h2;
      if (h2 * 6 < 1)
        return m1 + (m2 - m1) * h2 * 6;
      if (h2 * 2 < 1)
        return m2;
      if (h2 * 3 < 2)
        return m1 + (m2 - m1) * (2 / 3 - h2) * 6;
      return m1;
    }
    return new RGBA(r, g, b, a);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/ident.js
var require_ident = __commonJS((exports, module) => {
  /*!
   * Stylus - Ident
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var Ident = module.exports = function Ident(name, val, mixin) {
    Node.call(this);
    this.name = name;
    this.string = name;
    this.val = val || nodes.null;
    this.mixin = !!mixin;
  };
  Ident.prototype.__defineGetter__("isEmpty", function() {
    return this.val == undefined;
  });
  Ident.prototype.__defineGetter__("hash", function() {
    return this.name;
  });
  Ident.prototype.__proto__ = Node.prototype;
  Ident.prototype.clone = function(parent) {
    var clone = new Ident(this.name);
    clone.val = this.val.clone(parent, clone);
    clone.mixin = this.mixin;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    clone.property = this.property;
    clone.rest = this.rest;
    return clone;
  };
  Ident.prototype.toJSON = function() {
    return {
      __type: "Ident",
      name: this.name,
      val: this.val,
      mixin: this.mixin,
      property: this.property,
      rest: this.rest,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  Ident.prototype.toString = function() {
    return this.name;
  };
  Ident.prototype.coerce = function(other) {
    switch (other.nodeName) {
      case "ident":
      case "string":
      case "literal":
        return new Ident(other.string);
      case "unit":
        return new Ident(other.toString());
      default:
        return Node.prototype.coerce.call(this, other);
    }
  };
  Ident.prototype.operate = function(op, right) {
    var val = right.first;
    switch (op) {
      case "-":
        if (val.nodeName == "unit") {
          var expr = new nodes.Expression;
          val = val.clone();
          val.val = -val.val;
          expr.push(this);
          expr.push(val);
          return expr;
        }
      case "+":
        return new nodes.Ident(this.string + this.coerce(val).string);
    }
    return Node.prototype.operate.call(this, op, right);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/group.js
var require_group = __commonJS((exports, module) => {
  /*!
   * Stylus - Group
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Group = module.exports = function Group() {
    Node.call(this);
    this.nodes = [];
    this.extends = [];
  };
  Group.prototype.__proto__ = Node.prototype;
  Group.prototype.push = function(selector) {
    this.nodes.push(selector);
  };
  Group.prototype.__defineGetter__("block", function() {
    return this.nodes[0].block;
  });
  Group.prototype.__defineSetter__("block", function(block) {
    for (var i = 0, len = this.nodes.length;i < len; ++i) {
      this.nodes[i].block = block;
    }
  });
  Group.prototype.__defineGetter__("hasOnlyPlaceholders", function() {
    return this.nodes.every(function(selector) {
      return selector.isPlaceholder;
    });
  });
  Group.prototype.clone = function(parent) {
    var clone = new Group;
    clone.lineno = this.lineno;
    clone.column = this.column;
    this.nodes.forEach(function(node) {
      clone.push(node.clone(parent, clone));
    });
    clone.filename = this.filename;
    clone.block = this.block.clone(parent, clone);
    return clone;
  };
  Group.prototype.toJSON = function() {
    return {
      __type: "Group",
      nodes: this.nodes,
      block: this.block,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/literal.js
var require_literal = __commonJS((exports, module) => {
  /*!
   * Stylus - Literal
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var Literal = module.exports = function Literal(str) {
    Node.call(this);
    this.val = str;
    this.string = str;
    this.prefixed = false;
  };
  Literal.prototype.__proto__ = Node.prototype;
  Literal.prototype.__defineGetter__("hash", function() {
    return this.val;
  });
  Literal.prototype.toString = function() {
    return this.val.toString();
  };
  Literal.prototype.coerce = function(other) {
    switch (other.nodeName) {
      case "ident":
      case "string":
      case "literal":
        return new Literal(other.string);
      default:
        return Node.prototype.coerce.call(this, other);
    }
  };
  Literal.prototype.operate = function(op, right) {
    var val = right.first;
    switch (op) {
      case "+":
        return new nodes.Literal(this.string + this.coerce(val).string);
      default:
        return Node.prototype.operate.call(this, op, right);
    }
  };
  Literal.prototype.toJSON = function() {
    return {
      __type: "Literal",
      val: this.val,
      string: this.string,
      prefixed: this.prefixed,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/boolean.js
var require_boolean = __commonJS((exports, module) => {
  /*!
   * Stylus - Boolean
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var Boolean2 = module.exports = function Boolean(val) {
    Node.call(this);
    if (this.nodeName) {
      this.val = !!val;
    } else {
      return new Boolean(val);
    }
  };
  Boolean2.prototype.__proto__ = Node.prototype;
  Boolean2.prototype.toBoolean = function() {
    return this;
  };
  Boolean2.prototype.__defineGetter__("isTrue", function() {
    return this.val;
  });
  Boolean2.prototype.__defineGetter__("isFalse", function() {
    return !this.val;
  });
  Boolean2.prototype.negate = function() {
    return new Boolean2(!this.val);
  };
  Boolean2.prototype.inspect = function() {
    return "[Boolean " + this.val + "]";
  };
  Boolean2.prototype.toString = function() {
    return this.val ? "true" : "false";
  };
  Boolean2.prototype.toJSON = function() {
    return {
      __type: "Boolean",
      val: this.val
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/return.js
var require_return = __commonJS((exports, module) => {
  /*!
   * Stylus - Return
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var Return = module.exports = function Return(expr) {
    this.expr = expr || nodes.null;
  };
  Return.prototype.__proto__ = Node.prototype;
  Return.prototype.clone = function(parent) {
    var clone = new Return;
    clone.expr = this.expr.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Return.prototype.toJSON = function() {
    return {
      __type: "Return",
      expr: this.expr,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/atrule.js
var require_atrule = __commonJS((exports, module) => {
  var hasOutput = function(block) {
    var nodes = block.nodes;
    if (nodes.every(function(node) {
      return node.nodeName == "group" && node.hasOnlyPlaceholders;
    }))
      return false;
    return nodes.some(function(node) {
      switch (node.nodeName) {
        case "property":
        case "literal":
        case "import":
          return true;
        case "block":
          return hasOutput(node);
        default:
          if (node.block)
            return hasOutput(node.block);
      }
    });
  };
  /*!
   * Stylus - at-rule
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Atrule = module.exports = function Atrule(type) {
    Node.call(this);
    this.type = type;
  };
  Atrule.prototype.__proto__ = Node.prototype;
  Atrule.prototype.__defineGetter__("hasOnlyProperties", function() {
    if (!this.block)
      return false;
    var nodes = this.block.nodes;
    for (var i = 0, len = nodes.length;i < len; ++i) {
      var nodeName = nodes[i].nodeName;
      switch (nodes[i].nodeName) {
        case "property":
        case "expression":
        case "comment":
          continue;
        default:
          return false;
      }
    }
    return true;
  });
  Atrule.prototype.clone = function(parent) {
    var clone = new Atrule(this.type);
    if (this.block)
      clone.block = this.block.clone(parent, clone);
    clone.segments = this.segments.map(function(node) {
      return node.clone(parent, clone);
    });
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Atrule.prototype.toJSON = function() {
    var json = {
      __type: "Atrule",
      type: this.type,
      segments: this.segments,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
    if (this.block)
      json.block = this.block;
    return json;
  };
  Atrule.prototype.toString = function() {
    return "@" + this.type;
  };
  Atrule.prototype.__defineGetter__("hasOutput", function() {
    return !!this.block && hasOutput(this.block);
  });
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/media.js
var require_media = __commonJS((exports, module) => {
  /*!
   * Stylus - Media
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Atrule = require_atrule();
  var Media = module.exports = function Media(val) {
    Atrule.call(this, "media");
    this.val = val;
  };
  Media.prototype.__proto__ = Atrule.prototype;
  Media.prototype.clone = function(parent) {
    var clone = new Media;
    clone.val = this.val.clone(parent, clone);
    clone.block = this.block.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Media.prototype.toJSON = function() {
    return {
      __type: "Media",
      val: this.val,
      block: this.block,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  Media.prototype.toString = function() {
    return "@media " + this.val;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/query-list.js
var require_query_list = __commonJS((exports, module) => {
  /*!
   * Stylus - QueryList
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var QueryList = module.exports = function QueryList() {
    Node.call(this);
    this.nodes = [];
  };
  QueryList.prototype.__proto__ = Node.prototype;
  QueryList.prototype.clone = function(parent) {
    var clone = new QueryList;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    for (var i = 0;i < this.nodes.length; ++i) {
      clone.push(this.nodes[i].clone(parent, clone));
    }
    return clone;
  };
  QueryList.prototype.push = function(node) {
    this.nodes.push(node);
  };
  QueryList.prototype.merge = function(other) {
    var list = new QueryList, merged;
    this.nodes.forEach(function(query) {
      for (var i = 0, len = other.nodes.length;i < len; ++i) {
        merged = query.merge(other.nodes[i]);
        if (merged)
          list.push(merged);
      }
    });
    return list;
  };
  QueryList.prototype.toString = function() {
    return "(" + this.nodes.map(function(node) {
      return node.toString();
    }).join(", ") + ")";
  };
  QueryList.prototype.toJSON = function() {
    return {
      __type: "QueryList",
      nodes: this.nodes,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/query.js
var require_query = __commonJS((exports, module) => {
  /*!
   * Stylus - Query
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Query = module.exports = function Query() {
    Node.call(this);
    this.nodes = [];
    this.type = "";
    this.predicate = "";
  };
  Query.prototype.__proto__ = Node.prototype;
  Query.prototype.clone = function(parent) {
    var clone = new Query;
    clone.predicate = this.predicate;
    clone.type = this.type;
    for (var i = 0, len = this.nodes.length;i < len; ++i) {
      clone.push(this.nodes[i].clone(parent, clone));
    }
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Query.prototype.push = function(feature) {
    this.nodes.push(feature);
  };
  Query.prototype.__defineGetter__("resolvedType", function() {
    if (this.type) {
      return this.type.nodeName ? this.type.string : this.type;
    }
  });
  Query.prototype.__defineGetter__("resolvedPredicate", function() {
    if (this.predicate) {
      return this.predicate.nodeName ? this.predicate.string : this.predicate;
    }
  });
  Query.prototype.merge = function(other) {
    var query = new Query, p1 = this.resolvedPredicate, p2 = other.resolvedPredicate, t1 = this.resolvedType, t2 = other.resolvedType, type, pred;
    t1 = t1 || t2;
    t2 = t2 || t1;
    if (p1 == "not" ^ p2 == "not") {
      if (t1 == t2)
        return;
      type = p1 == "not" ? t2 : t1;
      pred = p1 == "not" ? p2 : p1;
    } else if (p1 == "not" && p2 == "not") {
      if (t1 != t2)
        return;
      type = t1;
      pred = "not";
    } else if (t1 != t2) {
      return;
    } else {
      type = t1;
      pred = p1 || p2;
    }
    query.predicate = pred;
    query.type = type;
    query.nodes = this.nodes.concat(other.nodes);
    return query;
  };
  Query.prototype.toString = function() {
    var pred = this.predicate ? this.predicate + " " : "", type = this.type || "", len = this.nodes.length, str = pred + type;
    if (len) {
      str += (type && " and ") + this.nodes.map(function(expr) {
        return expr.toString();
      }).join(" and ");
    }
    return str;
  };
  Query.prototype.toJSON = function() {
    return {
      __type: "Query",
      predicate: this.predicate,
      type: this.type,
      nodes: this.nodes,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/feature.js
var require_feature = __commonJS((exports, module) => {
  /*!
   * Stylus - Feature
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Feature = module.exports = function Feature(segs) {
    Node.call(this);
    this.segments = segs;
    this.expr = null;
  };
  Feature.prototype.__proto__ = Node.prototype;
  Feature.prototype.clone = function(parent) {
    var clone = new Feature;
    clone.segments = this.segments.map(function(node) {
      return node.clone(parent, clone);
    });
    if (this.expr)
      clone.expr = this.expr.clone(parent, clone);
    if (this.name)
      clone.name = this.name;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Feature.prototype.toString = function() {
    if (this.expr) {
      return "(" + this.segments.join("") + ": " + this.expr.toString() + ")";
    } else {
      return this.segments.join("");
    }
  };
  Feature.prototype.toJSON = function() {
    var json = {
      __type: "Feature",
      segments: this.segments,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
    if (this.expr)
      json.expr = this.expr;
    if (this.name)
      json.name = this.name;
    return json;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/params.js
var require_params = __commonJS((exports, module) => {
  /*!
   * Stylus - Params
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Params = module.exports = function Params() {
    Node.call(this);
    this.nodes = [];
  };
  Params.prototype.__defineGetter__("length", function() {
    return this.nodes.length;
  });
  Params.prototype.__proto__ = Node.prototype;
  Params.prototype.push = function(node) {
    this.nodes.push(node);
  };
  Params.prototype.clone = function(parent) {
    var clone = new Params;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    this.nodes.forEach(function(node) {
      clone.push(node.clone(parent, clone));
    });
    return clone;
  };
  Params.prototype.toJSON = function() {
    return {
      __type: "Params",
      nodes: this.nodes,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/comment.js
var require_comment = __commonJS((exports, module) => {
  /*!
   * Stylus - Comment
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Comment = module.exports = function Comment(str, suppress, inline) {
    Node.call(this);
    this.str = str;
    this.suppress = suppress;
    this.inline = inline;
  };
  Comment.prototype.__proto__ = Node.prototype;
  Comment.prototype.toJSON = function() {
    return {
      __type: "Comment",
      str: this.str,
      suppress: this.suppress,
      inline: this.inline,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  Comment.prototype.toString = function() {
    return this.str;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/keyframes.js
var require_keyframes = __commonJS((exports, module) => {
  /*!
   * Stylus - Keyframes
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Atrule = require_atrule();
  var Keyframes = module.exports = function Keyframes(segs, prefix) {
    Atrule.call(this, "keyframes");
    this.segments = segs;
    this.prefix = prefix || "official";
  };
  Keyframes.prototype.__proto__ = Atrule.prototype;
  Keyframes.prototype.clone = function(parent) {
    var clone = new Keyframes;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    clone.segments = this.segments.map(function(node) {
      return node.clone(parent, clone);
    });
    clone.prefix = this.prefix;
    clone.block = this.block.clone(parent, clone);
    return clone;
  };
  Keyframes.prototype.toJSON = function() {
    return {
      __type: "Keyframes",
      segments: this.segments,
      prefix: this.prefix,
      block: this.block,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  Keyframes.prototype.toString = function() {
    return "@keyframes " + this.segments.join("");
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/member.js
var require_member = __commonJS((exports, module) => {
  /*!
   * Stylus - Member
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Member = module.exports = function Member(left, right) {
    Node.call(this);
    this.left = left;
    this.right = right;
  };
  Member.prototype.__proto__ = Node.prototype;
  Member.prototype.clone = function(parent) {
    var clone = new Member;
    clone.left = this.left.clone(parent, clone);
    clone.right = this.right.clone(parent, clone);
    if (this.val)
      clone.val = this.val.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Member.prototype.toJSON = function() {
    var json = {
      __type: "Member",
      left: this.left,
      right: this.right,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
    if (this.val)
      json.val = this.val;
    return json;
  };
  Member.prototype.toString = function() {
    return this.left.toString() + "." + this.right.toString();
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/charset.js
var require_charset = __commonJS((exports, module) => {
  /*!
   * Stylus - Charset
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Charset = module.exports = function Charset(val) {
    Node.call(this);
    this.val = val;
  };
  Charset.prototype.__proto__ = Node.prototype;
  Charset.prototype.toString = function() {
    return "@charset " + this.val;
  };
  Charset.prototype.toJSON = function() {
    return {
      __type: "Charset",
      val: this.val,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/namespace.js
var require_namespace = __commonJS((exports, module) => {
  /*!
   * Stylus - Namespace
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Namespace = module.exports = function Namespace(val, prefix) {
    Node.call(this);
    this.val = val;
    this.prefix = prefix;
  };
  Namespace.prototype.__proto__ = Node.prototype;
  Namespace.prototype.toString = function() {
    return "@namespace " + (this.prefix ? this.prefix + " " : "") + this.val;
  };
  Namespace.prototype.toJSON = function() {
    return {
      __type: "Namespace",
      val: this.val,
      prefix: this.prefix,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/import.js
var require_import = __commonJS((exports, module) => {
  /*!
   * Stylus - Import
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Import = module.exports = function Import(expr, once) {
    Node.call(this);
    this.path = expr;
    this.once = once || false;
  };
  Import.prototype.__proto__ = Node.prototype;
  Import.prototype.clone = function(parent) {
    var clone = new Import;
    clone.path = this.path.nodeName ? this.path.clone(parent, clone) : this.path;
    clone.once = this.once;
    clone.mtime = this.mtime;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Import.prototype.toJSON = function() {
    return {
      __type: "Import",
      path: this.path,
      once: this.once,
      mtime: this.mtime,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/extend.js
var require_extend = __commonJS((exports, module) => {
  /*!
   * Stylus - Extend
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Extend = module.exports = function Extend(selectors) {
    Node.call(this);
    this.selectors = selectors;
  };
  Extend.prototype.__proto__ = Node.prototype;
  Extend.prototype.clone = function() {
    return new Extend(this.selectors);
  };
  Extend.prototype.toString = function() {
    return "@extend " + this.selectors.join(", ");
  };
  Extend.prototype.toJSON = function() {
    return {
      __type: "Extend",
      selectors: this.selectors,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/object.js
var require_object = __commonJS((exports, module) => {
  /*!
   * Stylus - Object
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var nativeObj = {}.constructor;
  var Object2 = module.exports = function Object() {
    Node.call(this);
    this.vals = {};
    this.keys = {};
  };
  Object2.prototype.__proto__ = Node.prototype;
  Object2.prototype.setValue = function(key, val) {
    this.vals[key] = val;
    return this;
  };
  Object2.prototype.set = Object2.prototype.setValue;
  Object2.prototype.setKey = function(key, val) {
    this.keys[key] = val;
    return this;
  };
  Object2.prototype.__defineGetter__("length", function() {
    return nativeObj.keys(this.vals).length;
  });
  Object2.prototype.get = function(key) {
    return this.vals[key] || nodes.null;
  };
  Object2.prototype.has = function(key) {
    return key in this.vals;
  };
  Object2.prototype.operate = function(op, right) {
    switch (op) {
      case ".":
      case "[]":
        return this.get(right.hash);
      case "==":
        var vals = this.vals, a, b;
        if (right.nodeName != "object" || this.length != right.length)
          return nodes.false;
        for (var key in vals) {
          a = vals[key];
          b = right.vals[key];
          if (a.operate(op, b).isFalse)
            return nodes.false;
        }
        return nodes.true;
      case "!=":
        return this.operate("==", right).negate();
      default:
        return Node.prototype.operate.call(this, op, right);
    }
  };
  Object2.prototype.toBoolean = function() {
    return nodes.Boolean(this.length);
  };
  Object2.prototype.toBlock = function() {
    var str = "{", key, val;
    for (key in this.vals) {
      val = this.get(key);
      if (val.first.nodeName == "object") {
        str += key + " " + val.first.toBlock();
      } else {
        switch (key) {
          case "@charset":
            str += key + " " + val.first.toString() + ";";
            break;
          default:
            str += key + ":" + toString(val) + ";";
        }
      }
    }
    str += "}";
    return str;
    function toString(node) {
      if (node.nodes) {
        return node.nodes.map(toString).join(node.isList ? "," : " ");
      } else if (node.nodeName == "literal" && node.val == ",") {
        return "\\,";
      }
      return node.toString();
    }
  };
  Object2.prototype.clone = function(parent) {
    var clone = new Object2;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    var key;
    for (key in this.vals) {
      clone.vals[key] = this.vals[key].clone(parent, clone);
    }
    for (key in this.keys) {
      clone.keys[key] = this.keys[key].clone(parent, clone);
    }
    return clone;
  };
  Object2.prototype.toJSON = function() {
    return {
      __type: "Object",
      vals: this.vals,
      keys: this.keys,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  Object2.prototype.toString = function() {
    var obj = {};
    for (var prop in this.vals) {
      obj[prop] = this.vals[prop].toString();
    }
    return JSON.stringify(obj);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/function.js
var require_function = __commonJS((exports, module) => {
  /*!
   * Stylus - Function
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Function2 = module.exports = function Function(name, params, body) {
    Node.call(this);
    this.name = name;
    this.params = params;
    this.block = body;
    if (typeof params == "function")
      this.fn = params;
  };
  Function2.prototype.__defineGetter__("arity", function() {
    return this.params.length;
  });
  Function2.prototype.__proto__ = Node.prototype;
  Function2.prototype.__defineGetter__("hash", function() {
    return "function " + this.name;
  });
  Function2.prototype.clone = function(parent) {
    if (this.fn) {
      var clone = new Function2(this.name, this.fn);
    } else {
      var clone = new Function2(this.name);
      clone.params = this.params.clone(parent, clone);
      clone.block = this.block.clone(parent, clone);
    }
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Function2.prototype.toString = function() {
    if (this.fn) {
      return this.name + "(" + this.fn.toString().match(/^function *\w*\((.*?)\)/).slice(1).join(", ") + ")";
    } else {
      return this.name + "(" + this.params.nodes.join(", ") + ")";
    }
  };
  Function2.prototype.toJSON = function() {
    var json = {
      __type: "Function",
      name: this.name,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
    if (this.fn) {
      json.fn = this.fn;
    } else {
      json.params = this.params;
      json.block = this.block;
    }
    return json;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/property.js
var require_property = __commonJS((exports, module) => {
  /*!
   * Stylus - Property
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Property = module.exports = function Property(segs, expr) {
    Node.call(this);
    this.segments = segs;
    this.expr = expr;
  };
  Property.prototype.__proto__ = Node.prototype;
  Property.prototype.clone = function(parent) {
    var clone = new Property(this.segments);
    clone.name = this.name;
    if (this.literal)
      clone.literal = this.literal;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    clone.segments = this.segments.map(function(node) {
      return node.clone(parent, clone);
    });
    if (this.expr)
      clone.expr = this.expr.clone(parent, clone);
    return clone;
  };
  Property.prototype.toJSON = function() {
    var json = {
      __type: "Property",
      segments: this.segments,
      name: this.name,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
    if (this.expr)
      json.expr = this.expr;
    if (this.literal)
      json.literal = this.literal;
    return json;
  };
  Property.prototype.toString = function() {
    return "property(" + this.segments.join("") + ", " + this.expr + ")";
  };
  Property.prototype.operate = function(op, right, val) {
    return this.expr.operate(op, right, val);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/selector.js
var require_selector2 = __commonJS((exports, module) => {
  /*!
   * Stylus - Selector
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Block = require_block();
  var Node = require_node2();
  var Selector = module.exports = function Selector(segs) {
    Node.call(this);
    this.inherits = true;
    this.segments = segs;
    this.optional = false;
  };
  Selector.prototype.__proto__ = Node.prototype;
  Selector.prototype.toString = function() {
    return this.segments.join("") + (this.optional ? " !optional" : "");
  };
  Selector.prototype.__defineGetter__("isPlaceholder", function() {
    return this.val && ~this.val.substr(0, 2).indexOf("$");
  });
  Selector.prototype.clone = function(parent) {
    var clone = new Selector;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    clone.inherits = this.inherits;
    clone.val = this.val;
    clone.segments = this.segments.map(function(node) {
      return node.clone(parent, clone);
    });
    clone.optional = this.optional;
    return clone;
  };
  Selector.prototype.toJSON = function() {
    return {
      __type: "Selector",
      inherits: this.inherits,
      segments: this.segments,
      optional: this.optional,
      val: this.val,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/expression.js
var require_expression = __commonJS((exports, module) => {
  /*!
   * Stylus - Expression
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var utils = require_utils();
  var Expression = module.exports = function Expression(isList) {
    Node.call(this);
    this.nodes = [];
    this.isList = isList;
  };
  Expression.prototype.__defineGetter__("isEmpty", function() {
    return !this.nodes.length;
  });
  Expression.prototype.__defineGetter__("first", function() {
    return this.nodes[0] ? this.nodes[0].first : nodes.null;
  });
  Expression.prototype.__defineGetter__("hash", function() {
    return this.nodes.map(function(node) {
      return node.hash;
    }).join("::");
  });
  Expression.prototype.__proto__ = Node.prototype;
  Expression.prototype.clone = function(parent) {
    var clone = new this.constructor(this.isList);
    clone.preserve = this.preserve;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    clone.nodes = this.nodes.map(function(node) {
      return node.clone(parent, clone);
    });
    return clone;
  };
  Expression.prototype.push = function(node) {
    this.nodes.push(node);
  };
  Expression.prototype.operate = function(op, right, val) {
    switch (op) {
      case "[]=":
        var self2 = this, range = utils.unwrap(right).nodes, val = utils.unwrap(val), len, node;
        range.forEach(function(unit) {
          len = self2.nodes.length;
          if (unit.nodeName == "unit") {
            var i2 = unit.val < 0 ? len + unit.val : unit.val, n = i2;
            while (i2-- > len)
              self2.nodes[i2] = nodes.null;
            self2.nodes[n] = val;
          } else if (unit.string) {
            node = self2.nodes[0];
            if (node && node.nodeName == "object")
              node.set(unit.string, val.clone());
          }
        });
        return val;
      case "[]":
        var expr = new nodes.Expression, vals = utils.unwrap(this).nodes, range = utils.unwrap(right).nodes, node;
        range.forEach(function(unit) {
          if (unit.nodeName == "unit") {
            node = vals[unit.val < 0 ? vals.length + unit.val : unit.val];
          } else if (vals[0].nodeName == "object") {
            node = vals[0].get(unit.string);
          }
          if (node)
            expr.push(node);
        });
        return expr.isEmpty ? nodes.null : utils.unwrap(expr);
      case "||":
        return this.toBoolean().isTrue ? this : right;
      case "in":
        return Node.prototype.operate.call(this, op, right);
      case "!=":
        return this.operate("==", right, val).negate();
      case "==":
        var len = this.nodes.length, right = right.toExpression(), a, b;
        if (len != right.nodes.length)
          return nodes.false;
        for (var i = 0;i < len; ++i) {
          a = this.nodes[i];
          b = right.nodes[i];
          if (a.operate(op, b).isTrue)
            continue;
          return nodes.false;
        }
        return nodes.true;
        break;
      default:
        return this.first.operate(op, right, val);
    }
  };
  Expression.prototype.toBoolean = function() {
    if (this.nodes.length > 1)
      return nodes.true;
    return this.first.toBoolean();
  };
  Expression.prototype.toString = function() {
    return "(" + this.nodes.map(function(node) {
      return node.toString();
    }).join(this.isList ? ", " : " ") + ")";
  };
  Expression.prototype.toJSON = function() {
    return {
      __type: "Expression",
      isList: this.isList,
      preserve: this.preserve,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename,
      nodes: this.nodes
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/arguments.js
var require_arguments = __commonJS((exports, module) => {
  /*!
   * Stylus - Arguments
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var nodes = require_nodes();
  var utils = require_utils();
  var Arguments = module.exports = function Arguments() {
    nodes.Expression.call(this);
    this.map = {};
  };
  Arguments.prototype.__proto__ = nodes.Expression.prototype;
  Arguments.fromExpression = function(expr) {
    var args = new Arguments, len = expr.nodes.length;
    args.lineno = expr.lineno;
    args.column = expr.column;
    args.isList = expr.isList;
    for (var i = 0;i < len; ++i) {
      args.push(expr.nodes[i]);
    }
    return args;
  };
  Arguments.prototype.clone = function(parent) {
    var clone = nodes.Expression.prototype.clone.call(this, parent);
    clone.map = {};
    for (var key in this.map) {
      clone.map[key] = this.map[key].clone(parent, clone);
    }
    clone.isList = this.isList;
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Arguments.prototype.toJSON = function() {
    return {
      __type: "Arguments",
      map: this.map,
      isList: this.isList,
      preserve: this.preserve,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename,
      nodes: this.nodes
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/atblock.js
var require_atblock = __commonJS((exports, module) => {
  /*!
   * Stylus - @block
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Node = require_node2();
  var Atblock = module.exports = function Atblock() {
    Node.call(this);
  };
  Atblock.prototype.__defineGetter__("nodes", function() {
    return this.block.nodes;
  });
  Atblock.prototype.__proto__ = Node.prototype;
  Atblock.prototype.clone = function(parent) {
    var clone = new Atblock;
    clone.block = this.block.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Atblock.prototype.toString = function() {
    return "@block";
  };
  Atblock.prototype.toJSON = function() {
    return {
      __type: "Atblock",
      block: this.block,
      lineno: this.lineno,
      column: this.column,
      fileno: this.fileno
    };
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/supports.js
var require_supports = __commonJS((exports, module) => {
  /*!
   * Stylus - supports
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Atrule = require_atrule();
  var Supports = module.exports = function Supports(condition) {
    Atrule.call(this, "supports");
    this.condition = condition;
  };
  Supports.prototype.__proto__ = Atrule.prototype;
  Supports.prototype.clone = function(parent) {
    var clone = new Supports;
    clone.condition = this.condition.clone(parent, clone);
    clone.block = this.block.clone(parent, clone);
    clone.lineno = this.lineno;
    clone.column = this.column;
    clone.filename = this.filename;
    return clone;
  };
  Supports.prototype.toJSON = function() {
    return {
      __type: "Supports",
      condition: this.condition,
      block: this.block,
      lineno: this.lineno,
      column: this.column,
      filename: this.filename
    };
  };
  Supports.prototype.toString = function() {
    return "@supports " + this.condition;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/nodes/index.js
var require_nodes = __commonJS((exports) => {
  /*!
   * Stylus - nodes
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  exports.lineno = null;
  exports.column = null;
  exports.filename = null;
  exports.Node = require_node2();
  exports.Root = require_root();
  exports.Null = require_null();
  exports.Each = require_each();
  exports.If = require_if();
  exports.Call = require_call();
  exports.UnaryOp = require_unaryop();
  exports.BinOp = require_binop();
  exports.Ternary = require_ternary();
  exports.Block = require_block();
  exports.Unit = require_unit2();
  exports.String = require_string();
  exports.HSLA = require_hsla2();
  exports.RGBA = require_rgba2();
  exports.Ident = require_ident();
  exports.Group = require_group();
  exports.Literal = require_literal();
  exports.Boolean = require_boolean();
  exports.Return = require_return();
  exports.Media = require_media();
  exports.QueryList = require_query_list();
  exports.Query = require_query();
  exports.Feature = require_feature();
  exports.Params = require_params();
  exports.Comment = require_comment();
  exports.Keyframes = require_keyframes();
  exports.Member = require_member();
  exports.Charset = require_charset();
  exports.Namespace = require_namespace();
  exports.Import = require_import();
  exports.Extend = require_extend();
  exports.Object = require_object();
  exports.Function = require_function();
  exports.Property = require_property();
  exports.Selector = require_selector2();
  exports.Expression = require_expression();
  exports.Arguments = require_arguments();
  exports.Atblock = require_atblock();
  exports.Atrule = require_atrule();
  exports.Supports = require_supports();
  exports.true = new exports.Boolean(true);
  exports.false = new exports.Boolean(false);
  exports.null = new exports.Null;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/errors.js
var require_errors = __commonJS((exports) => {
  var ParseError = function(msg) {
    this.name = "ParseError";
    this.message = msg;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ParseError);
    }
  };
  var SyntaxError2 = function(msg) {
    this.name = "SyntaxError";
    this.message = msg;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ParseError);
    }
  };
  /*!
   * Stylus - errors
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  exports.ParseError = ParseError;
  exports.SyntaxError = SyntaxError2;
  ParseError.prototype.__proto__ = Error.prototype;
  SyntaxError2.prototype.__proto__ = Error.prototype;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/lexer.js
var require_lexer = __commonJS((exports, module) => {
  var Lexer = function(str, options) {
    options = options || {};
    this.stash = [];
    this.indentStack = [];
    this.indentRe = null;
    this.lineno = 1;
    this.column = 1;
    function comment(str2, val, offset, s) {
      var inComment = s.lastIndexOf("/*", offset) > s.lastIndexOf("*/", offset), commentIdx = s.lastIndexOf("//", offset), i = s.lastIndexOf("\n", offset), double = 0, single = 0;
      if (~commentIdx && commentIdx > i) {
        while (i != offset) {
          if (s[i] == "'")
            single ? single-- : single++;
          if (s[i] == '"')
            double ? double-- : double++;
          if (s[i] == "/" && s[i + 1] == "/") {
            inComment = !single && !double;
            break;
          }
          ++i;
        }
      }
      return inComment ? str2 : val === "," && /^[,\t\n]+$/.test(str2) ? str2.replace(/\n/, "\r") : val + "\r";
    }
    if (str.charAt(0) == "\uFEFF")
      str = str.slice(1);
    this.str = str.replace(/\s+$/, "\n").replace(/\r\n?/g, "\n").replace(/\\ *\n/g, "\r").replace(/([,(:](?!\/\/[^ ])) *(?:\/\/[^\n]*|\/\*.*?\*\/)?\n\s*/g, comment).replace(/\s*\n[ \t]*([,)])/g, comment);
  };
  /*!
   * Stylus - Lexer
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Token = require_token();
  var nodes = require_nodes();
  var errors = require_errors();
  exports = module.exports = Lexer;
  var alias = {
    and: "&&",
    or: "||",
    is: "==",
    isnt: "!=",
    "is not": "!=",
    ":=": "?="
  };
  Lexer.prototype = {
    inspect: function() {
      var tok, tmp = this.str, buf = [];
      while ((tok = this.next()).type != "eos") {
        buf.push(tok.inspect());
      }
      this.str = tmp;
      return buf.concat(tok.inspect()).join("\n");
    },
    lookahead: function(n) {
      var fetch2 = n - this.stash.length;
      while (fetch2-- > 0)
        this.stash.push(this.advance());
      return this.stash[--n];
    },
    skip: function(len) {
      var chunk = len[0];
      len = chunk ? chunk.length : len;
      this.str = this.str.substr(len);
      if (chunk) {
        this.move(chunk);
      } else {
        this.column += len;
      }
    },
    move: function(str) {
      var lines = str.match(/\n/g), idx = str.lastIndexOf("\n");
      if (lines)
        this.lineno += lines.length;
      this.column = ~idx ? str.length - idx : this.column + str.length;
    },
    next: function() {
      var tok = this.stashed() || this.advance();
      this.prev = tok;
      return tok;
    },
    isPartOfSelector: function() {
      var tok = this.stash[this.stash.length - 1] || this.prev;
      switch (tok && tok.type) {
        case "color":
          return tok.val.raw.length == 2;
        case ".":
        case "[":
          return true;
      }
      return false;
    },
    advance: function() {
      var column = this.column, line = this.lineno, tok = this.eos() || this.null() || this.sep() || this.keyword() || this.urlchars() || this.comment() || this.newline() || this.escaped() || this.important() || this.literal() || this.anonFunc() || this.atrule() || this.function() || this.brace() || this.paren() || this.color() || this.string() || this.unit() || this.namedop() || this.boolean() || this.unicode() || this.ident() || this.op() || function() {
        var token = this.eol();
        if (token) {
          column = token.column;
          line = token.lineno;
        }
        return token;
      }.call(this) || this.space() || this.selector();
      tok.lineno = line;
      tok.column = column;
      return tok;
    },
    peek: function() {
      return this.lookahead(1);
    },
    stashed: function() {
      return this.stash.shift();
    },
    eos: function() {
      if (this.str.length)
        return;
      if (this.indentStack.length) {
        this.indentStack.shift();
        return new Token("outdent");
      } else {
        return new Token("eos");
      }
    },
    urlchars: function() {
      var captures;
      if (!this.isURL)
        return;
      if (captures = /^[\/:@.;?&=*!,<>#%0-9]+/.exec(this.str)) {
        this.skip(captures);
        return new Token("literal", new nodes.Literal(captures[0]));
      }
    },
    sep: function() {
      var captures;
      if (captures = /^;[ \t]*/.exec(this.str)) {
        this.skip(captures);
        return new Token(";");
      }
    },
    eol: function() {
      if (this.str[0] == "\r") {
        ++this.lineno;
        this.skip(1);
        this.column = 1;
        while (this.space())
          ;
        return this.advance();
      }
    },
    space: function() {
      var captures;
      if (captures = /^([ \t]+)/.exec(this.str)) {
        this.skip(captures);
        return new Token("space");
      }
    },
    escaped: function() {
      var captures;
      if (captures = /^\\(.)[ \t]*/.exec(this.str)) {
        var c = captures[1];
        this.skip(captures);
        return new Token("ident", new nodes.Literal(c));
      }
    },
    literal: function() {
      var captures;
      if (captures = /^@css[ \t]*\{/.exec(this.str)) {
        this.skip(captures);
        var c, braces = 1, css = "", node;
        while (c = this.str[0]) {
          this.str = this.str.substr(1);
          switch (c) {
            case "{":
              ++braces;
              break;
            case "}":
              --braces;
              break;
            case "\n":
            case "\r":
              ++this.lineno;
              break;
          }
          css += c;
          if (!braces)
            break;
        }
        css = css.replace(/\s*}$/, "");
        node = new nodes.Literal(css);
        node.css = true;
        return new Token("literal", node);
      }
    },
    important: function() {
      var captures;
      if (captures = /^!important[ \t]*/.exec(this.str)) {
        this.skip(captures);
        return new Token("ident", new nodes.Literal("!important"));
      }
    },
    brace: function() {
      var captures;
      if (captures = /^([{}])/.exec(this.str)) {
        this.skip(1);
        var brace = captures[1];
        return new Token(brace, brace);
      }
    },
    paren: function() {
      var captures;
      if (captures = /^([()])([ \t]*)/.exec(this.str)) {
        var paren = captures[1];
        this.skip(captures);
        if (paren == ")")
          this.isURL = false;
        var tok = new Token(paren, paren);
        tok.space = captures[2];
        return tok;
      }
    },
    null: function() {
      var captures, tok;
      if (captures = /^(null)\b[ \t]*/.exec(this.str)) {
        this.skip(captures);
        if (this.isPartOfSelector()) {
          tok = new Token("ident", new nodes.Ident(captures[0]));
        } else {
          tok = new Token("null", nodes.null);
        }
        return tok;
      }
    },
    keyword: function() {
      var captures, tok;
      if (captures = /^(return|if|else|unless|for|in)\b(?!-)[ \t]*/.exec(this.str)) {
        var keyword = captures[1];
        this.skip(captures);
        if (this.isPartOfSelector()) {
          tok = new Token("ident", new nodes.Ident(captures[0]));
        } else {
          tok = new Token(keyword, keyword);
        }
        return tok;
      }
    },
    namedop: function() {
      var captures, tok;
      if (captures = /^(not|and|or|is a|is defined|isnt|is not|is)(?!-)\b([ \t]*)/.exec(this.str)) {
        var op = captures[1];
        this.skip(captures);
        if (this.isPartOfSelector()) {
          tok = new Token("ident", new nodes.Ident(captures[0]));
        } else {
          op = alias[op] || op;
          tok = new Token(op, op);
        }
        tok.space = captures[2];
        return tok;
      }
    },
    op: function() {
      var captures;
      if (captures = /^([.]{1,3}|&&|\|\||[!<>=?:]=|\*\*|[-+*\/%]=?|[,=?:!~<>&\[\]])([ \t]*)/.exec(this.str)) {
        var op = captures[1];
        this.skip(captures);
        op = alias[op] || op;
        var tok = new Token(op, op);
        tok.space = captures[2];
        this.isURL = false;
        return tok;
      }
    },
    anonFunc: function() {
      var tok;
      if (this.str[0] == "@" && this.str[1] == "(") {
        this.skip(2);
        tok = new Token("function", new nodes.Ident("anonymous"));
        tok.anonymous = true;
        return tok;
      }
    },
    atrule: function() {
      var captures;
      if (captures = /^@(?!apply)(?:-(\w+)-)?([a-zA-Z0-9-_]+)[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var vendor = captures[1], type = captures[2], tok;
        switch (type) {
          case "require":
          case "import":
          case "charset":
          case "namespace":
          case "media":
          case "scope":
          case "supports":
            return new Token(type);
          case "document":
            return new Token("-moz-document");
          case "block":
            return new Token("atblock");
          case "extend":
          case "extends":
            return new Token("extend");
          case "keyframes":
            return new Token(type, vendor);
          default:
            return new Token("atrule", vendor ? "-" + vendor + "-" + type : type);
        }
      }
    },
    comment: function() {
      if (this.str[0] == "/" && this.str[1] == "/") {
        var end = this.str.indexOf("\n");
        if (end == -1)
          end = this.str.length;
        this.skip(end);
        return this.advance();
      }
      if (this.str[0] == "/" && this.str[1] == "*") {
        var end = this.str.indexOf("*/");
        if (end == -1)
          end = this.str.length;
        var str = this.str.substr(0, end + 2), lines = str.split(/\n|\r/).length - 1, suppress = true, inline = false;
        this.lineno += lines;
        this.skip(end + 2);
        if (str[2] == "!") {
          str = str.replace("*!", "*");
          suppress = false;
        }
        if (this.prev && this.prev.type == ";")
          inline = true;
        return new Token("comment", new nodes.Comment(str, suppress, inline));
      }
    },
    boolean: function() {
      var captures;
      if (captures = /^(true|false)\b([ \t]*)/.exec(this.str)) {
        var val = nodes.Boolean(captures[1] == "true");
        this.skip(captures);
        var tok = new Token("boolean", val);
        tok.space = captures[2];
        return tok;
      }
    },
    unicode: function() {
      var captures;
      if (captures = /^u\+[0-9a-f?]{1,6}(?:-[0-9a-f]{1,6})?/i.exec(this.str)) {
        this.skip(captures);
        return new Token("literal", new nodes.Literal(captures[0]));
      }
    },
    function: function() {
      var captures;
      if (captures = /^(-*[_a-zA-Z$][-\w\d$]*)\(([ \t]*)/.exec(this.str)) {
        var name = captures[1];
        this.skip(captures);
        this.isURL = name == "url";
        var tok = new Token("function", new nodes.Ident(name));
        tok.space = captures[2];
        return tok;
      }
    },
    ident: function() {
      var captures;
      if (captures = /^-*([_a-zA-Z$]|@apply)[-\w\d$]*/.exec(this.str)) {
        this.skip(captures);
        return new Token("ident", new nodes.Ident(captures[0]));
      }
    },
    newline: function() {
      var captures, re;
      if (this.indentRe) {
        captures = this.indentRe.exec(this.str);
      } else {
        re = /^\n([\t]*)[ \t]*/;
        captures = re.exec(this.str);
        if (captures && !captures[1].length) {
          re = /^\n([ \t]*)/;
          captures = re.exec(this.str);
        }
        if (captures && captures[1].length)
          this.indentRe = re;
      }
      if (captures) {
        var tok, indents = captures[1].length;
        this.skip(captures);
        if (this.str[0] === " " || this.str[0] === "\t") {
          throw new errors.SyntaxError("Invalid indentation. You can use tabs or spaces to indent, but not both.");
        }
        if (this.str[0] == "\n")
          return this.advance();
        if (this.indentStack.length && indents < this.indentStack[0]) {
          while (this.indentStack.length && this.indentStack[0] > indents) {
            this.stash.push(new Token("outdent"));
            this.indentStack.shift();
          }
          tok = this.stash.pop();
        } else if (indents && indents != this.indentStack[0]) {
          this.indentStack.unshift(indents);
          tok = new Token("indent");
        } else {
          tok = new Token("newline");
        }
        return tok;
      }
    },
    unit: function() {
      var captures;
      if (captures = /^(-)?(\d+\.\d+|\d+|\.\d+)(%|[a-zA-Z]+)?[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var n = parseFloat(captures[2]);
        if (captures[1] == "-")
          n = -n;
        var node = new nodes.Unit(n, captures[3]);
        node.raw = captures[0];
        return new Token("unit", node);
      }
    },
    string: function() {
      var captures;
      if (captures = /^("[^"]*"|'[^']*')[ \t]*/.exec(this.str)) {
        var str = captures[1], quote = captures[0][0];
        this.skip(captures);
        str = str.slice(1, -1).replace(/\\n/g, "\n");
        return new Token("string", new nodes.String(str, quote));
      }
    },
    color: function() {
      return this.rrggbbaa() || this.rrggbb() || this.rgba() || this.rgb() || this.nn() || this.n();
    },
    n: function() {
      var captures;
      if (captures = /^#([a-fA-F0-9]{1})[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var n = parseInt(captures[1] + captures[1], 16), color = new nodes.RGBA(n, n, n, 1);
        color.raw = captures[0];
        return new Token("color", color);
      }
    },
    nn: function() {
      var captures;
      if (captures = /^#([a-fA-F0-9]{2})[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var n = parseInt(captures[1], 16), color = new nodes.RGBA(n, n, n, 1);
        color.raw = captures[0];
        return new Token("color", color);
      }
    },
    rgb: function() {
      var captures;
      if (captures = /^#([a-fA-F0-9]{3})[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var rgb = captures[1], r = parseInt(rgb[0] + rgb[0], 16), g = parseInt(rgb[1] + rgb[1], 16), b = parseInt(rgb[2] + rgb[2], 16), color = new nodes.RGBA(r, g, b, 1);
        color.raw = captures[0];
        return new Token("color", color);
      }
    },
    rgba: function() {
      var captures;
      if (captures = /^#([a-fA-F0-9]{4})[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var rgb = captures[1], r = parseInt(rgb[0] + rgb[0], 16), g = parseInt(rgb[1] + rgb[1], 16), b = parseInt(rgb[2] + rgb[2], 16), a = parseInt(rgb[3] + rgb[3], 16), color = new nodes.RGBA(r, g, b, a / 255);
        color.raw = captures[0];
        return new Token("color", color);
      }
    },
    rrggbb: function() {
      var captures;
      if (captures = /^#([a-fA-F0-9]{6})[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var rgb = captures[1], r = parseInt(rgb.substr(0, 2), 16), g = parseInt(rgb.substr(2, 2), 16), b = parseInt(rgb.substr(4, 2), 16), color = new nodes.RGBA(r, g, b, 1);
        color.raw = captures[0];
        return new Token("color", color);
      }
    },
    rrggbbaa: function() {
      var captures;
      if (captures = /^#([a-fA-F0-9]{8})[ \t]*/.exec(this.str)) {
        this.skip(captures);
        var rgb = captures[1], r = parseInt(rgb.substr(0, 2), 16), g = parseInt(rgb.substr(2, 2), 16), b = parseInt(rgb.substr(4, 2), 16), a = parseInt(rgb.substr(6, 2), 16), color = new nodes.RGBA(r, g, b, a / 255);
        color.raw = captures[0];
        return new Token("color", color);
      }
    },
    selector: function() {
      var captures;
      if (captures = /^\^|.*?(?=\/\/(?![^\[]*\])|[,\n{])/.exec(this.str)) {
        var selector = captures[0];
        this.skip(captures);
        return new Token("selector", selector);
      }
    }
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/cache/memory.js
var require_memory = __commonJS((exports, module) => {
  var crypto = __require("crypto");
  var nodes = require_nodes();
  var MemoryCache = module.exports = function(options) {
    options = options || {};
    this.limit = options["cache limit"] || 256;
    this._cache = {};
    this.length = 0;
    this.head = this.tail = null;
  };
  MemoryCache.prototype.set = function(key, value) {
    var clone = value.clone(), item;
    clone.filename = nodes.filename;
    clone.lineno = nodes.lineno;
    clone.column = nodes.column;
    item = { key, value: clone };
    this._cache[key] = item;
    if (this.tail) {
      this.tail.next = item;
      item.prev = this.tail;
    } else {
      this.head = item;
    }
    this.tail = item;
    if (this.length++ == this.limit)
      this.purge();
  };
  MemoryCache.prototype.get = function(key) {
    var item = this._cache[key], val = item.value.clone();
    if (item == this.tail)
      return val;
    if (item.next) {
      if (item == this.head)
        this.head = item.next;
      item.next.prev = item.prev;
    }
    if (item.prev)
      item.prev.next = item.next;
    item.next = null;
    item.prev = this.tail;
    if (this.tail)
      this.tail.next = item;
    this.tail = item;
    return val;
  };
  MemoryCache.prototype.has = function(key) {
    return !!this._cache[key];
  };
  MemoryCache.prototype.key = function(str, options) {
    var hash = crypto.createHash("sha1");
    hash.update(str + options.prefix);
    return hash.digest("hex");
  };
  MemoryCache.prototype.purge = function() {
    var item = this.head;
    if (this.head.next) {
      this.head = this.head.next;
      this.head.prev = null;
    }
    this._cache[item.key] = item.prev = item.next = null;
    this.length--;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/cache/null.js
var require_null2 = __commonJS((exports, module) => {
  var NullCache = module.exports = function() {
  };
  NullCache.prototype.set = function(key, value) {
  };
  NullCache.prototype.get = function(key) {
  };
  NullCache.prototype.has = function(key) {
    return false;
  };
  NullCache.prototype.key = function(str, options) {
    return "";
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/cache/index.js
var require_cache = __commonJS((exports, module) => {
  var getCache = module.exports = function(name, options) {
    if (typeof name == "function")
      return new name(options);
    var cache;
    switch (name) {
      case "memory":
        cache = require_memory();
        break;
      default:
        cache = require_null2();
    }
    return new cache(options);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  /*!
   * Stylus - Parser
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Lexer = require_lexer();
  var nodes = require_nodes();
  var Token = require_token();
  var units = require_units();
  var errors = require_errors();
  var cache = require_cache();
  var debug = {
    lexer: require_src()("stylus:lexer"),
    selector: require_src()("stylus:parser:selector")
  };
  var selectorTokens = [
    "ident",
    "string",
    "selector",
    "function",
    "comment",
    "boolean",
    "space",
    "color",
    "unit",
    "for",
    "in",
    "[",
    "]",
    "(",
    ")",
    "+",
    "-",
    "*",
    "*=",
    "<",
    ">",
    "=",
    ":",
    "&",
    "&&",
    "~",
    "{",
    "}",
    ".",
    "..",
    "/"
  ];
  var pseudoSelectors = [
    "matches",
    "not",
    "dir",
    "lang",
    "any-link",
    "link",
    "visited",
    "local-link",
    "target",
    "scope",
    "hover",
    "active",
    "focus",
    "drop",
    "current",
    "past",
    "future",
    "enabled",
    "disabled",
    "read-only",
    "read-write",
    "placeholder-shown",
    "checked",
    "indeterminate",
    "valid",
    "invalid",
    "in-range",
    "out-of-range",
    "required",
    "optional",
    "user-error",
    "root",
    "empty",
    "blank",
    "nth-child",
    "nth-last-child",
    "first-child",
    "last-child",
    "only-child",
    "nth-of-type",
    "nth-last-of-type",
    "first-of-type",
    "last-of-type",
    "only-of-type",
    "nth-match",
    "nth-last-match",
    "nth-column",
    "nth-last-column",
    "first-line",
    "first-letter",
    "before",
    "after",
    "selection"
  ];
  var Parser = module.exports = function Parser(str, options) {
    var self2 = this;
    options = options || {};
    Parser.cache = Parser.cache || Parser.getCache(options);
    this.hash = Parser.cache.key(str, options);
    this.lexer = {};
    if (!Parser.cache.has(this.hash)) {
      this.lexer = new Lexer(str, options);
    }
    this.prefix = options.prefix || "";
    this.root = options.root || new nodes.Root;
    this.state = ["root"];
    this.stash = [];
    this.parens = 0;
    this.css = 0;
    this.state.pop = function() {
      self2.prevState = [].pop.call(this);
    };
  };
  Parser.getCache = function(options) {
    return options.cache === false ? cache(false) : cache(options.cache || "memory", options);
  };
  Parser.prototype = {
    constructor: Parser,
    currentState: function() {
      return this.state[this.state.length - 1];
    },
    previousState: function() {
      return this.state[this.state.length - 2];
    },
    parse: function() {
      var block = this.parent = this.root;
      if (Parser.cache.has(this.hash)) {
        block = Parser.cache.get(this.hash);
        if (block.nodeName == "block")
          block.constructor = nodes.Root;
      } else {
        while (this.peek().type != "eos") {
          this.skipWhitespace();
          if (this.peek().type == "eos")
            break;
          var stmt = this.statement();
          this.accept(";");
          if (!stmt)
            this.error("unexpected token {peek}, not allowed at the root level");
          block.push(stmt);
        }
        Parser.cache.set(this.hash, block);
      }
      return block;
    },
    error: function(msg) {
      var type = this.peek().type, val = this.peek().val == undefined ? "" : " " + this.peek().toString();
      if (val.trim() == type.trim())
        val = "";
      throw new errors.ParseError(msg.replace("{peek}", '"' + type + val + '"'));
    },
    accept: function(type) {
      if (type == this.peek().type) {
        return this.next();
      }
    },
    expect: function(type) {
      if (type != this.peek().type) {
        this.error('expected "' + type + '", got {peek}');
      }
      return this.next();
    },
    next: function() {
      var tok = this.stash.length ? this.stash.pop() : this.lexer.next(), line = tok.lineno, column = tok.column || 1;
      if (tok.val && tok.val.nodeName) {
        tok.val.lineno = line;
        tok.val.column = column;
      }
      nodes.lineno = line;
      nodes.column = column;
      debug.lexer("%s %s", tok.type, tok.val || "");
      return tok;
    },
    peek: function() {
      return this.lexer.peek();
    },
    lookahead: function(n) {
      return this.lexer.lookahead(n);
    },
    isSelectorToken: function(n) {
      var la = this.lookahead(n).type;
      switch (la) {
        case "for":
          return this.bracketed;
        case "[":
          this.bracketed = true;
          return true;
        case "]":
          this.bracketed = false;
          return true;
        default:
          return ~selectorTokens.indexOf(la);
      }
    },
    isPseudoSelector: function(n) {
      var val = this.lookahead(n).val;
      return val && ~pseudoSelectors.indexOf(val.name);
    },
    lineContains: function(type) {
      var i = 1, la;
      while (la = this.lookahead(i++)) {
        if (~["indent", "outdent", "newline", "eos"].indexOf(la.type))
          return;
        if (type == la.type)
          return true;
      }
    },
    selectorToken: function() {
      if (this.isSelectorToken(1)) {
        if (this.peek().type == "{") {
          if (!this.lineContains("}"))
            return;
          var i = 0, la;
          while (la = this.lookahead(++i)) {
            if (la.type == "}") {
              if (i == 2 || i == 3 && this.lookahead(i - 1).type == "space")
                return;
              break;
            }
            if (la.type == ":")
              return;
          }
        }
        return this.next();
      }
    },
    skip: function(tokens) {
      while (~tokens.indexOf(this.peek().type))
        this.next();
    },
    skipWhitespace: function() {
      this.skip(["space", "indent", "outdent", "newline"]);
    },
    skipNewlines: function() {
      while (this.peek().type == "newline")
        this.next();
    },
    skipSpaces: function() {
      while (this.peek().type == "space")
        this.next();
    },
    skipSpacesAndComments: function() {
      while (this.peek().type == "space" || this.peek().type == "comment")
        this.next();
    },
    looksLikeFunctionDefinition: function(i) {
      return this.lookahead(i).type == "indent" || this.lookahead(i).type == "{";
    },
    looksLikeSelector: function(fromProperty) {
      var i = 1, node, brace;
      if (fromProperty && this.lookahead(i + 1).type == ":" && (this.lookahead(i + 1).space || this.lookahead(i + 2).type == "indent"))
        return false;
      while (this.lookahead(i).type == "ident" && (this.lookahead(i + 1).type == "newline" || this.lookahead(i + 1).type == ","))
        i += 2;
      while (this.isSelectorToken(i) || this.lookahead(i).type == ",") {
        if (this.lookahead(i).type == "selector")
          return true;
        if (this.lookahead(i + 1).type == "&")
          return true;
        if (i > 1 && this.lookahead(i - 1).type === "ident" && this.lookahead(i).type === "." && this.lookahead(i + 1).type === "ident") {
          while (node = this.lookahead(i + 2)) {
            if ([
              "indent",
              "outdent",
              "{",
              ";",
              "eos",
              "selector",
              "media",
              "if",
              "atrule",
              ")",
              "}",
              "unit",
              "[",
              "for",
              "function"
            ].indexOf(node.type) !== -1) {
              if (node.type === "[") {
                while ((node = this.lookahead(i + 3)) && node.type !== "]") {
                  if (~[".", "unit"].indexOf(node.type)) {
                    return false;
                  }
                  i += 1;
                }
              } else {
                if (this.isPseudoSelector(i + 2)) {
                  return true;
                }
                if (node.type === ")" && this.lookahead(i + 3) && this.lookahead(i + 3).type === "}") {
                  break;
                }
                return [
                  "outdent",
                  ";",
                  "eos",
                  "media",
                  "if",
                  "atrule",
                  ")",
                  "}",
                  "unit",
                  "for",
                  "function"
                ].indexOf(node.type) === -1;
              }
            }
            i += 1;
          }
          return true;
        }
        if (this.lookahead(i).type == "." && this.lookahead(i + 1).type == "ident") {
          return true;
        }
        if (this.lookahead(i).type == "*" && this.lookahead(i + 1).type == "newline")
          return true;
        if (this.lookahead(i).type == ":" && this.lookahead(i + 1).type == ":")
          return true;
        if (this.lookahead(i).type == "color" && this.lookahead(i - 1).type == "newline")
          return true;
        if (this.looksLikeAttributeSelector(i))
          return true;
        if ((this.lookahead(i).type == "=" || this.lookahead(i).type == "function") && this.lookahead(i + 1).type == "{")
          return false;
        if (this.lookahead(i).type == ":" && !this.isPseudoSelector(i + 1) && this.lineContains("."))
          return false;
        if (this.lookahead(i).type == "{")
          brace = true;
        else if (this.lookahead(i).type == "}")
          brace = false;
        if (brace && this.lookahead(i).type == ":")
          return true;
        if (this.lookahead(i).type == "space" && this.lookahead(i + 1).type == "{")
          return true;
        if (this.lookahead(i++).type == ":" && !this.lookahead(i - 1).space && this.isPseudoSelector(i))
          return true;
        if (this.lookahead(i).type == "space" && this.lookahead(i + 1).type == "newline" && this.lookahead(i + 2).type == "{")
          return true;
        if (this.lookahead(i).type == "," && this.lookahead(i + 1).type == "newline")
          return true;
      }
      if (this.lookahead(i).type == "," && this.lookahead(i + 1).type == "newline")
        return true;
      if (this.lookahead(i).type == "{" && this.lookahead(i + 1).type == "newline")
        return true;
      if (this.css) {
        if (this.lookahead(i).type == ";" || this.lookahead(i - 1).type == "}")
          return false;
      }
      while (!~[
        "indent",
        "outdent",
        "newline",
        "for",
        "if",
        ";",
        "}",
        "eos"
      ].indexOf(this.lookahead(i).type))
        ++i;
      if (this.lookahead(i).type == "indent")
        return true;
    },
    looksLikeAttributeSelector: function(n) {
      var type = this.lookahead(n).type;
      if (type == "=" && this.bracketed)
        return true;
      return (type == "ident" || type == "string") && this.lookahead(n + 1).type == "]" && (this.lookahead(n + 2).type == "newline" || this.isSelectorToken(n + 2)) && !this.lineContains(":") && !this.lineContains("=");
    },
    looksLikeKeyframe: function() {
      var i = 2, type;
      switch (this.lookahead(i).type) {
        case "{":
        case "indent":
        case ",":
          return true;
        case "newline":
          while (this.lookahead(++i).type == "unit" || this.lookahead(i).type == "newline")
            ;
          type = this.lookahead(i).type;
          return type == "indent" || type == "{";
      }
    },
    stateAllowsSelector: function() {
      switch (this.currentState()) {
        case "root":
        case "atblock":
        case "selector":
        case "conditional":
        case "function":
        case "atrule":
        case "for":
          return true;
      }
    },
    assignAtblock: function(expr) {
      try {
        expr.push(this.atblock(expr));
      } catch (err) {
        this.error("invalid right-hand side operand in assignment, got {peek}");
      }
    },
    statement: function() {
      var stmt = this.stmt(), state = this.prevState, block, op;
      if (this.allowPostfix) {
        this.allowPostfix = false;
        state = "expression";
      }
      switch (state) {
        case "assignment":
        case "expression":
        case "function arguments":
          while (op = this.accept("if") || this.accept("unless") || this.accept("for")) {
            switch (op.type) {
              case "if":
              case "unless":
                stmt = new nodes.If(this.expression(), stmt);
                stmt.postfix = true;
                stmt.negate = op.type == "unless";
                this.accept(";");
                break;
              case "for":
                var key, val = this.id().name;
                if (this.accept(","))
                  key = this.id().name;
                this.expect("in");
                var each = new nodes.Each(val, key, this.expression());
                block = new nodes.Block(this.parent, each);
                block.push(stmt);
                each.block = block;
                stmt = each;
            }
          }
      }
      return stmt;
    },
    stmt: function() {
      var tok = this.peek(), selector;
      switch (tok.type) {
        case "keyframes":
          return this.keyframes();
        case "-moz-document":
          return this.mozdocument();
        case "comment":
        case "selector":
        case "literal":
        case "charset":
        case "namespace":
        case "import":
        case "require":
        case "extend":
        case "media":
        case "atrule":
        case "ident":
        case "scope":
        case "supports":
        case "unless":
        case "function":
        case "for":
        case "if":
          return this[tok.type]();
        case "return":
          return this.return();
        case "{":
          return this.property();
        default:
          if (this.stateAllowsSelector()) {
            switch (tok.type) {
              case "color":
              case "~":
              case ">":
              case "<":
              case ":":
              case "&":
              case "&&":
              case "[":
              case ".":
              case "/":
                selector = this.selector();
                selector.column = tok.column;
                selector.lineno = tok.lineno;
                return selector;
              case "..":
                if (this.lookahead(2).type == "/")
                  return this.selector();
              case "+":
                return this.lookahead(2).type == "function" ? this.functionCall() : this.selector();
              case "*":
                return this.property();
              case "unit":
                if (this.looksLikeKeyframe()) {
                  selector = this.selector();
                  selector.column = tok.column;
                  selector.lineno = tok.lineno;
                  return selector;
                }
              case "-":
                if (this.lookahead(2).type == "{")
                  return this.property();
            }
          }
          var expr = this.expression();
          if (expr.isEmpty)
            this.error("unexpected {peek}");
          return expr;
      }
    },
    block: function(node, scope) {
      var delim, stmt, next, block = this.parent = new nodes.Block(this.parent, node);
      if (scope === false)
        block.scope = false;
      this.accept("newline");
      if (this.accept("{")) {
        this.css++;
        delim = "}";
        this.skipWhitespace();
      } else {
        delim = "outdent";
        this.expect("indent");
      }
      while (delim != this.peek().type) {
        if (this.css) {
          if (this.accept("newline") || this.accept("indent"))
            continue;
          stmt = this.statement();
          this.accept(";");
          this.skipWhitespace();
        } else {
          if (this.accept("newline"))
            continue;
          next = this.lookahead(2).type;
          if (this.peek().type == "indent" && ~["outdent", "newline", "comment"].indexOf(next)) {
            this.skip(["indent", "outdent"]);
            continue;
          }
          if (this.peek().type == "eos")
            return block;
          stmt = this.statement();
          this.accept(";");
        }
        if (!stmt)
          this.error("unexpected token {peek} in block");
        block.push(stmt);
      }
      if (this.css) {
        this.skipWhitespace();
        this.expect("}");
        this.skipSpaces();
        this.css--;
      } else {
        this.expect("outdent");
      }
      this.parent = block.parent;
      return block;
    },
    comment: function() {
      var node = this.next().val;
      this.skipSpaces();
      return node;
    },
    for: function() {
      this.expect("for");
      var key, val = this.id().name;
      if (this.accept(","))
        key = this.id().name;
      this.expect("in");
      this.state.push("for");
      this.cond = true;
      var each = new nodes.Each(val, key, this.expression());
      this.cond = false;
      each.block = this.block(each, false);
      this.state.pop();
      return each;
    },
    return: function() {
      this.expect("return");
      var expr = this.expression();
      return expr.isEmpty ? new nodes.Return : new nodes.Return(expr);
    },
    unless: function() {
      this.expect("unless");
      this.state.push("conditional");
      this.cond = true;
      var node = new nodes.If(this.expression(), true);
      this.cond = false;
      node.block = this.block(node, false);
      this.state.pop();
      return node;
    },
    if: function() {
      var token = this.expect("if");
      this.state.push("conditional");
      this.cond = true;
      var node = new nodes.If(this.expression()), cond, block, item;
      node.column = token.column;
      this.cond = false;
      node.block = this.block(node, false);
      this.skip(["newline", "comment"]);
      while (this.accept("else")) {
        token = this.accept("if");
        if (token) {
          this.cond = true;
          cond = this.expression();
          this.cond = false;
          block = this.block(node, false);
          item = new nodes.If(cond, block);
          item.column = token.column;
          node.elses.push(item);
        } else {
          node.elses.push(this.block(node, false));
          break;
        }
        this.skip(["newline", "comment"]);
      }
      this.state.pop();
      return node;
    },
    atblock: function(node) {
      if (!node)
        this.expect("atblock");
      node = new nodes.Atblock;
      this.state.push("atblock");
      node.block = this.block(node, false);
      this.state.pop();
      return node;
    },
    atrule: function() {
      var type = this.expect("atrule").val, node = new nodes.Atrule(type), tok;
      this.skipSpacesAndComments();
      node.segments = this.selectorParts();
      this.skipSpacesAndComments();
      tok = this.peek().type;
      if (tok == "indent" || tok == "{" || tok == "newline" && this.lookahead(2).type == "{") {
        this.state.push("atrule");
        node.block = this.block(node);
        this.state.pop();
      }
      return node;
    },
    scope: function() {
      this.expect("scope");
      var selector = this.selectorParts().map(function(selector2) {
        return selector2.val;
      }).join("");
      this.selectorScope = selector.trim();
      return nodes.null;
    },
    supports: function() {
      this.expect("supports");
      var node = new nodes.Supports(this.supportsCondition());
      this.state.push("atrule");
      node.block = this.block(node);
      this.state.pop();
      return node;
    },
    supportsCondition: function() {
      var node = this.supportsNegation() || this.supportsOp();
      if (!node) {
        this.cond = true;
        node = this.expression();
        this.cond = false;
      }
      return node;
    },
    supportsNegation: function() {
      if (this.accept("not")) {
        var node = new nodes.Expression;
        node.push(new nodes.Literal("not"));
        node.push(this.supportsFeature());
        return node;
      }
    },
    supportsOp: function() {
      var feature = this.supportsFeature(), op, expr;
      if (feature) {
        expr = new nodes.Expression;
        expr.push(feature);
        while (op = this.accept("&&") || this.accept("||")) {
          expr.push(new nodes.Literal(op.val == "&&" ? "and" : "or"));
          expr.push(this.supportsFeature());
        }
        return expr;
      }
    },
    supportsFeature: function() {
      this.skipSpacesAndComments();
      if (this.peek().type == "(") {
        var la = this.lookahead(2).type;
        if (la == "ident" || la == "{") {
          return this.feature();
        } else {
          this.expect("(");
          var node = new nodes.Expression;
          node.push(new nodes.Literal("("));
          node.push(this.supportsCondition());
          this.expect(")");
          node.push(new nodes.Literal(")"));
          this.skipSpacesAndComments();
          return node;
        }
      }
    },
    extend: function() {
      var tok = this.expect("extend"), selectors = [], sel, node, arr;
      do {
        arr = this.selectorParts();
        if (!arr.length)
          continue;
        sel = new nodes.Selector(arr);
        selectors.push(sel);
        if (this.peek().type !== "!")
          continue;
        tok = this.lookahead(2);
        if (tok.type !== "ident" || tok.val.name !== "optional")
          continue;
        this.skip(["!", "ident"]);
        sel.optional = true;
      } while (this.accept(","));
      node = new nodes.Extend(selectors);
      node.lineno = tok.lineno;
      node.column = tok.column;
      return node;
    },
    media: function() {
      this.expect("media");
      this.state.push("atrule");
      var media = new nodes.Media(this.queries());
      media.block = this.block(media);
      this.state.pop();
      return media;
    },
    queries: function() {
      var queries = new nodes.QueryList, skip = ["comment", "newline", "space"];
      do {
        this.skip(skip);
        queries.push(this.query());
        this.skip(skip);
      } while (this.accept(","));
      return queries;
    },
    query: function() {
      var query = new nodes.Query, expr, pred, id;
      if (this.peek().type == "ident" && (this.lookahead(2).type == "." || this.lookahead(2).type == "[")) {
        this.cond = true;
        expr = this.expression();
        this.cond = false;
        query.push(new nodes.Feature(expr.nodes));
        return query;
      }
      if (pred = this.accept("ident") || this.accept("not")) {
        pred = new nodes.Literal(pred.val.string || pred.val);
        this.skipSpacesAndComments();
        if (id = this.accept("ident")) {
          query.type = id.val;
          query.predicate = pred;
        } else {
          query.type = pred;
        }
        this.skipSpacesAndComments();
        if (!this.accept("&&"))
          return query;
      }
      do {
        query.push(this.feature());
      } while (this.accept("&&"));
      return query;
    },
    feature: function() {
      this.skipSpacesAndComments();
      this.expect("(");
      this.skipSpacesAndComments();
      var node = new nodes.Feature(this.interpolate());
      this.skipSpacesAndComments();
      this.accept(":");
      this.skipSpacesAndComments();
      this.inProperty = true;
      node.expr = this.list();
      this.inProperty = false;
      this.skipSpacesAndComments();
      this.expect(")");
      this.skipSpacesAndComments();
      return node;
    },
    mozdocument: function() {
      this.expect("-moz-document");
      var mozdocument = new nodes.Atrule("-moz-document"), calls = [];
      do {
        this.skipSpacesAndComments();
        calls.push(this.functionCall());
        this.skipSpacesAndComments();
      } while (this.accept(","));
      mozdocument.segments = [new nodes.Literal(calls.join(", "))];
      this.state.push("atrule");
      mozdocument.block = this.block(mozdocument, false);
      this.state.pop();
      return mozdocument;
    },
    import: function() {
      this.expect("import");
      this.allowPostfix = true;
      return new nodes.Import(this.expression(), false);
    },
    require: function() {
      this.expect("require");
      this.allowPostfix = true;
      return new nodes.Import(this.expression(), true);
    },
    charset: function() {
      this.expect("charset");
      var str = this.expect("string").val;
      this.allowPostfix = true;
      return new nodes.Charset(str);
    },
    namespace: function() {
      var str, prefix;
      this.expect("namespace");
      this.skipSpacesAndComments();
      if (prefix = this.accept("ident")) {
        prefix = prefix.val;
      }
      this.skipSpacesAndComments();
      str = this.accept("string") || this.url();
      this.allowPostfix = true;
      return new nodes.Namespace(str, prefix);
    },
    keyframes: function() {
      var tok = this.expect("keyframes"), keyframes;
      this.skipSpacesAndComments();
      keyframes = new nodes.Keyframes(this.selectorParts(), tok.val);
      keyframes.column = tok.column;
      this.skipSpacesAndComments();
      this.state.push("atrule");
      keyframes.block = this.block(keyframes);
      this.state.pop();
      return keyframes;
    },
    literal: function() {
      return this.expect("literal").val;
    },
    id: function() {
      var tok = this.expect("ident");
      this.accept("space");
      return tok.val;
    },
    ident: function() {
      var i = 2, la = this.lookahead(i).type;
      while (la == "space")
        la = this.lookahead(++i).type;
      switch (la) {
        case "=":
        case "?=":
        case "-=":
        case "+=":
        case "*=":
        case "/=":
        case "%=":
          return this.assignment();
        case ".":
          if (this.lookahead(i - 1).type == "space")
            return this.selector();
          if (this._ident == this.peek())
            return this.id();
          while (this.lookahead(++i).type != "=" && !~["[", ",", "newline", "indent", "eos"].indexOf(this.lookahead(i).type))
            ;
          if (this.lookahead(i).type == "=") {
            this._ident = this.peek();
            return this.expression();
          } else if (this.looksLikeSelector() && this.stateAllowsSelector()) {
            return this.selector();
          }
        case "[":
          if (this._ident == this.peek())
            return this.id();
          while (this.lookahead(i++).type != "]" && this.lookahead(i).type != "selector" && this.lookahead(i).type != "eos")
            ;
          if (this.lookahead(i).type == "=") {
            this._ident = this.peek();
            return this.expression();
          } else if (this.looksLikeSelector() && this.stateAllowsSelector()) {
            return this.selector();
          }
        case "-":
        case "+":
        case "/":
        case "*":
        case "%":
        case "**":
        case "&&":
        case "||":
        case ">":
        case "<":
        case ">=":
        case "<=":
        case "!=":
        case "==":
        case "?":
        case "in":
        case "is a":
        case "is defined":
          if (this._ident == this.peek()) {
            return this.id();
          } else {
            this._ident = this.peek();
            switch (this.currentState()) {
              case "for":
              case "selector":
                return this.property();
              case "root":
              case "atblock":
              case "atrule":
                return la == "[" ? this.subscript() : this.selector();
              case "function":
              case "conditional":
                return this.looksLikeSelector() ? this.selector() : this.expression();
              default:
                return this.operand ? this.id() : this.expression();
            }
          }
        default:
          switch (this.currentState()) {
            case "root":
              return this.selector();
            case "for":
            case "selector":
            case "function":
            case "conditional":
            case "atblock":
            case "atrule":
              return this.property();
            default:
              var id = this.id();
              if (this.previousState() == "interpolation")
                id.mixin = true;
              return id;
          }
      }
    },
    interpolate: function() {
      var node, segs = [], star;
      star = this.accept("*");
      if (star)
        segs.push(new nodes.Literal("*"));
      while (true) {
        if (this.accept("{")) {
          this.state.push("interpolation");
          segs.push(this.expression());
          this.expect("}");
          this.state.pop();
        } else if (node = this.accept("-")) {
          segs.push(new nodes.Literal("-"));
        } else if (node = this.accept("ident")) {
          segs.push(node.val);
        } else {
          break;
        }
      }
      if (!segs.length)
        this.expect("ident");
      return segs;
    },
    property: function() {
      if (this.looksLikeSelector(true))
        return this.selector();
      var ident = this.interpolate(), prop = new nodes.Property(ident), ret = prop;
      this.accept("space");
      if (this.accept(":"))
        this.accept("space");
      this.state.push("property");
      this.inProperty = true;
      prop.expr = this.list();
      if (prop.expr.isEmpty)
        ret = ident[0];
      this.inProperty = false;
      this.allowPostfix = true;
      this.state.pop();
      this.accept(";");
      return ret;
    },
    selector: function() {
      var arr, group = new nodes.Group, scope = this.selectorScope, isRoot = this.currentState() == "root", selector;
      do {
        this.accept("newline");
        arr = this.selectorParts();
        if (isRoot && scope)
          arr.unshift(new nodes.Literal(scope + " "));
        if (arr.length) {
          selector = new nodes.Selector(arr);
          selector.lineno = arr[0].lineno;
          selector.column = arr[0].column;
          group.push(selector);
        }
      } while (this.accept(",") || this.accept("newline"));
      if (this.currentState() == "selector-parts")
        return group.nodes;
      this.state.push("selector");
      group.block = this.block(group);
      this.state.pop();
      return group;
    },
    selectorParts: function() {
      var tok, arr = [];
      while (tok = this.selectorToken()) {
        debug.selector("%s", tok);
        switch (tok.type) {
          case "{":
            this.skipSpaces();
            var expr = this.expression();
            this.skipSpaces();
            this.expect("}");
            arr.push(expr);
            break;
          case (this.prefix && "."):
            var literal = new nodes.Literal(tok.val + this.prefix);
            literal.prefixed = true;
            arr.push(literal);
            break;
          case "comment":
            break;
          case "color":
          case "unit":
            arr.push(new nodes.Literal(tok.val.raw));
            break;
          case "space":
            arr.push(new nodes.Literal(" "));
            break;
          case "function":
            arr.push(new nodes.Literal(tok.val.name + "("));
            break;
          case "ident":
            arr.push(new nodes.Literal(tok.val.name || tok.val.string));
            break;
          default:
            arr.push(new nodes.Literal(tok.val));
            if (tok.space)
              arr.push(new nodes.Literal(" "));
        }
      }
      return arr;
    },
    assignment: function() {
      var op, node, ident = this.id(), name = ident.name;
      if (op = this.accept("=") || this.accept("?=") || this.accept("+=") || this.accept("-=") || this.accept("*=") || this.accept("/=") || this.accept("%=")) {
        this.state.push("assignment");
        var expr = this.list();
        if (expr.isEmpty)
          this.assignAtblock(expr);
        node = new nodes.Ident(name, expr);
        node.lineno = ident.lineno;
        node.column = ident.column;
        this.state.pop();
        switch (op.type) {
          case "?=":
            var defined = new nodes.BinOp("is defined", node), lookup = new nodes.Expression;
            lookup.push(new nodes.Ident(name));
            node = new nodes.Ternary(defined, lookup, node);
            break;
          case "+=":
          case "-=":
          case "*=":
          case "/=":
          case "%=":
            node.val = new nodes.BinOp(op.type[0], new nodes.Ident(name), expr);
            break;
        }
      }
      return node;
    },
    function: function() {
      var parens = 1, i = 2, tok;
      out:
        while (tok = this.lookahead(i++)) {
          switch (tok.type) {
            case "function":
            case "(":
              ++parens;
              break;
            case ")":
              if (!--parens)
                break out;
              break;
            case "eos":
              this.error('failed to find closing paren ")"');
          }
        }
      switch (this.currentState()) {
        case "expression":
          return this.functionCall();
        default:
          return this.looksLikeFunctionDefinition(i) ? this.functionDefinition() : this.expression();
      }
    },
    url: function() {
      this.expect("function");
      this.state.push("function arguments");
      var args = this.args();
      this.expect(")");
      this.state.pop();
      return new nodes.Call("url", args);
    },
    functionCall: function() {
      var withBlock = this.accept("+");
      if (this.peek().val.name == "url")
        return this.url();
      var tok = this.expect("function").val;
      var name = tok.name;
      this.state.push("function arguments");
      this.parens++;
      var args = this.args();
      this.expect(")");
      this.parens--;
      this.state.pop();
      var call = new nodes.Call(name, args);
      call.column = tok.column;
      call.lineno = tok.lineno;
      if (withBlock) {
        this.state.push("function");
        call.block = this.block(call);
        this.state.pop();
      }
      return call;
    },
    functionDefinition: function() {
      var tok = this.expect("function"), name = tok.val.name;
      this.state.push("function params");
      this.skipWhitespace();
      var params = this.params();
      this.skipWhitespace();
      this.expect(")");
      this.state.pop();
      this.state.push("function");
      var fn = new nodes.Function(name, params);
      fn.column = tok.column;
      fn.lineno = tok.lineno;
      fn.block = this.block(fn);
      this.state.pop();
      return new nodes.Ident(name, fn);
    },
    params: function() {
      var tok, node, params = new nodes.Params;
      while (tok = this.accept("ident")) {
        this.accept("space");
        params.push(node = tok.val);
        if (this.accept("...")) {
          node.rest = true;
        } else if (this.accept("=")) {
          node.val = this.expression();
        }
        this.skipWhitespace();
        this.accept(",");
        this.skipWhitespace();
      }
      return params;
    },
    args: function() {
      var args = new nodes.Arguments, keyword;
      do {
        if (this.peek().type == "ident" && this.lookahead(2).type == ":") {
          keyword = this.next().val.string;
          this.expect(":");
          args.map[keyword] = this.expression();
        } else {
          args.push(this.expression());
        }
      } while (this.accept(","));
      return args;
    },
    list: function() {
      var node = this.expression();
      while (this.accept(",")) {
        if (node.isList) {
          list.push(this.expression());
        } else {
          var list = new nodes.Expression(true);
          list.push(node);
          list.push(this.expression());
          node = list;
        }
      }
      return node;
    },
    expression: function() {
      var node, expr = new nodes.Expression;
      this.state.push("expression");
      while (node = this.negation()) {
        if (!node)
          this.error("unexpected token {peek} in expression");
        expr.push(node);
      }
      this.state.pop();
      if (expr.nodes.length) {
        expr.lineno = expr.nodes[0].lineno;
        expr.column = expr.nodes[0].column;
      }
      return expr;
    },
    negation: function() {
      if (this.accept("not")) {
        return new nodes.UnaryOp("!", this.negation());
      }
      return this.ternary();
    },
    ternary: function() {
      var node = this.logical();
      if (this.accept("?")) {
        var trueExpr = this.expression();
        this.expect(":");
        var falseExpr = this.expression();
        node = new nodes.Ternary(node, trueExpr, falseExpr);
      }
      return node;
    },
    logical: function() {
      var op, node = this.typecheck();
      while (op = this.accept("&&") || this.accept("||")) {
        node = new nodes.BinOp(op.type, node, this.typecheck());
      }
      return node;
    },
    typecheck: function() {
      var op, node = this.equality();
      while (op = this.accept("is a")) {
        this.operand = true;
        if (!node)
          this.error('illegal unary "' + op + '", missing left-hand operand');
        node = new nodes.BinOp(op.type, node, this.equality());
        this.operand = false;
      }
      return node;
    },
    equality: function() {
      var op, node = this.in();
      while (op = this.accept("==") || this.accept("!=")) {
        this.operand = true;
        if (!node)
          this.error('illegal unary "' + op + '", missing left-hand operand');
        node = new nodes.BinOp(op.type, node, this.in());
        this.operand = false;
      }
      return node;
    },
    in: function() {
      var node = this.relational();
      while (this.accept("in")) {
        this.operand = true;
        if (!node)
          this.error('illegal unary "in", missing left-hand operand');
        node = new nodes.BinOp("in", node, this.relational());
        this.operand = false;
      }
      return node;
    },
    relational: function() {
      var op, node = this.range();
      while (op = this.accept(">=") || this.accept("<=") || this.accept("<") || this.accept(">")) {
        this.operand = true;
        if (!node)
          this.error('illegal unary "' + op + '", missing left-hand operand');
        node = new nodes.BinOp(op.type, node, this.range());
        this.operand = false;
      }
      return node;
    },
    range: function() {
      var op, node = this.additive();
      if (op = this.accept("...") || this.accept("..")) {
        this.operand = true;
        if (!node)
          this.error('illegal unary "' + op + '", missing left-hand operand');
        node = new nodes.BinOp(op.val, node, this.additive());
        this.operand = false;
      }
      return node;
    },
    additive: function() {
      var op, node = this.multiplicative();
      while (op = this.accept("+") || this.accept("-")) {
        this.operand = true;
        node = new nodes.BinOp(op.type, node, this.multiplicative());
        this.operand = false;
      }
      return node;
    },
    multiplicative: function() {
      var op, node = this.defined();
      while (op = this.accept("**") || this.accept("*") || this.accept("/") || this.accept("%")) {
        this.operand = true;
        if (op == "/" && this.inProperty && !this.parens) {
          this.stash.push(new Token("literal", new nodes.Literal("/")));
          this.operand = false;
          return node;
        } else {
          if (!node)
            this.error('illegal unary "' + op + '", missing left-hand operand');
          node = new nodes.BinOp(op.type, node, this.defined());
          this.operand = false;
        }
      }
      return node;
    },
    defined: function() {
      var node = this.unary();
      if (this.accept("is defined")) {
        if (!node)
          this.error('illegal unary "is defined", missing left-hand operand');
        node = new nodes.BinOp("is defined", node);
      }
      return node;
    },
    unary: function() {
      var op, node;
      if (op = this.accept("!") || this.accept("~") || this.accept("+") || this.accept("-")) {
        this.operand = true;
        node = this.unary();
        if (!node)
          this.error('illegal unary "' + op + '"');
        node = new nodes.UnaryOp(op.type, node);
        this.operand = false;
        return node;
      }
      return this.subscript();
    },
    subscript: function() {
      var node = this.member(), id;
      while (this.accept("[")) {
        node = new nodes.BinOp("[]", node, this.expression());
        this.expect("]");
      }
      if (this.accept("=")) {
        node.op += "=";
        node.val = this.list();
        if (node.val.isEmpty)
          this.assignAtblock(node.val);
      }
      return node;
    },
    member: function() {
      var node = this.primary();
      if (node) {
        while (this.accept(".")) {
          var id = new nodes.Ident(this.expect("ident").val.string);
          node = new nodes.Member(node, id);
        }
        this.skipSpaces();
        if (this.accept("=")) {
          node.val = this.list();
          if (node.val.isEmpty)
            this.assignAtblock(node.val);
        }
      }
      return node;
    },
    object: function() {
      var obj = new nodes.Object, id, val, comma, hash;
      this.expect("{");
      this.skipWhitespace();
      while (!this.accept("}")) {
        if (this.accept("comment") || this.accept("newline"))
          continue;
        if (!comma)
          this.accept(",");
        id = this.accept("ident") || this.accept("string");
        if (!id) {
          this.error('expected "ident" or "string", got {peek}');
        }
        hash = id.val.hash;
        this.skipSpacesAndComments();
        this.expect(":");
        val = this.expression();
        obj.setValue(hash, val);
        obj.setKey(hash, id.val);
        comma = this.accept(",");
        this.skipWhitespace();
      }
      return obj;
    },
    primary: function() {
      var tok;
      this.skipSpaces();
      if (this.accept("(")) {
        ++this.parens;
        var expr = this.expression(), paren = this.expect(")");
        --this.parens;
        if (this.accept("%"))
          expr.push(new nodes.Ident("%"));
        tok = this.peek();
        if (!paren.space && tok.type == "ident" && ~units.indexOf(tok.val.string)) {
          expr.push(new nodes.Ident(tok.val.string));
          this.next();
        }
        return expr;
      }
      tok = this.peek();
      switch (tok.type) {
        case "null":
        case "unit":
        case "color":
        case "string":
        case "literal":
        case "boolean":
        case "comment":
          return this.next().val;
        case (!this.cond && "{"):
          return this.object();
        case "atblock":
          return this.atblock();
        case "atrule":
          var id = new nodes.Ident(this.next().val);
          id.property = true;
          return id;
        case "ident":
          return this.ident();
        case "function":
          return tok.anonymous ? this.functionDefinition() : this.functionCall();
      }
    }
  };
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var toVLQSigned = function(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  };
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  exports.encode = function base64VLQ_encode(aValue) {
    let encoded = "";
    let digit;
    let vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/util.js
var require_util = __commonJS((exports) => {
  var getArg = function(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    }
    throw new Error('"' + aName + '" is a required argument.');
  };
  var urlParse = function(aUrl) {
    const match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  };
  var urlGenerate = function(aParsedUrl) {
    let url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  };
  var lruMemoize = function(f) {
    const cache = [];
    return function(input) {
      for (let i = 0;i < cache.length; i++) {
        if (cache[i].input === input) {
          const temp = cache[0];
          cache[0] = cache[i];
          cache[i] = temp;
          return cache[0].result;
        }
      }
      const result = f(input);
      cache.unshift({
        input,
        result
      });
      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }
      return result;
    };
  };
  var join = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    const aPathUrl = urlParse(aPath);
    const aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    const joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  };
  var relative = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    let level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      const index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  };
  var identity = function(s) {
    return s;
  };
  var toSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  };
  var fromSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  };
  var isProtoString = function(s) {
    if (!s) {
      return false;
    }
    const length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (let i = length - 10;i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  };
  var compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
    let cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
    let cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var strcmp = function(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  };
  var compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
    let cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var parseSourceMapInput = function(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  };
  var computeSourceURL = function(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      const parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        const index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  };
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  exports.urlParse = urlParse;
  exports.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  var normalize = lruMemoize(function normalize(aPath) {
    let path = aPath;
    const url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    const isAbsolute = exports.isAbsolute(path);
    const parts = [];
    let start = 0;
    let i = 0;
    while (true) {
      start = i;
      i = path.indexOf("/", start);
      if (i === -1) {
        parts.push(path.slice(start));
        break;
      } else {
        parts.push(path.slice(start, i));
        while (i < path.length && path[i] === "/") {
          i++;
        }
      }
    }
    let up = 0;
    for (i = parts.length - 1;i >= 0; i--) {
      const part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  });
  exports.normalize = normalize;
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  exports.relative = relative;
  var supportsNullProto = function() {
    const obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  exports.toSetString = supportsNullProto ? identity : toSetString;
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  exports.compareByOriginalPositions = compareByOriginalPositions;
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  exports.parseSourceMapInput = parseSourceMapInput;
  exports.computeSourceURL = computeSourceURL;
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  class ArraySet {
    constructor() {
      this._array = [];
      this._set = new Map;
    }
    static fromArray(aArray, aAllowDuplicates) {
      const set = new ArraySet;
      for (let i = 0, len = aArray.length;i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    }
    size() {
      return this._set.size;
    }
    add(aStr, aAllowDuplicates) {
      const isDuplicate = this.has(aStr);
      const idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        this._set.set(aStr, idx);
      }
    }
    has(aStr) {
      return this._set.has(aStr);
    }
    indexOf(aStr) {
      const idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
      throw new Error('"' + aStr + '" is not in the set.');
    }
    at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    }
    toArray() {
      return this._array.slice();
    }
  }
  exports.ArraySet = ArraySet;
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var generatedPositionAfter = function(mappingA, mappingB) {
    const lineA = mappingA.generatedLine;
    const lineB = mappingB.generatedLine;
    const columnA = mappingA.generatedColumn;
    const columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  };
  var util = require_util();

  class MappingList {
    constructor() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    unsortedForEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    }
    add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    }
    toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    }
  }
  exports.MappingList = MappingList;
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
  var base64VLQ = require_base64_vlq();
  var util = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;

  class SourceMapGenerator {
    constructor(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet;
      this._names = new ArraySet;
      this._mappings = new MappingList;
      this._sourcesContents = null;
    }
    static fromSourceMap(aSourceMapConsumer) {
      const sourceRoot = aSourceMapConsumer.sourceRoot;
      const generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        const newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        let sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        const content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    }
    addMapping(aArgs) {
      const generated = util.getArg(aArgs, "generated");
      const original = util.getArg(aArgs, "original", null);
      let source = util.getArg(aArgs, "source", null);
      let name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    }
    setSourceContent(aSourceFile, aSourceContent) {
      let source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    }
    applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      let sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
        }
        sourceFile = aSourceMapConsumer.file;
      }
      const sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      const newSources = this._mappings.toArray().length > 0 ? new ArraySet : this._sources;
      const newNames = new ArraySet;
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          const original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        const source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        const name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(srcFile) {
        const content = aSourceMapConsumer.sourceContentFor(srcFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            srcFile = util.join(aSourceMapPath, srcFile);
          }
          if (sourceRoot != null) {
            srcFile = util.relative(sourceRoot, srcFile);
          }
          this.setSourceContent(srcFile, content);
        }
      }, this);
    }
    _validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    }
    _serializeMappings() {
      let previousGeneratedColumn = 0;
      let previousGeneratedLine = 1;
      let previousOriginalColumn = 0;
      let previousOriginalLine = 0;
      let previousName = 0;
      let previousSource = 0;
      let result = "";
      let next;
      let mapping;
      let nameIdx;
      let sourceIdx;
      const mappings = this._mappings.toArray();
      for (let i = 0, len = mappings.length;i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    }
    _generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        const key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    }
    toJSON() {
      const map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    }
    toString() {
      return JSON.stringify(this.toJSON());
    }
  }
  SourceMapGenerator.prototype._version = 3;
  exports.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS((exports) => {
  var recursiveSearch = function(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    const mid = Math.floor((aHigh - aLow) / 2) + aLow;
    const cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      }
      return mid;
    }
    if (mid - aLow > 1) {
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    }
    return aLow < 0 ? -1 : aLow;
  };
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/read-wasm.js
var require_read_wasm = __commonJS((exports, module) => {
  var __dirname = "/Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib";
  var isBrowserEnvironment = function() {
    return typeof window !== "undefined" && this === window;
  }.call();
  if (isBrowserEnvironment) {
    let mappingsWasm = null;
    module.exports = function readWasm() {
      if (typeof mappingsWasm === "string") {
        return fetch(mappingsWasm).then((response) => response.arrayBuffer());
      }
      if (mappingsWasm instanceof ArrayBuffer) {
        return Promise.resolve(mappingsWasm);
      }
      throw new Error("You must provide the string URL or ArrayBuffer contents of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer");
    };
    module.exports.initialize = (input) => mappingsWasm = input;
  } else {
    const fs = __require("fs");
    const path = __require("path");
    module.exports = function readWasm() {
      return new Promise((resolve, reject) => {
        const wasmPath = path.join(__dirname, "mappings.wasm");
        fs.readFile(wasmPath, null, (error, data) => {
          if (error) {
            reject(error);
            return;
          }
          resolve(data.buffer);
        });
      });
    };
    module.exports.initialize = (_) => {
      console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
    };
  }
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/wasm.js
var require_wasm = __commonJS((exports, module) => {
  var Mapping = function() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.lastGeneratedColumn = null;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  };
  var readWasm = require_read_wasm();
  var cachedWasm = null;
  module.exports = function wasm() {
    if (cachedWasm) {
      return cachedWasm;
    }
    const callbackStack = [];
    cachedWasm = readWasm().then((buffer) => {
      return WebAssembly.instantiate(buffer, {
        env: {
          mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {
            const mapping = new Mapping;
            mapping.generatedLine = generatedLine + 1;
            mapping.generatedColumn = generatedColumn;
            if (hasLastGeneratedColumn) {
              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
            }
            if (hasOriginal) {
              mapping.source = source;
              mapping.originalLine = originalLine + 1;
              mapping.originalColumn = originalColumn;
              if (hasName) {
                mapping.name = name;
              }
            }
            callbackStack[callbackStack.length - 1](mapping);
          },
          start_all_generated_locations_for() {
            console.time("all_generated_locations_for");
          },
          end_all_generated_locations_for() {
            console.timeEnd("all_generated_locations_for");
          },
          start_compute_column_spans() {
            console.time("compute_column_spans");
          },
          end_compute_column_spans() {
            console.timeEnd("compute_column_spans");
          },
          start_generated_location_for() {
            console.time("generated_location_for");
          },
          end_generated_location_for() {
            console.timeEnd("generated_location_for");
          },
          start_original_location_for() {
            console.time("original_location_for");
          },
          end_original_location_for() {
            console.timeEnd("original_location_for");
          },
          start_parse_mappings() {
            console.time("parse_mappings");
          },
          end_parse_mappings() {
            console.timeEnd("parse_mappings");
          },
          start_sort_by_generated_location() {
            console.time("sort_by_generated_location");
          },
          end_sort_by_generated_location() {
            console.timeEnd("sort_by_generated_location");
          },
          start_sort_by_original_location() {
            console.time("sort_by_original_location");
          },
          end_sort_by_original_location() {
            console.timeEnd("sort_by_original_location");
          }
        }
      });
    }).then((Wasm) => {
      return {
        exports: Wasm.instance.exports,
        withMappingCallback: (mappingCallback, f) => {
          callbackStack.push(mappingCallback);
          try {
            f();
          } finally {
            callbackStack.pop();
          }
        }
      };
    }).then(null, (e) => {
      cachedWasm = null;
      throw e;
    });
    return cachedWasm;
  };
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports) => {
  var _factory = function(aSourceMap, aSourceMapURL) {
    let sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    return Promise.resolve(consumer);
  };
  var _factoryBSM = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  var util = require_util();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var readWasm = require_read_wasm();
  var wasm = require_wasm();
  var INTERNAL = Symbol("smcInternal");

  class SourceMapConsumer {
    constructor(aSourceMap, aSourceMapURL) {
      if (aSourceMap == INTERNAL) {
        return Promise.resolve(this);
      }
      return _factory(aSourceMap, aSourceMapURL);
    }
    static initialize(opts) {
      readWasm.initialize(opts["lib/mappings.wasm"]);
    }
    static fromSourceMap(aSourceMap, aSourceMapURL) {
      return _factoryBSM(aSourceMap, aSourceMapURL);
    }
    static async with(rawSourceMap, sourceMapUrl, f) {
      const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);
      try {
        return await f(consumer);
      } finally {
        consumer.destroy();
      }
    }
    _parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    }
    eachMapping(aCallback, aContext, aOrder) {
      throw new Error("Subclasses must implement eachMapping");
    }
    allGeneratedPositionsFor(aArgs) {
      throw new Error("Subclasses must implement allGeneratedPositionsFor");
    }
    destroy() {
      throw new Error("Subclasses must implement destroy");
    }
  }
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  exports.SourceMapConsumer = SourceMapConsumer;

  class BasicSourceMapConsumer extends SourceMapConsumer {
    constructor(aSourceMap, aSourceMapURL) {
      return super(INTERNAL).then((that) => {
        let sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        const version = util.getArg(sourceMap, "version");
        let sources = util.getArg(sourceMap, "sources");
        const names = util.getArg(sourceMap, "names", []);
        let sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        const mappings = util.getArg(sourceMap, "mappings");
        const file = util.getArg(sourceMap, "file", null);
        if (version != that._version) {
          throw new Error("Unsupported version: " + version);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        that._names = ArraySet.fromArray(names.map(String), true);
        that._sources = ArraySet.fromArray(sources, true);
        that._absoluteSources = that._sources.toArray().map(function(s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        that.sourceRoot = sourceRoot;
        that.sourcesContent = sourcesContent;
        that._mappings = mappings;
        that._sourceMapURL = aSourceMapURL;
        that.file = file;
        that._computedColumnSpans = false;
        that._mappingsPtr = 0;
        that._wasm = null;
        return wasm().then((w) => {
          that._wasm = w;
          return that;
        });
      });
    }
    _findSourceIndex(aSource) {
      let relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      for (let i = 0;i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    }
    static fromSourceMap(aSourceMap, aSourceMapURL) {
      return new BasicSourceMapConsumer(aSourceMap.toString());
    }
    get sources() {
      return this._absoluteSources.slice();
    }
    _getMappingsPtr() {
      if (this._mappingsPtr === 0) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this._mappingsPtr;
    }
    _parseMappings(aStr, aSourceRoot) {
      const size = aStr.length;
      const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
      const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
      for (let i = 0;i < size; i++) {
        mappingsBuf[i] = aStr.charCodeAt(i);
      }
      const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);
      if (!mappingsPtr) {
        const error = this._wasm.exports.get_last_error();
        let msg = `Error parsing mappings (code ${error}): `;
        switch (error) {
          case 1:
            msg += "the mappings contained a negative line, column, source index, or name index";
            break;
          case 2:
            msg += "the mappings contained a number larger than 2**32";
            break;
          case 3:
            msg += "reached EOF while in the middle of parsing a VLQ";
            break;
          case 4:
            msg += "invalid base 64 character while parsing a VLQ";
            break;
          default:
            msg += "unknown error code";
            break;
        }
        throw new Error(msg);
      }
      this._mappingsPtr = mappingsPtr;
    }
    eachMapping(aCallback, aContext, aOrder) {
      const context = aContext || null;
      const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      const sourceRoot = this.sourceRoot;
      this._wasm.withMappingCallback((mapping) => {
        if (mapping.source !== null) {
          mapping.source = this._sources.at(mapping.source);
          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);
          if (mapping.name !== null) {
            mapping.name = this._names.at(mapping.name);
          }
        }
        aCallback.call(context, mapping);
      }, () => {
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            this._wasm.exports.by_generated_location(this._getMappingsPtr());
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            this._wasm.exports.by_original_location(this._getMappingsPtr());
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
      });
    }
    allGeneratedPositionsFor(aArgs) {
      let source = util.getArg(aArgs, "source");
      const originalLine = util.getArg(aArgs, "line");
      const originalColumn = aArgs.column || 0;
      source = this._findSourceIndex(source);
      if (source < 0) {
        return [];
      }
      if (originalLine < 1) {
        throw new Error("Line numbers must be >= 1");
      }
      if (originalColumn < 0) {
        throw new Error("Column numbers must be >= 0");
      }
      const mappings = [];
      this._wasm.withMappingCallback((m) => {
        let lastColumn = m.lastGeneratedColumn;
        if (this._computedColumnSpans && lastColumn === null) {
          lastColumn = Infinity;
        }
        mappings.push({
          line: m.generatedLine,
          column: m.generatedColumn,
          lastColumn
        });
      }, () => {
        this._wasm.exports.all_generated_locations_for(this._getMappingsPtr(), source, originalLine - 1, "column" in aArgs, originalColumn);
      });
      return mappings;
    }
    destroy() {
      if (this._mappingsPtr !== 0) {
        this._wasm.exports.free_mappings(this._mappingsPtr);
        this._mappingsPtr = 0;
      }
    }
    computeColumnSpans() {
      if (this._computedColumnSpans) {
        return;
      }
      this._wasm.exports.compute_column_spans(this._getMappingsPtr());
      this._computedColumnSpans = true;
    }
    originalPositionFor(aArgs) {
      const needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      if (needle.generatedLine < 1) {
        throw new Error("Line numbers must be >= 1");
      }
      if (needle.generatedColumn < 0) {
        throw new Error("Column numbers must be >= 0");
      }
      let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
      if (bias == null) {
        bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
      }
      let mapping;
      this._wasm.withMappingCallback((m) => mapping = m, () => {
        this._wasm.exports.original_location_for(this._getMappingsPtr(), needle.generatedLine - 1, needle.generatedColumn, bias);
      });
      if (mapping) {
        if (mapping.generatedLine === needle.generatedLine) {
          let source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          let name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    }
    sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      const index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      let relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      let url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        const fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      }
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
    generatedPositionFor(aArgs) {
      let source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      const needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      if (needle.originalLine < 1) {
        throw new Error("Line numbers must be >= 1");
      }
      if (needle.originalColumn < 0) {
        throw new Error("Column numbers must be >= 0");
      }
      let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
      if (bias == null) {
        bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
      }
      let mapping;
      this._wasm.withMappingCallback((m) => mapping = m, () => {
        this._wasm.exports.generated_location_for(this._getMappingsPtr(), needle.source, needle.originalLine - 1, needle.originalColumn, bias);
      });
      if (mapping) {
        if (mapping.source === needle.source) {
          let lastColumn = mapping.lastGeneratedColumn;
          if (this._computedColumnSpans && lastColumn === null) {
            lastColumn = Infinity;
          }
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
  }
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

  class IndexedSourceMapConsumer extends SourceMapConsumer {
    constructor(aSourceMap, aSourceMapURL) {
      return super(INTERNAL).then((that) => {
        let sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        const version = util.getArg(sourceMap, "version");
        const sections = util.getArg(sourceMap, "sections");
        if (version != that._version) {
          throw new Error("Unsupported version: " + version);
        }
        that._sources = new ArraySet;
        that._names = new ArraySet;
        that.__generatedMappings = null;
        that.__originalMappings = null;
        that.__generatedMappingsUnsorted = null;
        that.__originalMappingsUnsorted = null;
        let lastOffset = {
          line: -1,
          column: 0
        };
        return Promise.all(sections.map((s) => {
          if (s.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          const offset = util.getArg(s, "offset");
          const offsetLine = util.getArg(offset, "line");
          const offsetColumn = util.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset;
          const cons = new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL);
          return cons.then((consumer) => {
            return {
              generatedOffset: {
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1
              },
              consumer
            };
          });
        })).then((s) => {
          that._sections = s;
          return that;
        });
      });
    }
    get _generatedMappings() {
      if (!this.__generatedMappings) {
        this._sortGeneratedMappings();
      }
      return this.__generatedMappings;
    }
    get _originalMappings() {
      if (!this.__originalMappings) {
        this._sortOriginalMappings();
      }
      return this.__originalMappings;
    }
    get _generatedMappingsUnsorted() {
      if (!this.__generatedMappingsUnsorted) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappingsUnsorted;
    }
    get _originalMappingsUnsorted() {
      if (!this.__originalMappingsUnsorted) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappingsUnsorted;
    }
    _sortGeneratedMappings() {
      const mappings = this._generatedMappingsUnsorted;
      mappings.sort(util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = mappings;
    }
    _sortOriginalMappings() {
      const mappings = this._originalMappingsUnsorted;
      mappings.sort(util.compareByOriginalPositions);
      this.__originalMappings = mappings;
    }
    get sources() {
      const sources = [];
      for (let i = 0;i < this._sections.length; i++) {
        for (let j = 0;j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
    originalPositionFor(aArgs) {
      const needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      const sectionIndex = binarySearch.search(needle, this._sections, function(aNeedle, section2) {
        const cmp = aNeedle.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return aNeedle.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      const section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    }
    hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    }
    sourceContentFor(aSource, nullOnMissing) {
      for (let i = 0;i < this._sections.length; i++) {
        const section = this._sections[i];
        const content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
    generatedPositionFor(aArgs) {
      for (let i = 0;i < this._sections.length; i++) {
        const section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        const generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          const ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    }
    _parseMappings(aStr, aSourceRoot) {
      const generatedMappings = this.__generatedMappingsUnsorted = [];
      const originalMappings = this.__originalMappingsUnsorted = [];
      for (let i = 0;i < this._sections.length; i++) {
        const section = this._sections[i];
        const sectionMappings = [];
        section.consumer.eachMapping((m) => sectionMappings.push(m));
        for (let j = 0;j < sectionMappings.length; j++) {
          const mapping = sectionMappings[j];
          let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          let name = null;
          if (mapping.name) {
            this._names.add(mapping.name);
            name = this._names.indexOf(mapping.name);
          }
          const adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            originalMappings.push(adjustedMapping);
          }
        }
      }
    }
    eachMapping(aCallback, aContext, aOrder) {
      const context = aContext || null;
      const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      let mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      const sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        let source = null;
        if (mapping.source !== null) {
          source = this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        }
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    }
    _findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    }
    allGeneratedPositionsFor(aArgs) {
      const line = util.getArg(aArgs, "line");
      const needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      if (needle.originalLine < 1) {
        throw new Error("Line numbers must be >= 1");
      }
      if (needle.originalColumn < 0) {
        throw new Error("Column numbers must be >= 0");
      }
      const mappings = [];
      let index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        let mapping = this._originalMappings[index];
        if (aArgs.column === undefined) {
          const originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            let lastColumn = mapping.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          const originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            let lastColumn = mapping.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    }
    destroy() {
      for (let i = 0;i < this._sections.length; i++) {
        this._sections[i].consumer.destroy();
      }
    }
  }
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS((exports) => {
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util = require_util();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";

  class SourceNode {
    constructor(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      const node = new SourceNode;
      const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      let remainingLinesIndex = 0;
      const shiftNextLine = function() {
        const lineContents = getNextLine();
        const newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
        }
      };
      let lastGeneratedLine = 1, lastGeneratedColumn = 0;
      let lastMapping = null;
      let nextLine;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            nextLine = remainingLines[remainingLinesIndex] || "";
            const code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        const content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          const source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    }
    add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    }
    prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (let i = aChunk.length - 1;i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    }
    walk(aFn) {
      let chunk;
      for (let i = 0, len = this.children.length;i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
    join(aSep) {
      let newChildren;
      let i;
      const len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0;i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    }
    replaceRight(aPattern, aReplacement) {
      const lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    }
    setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    }
    walkSourceContents(aFn) {
      for (let i = 0, len = this.children.length;i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      const sources = Object.keys(this.sourceContents);
      for (let i = 0, len = sources.length;i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    }
    toString() {
      let str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    }
    toStringWithSourceMap(aArgs) {
      const generated = {
        code: "",
        line: 1,
        column: 0
      };
      const map = new SourceMapGenerator(aArgs);
      let sourceMappingActive = false;
      let lastOriginalSource = null;
      let lastOriginalLine = null;
      let lastOriginalColumn = null;
      let lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (let idx = 0, length = chunk.length;idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    }
  }
  exports.SourceNode = SourceNode;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/source-map/source-map.js
var require_source_map = __commonJS((exports) => {
  exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports.SourceNode = require_source_node().SourceNode;
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/visitor/sourcemapper.js
var require_sourcemapper = __commonJS((exports, module) => {
  /*!
   * Stylus - SourceMapper
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Compiler = require_compiler();
  var Buffer2 = require_safer().Buffer;
  var SourceMapGenerator = require_source_map().SourceMapGenerator;
  var basename = __require("path").basename;
  var extname = __require("path").extname;
  var dirname = __require("path").dirname;
  var join = __require("path").join;
  var relative = __require("path").relative;
  var sep = __require("path").sep;
  var fs = __require("fs");
  var SourceMapper = module.exports = function SourceMapper(root, options) {
    options = options || {};
    this.column = 1;
    this.lineno = 1;
    this.contents = {};
    this.filename = options.filename;
    this.dest = options.dest;
    var sourcemap = options.sourcemap;
    this.basePath = sourcemap.basePath || ".";
    this.inline = sourcemap.inline;
    this.comment = sourcemap.comment;
    if (this.dest && extname(this.dest) === ".css") {
      this.basename = basename(this.dest);
      this.dest = dirname(this.dest);
    } else {
      this.basename = basename(this.filename, extname(this.filename)) + ".css";
    }
    this.utf8 = false;
    this.map = new SourceMapGenerator({
      file: this.basename,
      sourceRoot: sourcemap.sourceRoot || null
    });
    Compiler.call(this, root, options);
  };
  SourceMapper.prototype.__proto__ = Compiler.prototype;
  var compile = Compiler.prototype.compile;
  SourceMapper.prototype.compile = function() {
    var css = compile.call(this), out = this.basename + ".map", url = this.normalizePath(this.dest ? join(this.dest, out) : join(dirname(this.filename), out)), map;
    if (this.inline) {
      map = this.map.toString();
      url = "data:application/json;" + (this.utf8 ? "charset=utf-8;" : "") + "base64," + Buffer2.from(map).toString("base64");
    }
    if (this.inline || this.comment !== false)
      css += "/*# sourceMappingURL=" + url + " */";
    return css;
  };
  SourceMapper.prototype.out = function(str, node) {
    if (node && node.lineno) {
      var filename = this.normalizePath(node.filename);
      this.map.addMapping({
        original: {
          line: node.lineno,
          column: node.column - 1
        },
        generated: {
          line: this.lineno,
          column: this.column - 1
        },
        source: filename
      });
      if (this.inline && !this.contents[filename]) {
        this.map.setSourceContent(filename, fs.readFileSync(node.filename, "utf-8"));
        this.contents[filename] = true;
      }
    }
    this.move(str);
    return str;
  };
  SourceMapper.prototype.move = function(str) {
    var lines = str.match(/\n/g), idx = str.lastIndexOf("\n");
    if (lines)
      this.lineno += lines.length;
    this.column = ~idx ? str.length - idx : this.column + str.length;
  };
  SourceMapper.prototype.normalizePath = function(path) {
    path = relative(this.dest || this.basePath, path);
    if (sep == "\\") {
      path = path.replace(/^[a-z]:\\/i, "/").replace(/\\/g, "/");
    }
    return path;
  };
  var literal = Compiler.prototype.visitLiteral;
  SourceMapper.prototype.visitLiteral = function(lit) {
    var val = literal.call(this, lit), filename = this.normalizePath(lit.filename), indentsRe = /^\s+/, lines = val.split("\n");
    if (lines.length > 1) {
      lines.forEach(function(line, i) {
        var indents = line.match(indentsRe), column = indents && indents[0] ? indents[0].length : 0;
        if (lit.css)
          column += 2;
        this.map.addMapping({
          original: {
            line: lit.lineno + i,
            column
          },
          generated: {
            line: this.lineno + i,
            column: 0
          },
          source: filename
        });
      }, this);
    }
    return val;
  };
  var charset = Compiler.prototype.visitCharset;
  SourceMapper.prototype.visitCharset = function(node) {
    this.utf8 = node.val.string.toLowerCase() == "utf-8";
    return charset.call(this, node);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/visitor/deps-resolver.js
var require_deps_resolver = __commonJS((exports, module) => {
  var Visitor = require_visitor();
  var Parser = require_parser();
  var nodes = require_nodes();
  var utils = require_utils();
  var dirname = __require("path").dirname;
  var fs = __require("fs");
  var DepsResolver = module.exports = function DepsResolver(root, options) {
    this.root = root;
    this.filename = options.filename;
    this.paths = options.paths || [];
    this.paths.push(dirname(options.filename || "."));
    this.options = options;
    this.functions = {};
    this.deps = [];
  };
  DepsResolver.prototype.__proto__ = Visitor.prototype;
  var visit = DepsResolver.prototype.visit;
  DepsResolver.prototype.visit = function(node) {
    switch (node.nodeName) {
      case "root":
      case "block":
      case "expression":
        this.visitRoot(node);
        break;
      case "group":
      case "media":
      case "atblock":
      case "atrule":
      case "keyframes":
      case "each":
      case "supports":
        this.visit(node.block);
        break;
      default:
        visit.call(this, node);
    }
  };
  DepsResolver.prototype.visitRoot = function(block) {
    for (var i = 0, len = block.nodes.length;i < len; ++i) {
      this.visit(block.nodes[i]);
    }
  };
  DepsResolver.prototype.visitIdent = function(ident) {
    this.visit(ident.val);
  };
  DepsResolver.prototype.visitIf = function(node) {
    this.visit(node.block);
    this.visit(node.cond);
    for (var i = 0, len = node.elses.length;i < len; ++i) {
      this.visit(node.elses[i]);
    }
  };
  DepsResolver.prototype.visitFunction = function(fn) {
    this.functions[fn.name] = fn.block;
  };
  DepsResolver.prototype.visitCall = function(call) {
    if (call.name in this.functions)
      this.visit(this.functions[call.name]);
    if (call.block)
      this.visit(call.block);
  };
  DepsResolver.prototype.visitImport = function(node) {
    if (node.path.first.name === "url")
      return;
    var path = !node.path.first.val.isNull && node.path.first.val || node.path.first.name, literal, found, oldPath;
    if (!path)
      return;
    literal = /\.css(?:"|$)/.test(path);
    if (!literal && !/\.styl$/i.test(path)) {
      oldPath = path;
      path += ".styl";
    }
    found = utils.find(path, this.paths, this.filename);
    if (!found && oldPath)
      found = utils.lookupIndex(oldPath, this.paths, this.filename);
    if (!found)
      return;
    this.deps = this.deps.concat(found);
    if (literal)
      return;
    for (var i = 0, len = found.length;i < len; ++i) {
      var file = found[i], dir = dirname(file), str = fs.readFileSync(file, "utf-8"), block = new nodes.Block, parser = new Parser(str, utils.merge({ root: block }, this.options));
      if (!~this.paths.indexOf(dir))
        this.paths.push(dir);
      try {
        block = parser.parse();
      } catch (err) {
        err.filename = file;
        err.lineno = parser.lexer.lineno;
        err.column = parser.lexer.column;
        err.input = str;
        throw err;
      }
      this.visit(block);
    }
  };
  DepsResolver.prototype.resolve = function() {
    this.visit(this.root);
    return utils.uniq(this.deps);
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/renderer.js
var require_renderer = __commonJS((exports, module) => {
  var Renderer = function(str, options) {
    options = options || {};
    options.globals = options.globals || {};
    options.functions = options.functions || {};
    options.use = options.use || [];
    options.use = Array.isArray(options.use) ? options.use : [options.use];
    options.imports = [join(__dirname, "functions/index.styl")].concat(options.imports || []);
    options.paths = options.paths || [];
    options.filename = options.filename || "stylus";
    options.Evaluator = options.Evaluator || Evaluator;
    this.options = options;
    this.str = str;
    this.events = events;
  };
  var __dirname = "/Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib";
  /*!
   * Stylus - Renderer
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Parser = require_parser();
  var EventEmitter = __require("events").EventEmitter;
  var Evaluator = require_evaluator();
  var Normalizer = require_normalizer();
  var events = new EventEmitter;
  var utils = require_utils();
  var nodes = require_nodes();
  var join = __require("path").join;
  module.exports = Renderer;
  Renderer.prototype.__proto__ = EventEmitter.prototype;
  module.exports.events = events;
  Renderer.prototype.render = function(fn) {
    var parser = this.parser = new Parser(this.str, this.options);
    for (var i = 0, len = this.options.use.length;i < len; i++) {
      this.use(this.options.use[i]);
    }
    try {
      nodes.filename = this.options.filename;
      var ast = parser.parse();
      this.evaluator = new this.options.Evaluator(ast, this.options);
      this.nodes = nodes;
      this.evaluator.renderer = this;
      ast = this.evaluator.evaluate();
      var normalizer = new Normalizer(ast, this.options);
      ast = normalizer.normalize();
      var compiler = this.options.sourcemap ? new (require_sourcemapper())(ast, this.options) : new (require_compiler())(ast, this.options), css = compiler.compile();
      if (this.options.sourcemap)
        this.sourcemap = compiler.map.toJSON();
    } catch (err) {
      var options = {};
      options.input = err.input || this.str;
      options.filename = err.filename || this.options.filename;
      options.lineno = err.lineno || parser.lexer.lineno;
      options.column = err.column || parser.lexer.column;
      if (!fn)
        throw utils.formatException(err, options);
      return fn(utils.formatException(err, options));
    }
    var listeners = this.listeners("end");
    if (fn)
      listeners.push(fn);
    for (var i = 0, len = listeners.length;i < len; i++) {
      var ret = listeners[i](null, css);
      if (ret)
        css = ret;
    }
    if (!fn)
      return css;
  };
  Renderer.prototype.deps = function(filename) {
    var opts = utils.merge({ cache: false }, this.options);
    if (filename)
      opts.filename = filename;
    var DepsResolver = require_deps_resolver(), parser = new Parser(this.str, opts);
    try {
      nodes.filename = opts.filename;
      var ast = parser.parse(), resolver = new DepsResolver(ast, opts);
      return resolver.resolve();
    } catch (err) {
      var options = {};
      options.input = err.input || this.str;
      options.filename = err.filename || opts.filename;
      options.lineno = err.lineno || parser.lexer.lineno;
      options.column = err.column || parser.lexer.column;
      throw utils.formatException(err, options);
    }
  };
  Renderer.prototype.set = function(key, val) {
    this.options[key] = val;
    return this;
  };
  Renderer.prototype.get = function(key) {
    return this.options[key];
  };
  Renderer.prototype.include = function(path) {
    this.options.paths.push(path);
    return this;
  };
  Renderer.prototype.use = function(fn) {
    fn.call(this, this);
    return this;
  };
  Renderer.prototype.define = function(name, fn, raw) {
    fn = utils.coerce(fn, raw);
    if (fn.nodeName) {
      this.options.globals[name] = fn;
      return this;
    }
    this.options.functions[name] = fn;
    if (raw != null)
      fn.raw = raw;
    return this;
  };
  Renderer.prototype.import = function(file) {
    this.options.imports.push(file);
    return this;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "stylus",
    description: "Robust, expressive, and feature-rich CSS superset",
    version: "0.56.0",
    author: "TJ Holowaychuk <tj@vision-media.ca>",
    keywords: [
      "css",
      "parser",
      "style",
      "stylesheets",
      "jade",
      "language"
    ],
    repository: {
      type: "git",
      url: "git://github.com/stylus/stylus"
    },
    main: "./index.js",
    browserify: "./lib/browserify.js",
    engines: {
      node: "*"
    },
    bin: {
      stylus: "./bin/stylus"
    },
    scripts: {
      prepublish: "npm prune",
      test: "mocha test/ test/middleware/ --require chai --bail --check-leaks --reporter dot",
      "test-cov": "mocha test/ test/middleware/ --require chai --bail --reporter html-cov > coverage.html"
    },
    dependencies: {
      css: "^3.0.0",
      debug: "^4.3.2",
      glob: "^7.1.6",
      "safer-buffer": "^2.1.2",
      sax: "~1.2.4",
      "source-map": "^0.7.3"
    },
    devDependencies: {
      chai: "^4.3.4",
      jscoverage: "~0.6.0",
      mocha: "^9.0.3"
    },
    bugs: {
      url: "https://github.com/stylus/stylus/issues"
    },
    homepage: "https://github.com/stylus/stylus",
    directories: {
      doc: "docs",
      example: "examples",
      test: "test"
    },
    license: "MIT"
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/middleware.js
var require_middleware = __commonJS((exports, module) => {
  var checkImports = function(path, fn) {
    var nodes = imports[path];
    if (!nodes)
      return fn();
    if (!nodes.length)
      return fn();
    var pending = nodes.length, changed = [];
    nodes.forEach(function(imported) {
      fs.stat(imported.path, function(err, stat) {
        if (err || !imported.mtime || stat.mtime > imported.mtime) {
          changed.push(imported.path);
        }
        --pending || fn(changed);
      });
    });
  };
  var compare = function(pathA, pathB) {
    pathA = pathA.split(sep);
    pathB = pathB.split("/");
    if (!pathA[pathA.length - 1])
      pathA.pop();
    if (!pathB[0])
      pathB.shift();
    var overlap = [];
    while (pathA[pathA.length - 1] == pathB[0]) {
      overlap.push(pathA.pop());
      pathB.shift();
    }
    return overlap.join("/");
  };
  /*!
   * Stylus - middleware
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var stylus = require_stylus();
  var fs = __require("fs");
  var url = __require("url");
  var dirname = __require("path").dirname;
  var join = __require("path").join;
  var sep = __require("path").sep;
  var debug = require_src()("stylus:middleware");
  var mkdir = fs.mkdir;
  var imports = {};
  module.exports = function(options) {
    options = options || {};
    if (typeof options == "string") {
      options = { src: options };
    }
    var force = options.force;
    var src = options.src;
    if (!src)
      throw new Error('stylus.middleware() requires "src" directory');
    var dest = options.dest || src;
    options.compile = options.compile || function(str, path) {
      if (options.sourcemap) {
        if (typeof options.sourcemap == "boolean")
          options.sourcemap = {};
        options.sourcemap.inline = true;
      }
      return stylus(str).set("filename", path).set("compress", options.compress).set("firebug", options.firebug).set("linenos", options.linenos).set("sourcemap", options.sourcemap);
    };
    return function stylus(req, res, next) {
      if (req.method != "GET" && req.method != "HEAD")
        return next();
      var path = url.parse(req.url).pathname;
      if (/\.css$/.test(path)) {
        let error2 = function(err) {
          next(err.code == "ENOENT" ? null : err);
        }, compile2 = function() {
          debug("read %s", cssPath);
          fs.readFile(stylusPath, "utf8", function(err, str) {
            if (err)
              return error2(err);
            var style = options.compile(str, stylusPath);
            var paths = style.options._imports = [];
            imports[stylusPath] = null;
            style.render(function(err2, css) {
              if (err2)
                return next(err2);
              debug("render %s", stylusPath);
              imports[stylusPath] = paths;
              mkdir(dirname(cssPath), { mode: parseInt("0700", 8), recursive: true }, function(err3) {
                if (err3)
                  return error2(err3);
                fs.writeFile(cssPath, css, "utf8", next);
              });
            });
          });
        };
        var error = error2, compile = compile2;
        if (typeof dest == "string") {
          var overlap = compare(dest, path).length;
          if (path.charAt(0) == "/")
            overlap++;
          path = path.slice(overlap);
        }
        var cssPath, stylusPath;
        cssPath = typeof dest == "function" ? dest(path) : join(dest, path);
        stylusPath = typeof src == "function" ? src(path) : join(src, path.replace(".css", ".styl"));
        if (force)
          return compile2();
        if (!imports[stylusPath])
          return compile2();
        fs.stat(stylusPath, function(err, stylusStats) {
          if (err)
            return error2(err);
          fs.stat(cssPath, function(err2, cssStats) {
            if (err2) {
              if (err2.code == "ENOENT") {
                debug("not found %s", cssPath);
                compile2();
              } else {
                next(err2);
              }
            } else {
              if (stylusStats.mtime > cssStats.mtime) {
                debug("modified %s", cssPath);
                compile2();
              } else {
                checkImports(stylusPath, function(changed) {
                  if (debug && changed.length) {
                    changed.forEach(function(path2) {
                      debug("modified import %s", path2);
                    });
                  }
                  changed.length ? compile2() : next();
                });
              }
            }
          });
        });
      } else {
        next();
      }
    };
  };
});

// node_modules/.pnpm/css@3.0.0/node_modules/css/lib/parse/index.js
var require_parse = __commonJS((exports, module) => {
  var trim = function(str) {
    return str ? str.replace(/^\s+|\s+$/g, "") : "";
  };
  var addParent = function(obj, parent) {
    var isNode = obj && typeof obj.type === "string";
    var childParent = isNode ? obj : parent;
    for (var k in obj) {
      var value = obj[k];
      if (Array.isArray(value)) {
        value.forEach(function(v) {
          addParent(v, childParent);
        });
      } else if (value && typeof value === "object") {
        addParent(value, childParent);
      }
    }
    if (isNode) {
      Object.defineProperty(obj, "parent", {
        configurable: true,
        writable: true,
        enumerable: false,
        value: parent || null
      });
    }
    return obj;
  };
  var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
  module.exports = function(css, options) {
    options = options || {};
    var lineno = 1;
    var column = 1;
    function updatePosition(str) {
      var lines = str.match(/\n/g);
      if (lines)
        lineno += lines.length;
      var i = str.lastIndexOf("\n");
      column = ~i ? str.length - i : column + str.length;
    }
    function position() {
      var start = { line: lineno, column };
      return function(node) {
        node.position = new Position(start);
        whitespace();
        return node;
      };
    }
    function Position(start) {
      this.start = start;
      this.end = { line: lineno, column };
      this.source = options.source;
    }
    Position.prototype.content = css;
    var errorsList = [];
    function error(msg) {
      var err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
      err.reason = msg;
      err.filename = options.source;
      err.line = lineno;
      err.column = column;
      err.source = css;
      if (options.silent) {
        errorsList.push(err);
      } else {
        throw err;
      }
    }
    function stylesheet() {
      var rulesList = rules();
      return {
        type: "stylesheet",
        stylesheet: {
          source: options.source,
          rules: rulesList,
          parsingErrors: errorsList
        }
      };
    }
    function open() {
      return match(/^{\s*/);
    }
    function close() {
      return match(/^}/);
    }
    function rules() {
      var node;
      var rules2 = [];
      whitespace();
      comments(rules2);
      while (css.length && css.charAt(0) != "}" && (node = atrule() || rule())) {
        if (node !== false) {
          rules2.push(node);
          comments(rules2);
        }
      }
      return rules2;
    }
    function match(re) {
      var m = re.exec(css);
      if (!m)
        return;
      var str = m[0];
      updatePosition(str);
      css = css.slice(str.length);
      return m;
    }
    function whitespace() {
      match(/^\s*/);
    }
    function comments(rules2) {
      var c;
      rules2 = rules2 || [];
      while (c = comment()) {
        if (c !== false) {
          rules2.push(c);
        }
      }
      return rules2;
    }
    function comment() {
      var pos = position();
      if (css.charAt(0) != "/" || css.charAt(1) != "*")
        return;
      var i = 2;
      while (css.charAt(i) != "" && (css.charAt(i) != "*" || css.charAt(i + 1) != "/"))
        ++i;
      i += 2;
      if (css.charAt(i - 1) === "") {
        return error("End of comment missing");
      }
      var str = css.slice(2, i - 2);
      column += 2;
      updatePosition(str);
      css = css.slice(i);
      column += 2;
      return pos({
        type: "comment",
        comment: str
      });
    }
    function selector() {
      var m = match(/^([^{]+)/);
      if (!m)
        return;
      return trim(m[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m2) {
        return m2.replace(/,/g, "\u200C");
      }).split(/\s*(?![^(]*\)),\s*/).map(function(s) {
        return s.replace(/\u200C/g, ",");
      });
    }
    function declaration() {
      var pos = position();
      var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
      if (!prop)
        return;
      prop = trim(prop[0]);
      if (!match(/^:\s*/))
        return error("property missing ':'");
      var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
      var ret = pos({
        type: "declaration",
        property: prop.replace(commentre, ""),
        value: val ? trim(val[0]).replace(commentre, "") : ""
      });
      match(/^[;\s]*/);
      return ret;
    }
    function declarations() {
      var decls = [];
      if (!open())
        return error("missing '{'");
      comments(decls);
      var decl;
      while (decl = declaration()) {
        if (decl !== false) {
          decls.push(decl);
          comments(decls);
        }
      }
      if (!close())
        return error("missing '}'");
      return decls;
    }
    function keyframe() {
      var m;
      var vals = [];
      var pos = position();
      while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
        vals.push(m[1]);
        match(/^,\s*/);
      }
      if (!vals.length)
        return;
      return pos({
        type: "keyframe",
        values: vals,
        declarations: declarations()
      });
    }
    function atkeyframes() {
      var pos = position();
      var m = match(/^@([-\w]+)?keyframes\s*/);
      if (!m)
        return;
      var vendor = m[1];
      var m = match(/^([-\w]+)\s*/);
      if (!m)
        return error("@keyframes missing name");
      var name = m[1];
      if (!open())
        return error("@keyframes missing '{'");
      var frame;
      var frames = comments();
      while (frame = keyframe()) {
        frames.push(frame);
        frames = frames.concat(comments());
      }
      if (!close())
        return error("@keyframes missing '}'");
      return pos({
        type: "keyframes",
        name,
        vendor,
        keyframes: frames
      });
    }
    function atsupports() {
      var pos = position();
      var m = match(/^@supports *([^{]+)/);
      if (!m)
        return;
      var supports = trim(m[1]);
      if (!open())
        return error("@supports missing '{'");
      var style = comments().concat(rules());
      if (!close())
        return error("@supports missing '}'");
      return pos({
        type: "supports",
        supports,
        rules: style
      });
    }
    function athost() {
      var pos = position();
      var m = match(/^@host\s*/);
      if (!m)
        return;
      if (!open())
        return error("@host missing '{'");
      var style = comments().concat(rules());
      if (!close())
        return error("@host missing '}'");
      return pos({
        type: "host",
        rules: style
      });
    }
    function atmedia() {
      var pos = position();
      var m = match(/^@media *([^{]+)/);
      if (!m)
        return;
      var media = trim(m[1]);
      if (!open())
        return error("@media missing '{'");
      var style = comments().concat(rules());
      if (!close())
        return error("@media missing '}'");
      return pos({
        type: "media",
        media,
        rules: style
      });
    }
    function atcustommedia() {
      var pos = position();
      var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
      if (!m)
        return;
      return pos({
        type: "custom-media",
        name: trim(m[1]),
        media: trim(m[2])
      });
    }
    function atpage() {
      var pos = position();
      var m = match(/^@page */);
      if (!m)
        return;
      var sel = selector() || [];
      if (!open())
        return error("@page missing '{'");
      var decls = comments();
      var decl;
      while (decl = declaration()) {
        decls.push(decl);
        decls = decls.concat(comments());
      }
      if (!close())
        return error("@page missing '}'");
      return pos({
        type: "page",
        selectors: sel,
        declarations: decls
      });
    }
    function atdocument() {
      var pos = position();
      var m = match(/^@([-\w]+)?document *([^{]+)/);
      if (!m)
        return;
      var vendor = trim(m[1]);
      var doc = trim(m[2]);
      if (!open())
        return error("@document missing '{'");
      var style = comments().concat(rules());
      if (!close())
        return error("@document missing '}'");
      return pos({
        type: "document",
        document: doc,
        vendor,
        rules: style
      });
    }
    function atfontface() {
      var pos = position();
      var m = match(/^@font-face\s*/);
      if (!m)
        return;
      if (!open())
        return error("@font-face missing '{'");
      var decls = comments();
      var decl;
      while (decl = declaration()) {
        decls.push(decl);
        decls = decls.concat(comments());
      }
      if (!close())
        return error("@font-face missing '}'");
      return pos({
        type: "font-face",
        declarations: decls
      });
    }
    var atimport = _compileAtrule("import");
    var atcharset = _compileAtrule("charset");
    var atnamespace = _compileAtrule("namespace");
    function _compileAtrule(name) {
      var re = new RegExp("^@" + name + "\\s*([^;]+);");
      return function() {
        var pos = position();
        var m = match(re);
        if (!m)
          return;
        var ret = { type: name };
        ret[name] = m[1].trim();
        return pos(ret);
      };
    }
    function atrule() {
      if (css[0] != "@")
        return;
      return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
    }
    function rule() {
      var pos = position();
      var sel = selector();
      if (!sel)
        return error("selector missing");
      comments();
      return pos({
        type: "rule",
        selectors: sel,
        declarations: declarations()
      });
    }
    return addParent(stylesheet());
  };
});

// node_modules/.pnpm/css@3.0.0/node_modules/css/lib/stringify/compiler.js
var require_compiler2 = __commonJS((exports, module) => {
  var Compiler = function(opts) {
    this.options = opts || {};
  };
  module.exports = Compiler;
  Compiler.prototype.emit = function(str) {
    return str;
  };
  Compiler.prototype.visit = function(node) {
    return this[node.type](node);
  };
  Compiler.prototype.mapVisit = function(nodes, delim) {
    var buf = "";
    delim = delim || "";
    for (var i = 0, length = nodes.length;i < length; i++) {
      buf += this.visit(nodes[i]);
      if (delim && i < length - 1)
        buf += this.emit(delim);
    }
    return buf;
  };
});

// node_modules/.pnpm/css@3.0.0/node_modules/css/lib/stringify/compress.js
var require_compress = __commonJS((exports, module) => {
  var Compiler = function(options) {
    Base.call(this, options);
  };
  var Base = require_compiler2();
  var inherits = require_inherits();
  module.exports = Compiler;
  inherits(Compiler, Base);
  Compiler.prototype.compile = function(node) {
    return node.stylesheet.rules.map(this.visit, this).join("");
  };
  Compiler.prototype.comment = function(node) {
    return this.emit("", node.position);
  };
  Compiler.prototype.import = function(node) {
    return this.emit("@import " + node.import + ";", node.position);
  };
  Compiler.prototype.media = function(node) {
    return this.emit("@media " + node.media, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler.prototype.document = function(node) {
    var doc = "@" + (node.vendor || "") + "document " + node.document;
    return this.emit(doc, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler.prototype.charset = function(node) {
    return this.emit("@charset " + node.charset + ";", node.position);
  };
  Compiler.prototype.namespace = function(node) {
    return this.emit("@namespace " + node.namespace + ";", node.position);
  };
  Compiler.prototype.supports = function(node) {
    return this.emit("@supports " + node.supports, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler.prototype.keyframes = function(node) {
    return this.emit("@" + (node.vendor || "") + "keyframes " + node.name, node.position) + this.emit("{") + this.mapVisit(node.keyframes) + this.emit("}");
  };
  Compiler.prototype.keyframe = function(node) {
    var decls = node.declarations;
    return this.emit(node.values.join(","), node.position) + this.emit("{") + this.mapVisit(decls) + this.emit("}");
  };
  Compiler.prototype.page = function(node) {
    var sel = node.selectors.length ? node.selectors.join(", ") : "";
    return this.emit("@page " + sel, node.position) + this.emit("{") + this.mapVisit(node.declarations) + this.emit("}");
  };
  Compiler.prototype["font-face"] = function(node) {
    return this.emit("@font-face", node.position) + this.emit("{") + this.mapVisit(node.declarations) + this.emit("}");
  };
  Compiler.prototype.host = function(node) {
    return this.emit("@host", node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler.prototype["custom-media"] = function(node) {
    return this.emit("@custom-media " + node.name + " " + node.media + ";", node.position);
  };
  Compiler.prototype.rule = function(node) {
    var decls = node.declarations;
    if (!decls.length)
      return "";
    return this.emit(node.selectors.join(","), node.position) + this.emit("{") + this.mapVisit(decls) + this.emit("}");
  };
  Compiler.prototype.declaration = function(node) {
    return this.emit(node.property + ":" + node.value, node.position) + this.emit(";");
  };
});

// node_modules/.pnpm/css@3.0.0/node_modules/css/lib/stringify/identity.js
var require_identity = __commonJS((exports, module) => {
  var Compiler = function(options) {
    options = options || {};
    Base.call(this, options);
    this.indentation = options.indent;
  };
  var Base = require_compiler2();
  var inherits = require_inherits();
  module.exports = Compiler;
  inherits(Compiler, Base);
  Compiler.prototype.compile = function(node) {
    return this.stylesheet(node);
  };
  Compiler.prototype.stylesheet = function(node) {
    return this.mapVisit(node.stylesheet.rules, "\n\n");
  };
  Compiler.prototype.comment = function(node) {
    return this.emit(this.indent() + "/*" + node.comment + "*/", node.position);
  };
  Compiler.prototype.import = function(node) {
    return this.emit("@import " + node.import + ";", node.position);
  };
  Compiler.prototype.media = function(node) {
    return this.emit("@media " + node.media, node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler.prototype.document = function(node) {
    var doc = "@" + (node.vendor || "") + "document " + node.document;
    return this.emit(doc, node.position) + this.emit("  {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler.prototype.charset = function(node) {
    return this.emit("@charset " + node.charset + ";", node.position);
  };
  Compiler.prototype.namespace = function(node) {
    return this.emit("@namespace " + node.namespace + ";", node.position);
  };
  Compiler.prototype.supports = function(node) {
    return this.emit("@supports " + node.supports, node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler.prototype.keyframes = function(node) {
    return this.emit("@" + (node.vendor || "") + "keyframes " + node.name, node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.keyframes, "\n") + this.emit(this.indent(-1) + "}");
  };
  Compiler.prototype.keyframe = function(node) {
    var decls = node.declarations;
    return this.emit(this.indent()) + this.emit(node.values.join(", "), node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(decls, "\n") + this.emit(this.indent(-1) + "\n" + this.indent() + "}\n");
  };
  Compiler.prototype.page = function(node) {
    var sel = node.selectors.length ? node.selectors.join(", ") + " " : "";
    return this.emit("@page " + sel, node.position) + this.emit("{\n") + this.emit(this.indent(1)) + this.mapVisit(node.declarations, "\n") + this.emit(this.indent(-1)) + this.emit("\n}");
  };
  Compiler.prototype["font-face"] = function(node) {
    return this.emit("@font-face ", node.position) + this.emit("{\n") + this.emit(this.indent(1)) + this.mapVisit(node.declarations, "\n") + this.emit(this.indent(-1)) + this.emit("\n}");
  };
  Compiler.prototype.host = function(node) {
    return this.emit("@host", node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler.prototype["custom-media"] = function(node) {
    return this.emit("@custom-media " + node.name + " " + node.media + ";", node.position);
  };
  Compiler.prototype.rule = function(node) {
    var indent = this.indent();
    var decls = node.declarations;
    if (!decls.length)
      return "";
    return this.emit(node.selectors.map(function(s) {
      return indent + s;
    }).join(",\n"), node.position) + this.emit(" {\n") + this.emit(this.indent(1)) + this.mapVisit(decls, "\n") + this.emit(this.indent(-1)) + this.emit("\n" + this.indent() + "}");
  };
  Compiler.prototype.declaration = function(node) {
    return this.emit(this.indent()) + this.emit(node.property + ": " + node.value, node.position) + this.emit(";");
  };
  Compiler.prototype.indent = function(level) {
    this.level = this.level || 1;
    if (level != null) {
      this.level += level;
      return "";
    }
    return Array(this.level).join(this.indentation || "  ");
  };
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
var require_base642 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq2 = __commonJS((exports) => {
  var toVLQSigned = function(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  };
  var fromVLQSigned = function(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  };
  var base64 = require_base642();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
var require_util2 = __commonJS((exports) => {
  var getArg = function(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  };
  var urlParse = function(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  };
  var urlGenerate = function(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  };
  var normalize = function(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  };
  var join = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  };
  var relative = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  };
  var identity = function(s) {
    return s;
  };
  var toSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  };
  var fromSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  };
  var isProtoString = function(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  };
  var compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var strcmp = function(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  };
  var compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var parseSourceMapInput = function(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  };
  var computeSourceURL = function(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  };
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  exports.urlParse = urlParse;
  exports.urlGenerate = urlGenerate;
  exports.normalize = normalize;
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  exports.toSetString = supportsNullProto ? identity : toSetString;
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  exports.compareByOriginalPositions = compareByOriginalPositions;
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  exports.parseSourceMapInput = parseSourceMapInput;
  exports.computeSourceURL = computeSourceURL;
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
var require_array_set2 = __commonJS((exports) => {
  var ArraySet = function() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  };
  var util = require_util2();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet;
    for (var i = 0, len = aArray.length;i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
var require_mapping_list2 = __commonJS((exports) => {
  var generatedPositionAfter = function(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  };
  var MappingList = function() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  };
  var util = require_util2();
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator2 = __commonJS((exports) => {
  var SourceMapGenerator = function(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet;
    this._names = new ArraySet;
    this._mappings = new MappingList;
    this._sourcesContents = null;
  };
  var base64VLQ = require_base64_vlq2();
  var util = require_util2();
  var ArraySet = require_array_set2().ArraySet;
  var MappingList = require_mapping_list2().MappingList;
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet;
    var newNames = new ArraySet;
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length;i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
var require_binary_search2 = __commonJS((exports) => {
  var recursiveSearch = function(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  };
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS((exports) => {
  var swap = function(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  };
  var randomIntInRange = function(low, high) {
    return Math.round(low + Math.random() * (high - low));
  };
  var doQuickSort = function(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p;j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  };
  exports.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer2 = __commonJS((exports) => {
  var SourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  };
  var BasicSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  };
  var Mapping = function() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  };
  var IndexedSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet;
    this._names = new ArraySet;
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  };
  var util = require_util2();
  var binarySearch = require_binary_search2();
  var ArraySet = require_array_set2().ArraySet;
  var base64VLQ = require_base64_vlq2();
  var quickSort = require_quick_sort().quickSort;
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports.SourceMapConsumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0;i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length;i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping;
        mapping.generatedLine = generatedLine;
        for (end = index;end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0;index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0;i < this._sections.length; i++) {
        for (var j = 0;j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0;j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
var require_source_node2 = __commonJS((exports) => {
  var SourceNode = function(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  };
  var SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
  var util = require_util2();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode;
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1;i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length;i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0;i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length;i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length;i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length;idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map };
  };
  exports.SourceNode = SourceNode;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/css@3.0.0/node_modules/source-map/source-map.js
var require_source_map2 = __commonJS((exports) => {
  exports.SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
  exports.SourceMapConsumer = require_source_map_consumer2().SourceMapConsumer;
  exports.SourceNode = require_source_node2().SourceNode;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/source-map-resolve@0.6.0/node_modules/atob/node-atob.js
var require_node_atob = __commonJS((exports, module) => {
  var atob = function(str) {
    return Buffer.from(str, "base64").toString("binary");
  };
  module.exports = atob.atob = atob;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/source-map-resolve@0.6.0/node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS((exports, module) => {
  var decodeComponents = function(components, split) {
    try {
      return [decodeURIComponent(components.join(""))];
    } catch (err) {
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  };
  var decode = function(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher) || [];
      for (var i = 1;i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join("");
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  };
  var customDecodeURIComponent = function(input) {
    var replaceMap = {
      "%FE%FF": "\uFFFD\uFFFD",
      "%FF%FE": "\uFFFD\uFFFD"
    };
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "\uFFFD";
    var entries = Object.keys(replaceMap);
    for (var i = 0;i < entries.length; i++) {
      var key = entries[i];
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  };
  var token = "%[a-f0-9]{2}";
  var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
  var multiMatcher = new RegExp("(" + token + ")+", "gi");
  module.exports = function(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, " ");
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent(encodedURI);
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/css@3.0.0/node_modules/source-map-resolve/index.js
var require_source_map_resolve = __commonJS((exports, module) => {
  var resolveUrl = function() {
    return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {
      return urlLib.resolve(resolved, nextUrl);
    });
  };
  var convertWindowsPath = function(aPath) {
    return pathLib.sep === "\\" ? aPath.replace(/\\/g, "/").replace(/^[a-z]:\/?/i, "/") : aPath;
  };
  var customDecodeUriComponent = function(string) {
    return decodeUriComponentLib(string.replace(/\+/g, "%2B"));
  };
  var callbackAsync = function(callback, error, result) {
    setImmediate(function() {
      callback(error, result);
    });
  };
  var parseMapToJSON = function(string, data) {
    try {
      return JSON.parse(string.replace(/^\)\]\}'/, ""));
    } catch (error) {
      error.sourceMapData = data;
      throw error;
    }
  };
  var readSync = function(read, url, data) {
    var readUrl = customDecodeUriComponent(url);
    try {
      return String(read(readUrl));
    } catch (error) {
      error.sourceMapData = data;
      throw error;
    }
  };
  var getSourceMappingUrl = function(code) {
    var match = code.match(sourceMappingURLRegex);
    return match ? match[1] || match[2] || "" : null;
  };
  var resolveSourceMap = function(code, codeUrl, read, callback) {
    var mapData;
    try {
      mapData = resolveSourceMapHelper(code, codeUrl);
    } catch (error) {
      return callbackAsync(callback, error);
    }
    if (!mapData || mapData.map) {
      return callbackAsync(callback, null, mapData);
    }
    var readUrl = customDecodeUriComponent(mapData.url);
    read(readUrl, function(error, result) {
      if (error) {
        error.sourceMapData = mapData;
        return callback(error);
      }
      mapData.map = String(result);
      try {
        mapData.map = parseMapToJSON(mapData.map, mapData);
      } catch (error2) {
        return callback(error2);
      }
      callback(null, mapData);
    });
  };
  var resolveSourceMapSync = function(code, codeUrl, read) {
    var mapData = resolveSourceMapHelper(code, codeUrl);
    if (!mapData || mapData.map) {
      return mapData;
    }
    mapData.map = readSync(read, mapData.url, mapData);
    mapData.map = parseMapToJSON(mapData.map, mapData);
    return mapData;
  };
  var base64ToBuf = function(b64) {
    var binStr = atob(b64);
    var len = binStr.length;
    var arr = new Uint8Array(len);
    for (var i = 0;i < len; i++) {
      arr[i] = binStr.charCodeAt(i);
    }
    return arr;
  };
  var decodeBase64String = function(b64) {
    if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
      return atob(b64);
    }
    var buf = base64ToBuf(b64);
    var decoder = new TextDecoder(jsonCharacterEncoding, { fatal: true });
    return decoder.decode(buf);
  };
  var resolveSourceMapHelper = function(code, codeUrl) {
    codeUrl = convertWindowsPath(codeUrl);
    var url = getSourceMappingUrl(code);
    if (!url) {
      return null;
    }
    var dataUri = url.match(dataUriRegex);
    if (dataUri) {
      var mimeType = dataUri[1] || "text/plain";
      var lastParameter = dataUri[2] || "";
      var encoded = dataUri[3] || "";
      var data = {
        sourceMappingURL: url,
        url: null,
        sourcesRelativeTo: codeUrl,
        map: encoded
      };
      if (!jsonMimeTypeRegex.test(mimeType)) {
        var error = new Error("Unuseful data uri mime type: " + mimeType);
        error.sourceMapData = data;
        throw error;
      }
      try {
        data.map = parseMapToJSON(lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);
      } catch (error2) {
        error2.sourceMapData = data;
        throw error2;
      }
      return data;
    }
    var mapUrl = resolveUrl(codeUrl, url);
    return {
      sourceMappingURL: url,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    };
  };
  var resolveSources = function(map, mapUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var pending = map.sources ? map.sources.length : 0;
    var result = {
      sourcesResolved: [],
      sourcesContent: []
    };
    if (pending === 0) {
      callbackAsync(callback, null, result);
      return;
    }
    var done = function() {
      pending--;
      if (pending === 0) {
        callback(null, result);
      }
    };
    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl;
      if (typeof sourceContent === "string") {
        result.sourcesContent[index] = sourceContent;
        callbackAsync(done, null);
      } else {
        var readUrl = customDecodeUriComponent(fullUrl);
        read(readUrl, function(error, source) {
          result.sourcesContent[index] = error ? error : String(source);
          done();
        });
      }
    });
  };
  var resolveSourcesSync = function(map, mapUrl, read, options) {
    var result = {
      sourcesResolved: [],
      sourcesContent: []
    };
    if (!map.sources || map.sources.length === 0) {
      return result;
    }
    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl;
      if (read !== null) {
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent;
        } else {
          var readUrl = customDecodeUriComponent(fullUrl);
          try {
            result.sourcesContent[index] = String(read(readUrl));
          } catch (error) {
            result.sourcesContent[index] = error;
          }
        }
      }
    });
    return result;
  };
  var resolveSourcesHelper = function(map, mapUrl, options, fn) {
    options = options || {};
    mapUrl = convertWindowsPath(mapUrl);
    var fullUrl;
    var sourceContent;
    var sourceRoot;
    for (var index = 0, len = map.sources.length;index < len; index++) {
      sourceRoot = null;
      if (typeof options.sourceRoot === "string") {
        sourceRoot = options.sourceRoot;
      } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
        sourceRoot = map.sourceRoot;
      }
      if (sourceRoot === null || sourceRoot === "") {
        fullUrl = resolveUrl(mapUrl, map.sources[index]);
      } else {
        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index]);
      }
      sourceContent = (map.sourcesContent || [])[index];
      fn(fullUrl, sourceContent, index);
    }
  };
  var resolve = function(code, codeUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (code === null) {
      var mapUrl = codeUrl;
      var data = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      };
      var readUrl = customDecodeUriComponent(mapUrl);
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = data;
          return callback(error);
        }
        data.map = String(result);
        try {
          data.map = parseMapToJSON(data.map, data);
        } catch (error2) {
          return callback(error2);
        }
        _resolveSources(data);
      });
    } else {
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error);
        }
        if (!mapData) {
          return callback(null, null);
        }
        _resolveSources(mapData);
      });
    }
    function _resolveSources(mapData) {
      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
        if (error) {
          return callback(error);
        }
        mapData.sourcesResolved = result.sourcesResolved;
        mapData.sourcesContent = result.sourcesContent;
        callback(null, mapData);
      });
    }
  };
  var resolveSync = function(code, codeUrl, read, options) {
    var mapData;
    if (code === null) {
      var mapUrl = codeUrl;
      mapData = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      };
      mapData.map = readSync(read, mapUrl, mapData);
      mapData.map = parseMapToJSON(mapData.map, mapData);
    } else {
      mapData = resolveSourceMapSync(code, codeUrl, read);
      if (!mapData) {
        return null;
      }
    }
    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);
    mapData.sourcesResolved = result.sourcesResolved;
    mapData.sourcesContent = result.sourcesContent;
    return mapData;
  };
  var atob = require_node_atob();
  var urlLib = __require("url");
  var pathLib = __require("path");
  var decodeUriComponentLib = require_decode_uri_component();
  var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;
  var sourceMappingURLRegex = RegExp("(?:/\\*(?:\\s*\r?\n(?://)?)?(?:" + innerRegex.source + ")\\s*\\*/|//(?:" + innerRegex.source + "))\\s*");
  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;
  var jsonMimeTypeRegex = /^(?:application|text)\/json$/;
  var jsonCharacterEncoding = "utf-8";
  var endingSlash = /\/?$/;
  module.exports = {
    resolveSourceMap,
    resolveSourceMapSync,
    resolveSources,
    resolveSourcesSync,
    resolve,
    resolveSync,
    parseMapToJSON
  };
});

// node_modules/.pnpm/css@3.0.0/node_modules/css/lib/stringify/source-map-support.js
var require_source_map_support = __commonJS((exports, module) => {
  var mixin = function(compiler) {
    compiler._comment = compiler.comment;
    compiler.map = new SourceMap;
    compiler.position = { line: 1, column: 1 };
    compiler.files = {};
    for (var k in exports)
      compiler[k] = exports[k];
  };
  var SourceMap = require_source_map2().SourceMapGenerator;
  var SourceMapConsumer = require_source_map2().SourceMapConsumer;
  var sourceMapResolve = require_source_map_resolve();
  var fs = __require("fs");
  var path = __require("path");
  module.exports = mixin;
  var makeFriendlyPath = function(aPath) {
    return path.sep === "\\" ? aPath.replace(/\\/g, "/").replace(/^[a-z]:\/?/i, "/") : aPath;
  };
  exports.updatePosition = function(str) {
    var lines = str.match(/\n/g);
    if (lines)
      this.position.line += lines.length;
    var i = str.lastIndexOf("\n");
    this.position.column = ~i ? str.length - i : this.position.column + str.length;
  };
  exports.emit = function(str, pos) {
    if (pos) {
      var sourceFile = makeFriendlyPath(pos.source || "source.css");
      this.map.addMapping({
        source: sourceFile,
        generated: {
          line: this.position.line,
          column: Math.max(this.position.column - 1, 0)
        },
        original: {
          line: pos.start.line,
          column: pos.start.column - 1
        }
      });
      this.addFile(sourceFile, pos);
    }
    this.updatePosition(str);
    return str;
  };
  exports.addFile = function(file, pos) {
    if (typeof pos.content !== "string")
      return;
    if (Object.prototype.hasOwnProperty.call(this.files, file))
      return;
    this.files[file] = pos.content;
  };
  exports.applySourceMaps = function() {
    Object.keys(this.files).forEach(function(file) {
      var content = this.files[file];
      this.map.setSourceContent(file, content);
      if (this.options.inputSourcemaps !== false) {
        var originalMap = sourceMapResolve.resolveSync(content, file, fs.readFileSync);
        if (originalMap) {
          var map = new SourceMapConsumer(originalMap.map);
          var relativeTo = originalMap.sourcesRelativeTo;
          this.map.applySourceMap(map, file, makeFriendlyPath(path.dirname(relativeTo)));
        }
      }
    }, this);
  };
  exports.comment = function(node) {
    if (/^# sourceMappingURL=/.test(node.comment))
      return this.emit("", node.position);
    else
      return this._comment(node);
  };
});

// node_modules/.pnpm/css@3.0.0/node_modules/css/lib/stringify/index.js
var require_stringify = __commonJS((exports, module) => {
  var Compressed = require_compress();
  var Identity = require_identity();
  module.exports = function(node, options) {
    options = options || {};
    var compiler = options.compress ? new Compressed(options) : new Identity(options);
    if (options.sourcemap) {
      var sourcemaps = require_source_map_support();
      sourcemaps(compiler);
      var code = compiler.compile(node);
      compiler.applySourceMaps();
      var map = options.sourcemap === "generator" ? compiler.map : compiler.map.toJSON();
      return { code, map };
    }
    var code = compiler.compile(node);
    return code;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/stylus@0.56.0/node_modules/css/index.js
var require_css = __commonJS((exports) => {
  exports.parse = require_parse();
  exports.stringify = require_stringify();
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/convert/css.js
var require_css2 = __commonJS((exports, module) => {
  var Converter = function(css) {
    var { parse } = require_css();
    this.css = css;
    this.root = parse(css, { position: false });
    this.indents = 0;
  };
  /*!
   * Stylus - CSS to Stylus conversion
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  module.exports = function(css) {
    return new Converter(css).stylus();
  };
  Converter.prototype.stylus = function() {
    return this.visitRules(this.root.stylesheet.rules);
  };
  Converter.prototype.__defineGetter__("indent", function() {
    return Array(this.indents + 1).join("  ");
  });
  Converter.prototype.visit = function(node) {
    switch (node.type) {
      case "rule":
      case "comment":
      case "charset":
      case "namespace":
      case "media":
      case "import":
      case "document":
      case "keyframes":
      case "page":
      case "host":
      case "supports":
        var name = node.type[0].toUpperCase() + node.type.slice(1);
        return this["visit" + name](node);
      case "font-face":
        return this.visitFontFace(node);
    }
  };
  Converter.prototype.visitRules = function(node) {
    var buf = "";
    for (var i = 0, len = node.length;i < len; ++i) {
      buf += this.visit(node[i]);
    }
    return buf;
  };
  Converter.prototype.visitFontFace = function(node) {
    var buf = this.indent + "@font-face";
    buf += "\n";
    ++this.indents;
    for (var i = 0, len = node.declarations.length;i < len; ++i) {
      buf += this.visitDeclaration(node.declarations[i]);
    }
    --this.indents;
    return buf;
  };
  Converter.prototype.visitMedia = function(node) {
    var buf = this.indent + "@media " + node.media;
    buf += "\n";
    ++this.indents;
    buf += this.visitRules(node.rules);
    --this.indents;
    return buf;
  };
  Converter.prototype.visitDeclaration = function(node) {
    if (node.type == "comment") {
      return this.visitComment(node);
    } else {
      var buf = this.indent + node.property + ": " + node.value + "\n";
      return buf;
    }
  };
  Converter.prototype.visitRule = function(node) {
    var buf = this.indent + node.selectors.join(",\n" + this.indent) + "\n";
    ++this.indents;
    for (var i = 0, len = node.declarations.length;i < len; ++i) {
      buf += this.visitDeclaration(node.declarations[i]);
    }
    --this.indents;
    return buf + "\n";
  };
  Converter.prototype.visitComment = function(node) {
    var buf = this.indent + "/*" + node.comment + "*/";
    return buf + "\n";
  };
  Converter.prototype.visitCharset = function(node) {
    var buf = this.indent + "@charset " + node.charset;
    return buf + "\n";
  };
  Converter.prototype.visitNamespace = function(node) {
    var buf = this.indent + "@namespace " + node.namespace;
    return buf + "\n";
  };
  Converter.prototype.visitImport = function(node) {
    var buf = this.indent + "@import " + node.import;
    return buf + "\n";
  };
  Converter.prototype.visitDocument = function(node) {
    var buf = this.indent + "@" + node.vendor + "document " + node.document;
    buf += "\n";
    ++this.indents;
    buf += this.visitRules(node.rules);
    --this.indents;
    return buf;
  };
  Converter.prototype.visitKeyframes = function(node) {
    var buf = this.indent + "@keyframes " + node.name;
    buf += "\n";
    ++this.indents;
    for (var i = 0, len = node.keyframes.length;i < len; ++i) {
      buf += this.visitKeyframe(node.keyframes[i]);
    }
    --this.indents;
    return buf;
  };
  Converter.prototype.visitKeyframe = function(node) {
    var buf = this.indent + node.values.join(", ");
    buf += "\n";
    ++this.indents;
    for (var i = 0, len = node.declarations.length;i < len; ++i) {
      buf += this.visitDeclaration(node.declarations[i]);
    }
    --this.indents;
    return buf;
  };
  Converter.prototype.visitPage = function(node) {
    var buf = this.indent + "@page" + (node.selectors.length ? " " + node.selectors.join(", ") : "");
    buf += "\n";
    ++this.indents;
    for (var i = 0, len = node.declarations.length;i < len; ++i) {
      buf += this.visitDeclaration(node.declarations[i]);
    }
    --this.indents;
    return buf;
  };
  Converter.prototype.visitSupports = function(node) {
    var buf = this.indent + "@supports " + node.supports;
    buf += "\n";
    ++this.indents;
    buf += this.visitRules(node.rules);
    --this.indents;
    return buf;
  };
  Converter.prototype.visitHost = function(node) {
    var buf = this.indent + "@host";
    buf += "\n";
    ++this.indents;
    buf += this.visitRules(node.rules);
    --this.indents;
    return buf;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/functions/resolver.js
var require_resolver = __commonJS((exports, module) => {
  var Compiler = require_compiler();
  var nodes = require_nodes();
  var parse = __require("url").parse;
  var relative = __require("path").relative;
  var join = __require("path").join;
  var dirname = __require("path").dirname;
  var extname = __require("path").extname;
  var sep = __require("path").sep;
  module.exports = function(options) {
    options = options || {};
    function resolver(url) {
      var compiler = new Compiler(url), filename = url.filename;
      compiler.isURL = true;
      url = parse(url.nodes.map(function(node) {
        return compiler.visit(node);
      }).join(""));
      var literal = new nodes.Literal('url("' + url.href + '")'), path = url.pathname, dest = this.options.dest, tail = "", res;
      if (url.protocol || !path || path[0] == "/")
        return literal;
      if (!options.nocheck) {
        var _paths = options.paths || [];
        path = require_utils().lookup(path, _paths.concat(this.paths));
        if (!path)
          return literal;
      }
      if (this.includeCSS && extname(path) == ".css")
        return new nodes.Literal(url.href);
      if (url.search)
        tail += url.search;
      if (url.hash)
        tail += url.hash;
      if (dest && extname(dest) == ".css")
        dest = dirname(dest);
      res = relative(dest || dirname(this.filename), options.nocheck ? join(dirname(filename), path) : path) + tail;
      if (sep == "\\")
        res = res.replace(/\\/g, "/");
      return new nodes.Literal('url("' + res + '")');
    }
    resolver.options = options;
    resolver.raw = true;
    return resolver;
  };
});

// node_modules/.pnpm/stylus@0.56.0/node_modules/stylus/lib/stylus.js
var require_stylus = __commonJS((exports, module) => {
  var render = function(str, options) {
    return new Renderer(str, options);
  };
  /*!
   * Stylus
   * Copyright (c) Automattic <developer.wordpress.com>
   * MIT Licensed
   */
  var Renderer = require_renderer();
  var nodes = require_nodes();
  var utils = require_utils();
  exports = module.exports = render;
  exports.version = require_package().version;
  exports.nodes = nodes;
  exports.functions = require_functions();
  exports.utils = require_utils();
  exports.middleware = require_middleware();
  exports.Visitor = require_visitor();
  exports.Parser = require_parser();
  exports.Evaluator = require_evaluator();
  exports.Normalizer = require_normalizer();
  exports.Compiler = require_compiler();
  exports.convertCSS = require_css2();
  exports.render = function(str, options, fn) {
    if (typeof options == "function")
      fn = options, options = {};
    return new Renderer(str, options).render(fn);
  };
  exports.url = require_url();
  exports.resolver = require_resolver();
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/stylus/index.js
var require_stylus2 = __commonJS((exports, module) => {
  module.exports = process.env.STYLUS_COV ? require_stylus() : require_stylus();
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/is-expression@4.0.0/node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS((exports, module) => {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.acorn = {}));
  })(exports, function(exports2) {
    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    var keywords = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    var keywordRelationalOperator = /^in(stanceof)?$/;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      var pos = 65536;
      for (var i = 0;i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) {
          return false;
        }
        pos += set[i + 1];
        if (pos >= code) {
          return true;
        }
      }
    }
    function isIdentifierStart(code, astral) {
      if (code < 65) {
        return code === 36;
      }
      if (code < 91) {
        return true;
      }
      if (code < 97) {
        return code === 95;
      }
      if (code < 123) {
        return true;
      }
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code, astral) {
      if (code < 48) {
        return code === 36;
      }
      if (code < 58) {
        return true;
      }
      if (code < 65) {
        return false;
      }
      if (code < 91) {
        return true;
      }
      if (code < 97) {
        return code === 95;
      }
      if (code < 123) {
        return true;
      }
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    var TokenType = function TokenType(label, conf) {
      if (conf === undefined)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    function binop(name, prec) {
      return new TokenType(name, { beforeExpr: true, binop: prec });
    }
    var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
    var keywords$1 = {};
    function kw(name, options) {
      if (options === undefined)
        options = {};
      options.keyword = name;
      return keywords$1[name] = new TokenType(name, options);
    }
    var types = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", { beforeExpr: true }),
      coalesce: binop("??", 1),
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", { isLoop: true, beforeExpr: true }),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", { isLoop: true }),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", { isLoop: true }),
      _with: kw("with"),
      _new: kw("new", { beforeExpr: true, startsExpr: true }),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code, ecma2019String) {
      return code === 10 || code === 13 || !ecma2019String && (code === 8232 || code === 8233);
    }
    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var ref = Object.prototype;
    var hasOwnProperty = ref.hasOwnProperty;
    var toString = ref.toString;
    function has(obj, propName) {
      return hasOwnProperty.call(obj, propName);
    }
    var isArray = Array.isArray || function(obj) {
      return toString.call(obj) === "[object Array]";
    };
    function wordsRegexp(words) {
      return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
    }
    var Position = function Position(line, col) {
      this.line = line;
      this.column = col;
    };
    Position.prototype.offset = function offset(n) {
      return new Position(this.line, this.column + n);
    };
    var SourceLocation = function SourceLocation(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) {
        this.source = p.sourceFile;
      }
    };
    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;; ) {
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
          ++line;
          cur = match.index + match[0].length;
        } else {
          return new Position(line, offset - cur);
        }
      }
    }
    var defaultOptions = {
      ecmaVersion: 10,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowAwaitOutsideFunction: false,
      allowHashBang: false,
      locations: false,
      onToken: null,
      onComment: null,
      ranges: false,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: false
    };
    function getOptions(opts) {
      var options = {};
      for (var opt in defaultOptions) {
        options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
      }
      if (options.ecmaVersion >= 2015) {
        options.ecmaVersion -= 2009;
      }
      if (options.allowReserved == null) {
        options.allowReserved = options.ecmaVersion < 5;
      }
      if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function(token) {
          return tokens.push(token);
        };
      }
      if (isArray(options.onComment)) {
        options.onComment = pushComment(options, options.onComment);
      }
      return options;
    }
    function pushComment(options, array) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start,
          end
        };
        if (options.locations) {
          comment.loc = new SourceLocation(this, startLoc, endLoc);
        }
        if (options.ranges) {
          comment.range = [start, end];
        }
        array.push(comment);
      };
    }
    var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128;
    function functionFlags(async, generator) {
      return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
    var Parser = function Parser(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        for (var v = options.ecmaVersion;; v--) {
          if (reserved = reservedWords[v]) {
            break;
          }
        }
        if (options.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = {};
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);
      this.regexpState = null;
    };
    var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true } };
    Parser.prototype.parse = function parse() {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node);
    };
    prototypeAccessors.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
    };
    prototypeAccessors.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
    };
    prototypeAccessors.allowSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    Parser.prototype.inNonArrowFunction = function inNonArrowFunction() {
      return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
    };
    Parser.extend = function extend() {
      var plugins = [], len = arguments.length;
      while (len--)
        plugins[len] = arguments[len];
      var cls = this;
      for (var i = 0;i < plugins.length; i++) {
        cls = plugins[i](cls);
      }
      return cls;
    };
    Parser.parse = function parse(input, options) {
      return new this(options, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression();
    };
    Parser.tokenizer = function tokenizer(input, options) {
      return new this(options, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    var pp = Parser.prototype;
    var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp.strictDirective = function(start) {
      for (;; ) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) {
          return false;
        }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp.isContextual = function(name) {
      return this.type === types.name && this.value === name && !this.containsEsc;
    };
    pp.eatContextual = function(name) {
      if (!this.isContextual(name)) {
        return false;
      }
      this.next();
      return true;
    };
    pp.expectContextual = function(name) {
      if (!this.eatContextual(name)) {
        this.unexpected();
      }
    };
    pp.canInsertSemicolon = function() {
      return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp.semicolon = function() {
      if (!this.eat(types.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    function DestructuringErrors() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    }
    pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, "Parenthesized pattern");
      }
    };
    pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    var pp$1 = Parser.prototype;
    pp$1.parseTopLevel = function(node) {
      var exports3 = {};
      if (!node.body) {
        node.body = [];
      }
      while (this.type !== types.eof) {
        var stmt = this.parseStatement(null, true, exports3);
        node.body.push(stmt);
      }
      if (this.inModule) {
        for (var i = 0, list = Object.keys(this.undefinedExports);i < list.length; i += 1) {
          var name = list[i];
          this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node.body);
      this.next();
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program");
    };
    var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
    pp$1.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) {
        return true;
      }
      if (context) {
        return false;
      }
      if (nextCh === 123) {
        return true;
      }
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$1.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length;
      return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
    };
    pp$1.parseStatement = function(context, topLevel, exports3) {
      var starttype = this.type, node = this.startNode(), kind;
      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }
      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types._debugger:
          return this.parseDebuggerStatement(node);
        case types._do:
          return this.parseDoStatement(node);
        case types._for:
          return this.parseForStatement(node);
        case types._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context);
        case types._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types._if:
          return this.parseIfStatement(node);
        case types._return:
          return this.parseReturnStatement(node);
        case types._switch:
          return this.parseSwitchStatement(node);
        case types._throw:
          return this.parseThrowStatement(node);
        case types._try:
          return this.parseTryStatement(node);
        case types._const:
        case types._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types._while:
          return this.parseWhileStatement(node);
        case types._with:
          return this.parseWithStatement(node);
        case types.braceL:
          return this.parseBlock(true, node);
        case types.semi:
          return this.parseEmptyStatement(node);
        case types._export:
        case types._import:
          if (this.options.ecmaVersion > 10 && starttype === types._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports3);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
      }
    };
    pp$1.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types.semi) || this.insertSemicolon()) {
        node.label = null;
      } else if (this.type !== types.name) {
        this.unexpected();
      } else {
        node.label = this.parseIdent();
        this.semicolon();
      }
      var i = 0;
      for (;i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node.label && isBreak) {
            break;
          }
        }
      }
      if (i === this.labels.length) {
        this.raise(node.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$1.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    pp$1.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node, "DoWhileStatement");
    };
    pp$1.parseForStatement = function(node) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types.parenL);
      if (this.type === types.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, null);
      }
      var isLet = this.isLet();
      if (this.type === types._var || this.type === types._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init$1);
      }
      var refDestructuringErrors = new DestructuringErrors;
      var init = this.parseExpression(true, refDestructuringErrors);
      if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node.await = awaitAt > -1;
          }
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLVal(init);
        return this.parseForIn(node, init);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    };
    pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$1.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    };
    pp$1.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types.semi) || this.insertSemicolon()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    pp$1.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false;this.type !== types.braceR; ) {
        if (this.type === types._case || this.type === types._default) {
          var isCase = this.type === types._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    pp$1.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    var empty = [];
    pp$1.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types.parenR);
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(node.start, "Missing catch or finally clause");
      }
      return this.finishNode(node, "TryStatement");
    };
    pp$1.parseVarStatement = function(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    pp$1.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    pp$1.parseWithStatement = function(node) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement");
    };
    pp$1.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels;i$1 < list.length; i$1 += 1) {
        var label = list[i$1];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
      for (var i = this.labels.length - 1;i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    pp$1.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
      if (createNewLexicalScope === undefined)
        createNewLexicalScope = true;
      if (node === undefined)
        node = this.startNode();
      node.body = [];
      this.expect(types.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node, "BlockStatement");
    };
    pp$1.parseFor = function(node, init) {
      node.init = init;
      this.expect(types.semi);
      node.test = this.type === types.semi ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.type === types.parenR ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    pp$1.parseForIn = function(node, init) {
      var isForIn = this.type === types._in;
      this.next();
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, "Invalid left-hand side in for-loop");
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$1.parseVar = function(node, isFor, kind) {
      node.declarations = [];
      node.kind = kind;
      for (;; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) {
          break;
        }
      }
      return node;
    };
    pp$1.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
    pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {
          this.unexpected();
        }
        node.generator = this.eat(types.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT) {
        node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
          this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));
      if (!(statement & FUNC_STATEMENT)) {
        node.id = this.type === types.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$1.parseFunctionParams = function(node) {
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$1.parseClass = function(node, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types.braceL);
      while (this.type !== types.braceR) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raise(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node.body = this.finishNode(classBody, "ClassBody");
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$1.parseClassElement = function(constructorAllowsSuper) {
      var this$1 = this;
      if (this.eat(types.semi)) {
        return null;
      }
      var method = this.startNode();
      var tryContextual = function(k, noLineBreak) {
        if (noLineBreak === undefined)
          noLineBreak = false;
        var { start, startLoc } = this$1;
        if (!this$1.eatContextual(k)) {
          return false;
        }
        if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {
          return true;
        }
        if (method.key) {
          this$1.unexpected();
        }
        method.computed = false;
        method.key = this$1.startNodeAt(start, startLoc);
        method.key.name = k;
        this$1.finishNode(method.key, "Identifier");
        return false;
      };
      method.kind = "method";
      method.static = tryContextual("static");
      var isGenerator = this.eat(types.star);
      var isAsync = false;
      if (!isGenerator) {
        if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        } else if (tryContextual("get")) {
          method.kind = "get";
        } else if (tryContextual("set")) {
          method.kind = "set";
        }
      }
      if (!method.key) {
        this.parsePropertyName(method);
      }
      var key = method.key;
      var allowsDirectSuper = false;
      if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (method.kind !== "method") {
          this.raise(key.start, "Constructor can't have get/set modifier");
        }
        if (isGenerator) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
        method.kind = "constructor";
        allowsDirectSuper = constructorAllowsSuper;
      } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && method.value.params.length !== 0) {
        this.raiseRecoverable(method.value.start, "getter should have no params");
      }
      if (method.kind === "set" && method.value.params.length !== 1) {
        this.raiseRecoverable(method.value.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") {
        this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
      }
      return method;
    };
    pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      return this.finishNode(method, "MethodDefinition");
    };
    pp$1.parseClassId = function(node, isStatement) {
      if (this.type === types.name) {
        node.id = this.parseIdent();
        if (isStatement) {
          this.checkLVal(node.id, BIND_LEXICAL, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node.id = null;
      }
    };
    pp$1.parseClassSuper = function(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };
    pp$1.parseExport = function(node, exports3) {
      this.next();
      if (this.eat(types.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseIdent(true);
            this.checkExport(exports3, node.exported.name, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      if (this.eat(types._default)) {
        this.checkExport(exports3, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types._class) {
          var cNode = this.startNode();
          node.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(null);
        if (node.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports3, node.declaration.declarations);
        } else {
          this.checkExport(exports3, node.declaration.id.name, node.declaration.id.start);
        }
        node.specifiers = [];
        node.source = null;
      } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports3);
        if (this.eatContextual("from")) {
          if (this.type !== types.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
        } else {
          for (var i = 0, list = node.specifiers;i < list.length; i += 1) {
            var spec = list[i];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
          }
          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$1.checkExport = function(exports3, name, pos) {
      if (!exports3) {
        return;
      }
      if (has(exports3, name)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
      }
      exports3[name] = true;
    };
    pp$1.checkPatternExport = function(exports3, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports3, pat.name, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i = 0, list = pat.properties;i < list.length; i += 1) {
          var prop = list[i];
          this.checkPatternExport(exports3, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$1 = 0, list$1 = pat.elements;i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];
          if (elt) {
            this.checkPatternExport(exports3, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports3, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports3, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports3, pat.argument);
      } else if (type === "ParenthesizedExpression") {
        this.checkPatternExport(exports3, pat.expression);
      }
    };
    pp$1.checkVariableExport = function(exports3, decls) {
      if (!exports3) {
        return;
      }
      for (var i = 0, list = decls;i < list.length; i += 1) {
        var decl = list[i];
        this.checkPatternExport(exports3, decl.id);
      }
    };
    pp$1.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$1.parseExportSpecifiers = function(exports3) {
      var nodes = [], first = true;
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var node = this.startNode();
        node.local = this.parseIdent(true);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        this.checkExport(exports3, node.exported.name, node.exported.start);
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes;
    };
    pp$1.parseImport = function(node) {
      this.next();
      if (this.type === types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    pp$1.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types.name) {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types.comma)) {
          return nodes;
        }
      }
      if (this.type === types.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLVal(node$1.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var node$2 = this.startNode();
        node$2.imported = this.parseIdent(true);
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLVal(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes;
    };
    pp$1.adaptDirectivePrologue = function(statements) {
      for (var i = 0;i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$1.isDirectiveCandidate = function(statement) {
      return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
    };
    var pp$2 = Parser.prototype;
    pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node.properties;i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
          case "AssignmentPattern":
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node;
    };
    pp$2.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0;i < end; i++) {
        var elt = exprList[i];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$2.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement");
    };
    pp$2.parseRestBinding = function() {
      var node = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types.name) {
        this.unexpected();
      }
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    };
    pp$2.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }
        if (allowEmpty && this.type === types.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        } else if (this.type === types.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    pp$2.parseBindingListItem = function(param) {
      return param;
    };
    pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
        return left;
      }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };
    pp$2.checkLVal = function(expr, bindingType, checkClashes) {
      if (bindingType === undefined)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "Identifier":
          if (bindingType === BIND_LEXICAL && expr.name === "let") {
            this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
          }
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (checkClashes) {
            if (has(checkClashes, expr.name)) {
              this.raiseRecoverable(expr.start, "Argument name clash");
            }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) {
            this.declareName(expr.name, bindingType, expr.start);
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (bindingType) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ObjectPattern":
          for (var i = 0, list = expr.properties;i < list.length; i += 1) {
            var prop = list[i];
            this.checkLVal(prop, bindingType, checkClashes);
          }
          break;
        case "Property":
          this.checkLVal(expr.value, bindingType, checkClashes);
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements;i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLVal(elem, bindingType, checkClashes);
            }
          }
          break;
        case "AssignmentPattern":
          this.checkLVal(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLVal(expr.argument, bindingType, checkClashes);
          break;
        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, bindingType, checkClashes);
          break;
        default:
          this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    var pp$3 = Parser.prototype;
    pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name;
      switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$3.parseExpression = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
      if (this.type === types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
        }
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(noIn);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types.parenL || this.type === types.name) {
        this.potentialArrowAt = this.start;
      }
      var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= node.left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(noIn, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    };
    pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.type.binop;
      if (prec != null && (!noIn || this.type !== types._in)) {
        if (prec > minPrec) {
          var logical = this.type === types.logicalOR || this.type === types.logicalAND;
          var coalesce = this.type === types.coalesce;
          if (coalesce) {
            prec = types.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }
      return left;
    };
    pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
        expr = this.parseAwait();
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLVal(node.argument);
        } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
          this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLVal(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }
      if (!sawUnary && this.eat(types.starstar)) {
        return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
      } else {
        return expr;
      }
    };
    pp$3.parseExprSubscripts = function(refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result = this.parseSubscripts(expr, startPos, startLoc);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
      }
      return result;
    };
    pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base = element;
      }
    };
    pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types.bracketL);
      if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
        node.computed = !!computed;
        if (computed) {
          this.expect(types.bracketR);
        }
        if (optionalSupported) {
          node.optional = optional;
        }
        base = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types.parenL)) {
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        if (optionalSupported) {
          node$1.optional = optional;
        }
        base = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base;
    };
    pp$3.parseExprAtom = function(refDestructuringErrors) {
      if (this.type === types.slash) {
        this.readRegexp();
      }
      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
            }
          }
          return id;
        case types.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = { pattern: value.pattern, flags: value.flags };
          return node;
        case types.num:
        case types.string:
          return this.parseLiteral(this.value);
        case types._null:
        case types._true:
        case types._false:
          node = this.startNode();
          node.value = this.type === types._null ? null : this.type === types._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types.braceL:
          return this.parseObj(false, refDestructuringErrors);
        case types._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types._class:
          return this.parseClass(this.startNode(), false);
        case types._new:
          return this.parseNew();
        case types.backQuote:
          return this.parseTemplate();
        case types._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
      }
    };
    pp$3.parseExprImport = function() {
      var node = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      var meta = this.parseIdent(true);
      switch (this.type) {
        case types.parenL:
          return this.parseDynamicImport(node);
        case types.dot:
          node.meta = meta;
          return this.parseImportMeta(node);
        default:
          this.unexpected();
      }
    };
    pp$3.parseDynamicImport = function(node) {
      this.next();
      node.source = this.parseMaybeAssign();
      if (!this.eat(types.parenR)) {
        var errorPos = this.start;
        if (this.eat(types.comma) && this.eat(types.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node, "ImportExpression");
    };
    pp$3.parseImportMeta = function(node) {
      this.next();
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "meta") {
        this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module") {
        this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node, "MetaProperty");
    };
    pp$3.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
        node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node, "Literal");
    };
    pp$3.parseParenExpression = function() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    };
    pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types.parenR) {
          first ? first = false : this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.start, innerEndLoc = this.startLoc;
        this.expect(types.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$3.parseParenItem = function(item) {
      return item;
    };
    pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
    };
    var empty$1 = [];
    pp$3.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
        node.meta = meta;
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
        }
        if (!this.inNonArrowFunction()) {
          this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
        }
        return this.finishNode(node, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      if (isImport && node.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types.parenL)) {
        node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node.arguments = empty$1;
      }
      return this.finishNode(node, "NewExpression");
    };
    pp$3.parseTemplateElement = function(ref2) {
      var isTagged = ref2.isTagged;
      var elem = this.startNode();
      if (this.type === types.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$3.parseTemplate = function(ref2) {
      if (ref2 === undefined)
        ref2 = {};
      var isTagged = ref2.isTagged;
      if (isTagged === undefined)
        isTagged = false;
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };
    pp$3.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$3.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        if (this.type === types.parenL && refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0) {
            refDestructuringErrors.parenthesizedAssign = this.start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = this.start;
          }
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        this.parsePropertyName(prop, refDestructuringErrors);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types.colon) {
        this.unexpected();
      }
      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else if (this.type === types.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$3.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$3.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) {
        node.generator = node.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = false;
      }
    };
    pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) {
        node.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression");
    };
    pp$3.parseArrowExpression = function(node, params, isAsync) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
      var isExpression = isArrowFunction && this.type !== types.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        if (this.strict && node.id) {
          this.checkLVal(node.id, BIND_OUTSIDE);
        }
        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$3.isSimpleParamList = function(params) {
      for (var i = 0, list = params;i < list.length; i += 1) {
        var param = list[i];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$3.checkParams = function(node, allowDuplicates) {
      var nameHash = {};
      for (var i = 0, list = node.params;i < list.length; i += 1) {
        var param = list[i];
        this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };
    pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          }
        } else {
          first = false;
        }
        var elt = undefined;
        if (allowEmpty && this.type === types.comma) {
          elt = null;
        } else if (this.type === types.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$3.checkUnreserved = function(ref2) {
      var start = ref2.start;
      var end = ref2.end;
      var name = ref2.name;
      if (this.inGenerator && name === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.keywords.test(name)) {
        this.raise(start, "Unexpected keyword '" + name + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name)) {
        if (!this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
      }
    };
    pp$3.parseIdent = function(liberal, isBinding) {
      var node = this.startNode();
      if (this.type === types.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;
        if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next(!!liberal);
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node.start;
        }
      }
      return node;
    };
    pp$3.parseYield = function(noIn) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node = this.startNode();
      this.next();
      if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
      }
      return this.finishNode(node, "YieldExpression");
    };
    pp$3.parseAwait = function() {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, false);
      return this.finishNode(node, "AwaitExpression");
    };
    var pp$4 = Parser.prototype;
    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
    };
    var pp$5 = Parser.prototype;
    var Scope = function Scope(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
    };
    pp$5.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };
    pp$5.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$5.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$5.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) {
          delete this.undefinedExports[name];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        }
        scope$2.functions.push(name);
      } else {
        for (var i = this.scopeStack.length - 1;i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name);
          if (this.inModule && scope$3.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
          if (scope$3.flags & SCOPE_VAR) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
      }
    };
    pp$5.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$5.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$5.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };
    pp$5.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };
    var Node = function Node(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) {
        this.loc = new SourceLocation(parser, loc);
      }
      if (parser.options.directSourceFile) {
        this.sourceFile = parser.options.directSourceFile;
      }
      if (parser.options.ranges) {
        this.range = [pos, 0];
      }
    };
    var pp$6 = Parser.prototype;
    pp$6.startNode = function() {
      return new Node(this, this.start, this.startLoc);
    };
    pp$6.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc);
    };
    function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations) {
        node.loc.end = loc;
      }
      if (this.options.ranges) {
        node.range[1] = pos;
      }
      return node;
    }
    pp$6.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$6.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc);
    };
    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    var types$1 = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function(p) {
        return p.tryReadTemplateToken();
      }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    var pp$7 = Parser.prototype;
    pp$7.initialContext = function() {
      return [types$1.b_stat];
    };
    pp$7.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types$1.f_expr || parent === types$1.f_stat) {
        return true;
      }
      if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types._return || prevType === types.name && this.exprAllowed) {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
        return true;
      }
      if (prevType === types.braceL) {
        return parent === types$1.b_stat;
      }
      if (prevType === types._var || prevType === types._const || prevType === types.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$7.inGeneratorContext = function() {
      for (var i = this.context.length - 1;i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function") {
          return context.generator;
        }
      }
      return false;
    };
    pp$7.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    types.parenR.updateContext = types.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types$1.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    types.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
      this.exprAllowed = true;
    };
    types.dollarBraceL.updateContext = function() {
      this.context.push(types$1.b_tmpl);
      this.exprAllowed = true;
    };
    types.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
      this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
      this.exprAllowed = true;
    };
    types.incDec.updateContext = function() {
    };
    types._function.updateContext = types._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
        this.context.push(types$1.f_expr);
      } else {
        this.context.push(types$1.f_stat);
      }
      this.exprAllowed = false;
    };
    types.backQuote.updateContext = function() {
      if (this.curContext() === types$1.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types$1.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types.star.updateContext = function(prevType) {
      if (prevType === types._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$1.f_expr) {
          this.context[index] = types$1.f_expr_gen;
        } else {
          this.context[index] = types$1.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties
    };
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues
    };
    var data = {};
    function buildUnicodeData(ecmaVersion) {
      var d = data[ecmaVersion] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
        nonBinary: {
          General_Category: wordsRegexp(unicodeGeneralCategoryValues),
          Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
        }
      };
      d.nonBinary.Script_Extensions = d.nonBinary.Script;
      d.nonBinary.gc = d.nonBinary.General_Category;
      d.nonBinary.sc = d.nonBinary.Script;
      d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }
    buildUnicodeData(9);
    buildUnicodeData(10);
    buildUnicodeData(11);
    var pp$8 = Parser.prototype;
    var RegExpValidationState = function RegExpValidationState(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState.prototype.raise = function raise(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState.prototype.at = function at(i, forceU) {
      if (forceU === undefined)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1;
      }
      var c = s.charCodeAt(i);
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
        return c;
      }
      var next = s.charCodeAt(i + 1);
      return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
      if (forceU === undefined)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l;
      }
      var c = s.charCodeAt(i), next;
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
        return i + 1;
      }
      return i + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
      if (forceU === undefined)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
      if (forceU === undefined)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
      if (forceU === undefined)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
      if (forceU === undefined)
        forceU = false;
      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    function codePointToString(ch) {
      if (ch <= 65535) {
        return String.fromCharCode(ch);
      }
      ch -= 65536;
      return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
    }
    pp$8.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      for (var i = 0;i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };
    pp$8.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$8.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(41)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(93) || state.eat(125)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames;i < list.length; i += 1) {
        var name = list[i];
        if (state.groupNames.indexOf(name) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$8.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(124)) {
        this.regexp_alternative(state);
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(123)) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$8.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$8.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$8.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(94) || state.eat(36)) {
        return true;
      }
      if (state.eat(92)) {
        if (state.eat(66) || state.eat(98)) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(40) && state.eat(63)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(60);
        }
        if (state.eat(61) || state.eat(33)) {
          this.regexp_disjunction(state);
          if (!state.eat(41)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$8.regexp_eatQuantifier = function(state, noError) {
      if (noError === undefined)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(63);
        return true;
      }
      return false;
    };
    pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$8.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(123)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(125)) {
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(40)) {
        if (state.eat(63) && state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatCapturingGroup = function(state) {
      if (state.eat(40)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$8.regexp_eatExtendedAtom = function(state) {
      return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$8.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    function isSyntaxCharacter(ch) {
      return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
    }
    pp$8.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$8.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_groupSpecifier = function(state) {
      if (state.eat(63)) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return;
        }
        state.raise("Invalid group");
      }
    };
    pp$8.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$8.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$8.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierStart(ch) {
      return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
    }
    pp$8.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierPart(ch) {
      return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
    }
    pp$8.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$8.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
          if (n > state.maxBackReference) {
            state.maxBackReference = n;
          }
          return true;
        }
        if (n <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatKGroupName = function(state) {
      if (state.eat(107)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$8.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$8.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(99)) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    function isControlLetter(ch) {
      return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
    }
    pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === undefined)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(117)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    function isValidUnicode(ch) {
      return ch >= 0 && ch <= 1114111;
    }
    pp$8.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(47)) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch = state.current();
      if (ch !== 99 && (!state.switchN || ch !== 107)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 49 && ch <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        } while ((ch = state.current()) >= 48 && ch <= 57);
        return true;
      }
      return false;
    };
    pp$8.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();
      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
      }
      if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
          return true;
        }
        state.raise("Invalid property name");
      }
      return false;
    };
    function isCharacterClassEscape(ch) {
      return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
    }
    pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return true;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
      }
      return false;
    };
    pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!has(state.unicodeProperties.nonBinary, name)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name].test(value)) {
        state.raise("Invalid property value");
      }
    };
    pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue)) {
        state.raise("Invalid property name");
      }
    };
    pp$8.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyNameCharacter(ch) {
      return isControlLetter(ch) || ch === 95;
    }
    pp$8.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyValueCharacter(ch) {
      return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
    }
    pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$8.regexp_eatCharacterClass = function(state) {
      if (state.eat(91)) {
        state.eat(94);
        this.regexp_classRanges(state);
        if (state.eat(93)) {
          return true;
        }
        state.raise("Unterminated character class");
      }
      return false;
    };
    pp$8.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(45) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$8.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch = state.current();
      if (ch !== 93) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(45)) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(99)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$8.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 95) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$8.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(120)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$8.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    function isDecimalDigit(ch) {
      return ch >= 48 && ch <= 57;
    }
    pp$8.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start;
    };
    function isHexDigit(ch) {
      return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
    }
    function hexToInt(ch) {
      if (ch >= 65 && ch <= 70) {
        return 10 + (ch - 65);
      }
      if (ch >= 97 && ch <= 102) {
        return 10 + (ch - 97);
      }
      return ch - 48;
    }
    pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$8.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    function isOctalDigit(ch) {
      return ch >= 48 && ch <= 55;
    }
    pp$8.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0;i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true;
    };
    var Token = function Token(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations) {
        this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
      }
      if (p.options.ranges) {
        this.range = [p.start, p.end];
      }
    };
    var pp$9 = Parser.prototype;
    pp$9.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp$9.getToken = function() {
      this.next();
      return new Token(this);
    };
    if (typeof Symbol !== "undefined") {
      pp$9[Symbol.iterator] = function() {
        var this$1 = this;
        return {
          next: function() {
            var token = this$1.getToken();
            return {
              done: token.type === types.eof,
              value: token
            };
          }
        };
      };
    }
    pp$9.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$9.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp$9.readToken = function(code) {
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp$9.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 57344) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return (code << 10) + next - 56613888;
    };
    pp$9.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match;
        while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
          ++this.curLine;
          this.lineStart = match.index + match[0].length;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp$9.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp$9.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp$9.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp$9.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types.dot);
      }
    };
    pp$9.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(types.slash, 1);
    };
    pp$9.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types.star : types.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp$9.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    };
    pp$9.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(types.bitwiseXOR, 1);
    };
    pp$9.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types.assign, 2);
      }
      return this.finishOp(types.plusMin, 1);
    };
    pp$9.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types.assign, size + 1);
        }
        return this.finishOp(types.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types.relational, size);
    };
    pp$9.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types.arrow);
      }
      return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
    };
    pp$9.readToken_question = function() {
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types.assign, 3);
            }
          }
          return this.finishOp(types.coalesce, 2);
        }
      }
      return this.finishOp(types.question, 1);
    };
    pp$9.getTokenFromCode = function(code) {
      switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types.prefix, 1);
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
    };
    pp$9.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp$9.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (;; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped) {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }
          escaped = ch === "\\";
        } else {
          escaped = false;
        }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e) {
      }
      return this.finishToken(types.regexp, { pattern, flags, value });
    };
    pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i = 0, e = len == null ? Infinity : len;i < e; ++i, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = undefined;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    function stringToNumber(str, isLegacyOctalNumericLiteral) {
      if (isLegacyOctalNumericLiteral) {
        return parseInt(str, 8);
      }
      return parseFloat(str.replace(/_/g, ""));
    }
    function stringToBigInt(str) {
      if (typeof BigInt !== "function") {
        return null;
      }
      return BigInt(str.replace(/_/g, ""));
    }
    pp$9.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types.num, val);
    };
    pp$9.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, undefined, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types.num, val);
    };
    pp$9.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    function codePointToString$1(code) {
      if (code <= 65535) {
        return String.fromCharCode(code);
      }
      code -= 65536;
      return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
    }
    pp$9.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (;; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) {
          break;
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else {
          if (isNewLine(ch, this.options.ecmaVersion >= 10)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types.string, out);
    };
    var INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp$9.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp$9.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR;
      } else {
        this.raise(position, message);
      }
    };
    pp$9.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (;; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types.template, out);
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp$9.readInvalidTemplateToken = function() {
      for (;this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp$9.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString$1(this.readCodePoint());
        case 116:
          return "\t";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            return null;
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
      }
    };
    pp$9.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n;
    };
    pp$9.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString$1(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp$9.readWord = function() {
      var word = this.readWord1();
      var type = types.name;
      if (this.keywords.test(word)) {
        type = keywords$1[word];
      }
      return this.finishToken(type, word);
    };
    var version = "7.4.1";
    Parser.acorn = {
      Parser,
      version,
      defaultOptions,
      Position,
      SourceLocation,
      getLineInfo,
      Node,
      TokenType,
      tokTypes: types,
      keywordTypes: keywords$1,
      TokContext,
      tokContexts: types$1,
      isIdentifierChar,
      isIdentifierStart,
      Token,
      isNewLine,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace
    };
    function parse(input, options) {
      return Parser.parse(input, options);
    }
    function parseExpressionAt(input, pos, options) {
      return Parser.parseExpressionAt(input, pos, options);
    }
    function tokenizer(input, options) {
      return Parser.tokenizer(input, options);
    }
    exports2.Node = Node;
    exports2.Parser = Parser;
    exports2.Position = Position;
    exports2.SourceLocation = SourceLocation;
    exports2.TokContext = TokContext;
    exports2.Token = Token;
    exports2.TokenType = TokenType;
    exports2.defaultOptions = defaultOptions;
    exports2.getLineInfo = getLineInfo;
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierStart = isIdentifierStart;
    exports2.isNewLine = isNewLine;
    exports2.keywordTypes = keywords$1;
    exports2.lineBreak = lineBreak;
    exports2.lineBreakG = lineBreakG;
    exports2.nonASCIIwhitespace = nonASCIIwhitespace;
    exports2.parse = parse;
    exports2.parseExpressionAt = parseExpressionAt;
    exports2.tokContexts = types$1;
    exports2.tokTypes = types;
    exports2.tokenizer = tokenizer;
    exports2.version = version;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-load@3.0.0/node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports, module) => {
  var toObject = function(val) {
    if (val === null || val === undefined) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  };
  var shouldUseNative = function() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0;i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  };
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1;s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0;i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-lexer@5.0.1/node_modules/is-expression/index.js
var require_is_expression = __commonJS((exports, module) => {
  var isExpression = function(src, options) {
    options = objectAssign({}, DEFAULT_OPTIONS, options);
    try {
      var parser = new acorn.Parser(options, src, 0);
      if (options.strict) {
        parser.strict = true;
      }
      if (!options.lineComment) {
        parser.skipLineComment = function(startSkip) {
          this.raise(this.pos, "Line comments not allowed in an expression");
        };
      }
      parser.nextToken();
      parser.parseExpression();
      if (parser.type !== acorn.tokTypes.eof) {
        parser.unexpected();
      }
    } catch (ex) {
      if (!options.throw) {
        return false;
      }
      throw ex;
    }
    return true;
  };
  var acorn = require_acorn();
  var objectAssign = require_object_assign();
  module.exports = isExpression;
  var DEFAULT_OPTIONS = {
    throw: false,
    strict: false,
    lineComment: false
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/es-errors/range.js
var require_range2 = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/call-bind@1.0.7/node_modules/es-errors/type.js
var require_type2 = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/get-intrinsic@1.2.4/node_modules/has-proto/index.js
var require_has_proto = __commonJS((exports, module) => {
  var test = {
    __proto__: null,
    foo: {}
  };
  var $Object = Object;
  module.exports = function hasProto() {
    return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
  };
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/call-bind@1.0.7/node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/is-core-module@2.13.1/node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/call-bind@1.0.7/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range2();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type2();
  var $URIError = require_uri();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var hasProto = require_has_proto()();
  var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
    return x.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/call-bind@1.0.7/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/set-function-length@1.2.1/node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/set-function-length@1.2.1/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS((exports, module) => {
  var $defineProperty = require_es_define_property();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type2();
  var gopd = require_gopd();
  module.exports = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/set-function-length@1.2.1/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS((exports, module) => {
  var $defineProperty = require_es_define_property();
  var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  module.exports = hasPropertyDescriptors;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/call-bind@1.0.7/node_modules/set-function-length/index.js
var require_set_function_length = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var define2 = require_define_data_property();
  var hasDescriptors = require_has_property_descriptors()();
  var gOPD = require_gopd();
  var $TypeError = require_type2();
  var $floor = GetIntrinsic("%Math.floor%");
  module.exports = function setFunctionLength(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD) {
      var desc = gOPD(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define2(fn, "length", length, true, true);
      } else {
        define2(fn, "length", length);
      }
    }
    return fn;
  };
});

// node_modules/.pnpm/call-bind@1.0.7/node_modules/call-bind/index.js
var require_call_bind = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var GetIntrinsic = require_get_intrinsic();
  var setFunctionLength = require_set_function_length();
  var $TypeError = require_type2();
  var $apply = GetIntrinsic("%Function.prototype.apply%");
  var $call = GetIntrinsic("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
  var $defineProperty = require_es_define_property();
  var $max = GetIntrinsic("%Math.max%");
  module.exports = function callBind(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError("a function is required");
    }
    var func = $reflectApply(bind, $call, arguments);
    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
  };
  var applyBind = function applyBind() {
    return $reflectApply(bind, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/is-regex@1.1.4/node_modules/call-bind/callBound.js
var require_callBound = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBind = require_call_bind();
  var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
  module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind(intrinsic);
    }
    return intrinsic;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/is-regex@1.1.4/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
  var hasSymbols = require_shams();
  module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/character-parser@2.2.0/node_modules/is-regex/index.js
var require_is_regex = __commonJS((exports, module) => {
  var callBound = require_callBound();
  var hasToStringTag = require_shams2()();
  var has;
  var $exec;
  var isRegexMarker;
  var badStringifier;
  if (hasToStringTag) {
    has = callBound("Object.prototype.hasOwnProperty");
    $exec = callBound("RegExp.prototype.exec");
    isRegexMarker = {};
    throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
  }
  var throwRegexMarker;
  var $toString = callBound("Object.prototype.toString");
  var gOPD = Object.getOwnPropertyDescriptor;
  var regexClass = "[object RegExp]";
  module.exports = hasToStringTag ? function isRegex(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    var descriptor = gOPD(value, "lastIndex");
    var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
    if (!hasLastIndexDataProperty) {
      return false;
    }
    try {
      $exec(value, badStringifier);
    } catch (e) {
      return e === isRegexMarker;
    }
  } : function isRegex(value) {
    if (!value || typeof value !== "object" && typeof value !== "function") {
      return false;
    }
    return $toString(value) === regexClass;
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-lexer@5.0.1/node_modules/character-parser/index.js
var require_character_parser = __commonJS((exports, module) => {
  var parse = function(src, state, options) {
    options = options || {};
    state = state || exports.defaultState();
    var start = options.start || 0;
    var end = options.end || src.length;
    var index = start;
    while (index < end) {
      try {
        parseChar(src[index], state);
      } catch (ex) {
        ex.index = index;
        throw ex;
      }
      index++;
    }
    return state;
  };
  var parseUntil = function(src, delimiter, options) {
    options = options || {};
    var start = options.start || 0;
    var index = start;
    var state = exports.defaultState();
    while (index < src.length) {
      if ((options.ignoreNesting || !state.isNesting(options)) && matches(src, delimiter, index)) {
        var end = index;
        return {
          start,
          end,
          src: src.substring(start, end)
        };
      }
      try {
        parseChar(src[index], state);
      } catch (ex) {
        ex.index = index;
        throw ex;
      }
      index++;
    }
    var err = new Error("The end of the string was reached with no closing bracket found.");
    err.code = "CHARACTER_PARSER:END_OF_STRING_REACHED";
    err.index = index;
    throw err;
  };
  var parseChar = function(character, state) {
    if (character.length !== 1) {
      var err = new Error("Character must be a string of length 1");
      err.name = "InvalidArgumentError";
      err.code = "CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE";
      throw err;
    }
    state = state || exports.defaultState();
    state.src += character;
    var wasComment = state.isComment();
    var lastChar = state.history ? state.history[0] : "";
    if (state.regexpStart) {
      if (character === "/" || character == "*") {
        state.stack.pop();
      }
      state.regexpStart = false;
    }
    switch (state.current()) {
      case TOKEN_TYPES.LINE_COMMENT:
        if (character === "\n") {
          state.stack.pop();
        }
        break;
      case TOKEN_TYPES.BLOCK_COMMENT:
        if (state.lastChar === "*" && character === "/") {
          state.stack.pop();
        }
        break;
      case TOKEN_TYPES.SINGLE_QUOTE:
        if (character === "\'" && !state.escaped) {
          state.stack.pop();
        } else if (character === "\\" && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
        break;
      case TOKEN_TYPES.DOUBLE_QUOTE:
        if (character === '"' && !state.escaped) {
          state.stack.pop();
        } else if (character === "\\" && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
        break;
      case TOKEN_TYPES.TEMPLATE_QUOTE:
        if (character === "`" && !state.escaped) {
          state.stack.pop();
          state.hasDollar = false;
        } else if (character === "\\" && !state.escaped) {
          state.escaped = true;
          state.hasDollar = false;
        } else if (character === "$" && !state.escaped) {
          state.hasDollar = true;
        } else if (character === "{" && state.hasDollar) {
          state.stack.push(BRACKETS[character]);
        } else {
          state.escaped = false;
          state.hasDollar = false;
        }
        break;
      case TOKEN_TYPES.REGEXP:
        if (character === "/" && !state.escaped) {
          state.stack.pop();
        } else if (character === "\\" && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
        break;
      default:
        if (character in BRACKETS) {
          state.stack.push(BRACKETS[character]);
        } else if (character in BRACKETS_REVERSED) {
          if (state.current() !== character) {
            var err = new SyntaxError("Mismatched Bracket: " + character);
            err.code = "CHARACTER_PARSER:MISMATCHED_BRACKET";
            throw err;
          }
          state.stack.pop();
        } else if (lastChar === "/" && character === "/") {
          state.history = state.history.substr(1);
          state.stack.push(TOKEN_TYPES.LINE_COMMENT);
        } else if (lastChar === "/" && character === "*") {
          state.history = state.history.substr(1);
          state.stack.push(TOKEN_TYPES.BLOCK_COMMENT);
        } else if (character === "/" && isRegexp(state.history)) {
          state.stack.push(TOKEN_TYPES.REGEXP);
          state.regexpStart = true;
        } else if (character === "\'") {
          state.stack.push(TOKEN_TYPES.SINGLE_QUOTE);
        } else if (character === '"') {
          state.stack.push(TOKEN_TYPES.DOUBLE_QUOTE);
        } else if (character === "`") {
          state.stack.push(TOKEN_TYPES.TEMPLATE_QUOTE);
        }
        break;
    }
    if (!state.isComment() && !wasComment) {
      state.history = character + state.history;
    }
    state.lastChar = character;
    return state;
  };
  var State = function() {
    this.stack = [];
    this.regexpStart = false;
    this.escaped = false;
    this.hasDollar = false;
    this.src = "";
    this.history = "";
    this.lastChar = "";
  };
  var matches = function(str, matcher, i) {
    if (objIsRegex(matcher)) {
      return matcher.test(str.substr(i || 0));
    } else {
      return str.substr(i || 0, matcher.length) === matcher;
    }
  };
  var isPunctuator = function(c) {
    if (!c)
      return true;
    var code = c.charCodeAt(0);
    switch (code) {
      case 46:
      case 40:
      case 41:
      case 59:
      case 44:
      case 123:
      case 125:
      case 91:
      case 93:
      case 58:
      case 63:
      case 126:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 47:
      case 60:
      case 62:
      case 94:
      case 124:
      case 33:
      case 61:
        return true;
      default:
        return false;
    }
  };
  var isKeyword = function(id) {
    return id === "if" || id === "in" || id === "do" || id === "var" || id === "for" || id === "new" || id === "try" || id === "let" || id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum" || id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super" || id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import" || id === "default" || id === "finally" || id === "extends" || id === "function" || id === "continue" || id === "debugger" || id === "package" || id === "private" || id === "interface" || id === "instanceof" || id === "implements" || id === "protected" || id === "public" || id === "static";
  };
  var isRegexp = function(history) {
    history = history.replace(/^\s*/, "");
    if (history[0] === ")")
      return false;
    if (history[0] === "}")
      return true;
    if (isPunctuator(history[0]))
      return true;
    if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0].split("").reverse().join("")))
      return true;
    return false;
  };
  var objIsRegex = require_is_regex();
  exports = module.exports = parse;
  var TOKEN_TYPES = exports.TOKEN_TYPES = {
    LINE_COMMENT: "//",
    BLOCK_COMMENT: "/**/",
    SINGLE_QUOTE: "\'",
    DOUBLE_QUOTE: '"',
    TEMPLATE_QUOTE: "`",
    REGEXP: "//g"
  };
  var BRACKETS = exports.BRACKETS = {
    "(": ")",
    "{": "}",
    "[": "]"
  };
  var BRACKETS_REVERSED = {
    ")": "(",
    "}": "{",
    "]": "["
  };
  exports.parse = parse;
  exports.parseUntil = parseUntil;
  exports.parseChar = parseChar;
  exports.defaultState = function() {
    return new State;
  };
  State.prototype.current = function() {
    return this.stack[this.stack.length - 1];
  };
  State.prototype.isString = function() {
    return this.current() === TOKEN_TYPES.SINGLE_QUOTE || this.current() === TOKEN_TYPES.DOUBLE_QUOTE || this.current() === TOKEN_TYPES.TEMPLATE_QUOTE;
  };
  State.prototype.isComment = function() {
    return this.current() === TOKEN_TYPES.LINE_COMMENT || this.current() === TOKEN_TYPES.BLOCK_COMMENT;
  };
  State.prototype.isNesting = function(opts) {
    if (opts && opts.ignoreLineComment && this.stack.length === 1 && this.stack[0] === TOKEN_TYPES.LINE_COMMENT) {
      return false;
    }
    return !!this.stack.length;
  };
  exports.isPunctuator = isPunctuator;
  exports.isKeyword = isKeyword;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-strip-comments@2.0.0/node_modules/pug-error/index.js
var require_pug_error = __commonJS((exports, module) => {
  var makeError = function(code, message, options) {
    var line = options.line;
    var column = options.column;
    var filename = options.filename;
    var src = options.src;
    var fullMessage;
    var location = line + (column ? ":" + column : "");
    if (src && line >= 1 && line <= src.split("\n").length) {
      var lines = src.split("\n");
      var start = Math.max(line - 3, 0);
      var end = Math.min(lines.length, line + 3);
      var context = lines.slice(start, end).map(function(text, i) {
        var curr = i + start + 1;
        var preamble = (curr == line ? "  > " : "    ") + curr + "| ";
        var out = preamble + text;
        if (curr === line && column > 0) {
          out += "\n";
          out += Array(preamble.length + column).join("-") + "^";
        }
        return out;
      }).join("\n");
      fullMessage = (filename || "Pug") + ":" + location + "\n" + context + "\n\n" + message;
    } else {
      fullMessage = (filename || "Pug") + ":" + location + "\n\n" + message;
    }
    var err = new Error(fullMessage);
    err.code = "PUG:" + code;
    err.msg = message;
    err.line = line;
    err.column = column;
    err.filename = filename;
    err.src = src;
    err.toJSON = function() {
      return {
        code: this.code,
        msg: this.msg,
        line: this.line,
        column: this.column,
        filename: this.filename
      };
    };
    return err;
  };
  module.exports = makeError;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-lexer/index.js
var require_pug_lexer = __commonJS((exports, module) => {
  var lex = function(str, options) {
    var lexer = new Lexer(str, options);
    return JSON.parse(JSON.stringify(lexer.getTokens()));
  };
  var Lexer = function(str, options) {
    options = options || {};
    if (typeof str !== "string") {
      throw new Error('Expected source code to be a string but got "' + typeof str + '"');
    }
    if (typeof options !== "object") {
      throw new Error('Expected "options" to be an object but got "' + typeof options + '"');
    }
    str = str.replace(/^\uFEFF/, "");
    this.input = str.replace(/\r\n|\r/g, "\n");
    this.originalInput = this.input;
    this.filename = options.filename;
    this.interpolated = options.interpolated || false;
    this.lineno = options.startingLine || 1;
    this.colno = options.startingColumn || 1;
    this.plugins = options.plugins || [];
    this.indentStack = [0];
    this.indentRe = null;
    this.interpolationAllowed = true;
    this.whitespaceRe = /[ \n\t]/;
    this.tokens = [];
    this.ended = false;
  };
  var assert = __require("assert");
  var isExpression = require_is_expression();
  var characterParser = require_character_parser();
  var error = require_pug_error();
  module.exports = lex;
  module.exports.Lexer = Lexer;
  Lexer.prototype = {
    constructor: Lexer,
    error: function(code, message) {
      var err = error(code, message, {
        line: this.lineno,
        column: this.colno,
        filename: this.filename,
        src: this.originalInput
      });
      throw err;
    },
    assert: function(value, message) {
      if (!value)
        this.error("ASSERT_FAILED", message);
    },
    isExpression: function(exp) {
      return isExpression(exp, {
        throw: true
      });
    },
    assertExpression: function(exp, noThrow) {
      try {
        this.callLexerFunction("isExpression", exp);
        return true;
      } catch (ex) {
        if (noThrow)
          return false;
        if (!ex.loc)
          throw ex;
        this.incrementLine(ex.loc.line - 1);
        this.incrementColumn(ex.loc.column);
        var msg = "Syntax Error: " + ex.message.replace(/ \([0-9]+:[0-9]+\)$/, "");
        this.error("SYNTAX_ERROR", msg);
      }
    },
    assertNestingCorrect: function(exp) {
      var res = characterParser(exp);
      if (res.isNesting()) {
        this.error("INCORRECT_NESTING", "Nesting must match on expression `" + exp + "`");
      }
    },
    tok: function(type, val) {
      var res = {
        type,
        loc: {
          start: {
            line: this.lineno,
            column: this.colno
          },
          filename: this.filename
        }
      };
      if (val !== undefined)
        res.val = val;
      return res;
    },
    tokEnd: function(tok) {
      tok.loc.end = {
        line: this.lineno,
        column: this.colno
      };
      return tok;
    },
    incrementLine: function(increment) {
      this.lineno += increment;
      if (increment)
        this.colno = 1;
    },
    incrementColumn: function(increment) {
      this.colno += increment;
    },
    consume: function(len) {
      this.input = this.input.substr(len);
    },
    scan: function(regexp, type) {
      var captures;
      if (captures = regexp.exec(this.input)) {
        var len = captures[0].length;
        var val = captures[1];
        var diff = len - (val ? val.length : 0);
        var tok = this.tok(type, val);
        this.consume(len);
        this.incrementColumn(diff);
        return tok;
      }
    },
    scanEndOfLine: function(regexp, type) {
      var captures;
      if (captures = regexp.exec(this.input)) {
        var whitespaceLength = 0;
        var whitespace;
        var tok;
        if (whitespace = /^([ ]+)([^ ]*)/.exec(captures[0])) {
          whitespaceLength = whitespace[1].length;
          this.incrementColumn(whitespaceLength);
        }
        var newInput = this.input.substr(captures[0].length);
        if (newInput[0] === ":") {
          this.input = newInput;
          tok = this.tok(type, captures[1]);
          this.incrementColumn(captures[0].length - whitespaceLength);
          return tok;
        }
        if (/^[ \t]*(\n|$)/.test(newInput)) {
          this.input = newInput.substr(/^[ \t]*/.exec(newInput)[0].length);
          tok = this.tok(type, captures[1]);
          this.incrementColumn(captures[0].length - whitespaceLength);
          return tok;
        }
      }
    },
    bracketExpression: function(skip) {
      skip = skip || 0;
      var start = this.input[skip];
      assert(start === "(" || start === "{" || start === "[", 'The start character should be "(", "{" or "["');
      var end = characterParser.BRACKETS[start];
      var range;
      try {
        range = characterParser.parseUntil(this.input, end, { start: skip + 1 });
      } catch (ex) {
        if (ex.index !== undefined) {
          var idx = ex.index;
          var tmp = this.input.substr(skip).indexOf("\n");
          var nextNewline = tmp + skip;
          var ptr = 0;
          while (idx > nextNewline && tmp !== -1) {
            this.incrementLine(1);
            idx -= nextNewline + 1;
            ptr += nextNewline + 1;
            tmp = nextNewline = this.input.substr(ptr).indexOf("\n");
          }
          this.incrementColumn(idx);
        }
        if (ex.code === "CHARACTER_PARSER:END_OF_STRING_REACHED") {
          this.error("NO_END_BRACKET", "The end of the string reached with no closing bracket " + end + " found.");
        } else if (ex.code === "CHARACTER_PARSER:MISMATCHED_BRACKET") {
          this.error("BRACKET_MISMATCH", ex.message);
        }
        throw ex;
      }
      return range;
    },
    scanIndentation: function() {
      var captures, re;
      if (this.indentRe) {
        captures = this.indentRe.exec(this.input);
      } else {
        re = /^\n(\t*) */;
        captures = re.exec(this.input);
        if (captures && !captures[1].length) {
          re = /^\n( *)/;
          captures = re.exec(this.input);
        }
        if (captures && captures[1].length)
          this.indentRe = re;
      }
      return captures;
    },
    eos: function() {
      if (this.input.length)
        return;
      if (this.interpolated) {
        this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
      }
      for (var i = 0;this.indentStack[i]; i++) {
        this.tokens.push(this.tokEnd(this.tok("outdent")));
      }
      this.tokens.push(this.tokEnd(this.tok("eos")));
      this.ended = true;
      return true;
    },
    blank: function() {
      var captures;
      if (captures = /^\n[ \t]*\n/.exec(this.input)) {
        this.consume(captures[0].length - 1);
        this.incrementLine(1);
        return true;
      }
    },
    comment: function() {
      var captures;
      if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
        this.consume(captures[0].length);
        var tok = this.tok("comment", captures[2]);
        tok.buffer = captures[1] != "-";
        this.interpolationAllowed = tok.buffer;
        this.tokens.push(tok);
        this.incrementColumn(captures[0].length);
        this.tokEnd(tok);
        this.callLexerFunction("pipelessText");
        return true;
      }
    },
    interpolation: function() {
      if (/^#\{/.test(this.input)) {
        var match = this.bracketExpression(1);
        this.consume(match.end + 1);
        var tok = this.tok("interpolation", match.src);
        this.tokens.push(tok);
        this.incrementColumn(2);
        this.assertExpression(match.src);
        var splitted = match.src.split("\n");
        var lines = splitted.length - 1;
        this.incrementLine(lines);
        this.incrementColumn(splitted[lines].length + 1);
        this.tokEnd(tok);
        return true;
      }
    },
    tag: function() {
      var captures;
      if (captures = /^(\w(?:[-:\w]*\w)?)/.exec(this.input)) {
        var tok, name = captures[1], len = captures[0].length;
        this.consume(len);
        tok = this.tok("tag", name);
        this.tokens.push(tok);
        this.incrementColumn(len);
        this.tokEnd(tok);
        return true;
      }
    },
    filter: function(opts) {
      var tok = this.scan(/^:([\w\-]+)/, "filter");
      var inInclude = opts && opts.inInclude;
      if (tok) {
        this.tokens.push(tok);
        this.incrementColumn(tok.val.length);
        this.tokEnd(tok);
        this.callLexerFunction("attrs");
        if (!inInclude) {
          this.interpolationAllowed = false;
          this.callLexerFunction("pipelessText");
        }
        return true;
      }
    },
    doctype: function() {
      var node = this.scanEndOfLine(/^doctype *([^\n]*)/, "doctype");
      if (node) {
        this.tokens.push(this.tokEnd(node));
        return true;
      }
    },
    id: function() {
      var tok = this.scan(/^#([\w-]+)/, "id");
      if (tok) {
        this.tokens.push(tok);
        this.incrementColumn(tok.val.length);
        this.tokEnd(tok);
        return true;
      }
      if (/^#/.test(this.input)) {
        this.error("INVALID_ID", '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid ID.');
      }
    },
    className: function() {
      var tok = this.scan(/^\.([_a-z0-9\-]*[_a-z][_a-z0-9\-]*)/i, "class");
      if (tok) {
        this.tokens.push(tok);
        this.incrementColumn(tok.val.length);
        this.tokEnd(tok);
        return true;
      }
      if (/^\.[_a-z0-9\-]+/i.test(this.input)) {
        this.error("INVALID_CLASS_NAME", "Class names must contain at least one letter or underscore.");
      }
      if (/^\./.test(this.input)) {
        this.error("INVALID_CLASS_NAME", '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid class name.  Class names can only contain "_", "-", a-z and 0-9, and must contain at least one of "_", or a-z');
      }
    },
    endInterpolation: function() {
      if (this.interpolated && this.input[0] === "]") {
        this.input = this.input.substr(1);
        this.ended = true;
        return true;
      }
    },
    addText: function(type, value, prefix, escaped) {
      var tok;
      if (value + prefix === "")
        return;
      prefix = prefix || "";
      escaped = escaped || 0;
      var indexOfEnd = this.interpolated ? value.indexOf("]") : -1;
      var indexOfStart = this.interpolationAllowed ? value.indexOf("#[") : -1;
      var indexOfEscaped = this.interpolationAllowed ? value.indexOf("\\#[") : -1;
      var matchOfStringInterp = /(\\)?([#!]){((?:.|\n)*)$/.exec(value);
      var indexOfStringInterp = this.interpolationAllowed && matchOfStringInterp ? matchOfStringInterp.index : Infinity;
      if (indexOfEnd === -1)
        indexOfEnd = Infinity;
      if (indexOfStart === -1)
        indexOfStart = Infinity;
      if (indexOfEscaped === -1)
        indexOfEscaped = Infinity;
      if (indexOfEscaped !== Infinity && indexOfEscaped < indexOfEnd && indexOfEscaped < indexOfStart && indexOfEscaped < indexOfStringInterp) {
        prefix = prefix + value.substring(0, indexOfEscaped) + "#[";
        return this.addText(type, value.substring(indexOfEscaped + 3), prefix, escaped + 1);
      }
      if (indexOfStart !== Infinity && indexOfStart < indexOfEnd && indexOfStart < indexOfEscaped && indexOfStart < indexOfStringInterp) {
        tok = this.tok(type, prefix + value.substring(0, indexOfStart));
        this.incrementColumn(prefix.length + indexOfStart + escaped);
        this.tokens.push(this.tokEnd(tok));
        tok = this.tok("start-pug-interpolation");
        this.incrementColumn(2);
        this.tokens.push(this.tokEnd(tok));
        var child = new this.constructor(value.substr(indexOfStart + 2), {
          filename: this.filename,
          interpolated: true,
          startingLine: this.lineno,
          startingColumn: this.colno,
          plugins: this.plugins
        });
        var interpolated;
        try {
          interpolated = child.getTokens();
        } catch (ex) {
          if (ex.code && /^PUG:/.test(ex.code)) {
            this.colno = ex.column;
            this.error(ex.code.substr(4), ex.msg);
          }
          throw ex;
        }
        this.colno = child.colno;
        this.tokens = this.tokens.concat(interpolated);
        tok = this.tok("end-pug-interpolation");
        this.incrementColumn(1);
        this.tokens.push(this.tokEnd(tok));
        this.addText(type, child.input);
        return;
      }
      if (indexOfEnd !== Infinity && indexOfEnd < indexOfStart && indexOfEnd < indexOfEscaped && indexOfEnd < indexOfStringInterp) {
        if (prefix + value.substring(0, indexOfEnd)) {
          this.addText(type, value.substring(0, indexOfEnd), prefix);
        }
        this.ended = true;
        this.input = value.substr(value.indexOf("]") + 1) + this.input;
        return;
      }
      if (indexOfStringInterp !== Infinity) {
        if (matchOfStringInterp[1]) {
          prefix = prefix + value.substring(0, indexOfStringInterp) + matchOfStringInterp[2] + "{";
          return this.addText(type, value.substring(indexOfStringInterp + 3), prefix, escaped + 1);
        }
        var before = value.substr(0, indexOfStringInterp);
        if (prefix || before) {
          before = prefix + before;
          tok = this.tok(type, before);
          this.incrementColumn(before.length + escaped);
          this.tokens.push(this.tokEnd(tok));
        }
        var rest = matchOfStringInterp[3];
        var range;
        tok = this.tok("interpolated-code");
        this.incrementColumn(2);
        try {
          range = characterParser.parseUntil(rest, "}");
        } catch (ex) {
          if (ex.index !== undefined) {
            this.incrementColumn(ex.index);
          }
          if (ex.code === "CHARACTER_PARSER:END_OF_STRING_REACHED") {
            this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
          } else if (ex.code === "CHARACTER_PARSER:MISMATCHED_BRACKET") {
            this.error("BRACKET_MISMATCH", ex.message);
          } else {
            throw ex;
          }
        }
        tok.mustEscape = matchOfStringInterp[2] === "#";
        tok.buffer = true;
        tok.val = range.src;
        this.assertExpression(range.src);
        if (range.end + 1 < rest.length) {
          rest = rest.substr(range.end + 1);
          this.incrementColumn(range.end + 1);
          this.tokens.push(this.tokEnd(tok));
          this.addText(type, rest);
        } else {
          this.incrementColumn(rest.length);
          this.tokens.push(this.tokEnd(tok));
        }
        return;
      }
      value = prefix + value;
      tok = this.tok(type, value);
      this.incrementColumn(value.length + escaped);
      this.tokens.push(this.tokEnd(tok));
    },
    text: function() {
      var tok = this.scan(/^(?:\| ?| )([^\n]+)/, "text") || this.scan(/^( )/, "text") || this.scan(/^\|( ?)/, "text");
      if (tok) {
        this.addText("text", tok.val);
        return true;
      }
    },
    textHtml: function() {
      var tok = this.scan(/^(<[^\n]*)/, "text-html");
      if (tok) {
        this.addText("text-html", tok.val);
        return true;
      }
    },
    dot: function() {
      var tok;
      if (tok = this.scanEndOfLine(/^\./, "dot")) {
        this.tokens.push(this.tokEnd(tok));
        this.callLexerFunction("pipelessText");
        return true;
      }
    },
    extends: function() {
      var tok = this.scan(/^extends?(?= |$|\n)/, "extends");
      if (tok) {
        this.tokens.push(this.tokEnd(tok));
        if (!this.callLexerFunction("path")) {
          this.error("NO_EXTENDS_PATH", "missing path for extends");
        }
        return true;
      }
      if (this.scan(/^extends?\b/)) {
        this.error("MALFORMED_EXTENDS", "malformed extends");
      }
    },
    prepend: function() {
      var captures;
      if (captures = /^(?:block +)?prepend +([^\n]+)/.exec(this.input)) {
        var name = captures[1].trim();
        var comment = "";
        if (name.indexOf("//") !== -1) {
          comment = "//" + name.split("//").slice(1).join("//");
          name = name.split("//")[0].trim();
        }
        if (!name)
          return;
        var tok = this.tok("block", name);
        var len = captures[0].length - comment.length;
        while (this.whitespaceRe.test(this.input.charAt(len - 1)))
          len--;
        this.incrementColumn(len);
        tok.mode = "prepend";
        this.tokens.push(this.tokEnd(tok));
        this.consume(captures[0].length - comment.length);
        this.incrementColumn(captures[0].length - comment.length - len);
        return true;
      }
    },
    append: function() {
      var captures;
      if (captures = /^(?:block +)?append +([^\n]+)/.exec(this.input)) {
        var name = captures[1].trim();
        var comment = "";
        if (name.indexOf("//") !== -1) {
          comment = "//" + name.split("//").slice(1).join("//");
          name = name.split("//")[0].trim();
        }
        if (!name)
          return;
        var tok = this.tok("block", name);
        var len = captures[0].length - comment.length;
        while (this.whitespaceRe.test(this.input.charAt(len - 1)))
          len--;
        this.incrementColumn(len);
        tok.mode = "append";
        this.tokens.push(this.tokEnd(tok));
        this.consume(captures[0].length - comment.length);
        this.incrementColumn(captures[0].length - comment.length - len);
        return true;
      }
    },
    block: function() {
      var captures;
      if (captures = /^block +([^\n]+)/.exec(this.input)) {
        var name = captures[1].trim();
        var comment = "";
        if (name.indexOf("//") !== -1) {
          comment = "//" + name.split("//").slice(1).join("//");
          name = name.split("//")[0].trim();
        }
        if (!name)
          return;
        var tok = this.tok("block", name);
        var len = captures[0].length - comment.length;
        while (this.whitespaceRe.test(this.input.charAt(len - 1)))
          len--;
        this.incrementColumn(len);
        tok.mode = "replace";
        this.tokens.push(this.tokEnd(tok));
        this.consume(captures[0].length - comment.length);
        this.incrementColumn(captures[0].length - comment.length - len);
        return true;
      }
    },
    mixinBlock: function() {
      var tok;
      if (tok = this.scanEndOfLine(/^block/, "mixin-block")) {
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    yield: function() {
      var tok = this.scanEndOfLine(/^yield/, "yield");
      if (tok) {
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    include: function() {
      var tok = this.scan(/^include(?=:| |$|\n)/, "include");
      if (tok) {
        this.tokens.push(this.tokEnd(tok));
        while (this.callLexerFunction("filter", { inInclude: true }))
          ;
        if (!this.callLexerFunction("path")) {
          if (/^[^ \n]+/.test(this.input)) {
            this.fail();
          } else {
            this.error("NO_INCLUDE_PATH", "missing path for include");
          }
        }
        return true;
      }
      if (this.scan(/^include\b/)) {
        this.error("MALFORMED_INCLUDE", "malformed include");
      }
    },
    path: function() {
      var tok = this.scanEndOfLine(/^ ([^\n]+)/, "path");
      if (tok && (tok.val = tok.val.trim())) {
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    case: function() {
      var tok = this.scanEndOfLine(/^case +([^\n]+)/, "case");
      if (tok) {
        this.incrementColumn(-tok.val.length);
        this.assertExpression(tok.val);
        this.incrementColumn(tok.val.length);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
      if (this.scan(/^case\b/)) {
        this.error("NO_CASE_EXPRESSION", "missing expression for case");
      }
    },
    when: function() {
      var tok = this.scanEndOfLine(/^when +([^:\n]+)/, "when");
      if (tok) {
        var parser = characterParser(tok.val);
        while (parser.isNesting() || parser.isString()) {
          var rest = /:([^:\n]+)/.exec(this.input);
          if (!rest)
            break;
          tok.val += rest[0];
          this.consume(rest[0].length);
          this.incrementColumn(rest[0].length);
          parser = characterParser(tok.val);
        }
        this.incrementColumn(-tok.val.length);
        this.assertExpression(tok.val);
        this.incrementColumn(tok.val.length);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
      if (this.scan(/^when\b/)) {
        this.error("NO_WHEN_EXPRESSION", "missing expression for when");
      }
    },
    default: function() {
      var tok = this.scanEndOfLine(/^default/, "default");
      if (tok) {
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
      if (this.scan(/^default\b/)) {
        this.error("DEFAULT_WITH_EXPRESSION", "default should not have an expression");
      }
    },
    call: function() {
      var tok, captures, increment;
      if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
        if (captures[3]) {
          increment = captures[0].length;
          this.consume(increment);
          tok = this.tok("call", captures[3]);
        } else {
          var match = this.bracketExpression(2 + captures[1].length);
          increment = match.end + 1;
          this.consume(increment);
          this.assertExpression(match.src);
          tok = this.tok("call", "#{" + match.src + "}");
        }
        this.incrementColumn(increment);
        tok.args = null;
        if (captures = /^ *\(/.exec(this.input)) {
          var range = this.bracketExpression(captures[0].length - 1);
          if (!/^\s*[-\w]+ *=/.test(range.src)) {
            this.incrementColumn(1);
            this.consume(range.end + 1);
            tok.args = range.src;
            this.assertExpression("[" + tok.args + "]");
            for (var i = 0;i <= tok.args.length; i++) {
              if (tok.args[i] === "\n") {
                this.incrementLine(1);
              } else {
                this.incrementColumn(1);
              }
            }
          }
        }
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    mixin: function() {
      var captures;
      if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
        this.consume(captures[0].length);
        var tok = this.tok("mixin", captures[1]);
        tok.args = captures[2] || null;
        this.incrementColumn(captures[0].length);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    conditional: function() {
      var captures;
      if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
        this.consume(captures[0].length);
        var type = captures[1].replace(/ /g, "-");
        var js = captures[2] && captures[2].trim();
        var tok = this.tok(type, js);
        this.incrementColumn(captures[0].length - js.length);
        switch (type) {
          case "if":
          case "else-if":
            this.assertExpression(js);
            break;
          case "unless":
            this.assertExpression(js);
            tok.val = "!(" + js + ")";
            tok.type = "if";
            break;
          case "else":
            if (js) {
              this.error("ELSE_CONDITION", "`else` cannot have a condition, perhaps you meant `else if`");
            }
            break;
        }
        this.incrementColumn(js.length);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    while: function() {
      var captures, tok;
      if (captures = /^while +([^\n]+)/.exec(this.input)) {
        this.consume(captures[0].length);
        this.assertExpression(captures[1]);
        tok = this.tok("while", captures[1]);
        this.incrementColumn(captures[0].length);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
      if (this.scan(/^while\b/)) {
        this.error("NO_WHILE_EXPRESSION", "missing expression for while");
      }
    },
    each: function() {
      var captures;
      if (captures = /^(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
        this.consume(captures[0].length);
        var tok = this.tok("each", captures[1]);
        tok.key = captures[2] || null;
        this.incrementColumn(captures[0].length - captures[3].length);
        this.assertExpression(captures[3]);
        tok.code = captures[3];
        this.incrementColumn(captures[3].length);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
      const name = /^each\b/.exec(this.input) ? "each" : "for";
      if (this.scan(/^(?:each|for)\b/)) {
        this.error("MALFORMED_EACH", "This `" + name + "` has a syntax error. `" + name + "` statements should be of the form: `" + name + " VARIABLE_NAME of JS_EXPRESSION`");
      }
      if (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +in +([^\n]+)/.exec(this.input)) {
        this.error("MALFORMED_EACH", 'Pug each and for should no longer be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
      }
    },
    eachOf: function() {
      var captures;
      if (captures = /^(?:each|for) (.*?) of *([^\n]+)/.exec(this.input)) {
        this.consume(captures[0].length);
        var tok = this.tok("eachOf", captures[1]);
        tok.value = captures[1];
        this.incrementColumn(captures[0].length - captures[2].length);
        this.assertExpression(captures[2]);
        tok.code = captures[2];
        this.incrementColumn(captures[2].length);
        this.tokens.push(this.tokEnd(tok));
        if (!(/^[a-zA-Z_$][\w$]*$/.test(tok.value.trim()) || /^\[ *[a-zA-Z_$][\w$]* *\, *[a-zA-Z_$][\w$]* *\]$/.test(tok.value.trim()))) {
          this.error("MALFORMED_EACH_OF_LVAL", "The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).");
        }
        return true;
      }
      if (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +of +([^\n]+)/.exec(this.input)) {
        this.error("MALFORMED_EACH", 'Pug each and for should not be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
      }
    },
    code: function() {
      var captures;
      if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
        var flags = captures[1];
        var code = captures[2];
        var shortened = 0;
        if (this.interpolated) {
          var parsed;
          try {
            parsed = characterParser.parseUntil(code, "]");
          } catch (err) {
            if (err.index !== undefined) {
              this.incrementColumn(captures[0].length - code.length + err.index);
            }
            if (err.code === "CHARACTER_PARSER:END_OF_STRING_REACHED") {
              this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
            } else if (err.code === "CHARACTER_PARSER:MISMATCHED_BRACKET") {
              this.error("BRACKET_MISMATCH", err.message);
            } else {
              throw err;
            }
          }
          shortened = code.length - parsed.end;
          code = parsed.src;
        }
        var consumed = captures[0].length - shortened;
        this.consume(consumed);
        var tok = this.tok("code", code);
        tok.mustEscape = flags.charAt(0) === "=";
        tok.buffer = flags.charAt(0) === "=" || flags.charAt(1) === "=";
        this.incrementColumn(captures[0].length - captures[2].length);
        if (tok.buffer)
          this.assertExpression(code);
        this.tokens.push(tok);
        this.incrementColumn(code.length);
        this.tokEnd(tok);
        return true;
      }
    },
    blockCode: function() {
      var tok;
      if (tok = this.scanEndOfLine(/^-/, "blockcode")) {
        this.tokens.push(this.tokEnd(tok));
        this.interpolationAllowed = false;
        this.callLexerFunction("pipelessText");
        return true;
      }
    },
    attribute: function(str) {
      var quote = "";
      var quoteRe = /['"]/;
      var key = "";
      var i;
      for (i = 0;i < str.length; i++) {
        if (!this.whitespaceRe.test(str[i]))
          break;
        if (str[i] === "\n") {
          this.incrementLine(1);
        } else {
          this.incrementColumn(1);
        }
      }
      if (i === str.length) {
        return "";
      }
      var tok = this.tok("attribute");
      if (quoteRe.test(str[i])) {
        quote = str[i];
        this.incrementColumn(1);
        i++;
      }
      for (;i < str.length; i++) {
        if (quote) {
          if (str[i] === quote) {
            this.incrementColumn(1);
            i++;
            break;
          }
        } else {
          if (this.whitespaceRe.test(str[i]) || str[i] === "!" || str[i] === "=" || str[i] === ",") {
            break;
          }
        }
        key += str[i];
        if (str[i] === "\n") {
          this.incrementLine(1);
        } else {
          this.incrementColumn(1);
        }
      }
      tok.name = key;
      var valueResponse = this.attributeValue(str.substr(i));
      if (valueResponse.val) {
        tok.val = valueResponse.val;
        tok.mustEscape = valueResponse.mustEscape;
      } else {
        tok.val = true;
        tok.mustEscape = true;
      }
      str = valueResponse.remainingSource;
      this.tokens.push(this.tokEnd(tok));
      for (i = 0;i < str.length; i++) {
        if (!this.whitespaceRe.test(str[i])) {
          break;
        }
        if (str[i] === "\n") {
          this.incrementLine(1);
        } else {
          this.incrementColumn(1);
        }
      }
      if (str[i] === ",") {
        this.incrementColumn(1);
        i++;
      }
      return str.substr(i);
    },
    attributeValue: function(str) {
      var quoteRe = /['"]/;
      var val = "";
      var done, i, x;
      var escapeAttr = true;
      var state = characterParser.defaultState();
      var col = this.colno;
      var line = this.lineno;
      for (i = 0;i < str.length; i++) {
        if (!this.whitespaceRe.test(str[i]))
          break;
        if (str[i] === "\n") {
          line++;
          col = 1;
        } else {
          col++;
        }
      }
      if (i === str.length) {
        return { remainingSource: str };
      }
      if (str[i] === "!") {
        escapeAttr = false;
        col++;
        i++;
        if (str[i] !== "=")
          this.error("INVALID_KEY_CHARACTER", "Unexpected character " + str[i] + " expected `=`");
      }
      if (str[i] !== "=") {
        if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ",") {
          this.error("INVALID_KEY_CHARACTER", "Unexpected character " + str[0] + " expected `=`");
        } else {
          return { remainingSource: str };
        }
      }
      this.lineno = line;
      this.colno = col + 1;
      i++;
      for (;i < str.length; i++) {
        if (!this.whitespaceRe.test(str[i]))
          break;
        if (str[i] === "\n") {
          this.incrementLine(1);
        } else {
          this.incrementColumn(1);
        }
      }
      line = this.lineno;
      col = this.colno;
      for (;i < str.length; i++) {
        if (!(state.isNesting() || state.isString())) {
          if (this.whitespaceRe.test(str[i])) {
            done = false;
            for (x = i;x < str.length; x++) {
              if (!this.whitespaceRe.test(str[x])) {
                const isNotPunctuator = !characterParser.isPunctuator(str[x]);
                const isQuote = quoteRe.test(str[x]);
                const isColon = str[x] === ":";
                const isSpreadOperator = str[x] + str[x + 1] + str[x + 2] === "...";
                if ((isNotPunctuator || isQuote || isColon || isSpreadOperator) && this.assertExpression(val, true)) {
                  done = true;
                }
                break;
              }
            }
            if (done || x === str.length) {
              break;
            }
          }
          if (str[i] === "," && this.assertExpression(val, true)) {
            break;
          }
        }
        state = characterParser.parseChar(str[i], state);
        val += str[i];
        if (str[i] === "\n") {
          line++;
          col = 1;
        } else {
          col++;
        }
      }
      this.assertExpression(val);
      this.lineno = line;
      this.colno = col;
      return { val, mustEscape: escapeAttr, remainingSource: str.substr(i) };
    },
    attrs: function() {
      var tok;
      if (this.input.charAt(0) == "(") {
        tok = this.tok("start-attributes");
        var index = this.bracketExpression().end;
        var str = this.input.substr(1, index - 1);
        this.incrementColumn(1);
        this.tokens.push(this.tokEnd(tok));
        this.assertNestingCorrect(str);
        this.consume(index + 1);
        while (str) {
          str = this.attribute(str);
        }
        tok = this.tok("end-attributes");
        this.incrementColumn(1);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    attributesBlock: function() {
      if (/^&attributes\b/.test(this.input)) {
        var consumed = 11;
        this.consume(consumed);
        var tok = this.tok("&attributes");
        this.incrementColumn(consumed);
        var args = this.bracketExpression();
        consumed = args.end + 1;
        this.consume(consumed);
        tok.val = args.src;
        this.incrementColumn(consumed);
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    indent: function() {
      var captures = this.scanIndentation();
      var tok;
      if (captures) {
        var indents = captures[1].length;
        this.incrementLine(1);
        this.consume(indents + 1);
        if (this.input[0] == " " || this.input[0] == "\t") {
          this.error("INVALID_INDENTATION", "Invalid indentation, you can use tabs or spaces but not both");
        }
        if (this.input[0] == "\n") {
          this.interpolationAllowed = true;
          return this.tokEnd(this.tok("newline"));
        }
        if (indents < this.indentStack[0]) {
          var outdent_count = 0;
          while (this.indentStack[0] > indents) {
            if (this.indentStack[1] < indents) {
              this.error("INCONSISTENT_INDENTATION", "Inconsistent indentation. Expecting either " + this.indentStack[1] + " or " + this.indentStack[0] + " spaces/tabs.");
            }
            outdent_count++;
            this.indentStack.shift();
          }
          while (outdent_count--) {
            this.colno = 1;
            tok = this.tok("outdent");
            this.colno = this.indentStack[0] + 1;
            this.tokens.push(this.tokEnd(tok));
          }
        } else if (indents && indents != this.indentStack[0]) {
          tok = this.tok("indent", indents);
          this.colno = 1 + indents;
          this.tokens.push(this.tokEnd(tok));
          this.indentStack.unshift(indents);
        } else {
          tok = this.tok("newline");
          this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);
          this.tokens.push(this.tokEnd(tok));
        }
        this.interpolationAllowed = true;
        return true;
      }
    },
    pipelessText: function pipelessText(indents) {
      while (this.callLexerFunction("blank"))
        ;
      var captures = this.scanIndentation();
      indents = indents || captures && captures[1].length;
      if (indents > this.indentStack[0]) {
        this.tokens.push(this.tokEnd(this.tok("start-pipeless-text")));
        var tokens = [];
        var token_indent = [];
        var isMatch;
        var stringPtr = 0;
        do {
          var i = this.input.substr(stringPtr + 1).indexOf("\n");
          if (i == -1)
            i = this.input.length - stringPtr - 1;
          var str = this.input.substr(stringPtr + 1, i);
          var lineCaptures = this.indentRe.exec("\n" + str);
          var lineIndents = lineCaptures && lineCaptures[1].length;
          isMatch = lineIndents >= indents;
          token_indent.push(isMatch);
          isMatch = isMatch || !str.trim();
          if (isMatch) {
            stringPtr += str.length + 1;
            tokens.push(str.substr(indents));
          } else if (lineIndents > this.indentStack[0]) {
            this.tokens.pop();
            return pipelessText.call(this, lineCaptures[1].length);
          }
        } while (this.input.length - stringPtr && isMatch);
        this.consume(stringPtr);
        while (this.input.length === 0 && tokens[tokens.length - 1] === "")
          tokens.pop();
        tokens.forEach(function(token, i2) {
          var tok;
          this.incrementLine(1);
          if (i2 !== 0)
            tok = this.tok("newline");
          if (token_indent[i2])
            this.incrementColumn(indents);
          if (tok)
            this.tokens.push(this.tokEnd(tok));
          this.addText("text", token);
        }.bind(this));
        this.tokens.push(this.tokEnd(this.tok("end-pipeless-text")));
        return true;
      }
    },
    slash: function() {
      var tok = this.scan(/^\//, "slash");
      if (tok) {
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    colon: function() {
      var tok = this.scan(/^: +/, ":");
      if (tok) {
        this.tokens.push(this.tokEnd(tok));
        return true;
      }
    },
    fail: function() {
      this.error("UNEXPECTED_TEXT", 'unexpected text "' + this.input.substr(0, 5) + '"');
    },
    callLexerFunction: function(func) {
      var rest = [];
      for (var i = 1;i < arguments.length; i++) {
        rest.push(arguments[i]);
      }
      var pluginArgs = [this].concat(rest);
      for (var i = 0;i < this.plugins.length; i++) {
        var plugin = this.plugins[i];
        if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) {
          return true;
        }
      }
      return this[func].apply(this, rest);
    },
    advance: function() {
      return this.callLexerFunction("blank") || this.callLexerFunction("eos") || this.callLexerFunction("endInterpolation") || this.callLexerFunction("yield") || this.callLexerFunction("doctype") || this.callLexerFunction("interpolation") || this.callLexerFunction("case") || this.callLexerFunction("when") || this.callLexerFunction("default") || this.callLexerFunction("extends") || this.callLexerFunction("append") || this.callLexerFunction("prepend") || this.callLexerFunction("block") || this.callLexerFunction("mixinBlock") || this.callLexerFunction("include") || this.callLexerFunction("mixin") || this.callLexerFunction("call") || this.callLexerFunction("conditional") || this.callLexerFunction("eachOf") || this.callLexerFunction("each") || this.callLexerFunction("while") || this.callLexerFunction("tag") || this.callLexerFunction("filter") || this.callLexerFunction("blockCode") || this.callLexerFunction("code") || this.callLexerFunction("id") || this.callLexerFunction("dot") || this.callLexerFunction("className") || this.callLexerFunction("attrs") || this.callLexerFunction("attributesBlock") || this.callLexerFunction("indent") || this.callLexerFunction("text") || this.callLexerFunction("textHtml") || this.callLexerFunction("comment") || this.callLexerFunction("slash") || this.callLexerFunction("colon") || this.fail();
    },
    getTokens: function() {
      while (!this.ended) {
        this.callLexerFunction("advance");
      }
      return this.tokens;
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-strip-comments/index.js
var require_pug_strip_comments = __commonJS((exports, module) => {
  var unexpectedToken = function(type, occasion, filename, line) {
    var msg = "`" + type + "` encountered when " + occasion;
    throw error("UNEXPECTED_TOKEN", msg, { filename, line });
  };
  var stripComments = function(input, options) {
    options = options || {};
    var stripUnbuffered = options.stripUnbuffered !== false;
    var stripBuffered = options.stripBuffered === true;
    var filename = options.filename;
    var out = [];
    var inComment = false;
    var inPipelessText = false;
    return input.filter(function(tok) {
      switch (tok.type) {
        case "comment":
          if (inComment) {
            unexpectedToken("comment", "already in a comment", filename, tok.line);
          } else {
            inComment = tok.buffer ? stripBuffered : stripUnbuffered;
            return !inComment;
          }
        case "start-pipeless-text":
          if (!inComment)
            return true;
          if (inPipelessText) {
            unexpectedToken("start-pipeless-text", "already in pipeless text mode", filename, tok.line);
          }
          inPipelessText = true;
          return false;
        case "end-pipeless-text":
          if (!inComment)
            return true;
          if (!inPipelessText) {
            unexpectedToken("end-pipeless-text", "not in pipeless text mode", filename, tok.line);
          }
          inPipelessText = false;
          inComment = false;
          return false;
        case "text":
          return !inComment;
        default:
          if (inPipelessText)
            return false;
          inComment = false;
          return true;
      }
    });
  };
  var error = require_pug_error();
  module.exports = stripComments;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-parser@6.0.0/node_modules/token-stream/index.js
var require_token_stream = __commonJS((exports, module) => {
  var TokenStream = function(tokens) {
    if (!Array.isArray(tokens)) {
      throw new TypeError("tokens must be passed to TokenStream as an array.");
    }
    this._tokens = tokens;
  };
  module.exports = TokenStream;
  TokenStream.prototype.lookahead = function(index) {
    if (this._tokens.length <= index) {
      throw new Error("Cannot read past the end of a stream");
    }
    return this._tokens[index];
  };
  TokenStream.prototype.peek = function() {
    if (this._tokens.length === 0) {
      throw new Error("Cannot read past the end of a stream");
    }
    return this._tokens[0];
  };
  TokenStream.prototype.advance = function() {
    if (this._tokens.length === 0) {
      throw new Error("Cannot read past the end of a stream");
    }
    return this._tokens.shift();
  };
  TokenStream.prototype.defer = function(token) {
    this._tokens.unshift(token);
  };
});

// node_modules/.pnpm/pug-parser@6.0.0/node_modules/pug-parser/lib/inline-tags.js
var require_inline_tags = __commonJS((exports, module) => {
  module.exports = [
    "a",
    "abbr",
    "acronym",
    "b",
    "br",
    "code",
    "em",
    "font",
    "i",
    "img",
    "ins",
    "kbd",
    "map",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup"
  ];
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-parser/index.js
var require_pug_parser = __commonJS((exports, module) => {
  var parse = function(tokens, options) {
    var parser = new Parser(tokens, options);
    var ast = parser.parse();
    return JSON.parse(JSON.stringify(ast));
  };
  var Parser = function(tokens, options) {
    options = options || {};
    if (!Array.isArray(tokens)) {
      throw new Error('Expected tokens to be an Array but got "' + typeof tokens + '"');
    }
    if (typeof options !== "object") {
      throw new Error('Expected "options" to be an object but got "' + typeof options + '"');
    }
    this.tokens = new TokenStream(tokens);
    this.filename = options.filename;
    this.src = options.src;
    this.inMixin = 0;
    this.plugins = options.plugins || [];
  };
  var assert = __require("assert");
  var TokenStream = require_token_stream();
  var error = require_pug_error();
  var inlineTags = require_inline_tags();
  module.exports = parse;
  module.exports.Parser = Parser;
  Parser.prototype = {
    constructor: Parser,
    error: function(code, message, token) {
      var err = error(code, message, {
        line: token.loc.start.line,
        column: token.loc.start.column,
        filename: this.filename,
        src: this.src
      });
      throw err;
    },
    advance: function() {
      return this.tokens.advance();
    },
    peek: function() {
      return this.tokens.peek();
    },
    lookahead: function(n) {
      return this.tokens.lookahead(n);
    },
    parse: function() {
      var block = this.emptyBlock(0);
      while (this.peek().type != "eos") {
        if (this.peek().type == "newline") {
          this.advance();
        } else if (this.peek().type == "text-html") {
          block.nodes = block.nodes.concat(this.parseTextHtml());
        } else {
          var expr = this.parseExpr();
          if (expr) {
            if (expr.type === "Block") {
              block.nodes = block.nodes.concat(expr.nodes);
            } else {
              block.nodes.push(expr);
            }
          }
        }
      }
      return block;
    },
    expect: function(type) {
      if (this.peek().type === type) {
        return this.advance();
      } else {
        this.error("INVALID_TOKEN", 'expected "' + type + '", but got "' + this.peek().type + '"', this.peek());
      }
    },
    accept: function(type) {
      if (this.peek().type === type) {
        return this.advance();
      }
    },
    initBlock: function(line, nodes) {
      if ((line | 0) !== line)
        throw new Error("`line` is not an integer");
      if (!Array.isArray(nodes))
        throw new Error("`nodes` is not an array");
      return {
        type: "Block",
        nodes,
        line,
        filename: this.filename
      };
    },
    emptyBlock: function(line) {
      return this.initBlock(line, []);
    },
    runPlugin: function(context, tok) {
      var rest = [this];
      for (var i = 2;i < arguments.length; i++) {
        rest.push(arguments[i]);
      }
      var pluginContext;
      for (var i = 0;i < this.plugins.length; i++) {
        var plugin = this.plugins[i];
        if (plugin[context] && plugin[context][tok.type]) {
          if (pluginContext)
            throw new Error("Multiple plugin handlers found for context " + JSON.stringify(context) + ", token type " + JSON.stringify(tok.type));
          pluginContext = plugin[context];
        }
      }
      if (pluginContext)
        return pluginContext[tok.type].apply(pluginContext, rest);
    },
    parseExpr: function() {
      switch (this.peek().type) {
        case "tag":
          return this.parseTag();
        case "mixin":
          return this.parseMixin();
        case "block":
          return this.parseBlock();
        case "mixin-block":
          return this.parseMixinBlock();
        case "case":
          return this.parseCase();
        case "extends":
          return this.parseExtends();
        case "include":
          return this.parseInclude();
        case "doctype":
          return this.parseDoctype();
        case "filter":
          return this.parseFilter();
        case "comment":
          return this.parseComment();
        case "text":
        case "interpolated-code":
        case "start-pug-interpolation":
          return this.parseText({ block: true });
        case "text-html":
          return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());
        case "dot":
          return this.parseDot();
        case "each":
          return this.parseEach();
        case "eachOf":
          return this.parseEachOf();
        case "code":
          return this.parseCode();
        case "blockcode":
          return this.parseBlockCode();
        case "if":
          return this.parseConditional();
        case "while":
          return this.parseWhile();
        case "call":
          return this.parseCall();
        case "interpolation":
          return this.parseInterpolation();
        case "yield":
          return this.parseYield();
        case "id":
        case "class":
          if (!this.peek().loc.start)
            debugger;
          this.tokens.defer({
            type: "tag",
            val: "div",
            loc: this.peek().loc,
            filename: this.filename
          });
          return this.parseExpr();
        default:
          var pluginResult = this.runPlugin("expressionTokens", this.peek());
          if (pluginResult)
            return pluginResult;
          this.error("INVALID_TOKEN", 'unexpected token "' + this.peek().type + '"', this.peek());
      }
    },
    parseDot: function() {
      this.advance();
      return this.parseTextBlock();
    },
    parseText: function(options) {
      var tags = [];
      var lineno = this.peek().loc.start.line;
      var nextTok = this.peek();
      loop:
        while (true) {
          switch (nextTok.type) {
            case "text":
              var tok = this.advance();
              tags.push({
                type: "Text",
                val: tok.val,
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename
              });
              break;
            case "interpolated-code":
              var tok = this.advance();
              tags.push({
                type: "Code",
                val: tok.val,
                buffer: tok.buffer,
                mustEscape: tok.mustEscape !== false,
                isInline: true,
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename
              });
              break;
            case "newline":
              if (!options || !options.block)
                break loop;
              var tok = this.advance();
              var nextType = this.peek().type;
              if (nextType === "text" || nextType === "interpolated-code") {
                tags.push({
                  type: "Text",
                  val: "\n",
                  line: tok.loc.start.line,
                  column: tok.loc.start.column,
                  filename: this.filename
                });
              }
              break;
            case "start-pug-interpolation":
              this.advance();
              tags.push(this.parseExpr());
              this.expect("end-pug-interpolation");
              break;
            default:
              var pluginResult = this.runPlugin("textTokens", nextTok, tags);
              if (pluginResult)
                break;
              break loop;
          }
          nextTok = this.peek();
        }
      if (tags.length === 1)
        return tags[0];
      else
        return this.initBlock(lineno, tags);
    },
    parseTextHtml: function() {
      var nodes = [];
      var currentNode = null;
      loop:
        while (true) {
          switch (this.peek().type) {
            case "text-html":
              var text = this.advance();
              if (!currentNode) {
                currentNode = {
                  type: "Text",
                  val: text.val,
                  filename: this.filename,
                  line: text.loc.start.line,
                  column: text.loc.start.column,
                  isHtml: true
                };
                nodes.push(currentNode);
              } else {
                currentNode.val += "\n" + text.val;
              }
              break;
            case "indent":
              var block = this.block();
              block.nodes.forEach(function(node) {
                if (node.isHtml) {
                  if (!currentNode) {
                    currentNode = node;
                    nodes.push(currentNode);
                  } else {
                    currentNode.val += "\n" + node.val;
                  }
                } else {
                  currentNode = null;
                  nodes.push(node);
                }
              });
              break;
            case "code":
              currentNode = null;
              nodes.push(this.parseCode(true));
              break;
            case "newline":
              this.advance();
              break;
            default:
              break loop;
          }
        }
      return nodes;
    },
    parseBlockExpansion: function() {
      var tok = this.accept(":");
      if (tok) {
        var expr = this.parseExpr();
        return expr.type === "Block" ? expr : this.initBlock(tok.loc.start.line, [expr]);
      } else {
        return this.block();
      }
    },
    parseCase: function() {
      var tok = this.expect("case");
      var node = {
        type: "Case",
        expr: tok.val,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      var block = this.emptyBlock(tok.loc.start.line + 1);
      this.expect("indent");
      while (this.peek().type != "outdent") {
        switch (this.peek().type) {
          case "comment":
          case "newline":
            this.advance();
            break;
          case "when":
            block.nodes.push(this.parseWhen());
            break;
          case "default":
            block.nodes.push(this.parseDefault());
            break;
          default:
            var pluginResult = this.runPlugin("caseTokens", this.peek(), block);
            if (pluginResult)
              break;
            this.error("INVALID_TOKEN", 'Unexpected token "' + this.peek().type + '", expected "when", "default" or "newline"', this.peek());
        }
      }
      this.expect("outdent");
      node.block = block;
      return node;
    },
    parseWhen: function() {
      var tok = this.expect("when");
      if (this.peek().type !== "newline") {
        return {
          type: "When",
          expr: tok.val,
          block: this.parseBlockExpansion(),
          debug: false,
          line: tok.loc.start.line,
          column: tok.loc.start.column,
          filename: this.filename
        };
      } else {
        return {
          type: "When",
          expr: tok.val,
          debug: false,
          line: tok.loc.start.line,
          column: tok.loc.start.column,
          filename: this.filename
        };
      }
    },
    parseDefault: function() {
      var tok = this.expect("default");
      return {
        type: "When",
        expr: "default",
        block: this.parseBlockExpansion(),
        debug: false,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
    },
    parseCode: function(noBlock) {
      var tok = this.expect("code");
      assert(typeof tok.mustEscape === "boolean", "Please update to the newest version of pug-lexer.");
      var node = {
        type: "Code",
        val: tok.val,
        buffer: tok.buffer,
        mustEscape: tok.mustEscape !== false,
        isInline: !!noBlock,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      if (node.val.match(/^ *else/))
        node.debug = false;
      if (noBlock)
        return node;
      var block;
      block = this.peek().type == "indent";
      if (block) {
        if (tok.buffer) {
          this.error("BLOCK_IN_BUFFERED_CODE", "Buffered code cannot have a block attached to it", this.peek());
        }
        node.block = this.block();
      }
      return node;
    },
    parseConditional: function() {
      var tok = this.expect("if");
      var node = {
        type: "Conditional",
        test: tok.val,
        consequent: this.emptyBlock(tok.loc.start.line),
        alternate: null,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      if (this.peek().type == "indent") {
        node.consequent = this.block();
      }
      var currentNode = node;
      while (true) {
        if (this.peek().type === "newline") {
          this.expect("newline");
        } else if (this.peek().type === "else-if") {
          tok = this.expect("else-if");
          currentNode = currentNode.alternate = {
            type: "Conditional",
            test: tok.val,
            consequent: this.emptyBlock(tok.loc.start.line),
            alternate: null,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
          };
          if (this.peek().type == "indent") {
            currentNode.consequent = this.block();
          }
        } else if (this.peek().type === "else") {
          this.expect("else");
          if (this.peek().type === "indent") {
            currentNode.alternate = this.block();
          }
          break;
        } else {
          break;
        }
      }
      return node;
    },
    parseWhile: function() {
      var tok = this.expect("while");
      var node = {
        type: "While",
        test: tok.val,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      if (this.peek().type == "indent") {
        node.block = this.block();
      } else {
        node.block = this.emptyBlock(tok.loc.start.line);
      }
      return node;
    },
    parseBlockCode: function() {
      var tok = this.expect("blockcode");
      var line = tok.loc.start.line;
      var column = tok.loc.start.column;
      var body = this.peek();
      var text = "";
      if (body.type === "start-pipeless-text") {
        this.advance();
        while (this.peek().type !== "end-pipeless-text") {
          tok = this.advance();
          switch (tok.type) {
            case "text":
              text += tok.val;
              break;
            case "newline":
              text += "\n";
              break;
            default:
              var pluginResult = this.runPlugin("blockCodeTokens", tok, tok);
              if (pluginResult) {
                text += pluginResult;
                break;
              }
              this.error("INVALID_TOKEN", "Unexpected token type: " + tok.type, tok);
          }
        }
        this.advance();
      }
      return {
        type: "Code",
        val: text,
        buffer: false,
        mustEscape: false,
        isInline: false,
        line,
        column,
        filename: this.filename
      };
    },
    parseComment: function() {
      var tok = this.expect("comment");
      var block;
      if (block = this.parseTextBlock()) {
        return {
          type: "BlockComment",
          val: tok.val,
          block,
          buffer: tok.buffer,
          line: tok.loc.start.line,
          column: tok.loc.start.column,
          filename: this.filename
        };
      } else {
        return {
          type: "Comment",
          val: tok.val,
          buffer: tok.buffer,
          line: tok.loc.start.line,
          column: tok.loc.start.column,
          filename: this.filename
        };
      }
    },
    parseDoctype: function() {
      var tok = this.expect("doctype");
      return {
        type: "Doctype",
        val: tok.val,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
    },
    parseIncludeFilter: function() {
      var tok = this.expect("filter");
      var attrs = [];
      if (this.peek().type === "start-attributes") {
        attrs = this.attrs();
      }
      return {
        type: "IncludeFilter",
        name: tok.val,
        attrs,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
    },
    parseFilter: function() {
      var tok = this.expect("filter");
      var block, attrs = [];
      if (this.peek().type === "start-attributes") {
        attrs = this.attrs();
      }
      if (this.peek().type === "text") {
        var textToken = this.advance();
        block = this.initBlock(textToken.loc.start.line, [
          {
            type: "Text",
            val: textToken.val,
            line: textToken.loc.start.line,
            column: textToken.loc.start.column,
            filename: this.filename
          }
        ]);
      } else if (this.peek().type === "filter") {
        block = this.initBlock(tok.loc.start.line, [this.parseFilter()]);
      } else {
        block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);
      }
      return {
        type: "Filter",
        name: tok.val,
        block,
        attrs,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
    },
    parseEach: function() {
      var tok = this.expect("each");
      var node = {
        type: "Each",
        obj: tok.code,
        val: tok.val,
        key: tok.key,
        block: this.block(),
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      if (this.peek().type == "else") {
        this.advance();
        node.alternate = this.block();
      }
      return node;
    },
    parseEachOf: function() {
      var tok = this.expect("eachOf");
      var node = {
        type: "EachOf",
        obj: tok.code,
        val: tok.val,
        block: this.block(),
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      return node;
    },
    parseExtends: function() {
      var tok = this.expect("extends");
      var path = this.expect("path");
      return {
        type: "Extends",
        file: {
          type: "FileReference",
          path: path.val.trim(),
          line: path.loc.start.line,
          column: path.loc.start.column,
          filename: this.filename
        },
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
    },
    parseBlock: function() {
      var tok = this.expect("block");
      var node = this.peek().type == "indent" ? this.block() : this.emptyBlock(tok.loc.start.line);
      node.type = "NamedBlock";
      node.name = tok.val.trim();
      node.mode = tok.mode;
      node.line = tok.loc.start.line;
      node.column = tok.loc.start.column;
      return node;
    },
    parseMixinBlock: function() {
      var tok = this.expect("mixin-block");
      if (!this.inMixin) {
        this.error("BLOCK_OUTISDE_MIXIN", "Anonymous blocks are not allowed unless they are part of a mixin.", tok);
      }
      return {
        type: "MixinBlock",
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
    },
    parseYield: function() {
      var tok = this.expect("yield");
      return {
        type: "YieldBlock",
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
    },
    parseInclude: function() {
      var tok = this.expect("include");
      var node = {
        type: "Include",
        file: {
          type: "FileReference",
          filename: this.filename
        },
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      var filters = [];
      while (this.peek().type === "filter") {
        filters.push(this.parseIncludeFilter());
      }
      var path = this.expect("path");
      node.file.path = path.val.trim();
      node.file.line = path.loc.start.line;
      node.file.column = path.loc.start.column;
      if ((/\.jade$/.test(node.file.path) || /\.pug$/.test(node.file.path)) && !filters.length) {
        node.block = this.peek().type == "indent" ? this.block() : this.emptyBlock(tok.loc.start.line);
        if (/\.jade$/.test(node.file.path)) {
          console.warn(this.filename + ", line " + tok.loc.start.line + ':\nThe .jade extension is deprecated, use .pug for "' + node.file.path + '".');
        }
      } else {
        node.type = "RawInclude";
        node.filters = filters;
        if (this.peek().type === "indent") {
          this.error("RAW_INCLUDE_BLOCK", "Raw inclusion cannot contain a block", this.peek());
        }
      }
      return node;
    },
    parseCall: function() {
      var tok = this.expect("call");
      var name = tok.val;
      var args = tok.args;
      var mixin = {
        type: "Mixin",
        name,
        args,
        block: this.emptyBlock(tok.loc.start.line),
        call: true,
        attrs: [],
        attributeBlocks: [],
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      this.tag(mixin);
      if (mixin.code) {
        mixin.block.nodes.push(mixin.code);
        delete mixin.code;
      }
      if (mixin.block.nodes.length === 0)
        mixin.block = null;
      return mixin;
    },
    parseMixin: function() {
      var tok = this.expect("mixin");
      var name = tok.val;
      var args = tok.args;
      if (this.peek().type == "indent") {
        this.inMixin++;
        var mixin = {
          type: "Mixin",
          name,
          args,
          block: this.block(),
          call: false,
          line: tok.loc.start.line,
          column: tok.loc.start.column,
          filename: this.filename
        };
        this.inMixin--;
        return mixin;
      } else {
        this.error("MIXIN_WITHOUT_BODY", "Mixin " + name + " declared without body", tok);
      }
    },
    parseTextBlock: function() {
      var tok = this.accept("start-pipeless-text");
      if (!tok)
        return;
      var block = this.emptyBlock(tok.loc.start.line);
      while (this.peek().type !== "end-pipeless-text") {
        var tok = this.advance();
        switch (tok.type) {
          case "text":
            block.nodes.push({
              type: "Text",
              val: tok.val,
              line: tok.loc.start.line,
              column: tok.loc.start.column,
              filename: this.filename
            });
            break;
          case "newline":
            block.nodes.push({
              type: "Text",
              val: "\n",
              line: tok.loc.start.line,
              column: tok.loc.start.column,
              filename: this.filename
            });
            break;
          case "start-pug-interpolation":
            block.nodes.push(this.parseExpr());
            this.expect("end-pug-interpolation");
            break;
          case "interpolated-code":
            block.nodes.push({
              type: "Code",
              val: tok.val,
              buffer: tok.buffer,
              mustEscape: tok.mustEscape !== false,
              isInline: true,
              line: tok.loc.start.line,
              column: tok.loc.start.column,
              filename: this.filename
            });
            break;
          default:
            var pluginResult = this.runPlugin("textBlockTokens", tok, block, tok);
            if (pluginResult)
              break;
            this.error("INVALID_TOKEN", "Unexpected token type: " + tok.type, tok);
        }
      }
      this.advance();
      return block;
    },
    block: function() {
      var tok = this.expect("indent");
      var block = this.emptyBlock(tok.loc.start.line);
      while (this.peek().type != "outdent") {
        if (this.peek().type == "newline") {
          this.advance();
        } else if (this.peek().type == "text-html") {
          block.nodes = block.nodes.concat(this.parseTextHtml());
        } else {
          var expr = this.parseExpr();
          if (expr.type === "Block") {
            block.nodes = block.nodes.concat(expr.nodes);
          } else {
            block.nodes.push(expr);
          }
        }
      }
      this.expect("outdent");
      return block;
    },
    parseInterpolation: function() {
      var tok = this.advance();
      var tag = {
        type: "InterpolatedTag",
        expr: tok.val,
        selfClosing: false,
        block: this.emptyBlock(tok.loc.start.line),
        attrs: [],
        attributeBlocks: [],
        isInline: false,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      return this.tag(tag, { selfClosingAllowed: true });
    },
    parseTag: function() {
      var tok = this.advance();
      var tag = {
        type: "Tag",
        name: tok.val,
        selfClosing: false,
        block: this.emptyBlock(tok.loc.start.line),
        attrs: [],
        attributeBlocks: [],
        isInline: inlineTags.indexOf(tok.val) !== -1,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename
      };
      return this.tag(tag, { selfClosingAllowed: true });
    },
    tag: function(tag, options) {
      var seenAttrs = false;
      var attributeNames = [];
      var selfClosingAllowed = options && options.selfClosingAllowed;
      out:
        while (true) {
          switch (this.peek().type) {
            case "id":
            case "class":
              var tok = this.advance();
              if (tok.type === "id") {
                if (attributeNames.indexOf("id") !== -1) {
                  this.error("DUPLICATE_ID", 'Duplicate attribute "id" is not allowed.', tok);
                }
                attributeNames.push("id");
              }
              tag.attrs.push({
                name: tok.type,
                val: "'" + tok.val + "'",
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename,
                mustEscape: false
              });
              continue;
            case "start-attributes":
              if (seenAttrs) {
                console.warn(this.filename + ", line " + this.peek().loc.start.line + ":\nYou should not have pug tags with multiple attributes.");
              }
              seenAttrs = true;
              tag.attrs = tag.attrs.concat(this.attrs(attributeNames));
              continue;
            case "&attributes":
              var tok = this.advance();
              tag.attributeBlocks.push({
                type: "AttributeBlock",
                val: tok.val,
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename
              });
              break;
            default:
              var pluginResult = this.runPlugin("tagAttributeTokens", this.peek(), tag, attributeNames);
              if (pluginResult)
                break;
              break out;
          }
        }
      if (this.peek().type == "dot") {
        tag.textOnly = true;
        this.advance();
      }
      switch (this.peek().type) {
        case "text":
        case "interpolated-code":
          var text = this.parseText();
          if (text.type === "Block") {
            tag.block.nodes.push.apply(tag.block.nodes, text.nodes);
          } else {
            tag.block.nodes.push(text);
          }
          break;
        case "code":
          tag.block.nodes.push(this.parseCode(true));
          break;
        case ":":
          this.advance();
          var expr = this.parseExpr();
          tag.block = expr.type === "Block" ? expr : this.initBlock(tag.line, [expr]);
          break;
        case "newline":
        case "indent":
        case "outdent":
        case "eos":
        case "start-pipeless-text":
        case "end-pug-interpolation":
          break;
        case "slash":
          if (selfClosingAllowed) {
            this.advance();
            tag.selfClosing = true;
            break;
          }
        default:
          var pluginResult = this.runPlugin("tagTokens", this.peek(), tag, options);
          if (pluginResult)
            break;
          this.error("INVALID_TOKEN", "Unexpected token `" + this.peek().type + "` expected `text`, `interpolated-code`, `code`, `:`" + (selfClosingAllowed ? ", `slash`" : "") + ", `newline` or `eos`", this.peek());
      }
      while (this.peek().type == "newline")
        this.advance();
      if (tag.textOnly) {
        tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);
      } else if (this.peek().type == "indent") {
        var block = this.block();
        for (var i = 0, len = block.nodes.length;i < len; ++i) {
          tag.block.nodes.push(block.nodes[i]);
        }
      }
      return tag;
    },
    attrs: function(attributeNames) {
      this.expect("start-attributes");
      var attrs = [];
      var tok = this.advance();
      while (tok.type === "attribute") {
        if (tok.name !== "class" && attributeNames) {
          if (attributeNames.indexOf(tok.name) !== -1) {
            this.error("DUPLICATE_ATTRIBUTE", 'Duplicate attribute "' + tok.name + '" is not allowed.', tok);
          }
          attributeNames.push(tok.name);
        }
        attrs.push({
          name: tok.name,
          val: tok.val,
          line: tok.loc.start.line,
          column: tok.loc.start.column,
          filename: this.filename,
          mustEscape: tok.mustEscape !== false
        });
        tok = this.advance();
      }
      this.tokens.defer(tok);
      this.expect("end-attributes");
      return attrs;
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-load@3.0.0/node_modules/pug-walk/index.js
var require_pug_walk = __commonJS((exports, module) => {
  var walkAST = function(ast, before, after, options) {
    if (after && typeof after === "object" && typeof options === "undefined") {
      options = after;
      after = null;
    }
    options = options || { includeDependencies: false };
    var parents = options.parents = options.parents || [];
    var replace = function replace(replacement) {
      if (Array.isArray(replacement) && !replace.arrayAllowed) {
        throw new Error("replace() can only be called with an array if the last parent is a Block or NamedBlock");
      }
      ast = replacement;
    };
    replace.arrayAllowed = parents[0] && (/^(Named)?Block$/.test(parents[0].type) || parents[0].type === "RawInclude" && ast.type === "IncludeFilter");
    if (before) {
      var result = before(ast, replace);
      if (result === false) {
        return ast;
      } else if (Array.isArray(ast)) {
        return walkAndMergeNodes(ast);
      }
    }
    parents.unshift(ast);
    switch (ast.type) {
      case "NamedBlock":
      case "Block":
        ast.nodes = walkAndMergeNodes(ast.nodes);
        break;
      case "Case":
      case "Filter":
      case "Mixin":
      case "Tag":
      case "InterpolatedTag":
      case "When":
      case "Code":
      case "While":
        if (ast.block) {
          ast.block = walkAST(ast.block, before, after, options);
        }
        break;
      case "Each":
        if (ast.block) {
          ast.block = walkAST(ast.block, before, after, options);
        }
        if (ast.alternate) {
          ast.alternate = walkAST(ast.alternate, before, after, options);
        }
        break;
      case "EachOf":
        if (ast.block) {
          ast.block = walkAST(ast.block, before, after, options);
        }
        break;
      case "Conditional":
        if (ast.consequent) {
          ast.consequent = walkAST(ast.consequent, before, after, options);
        }
        if (ast.alternate) {
          ast.alternate = walkAST(ast.alternate, before, after, options);
        }
        break;
      case "Include":
        walkAST(ast.block, before, after, options);
        walkAST(ast.file, before, after, options);
        break;
      case "Extends":
        walkAST(ast.file, before, after, options);
        break;
      case "RawInclude":
        ast.filters = walkAndMergeNodes(ast.filters);
        walkAST(ast.file, before, after, options);
        break;
      case "Attrs":
      case "BlockComment":
      case "Comment":
      case "Doctype":
      case "IncludeFilter":
      case "MixinBlock":
      case "YieldBlock":
      case "Text":
        break;
      case "FileReference":
        if (options.includeDependencies && ast.ast) {
          walkAST(ast.ast, before, after, options);
        }
        break;
      default:
        throw new Error("Unexpected node type " + ast.type);
        break;
    }
    parents.shift();
    after && after(ast, replace);
    return ast;
    function walkAndMergeNodes(nodes) {
      return nodes.reduce(function(nodes2, node) {
        var result2 = walkAST(node, before, after, options);
        if (Array.isArray(result2)) {
          return nodes2.concat(result2);
        } else {
          return nodes2.concat([result2]);
        }
      }, []);
    }
  };
  module.exports = walkAST;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-load/index.js
var require_pug_load = __commonJS((exports, module) => {
  var load = function(ast, options) {
    options = getOptions(options);
    ast = JSON.parse(JSON.stringify(ast));
    return walk(ast, function(node) {
      if (node.str === undefined) {
        if (node.type === "Include" || node.type === "RawInclude" || node.type === "Extends") {
          var file = node.file;
          if (file.type !== "FileReference") {
            throw new Error('Expected file.type to be "FileReference"');
          }
          var path2, str, raw;
          try {
            path2 = options.resolve(file.path, file.filename, options);
            file.fullPath = path2;
            raw = options.read(path2, options);
            str = raw.toString("utf8");
          } catch (ex) {
            ex.message += "\n    at " + node.filename + " line " + node.line;
            throw ex;
          }
          file.str = str;
          file.raw = raw;
          if (node.type === "Extends" || node.type === "Include") {
            file.ast = load.string(str, assign({}, options, {
              filename: path2
            }));
          }
        }
      }
    });
  };
  var getOptions = function(options) {
    load.validateOptions(options);
    return assign({
      resolve: load.resolve,
      read: load.read
    }, options);
  };
  var fs = __require("fs");
  var path = __require("path");
  var walk = require_pug_walk();
  var assign = require_object_assign();
  module.exports = load;
  load.string = function loadString(src, options) {
    options = assign(getOptions(options), {
      src
    });
    var tokens = options.lex(src, options);
    var ast = options.parse(tokens, options);
    return load(ast, options);
  };
  load.file = function loadFile(filename, options) {
    options = assign(getOptions(options), {
      filename
    });
    var str = options.read(filename).toString("utf8");
    return load.string(str, options);
  };
  load.resolve = function resolve(filename, source, options) {
    filename = filename.trim();
    if (filename[0] !== "/" && !source)
      throw new Error('the "filename" option is required to use includes and extends with "relative" paths');
    if (filename[0] === "/" && !options.basedir)
      throw new Error('the "basedir" option is required to use includes and extends with "absolute" paths');
    filename = path.join(filename[0] === "/" ? options.basedir : path.dirname(source.trim()), filename);
    return filename;
  };
  load.read = function read(filename, options) {
    return fs.readFileSync(filename);
  };
  load.validateOptions = function validateOptions(options) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    if (typeof options.lex !== "function") {
      throw new TypeError("options.lex must be a function");
    }
    if (typeof options.parse !== "function") {
      throw new TypeError("options.parse must be a function");
    }
    if (options.resolve && typeof options.resolve !== "function") {
      throw new TypeError("options.resolve must be a function");
    }
    if (options.read && typeof options.read !== "function") {
      throw new TypeError("options.read must be a function");
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/promise@7.3.1/node_modules/asap/raw.js
var require_raw = __commonJS((exports, module) => {
  var rawAsap = function(task) {
    if (!queue.length) {
      requestFlush();
      flushing = true;
    }
    queue[queue.length] = task;
  };
  var flush = function() {
    while (index < queue.length) {
      var currentIndex = index;
      index = index + 1;
      queue[currentIndex].call();
      if (index > capacity) {
        for (var scan = 0, newLength = queue.length - index;scan < newLength; scan++) {
          queue[scan] = queue[scan + index];
        }
        queue.length -= index;
        index = 0;
      }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
  };
  var requestFlush = function() {
    var parentDomain = process.domain;
    if (parentDomain) {
      if (!domain) {
        domain = __require("domain");
      }
      domain.active = process.domain = null;
    }
    if (flushing && hasSetImmediate) {
      setImmediate(flush);
    } else {
      process.nextTick(flush);
    }
    if (parentDomain) {
      domain.active = process.domain = parentDomain;
    }
  };
  var domain;
  var hasSetImmediate = typeof setImmediate === "function";
  module.exports = rawAsap;
  var queue = [];
  var flushing = false;
  var index = 0;
  var capacity = 1024;
  rawAsap.requestFlush = requestFlush;
});

// node_modules/.pnpm/promise@7.3.1/node_modules/promise/lib/core.js
var require_core = __commonJS((exports, module) => {
  var noop = function() {
  };
  var getThen = function(obj) {
    try {
      return obj.then;
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  };
  var tryCallOne = function(fn, a) {
    try {
      return fn(a);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  };
  var tryCallTwo = function(fn, a, b) {
    try {
      fn(a, b);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  };
  var Promise2 = function(fn) {
    if (typeof this !== "object") {
      throw new TypeError("Promises must be constructed via new");
    }
    if (typeof fn !== "function") {
      throw new TypeError("Promise constructor\'s argument is not a function");
    }
    this._40 = 0;
    this._65 = 0;
    this._55 = null;
    this._72 = null;
    if (fn === noop)
      return;
    doResolve(fn, this);
  };
  var safeThen = function(self2, onFulfilled, onRejected) {
    return new self2.constructor(function(resolve2, reject2) {
      var res = new Promise2(noop);
      res.then(resolve2, reject2);
      handle(self2, new Handler(onFulfilled, onRejected, res));
    });
  };
  var handle = function(self2, deferred) {
    while (self2._65 === 3) {
      self2 = self2._55;
    }
    if (Promise2._37) {
      Promise2._37(self2);
    }
    if (self2._65 === 0) {
      if (self2._40 === 0) {
        self2._40 = 1;
        self2._72 = deferred;
        return;
      }
      if (self2._40 === 1) {
        self2._40 = 2;
        self2._72 = [self2._72, deferred];
        return;
      }
      self2._72.push(deferred);
      return;
    }
    handleResolved(self2, deferred);
  };
  var handleResolved = function(self2, deferred) {
    asap(function() {
      var cb = self2._65 === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        if (self2._65 === 1) {
          resolve(deferred.promise, self2._55);
        } else {
          reject(deferred.promise, self2._55);
        }
        return;
      }
      var ret = tryCallOne(cb, self2._55);
      if (ret === IS_ERROR) {
        reject(deferred.promise, LAST_ERROR);
      } else {
        resolve(deferred.promise, ret);
      }
    });
  };
  var resolve = function(self2, newValue) {
    if (newValue === self2) {
      return reject(self2, new TypeError("A promise cannot be resolved with itself."));
    }
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then = getThen(newValue);
      if (then === IS_ERROR) {
        return reject(self2, LAST_ERROR);
      }
      if (then === self2.then && newValue instanceof Promise2) {
        self2._65 = 3;
        self2._55 = newValue;
        finale(self2);
        return;
      } else if (typeof then === "function") {
        doResolve(then.bind(newValue), self2);
        return;
      }
    }
    self2._65 = 1;
    self2._55 = newValue;
    finale(self2);
  };
  var reject = function(self2, newValue) {
    self2._65 = 2;
    self2._55 = newValue;
    if (Promise2._87) {
      Promise2._87(self2, newValue);
    }
    finale(self2);
  };
  var finale = function(self2) {
    if (self2._40 === 1) {
      handle(self2, self2._72);
      self2._72 = null;
    }
    if (self2._40 === 2) {
      for (var i = 0;i < self2._72.length; i++) {
        handle(self2, self2._72[i]);
      }
      self2._72 = null;
    }
  };
  var Handler = function(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
    this.onRejected = typeof onRejected === "function" ? onRejected : null;
    this.promise = promise;
  };
  var doResolve = function(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function(value) {
      if (done)
        return;
      done = true;
      resolve(promise, value);
    }, function(reason) {
      if (done)
        return;
      done = true;
      reject(promise, reason);
    });
    if (!done && res === IS_ERROR) {
      done = true;
      reject(promise, LAST_ERROR);
    }
  };
  var asap = require_raw();
  var LAST_ERROR = null;
  var IS_ERROR = {};
  module.exports = Promise2;
  Promise2._37 = null;
  Promise2._87 = null;
  Promise2._61 = noop;
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (this.constructor !== Promise2) {
      return safeThen(this, onFulfilled, onRejected);
    }
    var res = new Promise2(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
  };
});

// node_modules/.pnpm/promise@7.3.1/node_modules/promise/lib/done.js
var require_done = __commonJS((exports, module) => {
  var Promise2 = require_core();
  module.exports = Promise2;
  Promise2.prototype.done = function(onFulfilled, onRejected) {
    var self2 = arguments.length ? this.then.apply(this, arguments) : this;
    self2.then(null, function(err) {
      setTimeout(function() {
        throw err;
      }, 0);
    });
  };
});

// node_modules/.pnpm/promise@7.3.1/node_modules/promise/lib/finally.js
var require_finally = __commonJS((exports, module) => {
  var Promise2 = require_core();
  module.exports = Promise2;
  Promise2.prototype["finally"] = function(f) {
    return this.then(function(value) {
      return Promise2.resolve(f()).then(function() {
        return value;
      });
    }, function(err) {
      return Promise2.resolve(f()).then(function() {
        throw err;
      });
    });
  };
});

// node_modules/.pnpm/promise@7.3.1/node_modules/promise/lib/es6-extensions.js
var require_es6_extensions = __commonJS((exports, module) => {
  var valuePromise = function(value) {
    var p = new Promise2(Promise2._61);
    p._65 = 1;
    p._55 = value;
    return p;
  };
  var Promise2 = require_core();
  module.exports = Promise2;
  var TRUE = valuePromise(true);
  var FALSE = valuePromise(false);
  var NULL = valuePromise(null);
  var UNDEFINED = valuePromise(undefined);
  var ZERO = valuePromise(0);
  var EMPTYSTRING = valuePromise("");
  Promise2.resolve = function(value) {
    if (value instanceof Promise2)
      return value;
    if (value === null)
      return NULL;
    if (value === undefined)
      return UNDEFINED;
    if (value === true)
      return TRUE;
    if (value === false)
      return FALSE;
    if (value === 0)
      return ZERO;
    if (value === "")
      return EMPTYSTRING;
    if (typeof value === "object" || typeof value === "function") {
      try {
        var then = value.then;
        if (typeof then === "function") {
          return new Promise2(then.bind(value));
        }
      } catch (ex) {
        return new Promise2(function(resolve, reject) {
          reject(ex);
        });
      }
    }
    return valuePromise(value);
  };
  Promise2.all = function(arr) {
    var args = Array.prototype.slice.call(arr);
    return new Promise2(function(resolve, reject) {
      if (args.length === 0)
        return resolve([]);
      var remaining = args.length;
      function res(i2, val) {
        if (val && (typeof val === "object" || typeof val === "function")) {
          if (val instanceof Promise2 && val.then === Promise2.prototype.then) {
            while (val._65 === 3) {
              val = val._55;
            }
            if (val._65 === 1)
              return res(i2, val._55);
            if (val._65 === 2)
              reject(val._55);
            val.then(function(val2) {
              res(i2, val2);
            }, reject);
            return;
          } else {
            var then = val.then;
            if (typeof then === "function") {
              var p = new Promise2(then.bind(val));
              p.then(function(val2) {
                res(i2, val2);
              }, reject);
              return;
            }
          }
        }
        args[i2] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      }
      for (var i = 0;i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };
  Promise2.reject = function(value) {
    return new Promise2(function(resolve, reject) {
      reject(value);
    });
  };
  Promise2.race = function(values) {
    return new Promise2(function(resolve, reject) {
      values.forEach(function(value) {
        Promise2.resolve(value).then(resolve, reject);
      });
    });
  };
  Promise2.prototype["catch"] = function(onRejected) {
    return this.then(null, onRejected);
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/promise@7.3.1/node_modules/asap/asap.js
var require_asap = __commonJS((exports, module) => {
  var asap = function(task) {
    var rawTask;
    if (freeTasks.length) {
      rawTask = freeTasks.pop();
    } else {
      rawTask = new RawTask;
    }
    rawTask.task = task;
    rawTask.domain = process.domain;
    rawAsap(rawTask);
  };
  var RawTask = function() {
    this.task = null;
    this.domain = null;
  };
  var rawAsap = require_raw();
  var freeTasks = [];
  module.exports = asap;
  RawTask.prototype.call = function() {
    if (this.domain) {
      this.domain.enter();
    }
    var threw = true;
    try {
      this.task.call();
      threw = false;
      if (this.domain) {
        this.domain.exit();
      }
    } finally {
      if (threw) {
        rawAsap.requestFlush();
      }
      this.task = null;
      this.domain = null;
      freeTasks.push(this);
    }
  };
});

// node_modules/.pnpm/promise@7.3.1/node_modules/promise/lib/node-extensions.js
var require_node_extensions = __commonJS((exports, module) => {
  var denodeifyWithCount = function(fn, argumentCount) {
    var args = [];
    for (var i = 0;i < argumentCount; i++) {
      args.push("a" + i);
    }
    var body = [
      "return function (" + args.join(",") + ") {",
      "var self = this;",
      "return new Promise(function (rs, rj) {",
      "var res = fn.call(",
      ["self"].concat(args).concat([callbackFn]).join(","),
      ");",
      "if (res &&",
      '(typeof res === "object" || typeof res === "function") &&',
      'typeof res.then === "function"',
      ") {rs(res);}",
      "});",
      "};"
    ].join("");
    return Function(["Promise", "fn"], body)(Promise2, fn);
  };
  var denodeifyWithoutCount = function(fn) {
    var fnLength = Math.max(fn.length - 1, 3);
    var args = [];
    for (var i = 0;i < fnLength; i++) {
      args.push("a" + i);
    }
    var body = [
      "return function (" + args.join(",") + ") {",
      "var self = this;",
      "var args;",
      "var argLength = arguments.length;",
      "if (arguments.length > " + fnLength + ") {",
      "args = new Array(arguments.length + 1);",
      "for (var i = 0; i < arguments.length; i++) {",
      "args[i] = arguments[i];",
      "}",
      "}",
      "return new Promise(function (rs, rj) {",
      "var cb = " + callbackFn + ";",
      "var res;",
      "switch (argLength) {",
      args.concat(["extra"]).map(function(_, index) {
        return "case " + index + ":res = fn.call(" + ["self"].concat(args.slice(0, index)).concat("cb").join(",") + ");break;";
      }).join(""),
      "default:",
      "args[argLength] = cb;",
      "res = fn.apply(self, args);",
      "}",
      "if (res &&",
      '(typeof res === "object" || typeof res === "function") &&',
      'typeof res.then === "function"',
      ") {rs(res);}",
      "});",
      "};"
    ].join("");
    return Function(["Promise", "fn"], body)(Promise2, fn);
  };
  var Promise2 = require_core();
  var asap = require_asap();
  module.exports = Promise2;
  Promise2.denodeify = function(fn, argumentCount) {
    if (typeof argumentCount === "number" && argumentCount !== Infinity) {
      return denodeifyWithCount(fn, argumentCount);
    } else {
      return denodeifyWithoutCount(fn);
    }
  };
  var callbackFn = "function (err, res) {if (err) { rj(err); } else { rs(res); }}";
  Promise2.nodeify = function(fn) {
    return function() {
      var args = Array.prototype.slice.call(arguments);
      var callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
      var ctx = this;
      try {
        return fn.apply(this, arguments).nodeify(callback, ctx);
      } catch (ex) {
        if (callback === null || typeof callback == "undefined") {
          return new Promise2(function(resolve, reject) {
            reject(ex);
          });
        } else {
          asap(function() {
            callback.call(ctx, ex);
          });
        }
      }
    };
  };
  Promise2.prototype.nodeify = function(callback, ctx) {
    if (typeof callback != "function")
      return this;
    this.then(function(value) {
      asap(function() {
        callback.call(ctx, null, value);
      });
    }, function(err) {
      asap(function() {
        callback.call(ctx, err);
      });
    });
  };
});

// node_modules/.pnpm/promise@7.3.1/node_modules/promise/lib/synchronous.js
var require_synchronous = __commonJS((exports, module) => {
  var Promise2 = require_core();
  module.exports = Promise2;
  Promise2.enableSynchronous = function() {
    Promise2.prototype.isPending = function() {
      return this.getState() == 0;
    };
    Promise2.prototype.isFulfilled = function() {
      return this.getState() == 1;
    };
    Promise2.prototype.isRejected = function() {
      return this.getState() == 2;
    };
    Promise2.prototype.getValue = function() {
      if (this._65 === 3) {
        return this._55.getValue();
      }
      if (!this.isFulfilled()) {
        throw new Error("Cannot get a value of an unfulfilled promise.");
      }
      return this._55;
    };
    Promise2.prototype.getReason = function() {
      if (this._65 === 3) {
        return this._55.getReason();
      }
      if (!this.isRejected()) {
        throw new Error("Cannot get a rejection reason of a non-rejected promise.");
      }
      return this._55;
    };
    Promise2.prototype.getState = function() {
      if (this._65 === 3) {
        return this._55.getState();
      }
      if (this._65 === -1 || this._65 === -2) {
        return 0;
      }
      return this._65;
    };
  };
  Promise2.disableSynchronous = function() {
    Promise2.prototype.isPending = undefined;
    Promise2.prototype.isFulfilled = undefined;
    Promise2.prototype.isRejected = undefined;
    Promise2.prototype.getValue = undefined;
    Promise2.prototype.getReason = undefined;
    Promise2.prototype.getState = undefined;
  };
});

// node_modules/.pnpm/promise@7.3.1/node_modules/promise/lib/index.js
var require_lib = __commonJS((exports, module) => {
  module.exports = require_core();
  require_done();
  require_finally();
  require_es6_extensions();
  require_node_extensions();
  require_synchronous();
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/jstransformer@1.0.0/node_modules/is-promise/index.js
var require_is_promise = __commonJS((exports, module) => {
  var isPromise = function(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  };
  module.exports = isPromise;
  module.exports.default = isPromise;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-filters@4.0.0/node_modules/jstransformer/index.js
var require_jstransformer = __commonJS((exports, module) => {
  var normalizeFn = function(result) {
    if (typeof result === "function") {
      return { fn: result, dependencies: [] };
    } else if (result && typeof result === "object" && typeof result.fn === "function") {
      if ("dependencies" in result) {
        if (!Array.isArray(result.dependencies)) {
          throw new Error("Result should have a dependencies property that is an array");
        }
      } else {
        result.dependencies = [];
      }
      return result;
    } else {
      throw new Error("Invalid result object from transform.");
    }
  };
  var normalizeFnAsync = function(result, cb) {
    return Promise2.resolve(result).then(function(result2) {
      if (result2 && isPromise(result2.fn)) {
        return result2.fn.then(function(fn) {
          result2.fn = fn;
          return result2;
        });
      }
      return result2;
    }).then(tr.normalizeFn).nodeify(cb);
  };
  var normalize = function(result) {
    if (typeof result === "string") {
      return { body: result, dependencies: [] };
    } else if (result && typeof result === "object" && typeof result.body === "string") {
      if ("dependencies" in result) {
        if (!Array.isArray(result.dependencies)) {
          throw new Error("Result should have a dependencies property that is an array");
        }
      } else {
        result.dependencies = [];
      }
      return result;
    } else {
      throw new Error("Invalid result object from transform.");
    }
  };
  var normalizeAsync = function(result, cb) {
    return Promise2.resolve(result).then(function(result2) {
      if (result2 && isPromise(result2.body)) {
        return result2.body.then(function(body) {
          result2.body = body;
          return result2;
        });
      }
      return result2;
    }).then(tr.normalize).nodeify(cb);
  };
  var Transformer = function(tr2) {
    assert(tr2, "Transformer must be an object");
    assert(typeof tr2.name === "string", "Transformer must have a name");
    assert(typeof tr2.outputFormat === "string", "Transformer must have an output format");
    assert([
      "compile",
      "compileAsync",
      "compileFile",
      "compileFileAsync",
      "compileClient",
      "compileClientAsync",
      "compileFileClient",
      "compileFileClientAsync",
      "render",
      "renderAsync",
      "renderFile",
      "renderFileAsync"
    ].some(function(method) {
      return typeof tr2[method] === "function";
    }), "Transformer must implement at least one of the potential methods.");
    this._tr = tr2;
    this.name = this._tr.name;
    this.outputFormat = this._tr.outputFormat;
    this.inputFormats = this._tr.inputFormats || [this.name];
  };
  var fs = __require("fs");
  var assert = __require("assert");
  var Promise2 = require_lib();
  var isPromise = require_is_promise();
  var tr = module.exports = function(transformer) {
    return new Transformer(transformer);
  };
  tr.Transformer = Transformer;
  tr.normalizeFn = normalizeFn;
  tr.normalizeFnAsync = normalizeFnAsync;
  tr.normalize = normalize;
  tr.normalizeAsync = normalizeAsync;
  if (fs.readFile) {
    tr.readFile = Promise2.denodeify(fs.readFile);
    tr.readFileSync = fs.readFileSync;
  } else {
    tr.readFile = function() {
      throw new Error("fs.readFile unsupported");
    };
    tr.readFileSync = function() {
      throw new Error("fs.readFileSync unsupported");
    };
  }
  var fallbacks = {
    compile: ["compile", "render"],
    compileAsync: ["compileAsync", "compile", "render"],
    compileFile: ["compileFile", "compile", "renderFile", "render"],
    compileFileAsync: [
      "compileFileAsync",
      "compileFile",
      "compileAsync",
      "compile",
      "renderFile",
      "render"
    ],
    compileClient: ["compileClient"],
    compileClientAsync: ["compileClientAsync", "compileClient"],
    compileFileClient: ["compileFileClient", "compileClient"],
    compileFileClientAsync: [
      "compileFileClientAsync",
      "compileFileClient",
      "compileClientAsync",
      "compileClient"
    ],
    render: ["render", "compile"],
    renderAsync: ["renderAsync", "render", "compileAsync", "compile"],
    renderFile: ["renderFile", "render", "compileFile", "compile"],
    renderFileAsync: [
      "renderFileAsync",
      "renderFile",
      "renderAsync",
      "render",
      "compileFileAsync",
      "compileFile",
      "compileAsync",
      "compile"
    ]
  };
  Transformer.prototype._hasMethod = function(method) {
    return typeof this._tr[method] === "function";
  };
  Transformer.prototype.can = function(method) {
    return fallbacks[method].some(function(method2) {
      return this._hasMethod(method2);
    }.bind(this));
  };
  Transformer.prototype.compile = function(str, options) {
    if (!this._hasMethod("compile")) {
      if (this.can("render")) {
        var _this = this;
        return {
          fn: function(locals) {
            return tr.normalize(_this._tr.render(str, options, locals)).body;
          },
          dependencies: []
        };
      }
      if (this.can("compileAsync")) {
        throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
      } else if (this.can("compileFileAsync")) {
        throw new Error('The Transform "' + this.name + '" does not support compiling plain strings');
      } else {
        throw new Error('The Transform "' + this.name + '" does not support compilation');
      }
    }
    return tr.normalizeFn(this._tr.compile(str, options));
  };
  Transformer.prototype.compileAsync = function(str, options, cb) {
    if (!this.can("compileAsync")) {
      return Promise2.reject(new Error('The Transform "' + this.name + '" does not support compiling plain strings')).nodeify(cb);
    }
    if (this._hasMethod("compileAsync")) {
      return tr.normalizeFnAsync(this._tr.compileAsync(str, options), cb);
    } else {
      return tr.normalizeFnAsync(this.compile(str, options), cb);
    }
  };
  Transformer.prototype.compileFile = function(filename, options) {
    if (!this.can("compileFile")) {
      throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
    }
    if (this._hasMethod("compileFile")) {
      return tr.normalizeFn(this._tr.compileFile(filename, options));
    } else if (this._hasMethod("renderFile")) {
      return tr.normalizeFn(function(locals) {
        return tr.normalize(this._tr.renderFile(filename, options, locals)).body;
      }.bind(this));
    } else {
      if (!options)
        options = {};
      if (options.filename === undefined)
        options.filename = filename;
      return this.compile(tr.readFileSync(filename, "utf8"), options);
    }
  };
  Transformer.prototype.compileFileAsync = function(filename, options, cb) {
    if (!this.can("compileFileAsync")) {
      return Promise2.reject(new Error('The Transform "' + this.name + '" does not support compilation'));
    }
    if (this._hasMethod("compileFileAsync")) {
      return tr.normalizeFnAsync(this._tr.compileFileAsync(filename, options), cb);
    } else if (this._hasMethod("compileFile") || this._hasMethod("renderFile")) {
      return tr.normalizeFnAsync(this.compileFile(filename, options), cb);
    } else {
      if (!options)
        options = {};
      if (options.filename === undefined)
        options.filename = filename;
      return tr.normalizeFnAsync(tr.readFile(filename, "utf8").then(function(str) {
        if (this._hasMethod("compileAsync")) {
          return this._tr.compileAsync(str, options);
        } else {
          return this.compile(str, options);
        }
      }.bind(this)), cb);
    }
  };
  Transformer.prototype.compileClient = function(str, options) {
    if (!this.can("compileClient")) {
      if (this.can("compileClientAsync")) {
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
      } else if (this.can("compileFileClientAsync")) {
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.');
      } else {
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
      }
    }
    return tr.normalize(this._tr.compileClient(str, options));
  };
  Transformer.prototype.compileClientAsync = function(str, options, cb) {
    if (!this.can("compileClientAsync")) {
      if (this.can("compileFileClientAsync")) {
        return Promise2.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.')).nodeify(cb);
      } else {
        return Promise2.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(cb);
      }
    }
    if (this._hasMethod("compileClientAsync")) {
      return tr.normalizeAsync(this._tr.compileClientAsync(str, options), cb);
    } else {
      return tr.normalizeAsync(this._tr.compileClient(str, options), cb);
    }
  };
  Transformer.prototype.compileFileClient = function(filename, options) {
    if (!this.can("compileFileClient")) {
      if (this.can("compileFileClientAsync")) {
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
      } else {
        throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
      }
    }
    if (this._hasMethod("compileFileClient")) {
      return tr.normalize(this._tr.compileFileClient(filename, options));
    } else {
      if (!options)
        options = {};
      if (options.filename === undefined)
        options.filename = filename;
      return tr.normalize(this._tr.compileClient(tr.readFileSync(filename, "utf8"), options));
    }
  };
  Transformer.prototype.compileFileClientAsync = function(filename, options, cb) {
    if (!this.can("compileFileClientAsync")) {
      return Promise2.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(cb);
    }
    if (this._hasMethod("compileFileClientAsync")) {
      return tr.normalizeAsync(this._tr.compileFileClientAsync(filename, options), cb);
    } else if (this._hasMethod("compileFileClient")) {
      return tr.normalizeAsync(this._tr.compileFileClient(filename, options), cb);
    } else {
      if (!options)
        options = {};
      if (options.filename === undefined)
        options.filename = filename;
      return tr.normalizeAsync(tr.readFile(filename, "utf8").then(function(str) {
        if (this._hasMethod("compileClientAsync")) {
          return this._tr.compileClientAsync(str, options);
        } else {
          return this._tr.compileClient(str, options);
        }
      }.bind(this)), cb);
    }
  };
  Transformer.prototype.render = function(str, options, locals) {
    if (!this.can("render")) {
      if (this.can("renderAsync")) {
        throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
      } else if (this.can("renderFileAsync")) {
        throw new Error('The Transform "' + this.name + '" does not support rendering from a string.');
      } else {
        throw new Error('The Transform "' + this.name + '" does not support rendering');
      }
    }
    if (this._hasMethod("render")) {
      return tr.normalize(this._tr.render(str, options, locals));
    } else {
      var compiled = tr.normalizeFn(this._tr.compile(str, options));
      var body = compiled.fn(locals || options);
      if (typeof body !== "string") {
        throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
      }
      return tr.normalize({ body, dependencies: compiled.dependencies });
    }
  };
  Transformer.prototype.renderAsync = function(str, options, locals, cb) {
    if (typeof locals === "function") {
      cb = locals;
      locals = options;
    }
    if (!this.can("renderAsync")) {
      if (this.can("renderFileAsync")) {
        return Promise2.reject(new Error('The Transform "' + this.name + '" does not support rendering from a string.')).nodeify(cb);
      } else {
        return Promise2.reject(new Error('The Transform "' + this.name + '" does not support rendering')).nodeify(cb);
      }
    }
    if (this._hasMethod("renderAsync")) {
      return tr.normalizeAsync(this._tr.renderAsync(str, options, locals), cb);
    } else if (this._hasMethod("render")) {
      return tr.normalizeAsync(this._tr.render(str, options, locals), cb);
    } else {
      return tr.normalizeAsync(this.compileAsync(str, options).then(function(compiled) {
        return { body: compiled.fn(locals || options), dependencies: compiled.dependencies };
      }), cb);
    }
  };
  Transformer.prototype.renderFile = function(filename, options, locals) {
    if (!this.can("renderFile")) {
      throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
    }
    if (this._hasMethod("renderFile")) {
      return tr.normalize(this._tr.renderFile(filename, options, locals));
    } else if (this._hasMethod("render")) {
      if (!options)
        options = {};
      if (options.filename === undefined)
        options.filename = filename;
      return tr.normalize(this._tr.render(tr.readFileSync(filename, "utf8"), options, locals));
    } else {
      var compiled = this.compileFile(filename, options);
      return tr.normalize({ body: compiled.fn(locals || options), dependencies: compiled.dependencies });
    }
  };
  Transformer.prototype.renderFileAsync = function(filename, options, locals, cb) {
    if (!this.can("renderFileAsync")) {
      throw new Error('The Transform "' + this.name + '" does not support rendering.');
    }
    if (typeof locals === "function") {
      cb = locals;
      locals = options;
    }
    if (this._hasMethod("renderFileAsync")) {
      return tr.normalizeAsync(this._tr.renderFileAsync(filename, options, locals), cb);
    } else if (this._hasMethod("renderFile")) {
      return tr.normalizeAsync(this._tr.renderFile(filename, options, locals), cb);
    } else if (this._hasMethod("compile") || this._hasMethod("compileAsync") || this._hasMethod("compileFile") || this._hasMethod("compileFileAsync")) {
      return tr.normalizeAsync(this.compileFileAsync(filename, options).then(function(compiled) {
        return { body: compiled.fn(locals || options), dependencies: compiled.dependencies };
      }), cb);
    } else {
      if (!options)
        options = {};
      if (options.filename === undefined)
        options.filename = filename;
      return tr.normalizeAsync(tr.readFile(filename, "utf8").then(function(str) {
        return this.renderAsync(str, options, locals);
      }.bind(this)), cb);
    }
  };
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS((exports, module) => {
  var os = __require("os");
  module.exports = os.homedir || function homedir() {
    var home = process.env.HOME;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    if (process.platform === "win32") {
      return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }
    if (process.platform === "darwin") {
      return home || (user ? "/Users/" + user : null);
    }
    if (process.platform === "linux") {
      return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
    }
    return home || null;
  };
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  module.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/resolve@1.22.8/node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports, module) => {
  var win32SplitPath = function(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  };
  var posixSplitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };
  var isWindows = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows)
    module.exports = win32.parse;
  else
    module.exports = posix.parse;
  module.exports.posix = posix.parse;
  module.exports.win32 = win32.parse;
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports, module) => {
  var path = __require("path");
  var parse = path.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports, module) => {
  module.exports = function(x, opts) {
    return opts || {};
  };
});

// node_modules/.pnpm/is-core-module@2.13.1/node_modules/is-core-module/core.json
var require_core2 = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/resolve@1.22.8/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports, module) => {
  var specifierIncluded = function(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0;i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  };
  var matchesRange = function(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0;i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  };
  var versionIncluded = function(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0;i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  };
  var hasOwn = require_hasown();
  var data = require_core2();
  module.exports = function isCore(x, nodeVersion) {
    return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/async.js
var require_async = __commonJS((exports, module) => {
  var fs = __require("fs");
  var getHomedir = require_homedir();
  var path = __require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir, ".node_modules"),
      path.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg = JSON.parse(body);
          cb(null, pkg);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = path.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = undefined;
      }
      var exts = [""].concat(extensions);
      load(exts, x2, loadAsFilePackage);
      function load(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, undefined, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load([""].concat(extensions.slice()), path.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path.dirname(dir), cb2);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path.dirname(dir), cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb2(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path.join(x2, "index"), fpkg, cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                if (err4)
                  return cb2(err4);
                if (m)
                  return cb2(null, m, pkg2);
                if (!pkg2)
                  return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                var dir = path.resolve(x2, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg3);
                  loadAsFile(path.join(x2, "index"), pkg3, cb2);
                });
              });
              return;
            }
            loadAsFile(path.join(x2, "/index"), pkg, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, undefined);
      var dir = dirs[0];
      isDirectory(path.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.json
var require_core3 = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/core.js
var require_core4 = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  var data = require_core3();
  var core = {};
  for (mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core[mod] = isCoreModule(mod);
    }
  }
  var mod;
  module.exports = core;
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  module.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// node_modules/.pnpm/resolve@1.22.8/node_modules/resolve/lib/sync.js
var require_sync2 = __commonJS((exports, module) => {
  var isCore = require_is_core_module();
  var fs = __require("fs");
  var path = __require("path");
  var getHomedir = require_homedir();
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
  var homedir = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir, ".node_modules"),
      path.join(homedir, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs.statSync(file, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs.statSync(dir, { throwIfNoEntry: false });
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
      var pkg = JSON.parse(body);
      return pkg;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0;i < dirs.length; i++) {
      dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
  };
  module.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0;i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path.dirname(dir));
      }
      var pkg = readPackageSync(readFileSync, pkgfile);
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return { pkg, dir };
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x2);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0;i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path.dirname(dir))) {
          var m2 = loadAsFileSync(dir);
          if (m2)
            return m2;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-filters@4.0.0/node_modules/resolve/index.js
var require_resolve = __commonJS((exports, module) => {
  var async = require_async();
  async.core = require_core4();
  async.isCore = require_is_core();
  async.sync = require_sync2();
  module.exports = async;
});

// node_modules/.pnpm/pug-filters@4.0.0/node_modules/pug-filters/lib/run-filter.js
var require_run_filter = __commonJS((exports, module) => {
  var getMinifyTransformerName = function(outputFormat) {
    switch (outputFormat) {
      case "js":
        return "uglify-js";
      case "css":
        return "clean-css";
    }
  };
  var filter = function(name, str, options, currentDirectory, funcName) {
    funcName = funcName || "render";
    var trPath;
    try {
      try {
        trPath = resolve.sync("jstransformer-" + name, {
          basedir: currentDirectory || process.cwd()
        });
      } catch (ex) {
        trPath = __require.resolve("jstransformer-" + name);
      }
    } catch (ex) {
      var err = new Error('unknown filter ":' + name + '"');
      err.code = "UNKNOWN_FILTER";
      throw err;
    }
    var tr = jstransformer(__require(trPath));
    var result = tr[funcName](str, options, options).body;
    if (options && options.minify) {
      var minifyTranformer = getMinifyTransformerName(tr.outputFormat);
      if (minifyTranformer) {
        try {
          result = filter(minifyTranformer, result, null, currentDirectory);
        } catch (ex) {
        }
      }
    }
    return result;
  };
  var jstransformer = require_jstransformer();
  var resolve = require_resolve();
  module.exports = filter;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/with@7.0.2/node_modules/@babel/parser/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var _objectWithoutPropertiesLoose = function(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0;i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  };
  var createPositionWithColumnOffset = function(position, columnOffset) {
    const {
      line,
      column,
      index
    } = position;
    return new Position(line, column + columnOffset, index + columnOffset);
  };
  var defineHidden = function(obj, key, value) {
    Object.defineProperty(obj, key, {
      enumerable: false,
      configurable: true,
      value
    });
  };
  var toParseErrorConstructor = function(_ref) {
    let {
      toMessage
    } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded);
    return function constructor(loc, details) {
      const error = new SyntaxError;
      Object.assign(error, properties, {
        loc,
        pos: loc.index
      });
      if ("missingPlugin" in details) {
        Object.assign(error, {
          missingPlugin: details.missingPlugin
        });
      }
      defineHidden(error, "clone", function clone(overrides = {}) {
        var _overrides$loc;
        const {
          line,
          column,
          index
        } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
        return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
      });
      defineHidden(error, "details", details);
      Object.defineProperty(error, "message", {
        configurable: true,
        get() {
          const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
          this.message = message;
          return message;
        },
        set(value) {
          Object.defineProperty(this, "message", {
            value,
            writable: true
          });
        }
      });
      return error;
    };
  };
  var ParseErrorEnum = function(argument, syntaxPlugin) {
    if (Array.isArray(argument)) {
      return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
    }
    const ParseErrorConstructors = {};
    for (const reasonCode of Object.keys(argument)) {
      const template = argument[reasonCode];
      const _ref2 = typeof template === "string" ? {
        message: () => template
      } : typeof template === "function" ? {
        message: template
      } : template, {
        message
      } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);
      const toMessage = typeof message === "string" ? () => message : message;
      ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode,
        toMessage
      }, syntaxPlugin ? {
        syntaxPlugin
      } : {}, rest));
    }
    return ParseErrorConstructors;
  };
  var toESTreeLocation = function(node) {
    node.loc.start && toUnenumerable(node.loc.start, "index");
    node.loc.end && toUnenumerable(node.loc.end, "index");
    return node;
  };
  var createKeyword = function(name, options = {}) {
    options.keyword = name;
    const token = createToken(name, options);
    keywords$1.set(name, token);
    return token;
  };
  var createBinop = function(name, binop) {
    return createToken(name, {
      beforeExpr,
      binop
    });
  };
  var createToken = function(name, options = {}) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
    tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
    tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
    tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
    tokenTypes.push(new ExportedTokenType(name, options));
    return tokenTypeCounter;
  };
  var createKeywordLike = function(name, options = {}) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    ++tokenTypeCounter;
    keywords$1.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
    tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
    tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
    tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
    tokenTypes.push(new ExportedTokenType("name", options));
    return tokenTypeCounter;
  };
  var tokenIsIdentifier = function(token) {
    return token >= 93 && token <= 132;
  };
  var tokenKeywordOrIdentifierIsKeyword = function(token) {
    return token <= 92;
  };
  var tokenIsKeywordOrIdentifier = function(token) {
    return token >= 58 && token <= 132;
  };
  var tokenIsLiteralPropertyName = function(token) {
    return token >= 58 && token <= 136;
  };
  var tokenComesBeforeExpression = function(token) {
    return tokenBeforeExprs[token];
  };
  var tokenCanStartExpression = function(token) {
    return tokenStartsExprs[token];
  };
  var tokenIsAssignment = function(token) {
    return token >= 29 && token <= 33;
  };
  var tokenIsFlowInterfaceOrTypeOrOpaque = function(token) {
    return token >= 129 && token <= 131;
  };
  var tokenIsLoop = function(token) {
    return token >= 90 && token <= 92;
  };
  var tokenIsKeyword = function(token) {
    return token >= 58 && token <= 92;
  };
  var tokenIsOperator = function(token) {
    return token >= 39 && token <= 59;
  };
  var tokenIsPostfix = function(token) {
    return token === 34;
  };
  var tokenIsPrefix = function(token) {
    return tokenPrefixes[token];
  };
  var tokenIsTSTypeOperator = function(token) {
    return token >= 121 && token <= 123;
  };
  var tokenIsTSDeclarationStart = function(token) {
    return token >= 124 && token <= 130;
  };
  var tokenLabelName = function(token) {
    return tokenLabels[token];
  };
  var tokenOperatorPrecedence = function(token) {
    return tokenBinops[token];
  };
  var tokenIsRightAssociative = function(token) {
    return token === 57;
  };
  var tokenIsTemplate = function(token) {
    return token >= 24 && token <= 25;
  };
  var getExportedToken = function(token) {
    return tokenTypes[token];
  };
  var isInAstralSet = function(code2, set) {
    let pos = 65536;
    for (let i = 0, length = set.length;i < length; i += 2) {
      pos += set[i];
      if (pos > code2)
        return false;
      pos += set[i + 1];
      if (pos >= code2)
        return true;
    }
    return false;
  };
  var isIdentifierStart = function(code2) {
    if (code2 < 65)
      return code2 === 36;
    if (code2 <= 90)
      return true;
    if (code2 < 97)
      return code2 === 95;
    if (code2 <= 122)
      return true;
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
    }
    return isInAstralSet(code2, astralIdentifierStartCodes);
  };
  var isIdentifierChar = function(code2) {
    if (code2 < 48)
      return code2 === 36;
    if (code2 < 58)
      return true;
    if (code2 < 65)
      return false;
    if (code2 <= 90)
      return true;
    if (code2 < 97)
      return code2 === 95;
    if (code2 <= 122)
      return true;
    if (code2 <= 65535) {
      return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
    }
    return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  };
  var isReservedWord = function(word, inModule) {
    return inModule && word === "await" || word === "enum";
  };
  var isStrictReservedWord = function(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  };
  var isStrictBindOnlyReservedWord = function(word) {
    return reservedWordsStrictBindSet.has(word);
  };
  var isStrictBindReservedWord = function(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  };
  var isKeyword = function(word) {
    return keywords.has(word);
  };
  var isIteratorStart = function(current, next, next2) {
    return current === 64 && next === 64 && isIdentifierStart(next2);
  };
  var canBeReservedWord = function(word) {
    return reservedWordLikeSet.has(word);
  };
  var setTrailingComments = function(node, comments) {
    if (node.trailingComments === undefined) {
      node.trailingComments = comments;
    } else {
      node.trailingComments.unshift(...comments);
    }
  };
  var setLeadingComments = function(node, comments) {
    if (node.leadingComments === undefined) {
      node.leadingComments = comments;
    } else {
      node.leadingComments.unshift(...comments);
    }
  };
  var setInnerComments = function(node, comments) {
    if (node.innerComments === undefined) {
      node.innerComments = comments;
    } else {
      node.innerComments.unshift(...comments);
    }
  };
  var adjustInnerComments = function(node, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    while (lastElement === null && i > 0) {
      lastElement = elements[--i];
    }
    if (lastElement === null || lastElement.start > commentWS.start) {
      setInnerComments(node, commentWS.comments);
    } else {
      setTrailingComments(lastElement, commentWS.comments);
    }
  };
  var isNewLine = function(code2) {
    switch (code2) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  };
  var isWhitespace = function(code2) {
    switch (code2) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  };
  var readStringContents = function(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (;; ) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  };
  var isStringEnd = function(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  };
  var readEscapedChar = function(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code2;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCharCode(code2));
      }
      case 117: {
        let code2;
        ({
          code: code2,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code2 === null ? null : String.fromCodePoint(code2));
      }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  };
  var readHexChar = function(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  };
  var readInt = function(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len;i < e; ++i) {
      const code2 = input.charCodeAt(pos);
      let val;
      if (code2 === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code2 >= 97) {
        val = code2 - 97 + 10;
      } else if (code2 >= 65) {
        val = code2 - 65 + 10;
      } else if (_isDigit(code2)) {
        val = code2 - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  };
  var readCodePoint = function(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code2;
    if (ch === 123) {
      ++pos;
      ({
        code: code2,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
      ++pos;
      if (code2 !== null && code2 > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code: code2,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    return {
      code: code2,
      pos
    };
  };
  var buildPosition = function(pos, lineStart, curLine) {
    return new Position(curLine, pos - lineStart, pos);
  };
  var newParameterDeclarationScope = function() {
    return new ExpressionScope(3);
  };
  var newArrowHeadScope = function() {
    return new ArrowHeadParsingScope(1);
  };
  var newAsyncArrowScope = function() {
    return new ArrowHeadParsingScope(2);
  };
  var newExpressionScope = function() {
    return new ExpressionScope;
  };
  var functionFlags = function(isAsync, isGenerator) {
    return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
  };
  var clonePlaceholder = function(node) {
    return cloneIdentifier(node);
  };
  var cloneIdentifier = function(node) {
    const {
      type,
      start,
      end,
      loc,
      range,
      extra,
      name
    } = node;
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    cloned.extra = extra;
    cloned.name = name;
    if (type === "Placeholder") {
      cloned.expectedNode = node.expectedNode;
    }
    return cloned;
  };
  var cloneStringLiteral = function(node) {
    const {
      type,
      start,
      end,
      loc,
      range,
      extra
    } = node;
    if (type === "Placeholder") {
      return clonePlaceholder(node);
    }
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    if (node.raw !== undefined) {
      cloned.raw = node.raw;
    } else {
      cloned.extra = extra;
    }
    cloned.value = node.value;
    return cloned;
  };
  var isEsModuleType = function(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  };
  var hasTypeImportKind = function(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  };
  var partition = function(list, test) {
    const list1 = [];
    const list2 = [];
    for (let i = 0;i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }
    return [list1, list2];
  };
  var isFragment = function(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  };
  var getQualifiedJSXName = function(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    throw new Error("Node had unexpected type: " + object.type);
  };
  var nonNull = function(x) {
    if (x == null) {
      throw new Error(`Unexpected ${x} value.`);
    }
    return x;
  };
  var assert = function(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  };
  var keywordTypeFromName = function(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  };
  var tsIsAccessModifier = function(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  };
  var tsIsVarianceAnnotations = function(modifier) {
    return modifier === "in" || modifier === "out";
  };
  var isPossiblyLiteralEnum = function(expression) {
    if (expression.type !== "MemberExpression")
      return false;
    const {
      computed,
      property
    } = expression;
    if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  };
  var isValidAmbientConstInitializer = function(expression, estree2) {
    var _expression$extra;
    const {
      type
    } = expression;
    if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
      return false;
    }
    if (estree2) {
      if (type === "Literal") {
        const {
          value
        } = expression;
        if (typeof value === "string" || typeof value === "boolean") {
          return true;
        }
      }
    } else {
      if (type === "StringLiteral" || type === "BooleanLiteral") {
        return true;
      }
    }
    if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
      return true;
    }
    if (type === "TemplateLiteral" && expression.expressions.length === 0) {
      return true;
    }
    if (isPossiblyLiteralEnum(expression)) {
      return true;
    }
    return false;
  };
  var isNumber = function(expression, estree2) {
    if (estree2) {
      return expression.type === "Literal" && (typeof expression.value === "number" || ("bigint" in expression));
    }
    return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
  };
  var isNegativeNumber = function(expression, estree2) {
    if (expression.type === "UnaryExpression") {
      const {
        operator,
        argument
      } = expression;
      if (operator === "-" && isNumber(argument, estree2)) {
        return true;
      }
    }
    return false;
  };
  var isUncomputedMemberExpressionChain = function(expression) {
    if (expression.type === "Identifier")
      return true;
    if (expression.type !== "MemberExpression" || expression.computed) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  };
  var hasPlugin = function(plugins, expectedConfig) {
    const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
    const expectedKeys = Object.keys(expectedOptions);
    const expectedOptionsIsEmpty = expectedKeys.length === 0;
    return plugins.some((p) => {
      if (typeof p === "string") {
        return expectedOptionsIsEmpty && p === expectedName;
      } else {
        const [pluginName, pluginOptions] = p;
        if (pluginName !== expectedName) {
          return false;
        }
        for (const key of expectedKeys) {
          if (pluginOptions[key] !== expectedOptions[key]) {
            return false;
          }
        }
        return true;
      }
    });
  };
  var getPluginOption = function(plugins, name, option) {
    const plugin = plugins.find((plugin2) => {
      if (Array.isArray(plugin2)) {
        return plugin2[0] === name;
      } else {
        return plugin2 === name;
      }
    });
    if (plugin && Array.isArray(plugin) && plugin.length > 1) {
      return plugin[1][option];
    }
    return null;
  };
  var validatePlugins = function(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }
      const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
      if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      }
      const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
      if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
        throw new Error("'allowCallParenthesized' must be a boolean.");
      }
    }
    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }
    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }
    if (hasPlugin(plugins, "pipelineOperator")) {
      const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
      if (!PIPELINE_PROPOSALS.includes(proposal)) {
        const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
      }
      const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (proposal === "hack") {
        if (hasPlugin(plugins, "placeholders")) {
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        }
        if (hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        }
        const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
        if (!TOPIC_TOKENS.includes(topicToken)) {
          const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
        }
        if (topicToken === "#" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      } else if (proposal === "smart" && tupleSyntaxIsHash) {
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
    }
    if (hasPlugin(plugins, "moduleAttributes")) {
      {
        if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
          throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
        }
        const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
        if (moduleAttributesVersionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
      }
    }
    if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    }
    if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
    }
    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
      const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      error.missingPlugins = "doExpressions";
      throw error;
    }
    if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
    }
  };
  var getOptions = function(opts) {
    if (opts == null) {
      return Object.assign({}, defaultOptions);
    }
    if (opts.annexB != null && opts.annexB !== false) {
      throw new Error("The `annexB` option can only be set to `false`.");
    }
    const options = {};
    for (const key of Object.keys(defaultOptions)) {
      var _opts$key;
      options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];
    }
    return options;
  };
  var babel7CompatTokens = function(tokens, input) {
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i];
      const {
        type
      } = token;
      if (typeof type === "number") {
        {
          if (type === 138) {
            const {
              loc,
              start,
              value,
              end
            } = token;
            const hashEndPos = start + 1;
            const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
            tokens.splice(i, 1, new Token({
              type: getExportedToken(27),
              value: "#",
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: getExportedToken(132),
              value,
              start: hashEndPos,
              end,
              startLoc: hashEndLoc,
              endLoc: loc.end
            }));
            i++;
            continue;
          }
          if (tokenIsTemplate(type)) {
            const {
              loc,
              start,
              value,
              end
            } = token;
            const backquoteEnd = start + 1;
            const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
            let startToken;
            if (input.charCodeAt(start) === 96) {
              startToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            } else {
              startToken = new Token({
                type: getExportedToken(8),
                value: "}",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
            }
            let templateValue, templateElementEnd, templateElementEndLoc, endToken;
            if (type === 24) {
              templateElementEnd = end - 1;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
              templateValue = value === null ? null : value.slice(1, -1);
              endToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            } else {
              templateElementEnd = end - 2;
              templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
              templateValue = value === null ? null : value.slice(1, -2);
              endToken = new Token({
                type: getExportedToken(23),
                value: "${",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              });
            }
            tokens.splice(i, 1, startToken, new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc
            }), endToken);
            i += 2;
            continue;
          }
        }
        token.type = getExportedToken(type);
      }
    }
    return tokens;
  };
  var pluginsMap = function(plugins) {
    const pluginMap = new Map;
    for (const plugin of plugins) {
      const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
      if (!pluginMap.has(name))
        pluginMap.set(name, options || {});
    }
    return pluginMap;
  };
  var parse = function(input, options) {
    var _options;
    if (((_options = options) == null ? undefined : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);
      try {
        options.sourceType = "module";
        const parser = getParser(options, input);
        const ast = parser.parse();
        if (parser.sawUnambiguousESM) {
          return ast;
        }
        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {
          }
        } else {
          ast.program.sourceType = "script";
        }
        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {
        }
        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  };
  var parseExpression = function(input, options) {
    const parser = getParser(options, input);
    if (parser.options.strictMode) {
      parser.state.strict = true;
    }
    return parser.getExpression();
  };
  var generateExportedTokenTypes = function(internalTokenTypes) {
    const tokenTypes2 = {};
    for (const typeName of Object.keys(internalTokenTypes)) {
      tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
    }
    return tokenTypes2;
  };
  var getParser = function(options, input) {
    let cls = Parser;
    if (options != null && options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }
    return new cls(options, input);
  };
  var getParserClass = function(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
    const key = pluginList.join("/");
    let cls = parserClassCache[key];
    if (!cls) {
      cls = Parser;
      for (const plugin of pluginList) {
        cls = mixinPlugins[plugin](cls);
      }
      parserClassCache[key] = cls;
    }
    return cls;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  class Position {
    constructor(line, col, index) {
      this.line = undefined;
      this.column = undefined;
      this.index = undefined;
      this.line = line;
      this.column = col;
      this.index = index;
    }
  }

  class SourceLocation {
    constructor(start, end) {
      this.start = undefined;
      this.end = undefined;
      this.filename = undefined;
      this.identifierName = undefined;
      this.start = start;
      this.end = end;
    }
  }
  var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var ModuleErrors = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code
    }
  };
  var NodeDescriptions = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  };
  var toNodeDescription = ({
    type,
    prefix: prefix2
  }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
  var StandardErrors = {
    AccessorIsGenerator: ({
      kind
    }) => `A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind
    }) => `Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName
    }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: ({
      phase
    }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName,
      exportName
    }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type
    }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type
    }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: ({
      importName
    }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: ({
      maxArgumentCount
    }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix
    }) => `Expected number in radix ${radix}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord
    }) => `Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({
      identifierName
    }) => `Invalid identifier ${identifierName}.`,
    InvalidLhs: ({
      ancestor
    }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({
      ancestor
    }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor
    }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected
    }) => `Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName
    }) => `Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName
    }) => `Label '${labelName}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin
    }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key
    }) => `Duplicate key "${key}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode
    }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName
    }) => `Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName
    }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName
    }) => `Duplicate private name #${identifierName}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword
    }) => `Unexpected keyword '${keyword}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord
    }) => `Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected,
      unexpected
    }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target,
      onlyValidPropertyName
    }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName
    }) => `Identifier '${identifierName}' has already been declared.`,
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  };
  var StrictModeErrors = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName
    }) => `Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName
    }) => `Binding '${bindingName}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  };
  var UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var PipelineOperatorErrors = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token
    }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type
    }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
      type
    })}; please wrap it in parentheses.`,
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  };
  var _excluded = ["toMessage"];
  var _excluded2 = ["message"];
  var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
  var {
    defineProperty
  } = Object;
  var toUnenumerable = (object, key) => defineProperty(object, key, {
    enumerable: false,
    value: object[key]
  });
  var estree = (superClass) => class ESTreeParserMixin extends superClass {
    parse() {
      const file = toESTreeLocation(super.parse());
      if (this.options.tokens) {
        file.tokens = file.tokens.map(toESTreeLocation);
      }
      return file;
    }
    parseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex = null;
      try {
        regex = new RegExp(pattern, flags);
      } catch (e) {
      }
      const node = this.estreeParseLiteral(regex);
      node.regex = {
        pattern,
        flags
      };
      return node;
    }
    parseBigIntLiteral(value) {
      let bigInt;
      try {
        bigInt = BigInt(value);
      } catch (_unused) {
        bigInt = null;
      }
      const node = this.estreeParseLiteral(bigInt);
      node.bigint = String(node.value || value);
      return node;
    }
    parseDecimalLiteral(value) {
      const decimal = null;
      const node = this.estreeParseLiteral(decimal);
      node.decimal = String(node.value || value);
      return node;
    }
    estreeParseLiteral(value) {
      return this.parseLiteral(value, "Literal");
    }
    parseStringLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    directiveToStmt(directive) {
      const expression = directive.value;
      delete directive.value;
      expression.type = "Literal";
      expression.raw = expression.extra.raw;
      expression.value = expression.extra.expressionValue;
      const stmt = directive;
      stmt.type = "ExpressionStatement";
      stmt.expression = expression;
      stmt.directive = expression.extra.rawValue;
      delete expression.extra;
      return stmt;
    }
    initFunction(node, isAsync) {
      super.initFunction(node, isAsync);
      node.expression = false;
    }
    checkDeclaration(node) {
      if (node != null && this.isObjectProperty(node)) {
        this.checkDeclaration(node.value);
      } else {
        super.checkDeclaration(node);
      }
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params;
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr;
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    }
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
      const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
      node.body = directiveStatements.concat(node.body);
      delete node.directives;
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters;
        delete method.typeParameters;
      }
      classBody.body.push(method);
    }
    parsePrivateName() {
      const node = super.parsePrivateName();
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return node;
        }
      }
      return this.convertPrivateNameToPrivateIdentifier(node);
    }
    convertPrivateNameToPrivateIdentifier(node) {
      const name = super.getPrivateNameSV(node);
      node = node;
      delete node.id;
      node.name = name;
      node.type = "PrivateIdentifier";
      return node;
    }
    isPrivateName(node) {
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.isPrivateName(node);
        }
      }
      return node.type === "PrivateIdentifier";
    }
    getPrivateNameSV(node) {
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return super.getPrivateNameSV(node);
        }
      }
      return node.name;
    }
    parseLiteral(value, type) {
      const node = super.parseLiteral(value, type);
      node.raw = node.extra.raw;
      delete node.extra;
      return node;
    }
    parseFunctionBody(node, allowExpression, isMethod = false) {
      super.parseFunctionBody(node, allowExpression, isMethod);
      node.expression = node.body.type !== "BlockStatement";
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode();
      funcNode.kind = node.kind;
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
      funcNode.type = "FunctionExpression";
      delete funcNode.kind;
      node.value = funcNode;
      if (type === "ClassPrivateMethod") {
        node.computed = false;
      }
      return this.finishNode(node, "MethodDefinition");
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args);
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
      }
      propertyNode.type = "PropertyDefinition";
      return propertyNode;
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args);
      {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return propertyNode;
        }
      }
      propertyNode.type = "PropertyDefinition";
      propertyNode.computed = false;
      return propertyNode;
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
      if (node) {
        node.type = "Property";
        if (node.kind === "method") {
          node.kind = "init";
        }
        node.shorthand = false;
      }
      return node;
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      if (node) {
        node.kind = "init";
        node.type = "Property";
      }
      return node;
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
      return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
    }
    isAssignable(node, isBinding) {
      if (node != null && this.isObjectProperty(node)) {
        return this.isAssignable(node.value, isBinding);
      }
      return super.isAssignable(node, isBinding);
    }
    toAssignable(node, isLHS = false) {
      if (node != null && this.isObjectProperty(node)) {
        const {
          key,
          value
        } = node;
        if (this.isPrivateName(key)) {
          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
        }
        this.toAssignable(value, isLHS);
      } else {
        super.toAssignable(node, isLHS);
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.kind === "get" || prop.kind === "set") {
        this.raise(Errors.PatternHasAccessor, prop.key);
      } else if (prop.method) {
        this.raise(Errors.PatternHasMethod, prop.key);
      } else {
        super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
      }
    }
    finishCallExpression(unfinished, optional) {
      const node = super.finishCallExpression(unfinished, optional);
      if (node.callee.type === "Import") {
        node.type = "ImportExpression";
        node.source = node.arguments[0];
        if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var _node$arguments$, _node$arguments$2;
          node.options = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
          node.attributes = (_node$arguments$2 = node.arguments[1]) != null ? _node$arguments$2 : null;
        }
        delete node.arguments;
        delete node.callee;
      }
      return node;
    }
    toReferencedArguments(node) {
      if (node.type === "ImportExpression") {
        return;
      }
      super.toReferencedArguments(node);
    }
    parseExport(unfinished, decorators) {
      const exportStartLoc = this.state.lastTokStartLoc;
      const node = super.parseExport(unfinished, decorators);
      switch (node.type) {
        case "ExportAllDeclaration":
          node.exported = null;
          break;
        case "ExportNamedDeclaration":
          if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
            node.type = "ExportAllDeclaration";
            node.exported = node.specifiers[0].exported;
            delete node.specifiers;
          }
        case "ExportDefaultDeclaration":
          {
            var _declaration$decorato;
            const {
              declaration
            } = node;
            if ((declaration == null ? undefined : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? undefined : _declaration$decorato.length) > 0 && declaration.start === node.start) {
              this.resetStartLocation(node, exportStartLoc);
            }
          }
          break;
      }
      return node;
    }
    parseSubscript(base, startLoc, noCalls, state) {
      const node = super.parseSubscript(base, startLoc, noCalls, state);
      if (state.optionalChainMember) {
        if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
          node.type = node.type.substring(8);
        }
        if (state.stop) {
          const chain = this.startNodeAtNode(node);
          chain.expression = node;
          return this.finishNode(chain, "ChainExpression");
        }
      } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
        node.optional = false;
      }
      return node;
    }
    isOptionalMemberExpression(node) {
      if (node.type === "ChainExpression") {
        return node.expression.type === "MemberExpression";
      }
      return super.isOptionalMemberExpression(node);
    }
    hasPropertyAsPrivateName(node) {
      if (node.type === "ChainExpression") {
        node = node.expression;
      }
      return super.hasPropertyAsPrivateName(node);
    }
    isObjectProperty(node) {
      return node.type === "Property" && node.kind === "init" && !node.method;
    }
    isObjectMethod(node) {
      return node.method || node.kind === "get" || node.kind === "set";
    }
    finishNodeAt(node, type, endLoc) {
      return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
    }
    resetStartLocation(node, startLoc) {
      super.resetStartLocation(node, startLoc);
      toESTreeLocation(node);
    }
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
      super.resetEndLocation(node, endLoc);
      toESTreeLocation(node);
    }
  };

  class TokContext {
    constructor(token, preserveSpace) {
      this.token = undefined;
      this.preserveSpace = undefined;
      this.token = token;
      this.preserveSpace = !!preserveSpace;
    }
  }
  var types = {
    brace: new TokContext("{"),
    j_oTag: new TokContext("<tag"),
    j_cTag: new TokContext("</tag"),
    j_expr: new TokContext("<tag>...</tag>", true)
  };
  {
    types.template = new TokContext("`", true);
  }
  var beforeExpr = true;
  var startsExpr = true;
  var isLoop = true;
  var isAssign = true;
  var prefix = true;
  var postfix = true;

  class ExportedTokenType {
    constructor(label, conf = {}) {
      this.label = undefined;
      this.keyword = undefined;
      this.beforeExpr = undefined;
      this.startsExpr = undefined;
      this.rightAssociative = undefined;
      this.isLoop = undefined;
      this.isAssign = undefined;
      this.prefix = undefined;
      this.postfix = undefined;
      this.binop = undefined;
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      {
        this.updateContext = null;
      }
    }
  }
  var keywords$1 = new Map;
  var tokenTypeCounter = -1;
  var tokenTypes = [];
  var tokenLabels = [];
  var tokenBinops = [];
  var tokenBeforeExprs = [];
  var tokenStartsExprs = [];
  var tokenPrefixes = [];
  var tt = {
    bracketL: createToken("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: createToken("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: createToken("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: createToken("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: createToken("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: createToken("}"),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
      beforeExpr
    }),
    semi: createToken(";", {
      beforeExpr
    }),
    colon: createToken(":", {
      beforeExpr
    }),
    doubleColon: createToken("::", {
      beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
      beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
      beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
      beforeExpr
    }),
    backQuote: createToken("`", {
      startsExpr
    }),
    dollarBraceL: createToken("${", {
      beforeExpr,
      startsExpr
    }),
    templateTail: createToken("...`", {
      startsExpr
    }),
    templateNonTail: createToken("...${", {
      beforeExpr,
      startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
      startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
      beforeExpr,
      isAssign
    }),
    assign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    slashAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    xorAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    moduloAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: createToken("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: createToken("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: createToken("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    doubleCaret: createToken("^^", {
      startsExpr
    }),
    doubleAt: createToken("@@", {
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    bitShiftL: createBinop("<</>>/>>>", 8),
    bitShiftR: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: createToken("%", {
      binop: 10,
      startsExpr
    }),
    star: createToken("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _do: createKeyword("do", {
      isLoop,
      beforeExpr
    }),
    _for: createKeyword("for", {
      isLoop
    }),
    _while: createKeyword("while", {
      isLoop
    }),
    _as: createKeywordLike("as", {
      startsExpr
    }),
    _assert: createKeywordLike("assert", {
      startsExpr
    }),
    _async: createKeywordLike("async", {
      startsExpr
    }),
    _await: createKeywordLike("await", {
      startsExpr
    }),
    _defer: createKeywordLike("defer", {
      startsExpr
    }),
    _from: createKeywordLike("from", {
      startsExpr
    }),
    _get: createKeywordLike("get", {
      startsExpr
    }),
    _let: createKeywordLike("let", {
      startsExpr
    }),
    _meta: createKeywordLike("meta", {
      startsExpr
    }),
    _of: createKeywordLike("of", {
      startsExpr
    }),
    _sent: createKeywordLike("sent", {
      startsExpr
    }),
    _set: createKeywordLike("set", {
      startsExpr
    }),
    _source: createKeywordLike("source", {
      startsExpr
    }),
    _static: createKeywordLike("static", {
      startsExpr
    }),
    _using: createKeywordLike("using", {
      startsExpr
    }),
    _yield: createKeywordLike("yield", {
      startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
      startsExpr
    }),
    _checks: createKeywordLike("checks", {
      startsExpr
    }),
    _exports: createKeywordLike("exports", {
      startsExpr
    }),
    _global: createKeywordLike("global", {
      startsExpr
    }),
    _implements: createKeywordLike("implements", {
      startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
      startsExpr
    }),
    _infer: createKeywordLike("infer", {
      startsExpr
    }),
    _is: createKeywordLike("is", {
      startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
      startsExpr
    }),
    _proto: createKeywordLike("proto", {
      startsExpr
    }),
    _require: createKeywordLike("require", {
      startsExpr
    }),
    _satisfies: createKeywordLike("satisfies", {
      startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
      startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
      startsExpr
    }),
    _unique: createKeywordLike("unique", {
      startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
      startsExpr
    }),
    _declare: createKeywordLike("declare", {
      startsExpr
    }),
    _enum: createKeywordLike("enum", {
      startsExpr
    }),
    _module: createKeywordLike("module", {
      startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
      startsExpr
    }),
    _interface: createKeywordLike("interface", {
      startsExpr
    }),
    _type: createKeywordLike("type", {
      startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
      startsExpr
    }),
    name: createToken("name", {
      startsExpr
    }),
    string: createToken("string", {
      startsExpr
    }),
    num: createToken("num", {
      startsExpr
    }),
    bigint: createToken("bigint", {
      startsExpr
    }),
    decimal: createToken("decimal", {
      startsExpr
    }),
    regexp: createToken("regexp", {
      startsExpr
    }),
    privateName: createToken("#name", {
      startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
      beforeExpr: true
    }),
    jsxTagStart: createToken("jsxTagStart", {
      startsExpr: true
    }),
    jsxTagEnd: createToken("jsxTagEnd"),
    placeholder: createToken("%%", {
      startsExpr: true
    })
  };
  {
    tokenTypes[8].updateContext = (context) => {
      context.pop();
    };
    tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
      context.push(types.brace);
    };
    tokenTypes[22].updateContext = (context) => {
      if (context[context.length - 1] === types.template) {
        context.pop();
      } else {
        context.push(types.template);
      }
    };
    tokenTypes[142].updateContext = (context) => {
      context.push(types.j_expr, types.j_oTag);
    };
  }
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);

  class Scope {
    constructor(flags) {
      this.flags = 0;
      this.names = new Map;
      this.firstLexicalName = "";
      this.flags = flags;
    }
  }

  class ScopeHandler {
    constructor(parser, inModule) {
      this.parser = undefined;
      this.scopeStack = [];
      this.inModule = undefined;
      this.undefinedExports = new Map;
      this.parser = parser;
      this.inModule = inModule;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const flags = this.currentThisScopeFlags();
      return (flags & 64) > 0 && (flags & 2) === 0;
    }
    get inStaticBlock() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 128) {
          return true;
        }
        if (flags & (387 | 64)) {
          return false;
        }
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
      return new Scope(flags);
    }
    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
    exit() {
      const scope = this.scopeStack.pop();
      return scope.flags;
    }
    treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
    }
    declareName(name, bindingType, loc) {
      let scope = this.currentScope();
      if (bindingType & 8 || bindingType & 16) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        let type = scope.names.get(name) || 0;
        if (bindingType & 16) {
          type = type | 4;
        } else {
          if (!scope.firstLexicalName) {
            scope.firstLexicalName = name;
          }
          type = type | 2;
        }
        scope.names.set(name, type);
        if (bindingType & 8) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & 4) {
        for (let i = this.scopeStack.length - 1;i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          scope.names.set(name, (scope.names.get(name) || 0) | 1);
          this.maybeExportDefined(scope, name);
          if (scope.flags & 387)
            break;
        }
      }
      if (this.parser.inModule && scope.flags & 1) {
        this.undefinedExports.delete(name);
      }
    }
    maybeExportDefined(scope, name) {
      if (this.parser.inModule && scope.flags & 1) {
        this.undefinedExports.delete(name);
      }
    }
    checkRedeclarationInScope(scope, name, bindingType, loc) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.parser.raise(Errors.VarRedeclaration, loc, {
          identifierName: name
        });
      }
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & 1))
        return false;
      if (bindingType & 8) {
        return scope.names.has(name);
      }
      const type = scope.names.get(name);
      if (bindingType & 16) {
        return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
      }
      return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      const topLevelScope = this.scopeStack[0];
      if (!topLevelScope.names.has(name)) {
        this.undefinedExports.set(name, id.loc.start);
      }
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & 387) {
          return flags;
        }
      }
    }
    currentThisScopeFlags() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & (387 | 64) && !(flags & 4)) {
          return flags;
        }
      }
    }
  }

  class FlowScope extends Scope {
    constructor(...args) {
      super(...args);
      this.declareFunctions = new Set;
    }
  }

  class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }
    declareName(name, bindingType, loc) {
      const scope = this.currentScope();
      if (bindingType & 2048) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }
      super.declareName(name, bindingType, loc);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (super.isRedeclaredInScope(scope, name, bindingType))
        return true;
      if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
        const type = scope.names.get(name);
        return (type & 4) > 0 || (type & 2) > 0;
      }
      return false;
    }
    checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        super.checkLocalExport(id);
      }
    }
  }

  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(pluginConfig) {
      if (typeof pluginConfig === "string") {
        return this.plugins.has(pluginConfig);
      } else {
        const [pluginName, pluginOptions] = pluginConfig;
        if (!this.hasPlugin(pluginName)) {
          return false;
        }
        const actualOptions = this.plugins.get(pluginName);
        for (const key of Object.keys(pluginOptions)) {
          if ((actualOptions == null ? undefined : actualOptions[key]) !== pluginOptions[key]) {
            return false;
          }
        }
        return true;
      }
    }
    getPluginOption(plugin, name) {
      var _this$plugins$get;
      return (_this$plugins$get = this.plugins.get(plugin)) == null ? undefined : _this$plugins$get[name];
    }
  }

  class CommentsParser extends BaseParser {
    addComment(comment) {
      if (this.filename)
        comment.loc.filename = this.filename;
      const {
        commentsLen
      } = this.state;
      if (this.comments.length != commentsLen)
        this.comments.length = commentsLen;
      this.comments.push(comment);
      this.state.commentsLen++;
    }
    processComment(node) {
      const {
        commentStack
      } = this.state;
      const commentStackLength = commentStack.length;
      if (commentStackLength === 0)
        return;
      let i = commentStackLength - 1;
      const lastCommentWS = commentStack[i];
      if (lastCommentWS.start === node.end) {
        lastCommentWS.leadingNode = node;
        i--;
      }
      const {
        start: nodeStart
      } = node;
      for (;i >= 0; i--) {
        const commentWS = commentStack[i];
        const commentEnd = commentWS.end;
        if (commentEnd > nodeStart) {
          commentWS.containingNode = node;
          this.finalizeComment(commentWS);
          commentStack.splice(i, 1);
        } else {
          if (commentEnd === nodeStart) {
            commentWS.trailingNode = node;
          }
          break;
        }
      }
    }
    finalizeComment(commentWS) {
      const {
        comments
      } = commentWS;
      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
        if (commentWS.leadingNode !== null) {
          setTrailingComments(commentWS.leadingNode, comments);
        }
        if (commentWS.trailingNode !== null) {
          setLeadingComments(commentWS.trailingNode, comments);
        }
      } else {
        const {
          containingNode: node,
          start: commentStart
        } = commentWS;
        if (this.input.charCodeAt(commentStart - 1) === 44) {
          switch (node.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node, node.properties, commentWS);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node, node.arguments, commentWS);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node, node.params, commentWS);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node, node.elements, commentWS);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node, node.specifiers, commentWS);
              break;
            default: {
              setInnerComments(node, comments);
            }
          }
        } else {
          setInnerComments(node, comments);
        }
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack
      } = this.state;
      for (let i = commentStack.length - 1;i >= 0; i--) {
        this.finalizeComment(commentStack[i]);
      }
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node) {
      const {
        commentStack
      } = this.state;
      const {
        length
      } = commentStack;
      if (length === 0)
        return;
      const commentWS = commentStack[length - 1];
      if (commentWS.leadingNode === node) {
        commentWS.leadingNode = null;
      }
    }
    resetPreviousIdentifierLeadingComments(node) {
      const {
        commentStack
      } = this.state;
      const {
        length
      } = commentStack;
      if (length === 0)
        return;
      if (commentStack[length - 1].trailingNode === node) {
        commentStack[length - 1].trailingNode = null;
      } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
        commentStack[length - 2].trailingNode = null;
      }
    }
    takeSurroundingComments(node, start, end) {
      const {
        commentStack
      } = this.state;
      const commentStackLength = commentStack.length;
      if (commentStackLength === 0)
        return;
      let i = commentStackLength - 1;
      for (;i >= 0; i--) {
        const commentWS = commentStack[i];
        const commentEnd = commentWS.end;
        const commentStart = commentWS.start;
        if (commentStart === end) {
          commentWS.leadingNode = node;
        } else if (commentEnd === start) {
          commentWS.trailingNode = node;
        } else if (commentEnd < start) {
          break;
        }
      }
    }
  }
  var lineBreak = /\r\n?|[\n\u2028\u2029]/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");

  class State {
    constructor() {
      this.flags = 1024;
      this.curLine = undefined;
      this.lineStart = undefined;
      this.startLoc = undefined;
      this.endLoc = undefined;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.labels = [];
      this.commentsLen = 0;
      this.commentStack = [];
      this.pos = 0;
      this.type = 139;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.context = [types.brace];
      this.firstInvalidTemplateEscapePos = null;
      this.strictErrors = new Map;
      this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(value) {
      if (value) {
        this.flags |= 1;
      } else {
        this.flags &= ~1;
      }
    }
    init({
      strictMode,
      sourceType,
      startLine,
      startColumn
    }) {
      this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
      this.curLine = startLine;
      this.lineStart = -startColumn;
      this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(value) {
      if (value) {
        this.flags |= 2;
      } else {
        this.flags &= ~2;
      }
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(value) {
      if (value) {
        this.flags |= 4;
      } else {
        this.flags &= ~4;
      }
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(value) {
      if (value) {
        this.flags |= 8;
      } else {
        this.flags &= ~8;
      }
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(value) {
      if (value) {
        this.flags |= 16;
      } else {
        this.flags &= ~16;
      }
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(value) {
      if (value) {
        this.flags |= 32;
      } else {
        this.flags &= ~32;
      }
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(value) {
      if (value) {
        this.flags |= 64;
      } else {
        this.flags &= ~64;
      }
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(value) {
      if (value) {
        this.flags |= 128;
      } else {
        this.flags &= ~128;
      }
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(value) {
      if (value) {
        this.flags |= 256;
      } else {
        this.flags &= ~256;
      }
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(value) {
      if (value) {
        this.flags |= 512;
      } else {
        this.flags &= ~512;
      }
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(value) {
      if (value) {
        this.flags |= 1024;
      } else {
        this.flags &= ~1024;
      }
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(value) {
      if (value) {
        this.flags |= 2048;
      } else {
        this.flags &= ~2048;
      }
    }
    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      const state = new State;
      state.flags = this.flags;
      state.curLine = this.curLine;
      state.lineStart = this.lineStart;
      state.startLoc = this.startLoc;
      state.endLoc = this.endLoc;
      state.errors = this.errors.slice();
      state.potentialArrowAt = this.potentialArrowAt;
      state.noArrowAt = this.noArrowAt.slice();
      state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
      state.topicContext = this.topicContext;
      state.labels = this.labels.slice();
      state.commentsLen = this.commentsLen;
      state.commentStack = this.commentStack.slice();
      state.pos = this.pos;
      state.type = this.type;
      state.value = this.value;
      state.start = this.start;
      state.end = this.end;
      state.lastTokEndLoc = this.lastTokEndLoc;
      state.lastTokStartLoc = this.lastTokStartLoc;
      state.context = this.context.slice();
      state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
      state.strictErrors = this.strictErrors;
      state.tokensLength = this.tokensLength;
      return state;
    }
  }
  var _isDigit = function isDigit(code2) {
    return code2 >= 48 && code2 <= 57;
  };
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  };
  var isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);

  class Token {
    constructor(state) {
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
  }

  class Tokenizer extends CommentsParser {
    constructor(options, input) {
      super();
      this.isLookahead = undefined;
      this.tokens = [];
      this.errorHandlers_readInt = {
        invalidDigit: (pos, lineStart, curLine, radix) => {
          if (!this.options.errorRecovery)
            return false;
          this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
            radix
          });
          return true;
        },
        numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
      };
      this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
      });
      this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (pos, lineStart, curLine) => {
          this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
        },
        unterminated: (pos, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
        }
      });
      this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
        unterminated: (pos, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
        }
      });
      this.state = new State;
      this.state.init(options);
      this.input = input;
      this.length = input.length;
      this.comments = [];
      this.isLookahead = false;
    }
    pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes();
      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
    match(type) {
      return this.state.type === type;
    }
    createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        context: [this.curContext()],
        inType: state.inType,
        startLoc: state.startLoc,
        lastTokEndLoc: state.lastTokEndLoc,
        curLine: state.curLine,
        lineStart: state.lineStart,
        curPosition: state.curPosition
      };
    }
    lookahead() {
      const old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      const curr = this.state;
      this.state = old;
      return curr;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(pos) {
      skipWhiteSpaceInLine.lastIndex = pos;
      return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(pos) {
      let cp = this.input.charCodeAt(pos);
      if ((cp & 64512) === 55296 && ++pos < this.input.length) {
        const trail = this.input.charCodeAt(pos);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      return cp;
    }
    setStrict(strict) {
      this.state.strict = strict;
      if (strict) {
        this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
        this.state.strictErrors.clear();
      }
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead)
        this.state.startLoc = this.state.curPosition();
      if (this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(commentEnd) {
      let startLoc;
      if (!this.isLookahead)
        startLoc = this.state.curPosition();
      const start = this.state.pos;
      const end = this.input.indexOf(commentEnd, start + 2);
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      }
      this.state.pos = end + commentEnd.length;
      lineBreakG.lastIndex = start + 2;
      while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
        ++this.state.curLine;
        this.state.lineStart = lineBreakG.lastIndex;
      }
      if (this.isLookahead)
        return;
      const comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start,
        end: end + commentEnd.length,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(comment);
      return comment;
    }
    skipLineComment(startSkip) {
      const start = this.state.pos;
      let startLoc;
      if (!this.isLookahead)
        startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }
      if (this.isLookahead)
        return;
      const end = this.state.pos;
      const value = this.input.slice(start + startSkip, end);
      const comment = {
        type: "CommentLine",
        value,
        start,
        end,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(comment);
      return comment;
    }
    skipSpace() {
      const spaceStart = this.state.pos;
      const comments = [];
      loop:
        while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment("*/");
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.options.annexB) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.options.annexB) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== undefined) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
      if (comments.length > 0) {
        const end = this.state.pos;
        const commentWhitespace = {
          start: spaceStart,
          end,
          comments,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(commentWhitespace);
      }
    }
    finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) {
        this.updateContext(prevType);
      }
    }
    replaceToken(type) {
      this.state.type = type;
      this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }
      const nextPos = this.state.pos + 1;
      const next = this.codePointAtPos(nextPos);
      if (next >= 48 && next <= 57) {
        throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
      }
      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");
        if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
          throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        }
        this.state.pos += 2;
        if (next === 123) {
          this.finishToken(7);
        } else {
          this.finishToken(1);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(138, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(138, this.readWord1());
      } else {
        this.finishOp(27, 1);
      }
    }
    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }
      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(21);
      } else {
        ++this.state.pos;
        this.finishToken(16);
      }
    }
    readToken_slash() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(31, 2);
      } else {
        this.finishOp(56, 1);
      }
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33)
        return false;
      const start = this.state.pos;
      this.state.pos += 1;
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }
      const value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(28, value);
      return true;
    }
    readToken_mult_modulo(code2) {
      let type = code2 === 42 ? 55 : 54;
      let width = 1;
      let next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = 57;
      }
      if (next === 61 && !this.state.inType) {
        width++;
        type = code2 === 37 ? 33 : 30;
      }
      this.finishOp(type, width);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(code2 === 124 ? 41 : 42, 2);
        }
        return;
      }
      if (code2 === 124) {
        if (next === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          this.finishToken(4);
          return;
        }
      }
      if (next === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(code2 === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61 && !this.state.inType) {
        this.finishOp(32, 2);
      } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        this.finishOp(37, 2);
        const lookaheadCh = this.input.codePointAt(this.state.pos);
        if (lookaheadCh === 94) {
          this.unexpected();
        }
      } else {
        this.finishOp(44, 1);
      }
    }
    readToken_atSign() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }])) {
        this.finishOp(38, 2);
      } else {
        this.finishOp(26, 1);
      }
    }
    readToken_plus_min(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        this.finishOp(34, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(30, 2);
      } else {
        this.finishOp(53, 1);
      }
    }
    readToken_lt() {
      const {
        pos
      } = this.state;
      const next = this.input.charCodeAt(pos + 1);
      if (next === 60) {
        if (this.input.charCodeAt(pos + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos
      } = this.state;
      const next = this.input.charCodeAt(pos + 1);
      if (next === 62) {
        const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(pos + size) === 61) {
          this.finishOp(30, size + 1);
          return;
        }
        this.finishOp(52, size);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (code2 === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(19);
        return;
      }
      this.finishOp(code2 === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      const next2 = this.input.charCodeAt(this.state.pos + 2);
      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(40, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(18);
      } else {
        ++this.state.pos;
        this.finishToken(17);
      }
    }
    getTokenFromCode(code2) {
      switch (code2) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos;
          this.finishToken(10);
          return;
        case 41:
          ++this.state.pos;
          this.finishToken(11);
          return;
        case 59:
          ++this.state.pos;
          this.finishToken(13);
          return;
        case 44:
          ++this.state.pos;
          this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(2);
          } else {
            ++this.state.pos;
            this.finishToken(0);
          }
          return;
        case 93:
          ++this.state.pos;
          this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(6);
          } else {
            ++this.state.pos;
            this.finishToken(5);
          }
          return;
        case 125:
          ++this.state.pos;
          this.finishToken(8);
          return;
        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(15, 2);
          } else {
            ++this.state.pos;
            this.finishToken(14);
          }
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(code2);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(code2);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(code2);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(code2);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(code2);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (isIdentifierStart(code2)) {
            this.readWord(code2);
            return;
          }
      }
      throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(code2)
      });
    }
    finishOp(type, size) {
      const str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }
    readRegexp() {
      const startLoc = this.state.startLoc;
      const start = this.state.start + 1;
      let escaped, inClass;
      let {
        pos
      } = this.state;
      for (;; ++pos) {
        if (pos >= this.length) {
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        }
        const ch = this.input.charCodeAt(pos);
        if (isNewLine(ch)) {
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        }
        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }
          escaped = ch === 92;
        }
      }
      const content = this.input.slice(start, pos);
      ++pos;
      let mods = "";
      const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
      while (pos < this.length) {
        const cp = this.codePointAtPos(pos);
        const char = String.fromCharCode(cp);
        if (VALID_REGEX_FLAGS.has(cp)) {
          if (cp === 118) {
            if (mods.includes("u")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
            }
          } else if (cp === 117) {
            if (mods.includes("v")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
            }
          }
          if (mods.includes(char)) {
            this.raise(Errors.DuplicateRegExpFlags, nextPos());
          }
        } else if (isIdentifierChar(cp) || cp === 92) {
          this.raise(Errors.MalformedRegExpFlags, nextPos());
        } else {
          break;
        }
        ++pos;
        mods += char;
      }
      this.state.pos = pos;
      this.finishToken(137, {
        pattern: content,
        flags: mods
      });
    }
    readInt(radix, len, forceLen = false, allowNumSeparator = true) {
      const {
        n,
        pos
      } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
      this.state.pos = pos;
      return n;
    }
    readRadixNumber(radix) {
      const startLoc = this.state.curPosition();
      let isBigInt = false;
      this.state.pos += 2;
      const val = this.readInt(radix);
      if (val == null) {
        this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
          radix
        });
      }
      const next = this.input.charCodeAt(this.state.pos);
      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(Errors.InvalidDecimal, startLoc);
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      }
      if (isBigInt) {
        const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, str);
        return;
      }
      this.finishToken(134, val);
    }
    readNumber(startsWithDot) {
      const start = this.state.pos;
      const startLoc = this.state.curPosition();
      let isFloat = false;
      let isBigInt = false;
      let isDecimal = false;
      let hasExponent = false;
      let isOctal = false;
      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(Errors.InvalidNumber, this.state.curPosition());
      }
      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
        if (!this.state.strict) {
          const underscorePos = integer.indexOf("_");
          if (underscorePos > 0) {
            this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
          }
        }
        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }
      let next = this.input.charCodeAt(this.state.pos);
      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);
        if (next === 43 || next === 45) {
          ++this.state.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(Errors.InvalidOrMissingExponent, startLoc);
        }
        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(Errors.InvalidBigIntLiteral, startLoc);
        }
        ++this.state.pos;
        isBigInt = true;
      }
      if (next === 109) {
        this.expectPlugin("decimal", this.state.curPosition());
        if (hasExponent || hasLeadingZero) {
          this.raise(Errors.InvalidDecimal, startLoc);
        }
        ++this.state.pos;
        isDecimal = true;
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      }
      const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
      if (isBigInt) {
        this.finishToken(135, str);
        return;
      }
      if (isDecimal) {
        this.finishToken(136, str);
        return;
      }
      const val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(134, val);
    }
    readCodePoint(throwOnInvalid) {
      const {
        code: code2,
        pos
      } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
      this.state.pos = pos;
      return code2;
    }
    readString(quote) {
      const {
        str,
        pos,
        curLine,
        lineStart
      } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      this.finishToken(133, str);
    }
    readTemplateContinuation() {
      if (!this.match(8)) {
        this.unexpected(null, 8);
      }
      this.state.pos--;
      this.readTemplateToken();
    }
    readTemplateToken() {
      const opening = this.input[this.state.pos];
      const {
        str,
        firstInvalidLoc,
        pos,
        curLine,
        lineStart
      } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      if (firstInvalidLoc) {
        this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
      }
      if (this.input.codePointAt(pos) === 96) {
        this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
      } else {
        this.state.pos++;
        this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
      }
    }
    recordStrictModeErrors(toParseError, at) {
      const index = at.index;
      if (this.state.strict && !this.state.strictErrors.has(index)) {
        this.raise(toParseError, at);
      } else {
        this.state.strictErrors.set(index, [toParseError, at]);
      }
    }
    readWord1(firstCode) {
      this.state.containsEsc = false;
      let word = "";
      const start = this.state.pos;
      let chunkStart = this.state.pos;
      if (firstCode !== undefined) {
        this.state.pos += firstCode <= 65535 ? 1 : 2;
      }
      while (this.state.pos < this.length) {
        const ch = this.codePointAtPos(this.state.pos);
        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.curPosition();
          const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
            chunkStart = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const esc = this.readCodePoint(true);
          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
            }
            word += String.fromCodePoint(esc);
          }
          chunkStart = this.state.pos;
        } else {
          break;
        }
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode) {
      const word = this.readWord1(firstCode);
      const type = keywords$1.get(word);
      if (type !== undefined) {
        this.finishToken(type, tokenLabelName(type));
      } else {
        this.finishToken(132, word);
      }
    }
    checkKeywordEscapes() {
      const {
        type
      } = this.state;
      if (tokenIsKeyword(type) && this.state.containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
          reservedWord: tokenLabelName(type)
        });
      }
    }
    raise(toParseError, at, details = {}) {
      const loc = at instanceof Position ? at : at.loc.start;
      const error = toParseError(loc, details);
      if (!this.options.errorRecovery)
        throw error;
      if (!this.isLookahead)
        this.state.errors.push(error);
      return error;
    }
    raiseOverwrite(toParseError, at, details = {}) {
      const loc = at instanceof Position ? at : at.loc.start;
      const pos = loc.index;
      const errors = this.state.errors;
      for (let i = errors.length - 1;i >= 0; i--) {
        const error = errors[i];
        if (error.loc.index === pos) {
          return errors[i] = toParseError(loc, details);
        }
        if (error.loc.index < pos)
          break;
      }
      return this.raise(toParseError, at, details);
    }
    updateContext(prevType) {
    }
    unexpected(loc, type) {
      throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
        expected: type ? tokenLabelName(type) : null
      });
    }
    expectPlugin(pluginName, loc) {
      if (this.hasPlugin(pluginName)) {
        return true;
      }
      throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
        missingPlugin: [pluginName]
      });
    }
    expectOnePlugin(pluginNames) {
      if (!pluginNames.some((name) => this.hasPlugin(name))) {
        throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: pluginNames
        });
      }
    }
    errorBuilder(error) {
      return (pos, lineStart, curLine) => {
        this.raise(error, buildPosition(pos, lineStart, curLine));
      };
    }
  }

  class ClassScope {
    constructor() {
      this.privateNames = new Set;
      this.loneAccessors = new Map;
      this.undefinedPrivateNames = new Map;
    }
  }

  class ClassScopeHandler {
    constructor(parser) {
      this.parser = undefined;
      this.stack = [];
      this.undefinedPrivateNames = new Map;
      this.parser = parser;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ClassScope);
    }
    exit() {
      const oldClassScope = this.stack.pop();
      const current = this.current();
      for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, loc);
          }
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
        }
      }
    }
    declarePrivateName(name, elementType, loc) {
      const {
        privateNames,
        loneAccessors,
        undefinedPrivateNames
      } = this.current();
      let redefined = privateNames.has(name);
      if (elementType & 3) {
        const accessor = redefined && loneAccessors.get(name);
        if (accessor) {
          const oldStatic = accessor & 4;
          const newStatic = elementType & 4;
          const oldKind = accessor & 3;
          const newKind = elementType & 3;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined)
            loneAccessors.delete(name);
        } else if (!redefined) {
          loneAccessors.set(name, elementType);
        }
      }
      if (redefined) {
        this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
          identifierName: name
        });
      }
      privateNames.add(name);
      undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, loc) {
      let classScope;
      for (classScope of this.stack) {
        if (classScope.privateNames.has(name))
          return;
      }
      if (classScope) {
        classScope.undefinedPrivateNames.set(name, loc);
      } else {
        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
          identifierName: name
        });
      }
    }
  }

  class ExpressionScope {
    constructor(type = 0) {
      this.type = type;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }

  class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type) {
      super(type);
      this.declarationErrors = new Map;
    }
    recordDeclarationError(ParsingErrorClass, at) {
      const index = at.index;
      this.declarationErrors.set(index, [ParsingErrorClass, at]);
    }
    clearDeclarationError(index) {
      this.declarationErrors.delete(index);
    }
    iterateErrors(iterator) {
      this.declarationErrors.forEach(iterator);
    }
  }

  class ExpressionScopeHandler {
    constructor(parser) {
      this.parser = undefined;
      this.stack = [new ExpressionScope];
      this.parser = parser;
    }
    enter(scope) {
      this.stack.push(scope);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(toParseError, node) {
      const origin = node.loc.start;
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];
      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(toParseError, origin);
        } else {
          return;
        }
        scope = stack[--i];
      }
      this.parser.raise(toParseError, origin);
    }
    recordArrowParameterBindingError(error, node) {
      const {
        stack
      } = this;
      const scope = stack[stack.length - 1];
      const origin = node.loc.start;
      if (scope.isCertainlyParameterDeclaration()) {
        this.parser.raise(error, origin);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(error, origin);
      } else {
        return;
      }
    }
    recordAsyncArrowParametersError(at) {
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];
      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === 2) {
          scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
        }
        scope = stack[--i];
      }
    }
    validateAsPattern() {
      const {
        stack
      } = this;
      const currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration())
        return;
      currentScope.iterateErrors(([toParseError, loc]) => {
        this.parser.raise(toParseError, loc);
        let i = stack.length - 2;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(loc.index);
          scope = stack[--i];
        }
      });
    }
  }

  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }
    enter(flags) {
      this.stacks.push(flags);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }

  class UtilParser extends Tokenizer {
    addExtra(node, key, value, enumerable = true) {
      if (!node)
        return;
      const extra = node.extra = node.extra || {};
      if (enumerable) {
        extra[key] = value;
      } else {
        Object.defineProperty(extra, key, {
          enumerable,
          value
        });
      }
    }
    isContextual(token) {
      return this.state.type === token && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      if (this.input.slice(nameStart, nameEnd) === name) {
        const nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
    eatContextual(token) {
      if (this.isContextual(token)) {
        this.next();
        return true;
      }
      return false;
    }
    expectContextual(token, toParseError) {
      if (!this.eatContextual(token)) {
        if (toParseError != null) {
          throw this.raise(toParseError, this.state.startLoc);
        }
        this.unexpected(null, token);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
      return skipWhiteSpaceToLineBreak.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = true) {
      if (allowAsi ? this.isLineTerminator() : this.eat(13))
        return;
      this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(type, loc) {
      this.eat(type) || this.unexpected(loc, type);
    }
    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };
      try {
        const node = fn((node2 = null) => {
          abortSignal.node = node2;
          throw abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState
          };
        }
        return {
          node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        const failState = this.state;
        this.state = oldState;
        if (error instanceof SyntaxError) {
          return {
            node: null,
            error,
            thrown: true,
            aborted: false,
            failState
          };
        }
        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState
          };
        }
        throw error;
      }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors)
        return false;
      const {
        shorthandAssignLoc,
        doubleProtoLoc,
        privateKeyLoc,
        optionalParametersLoc
      } = refExpressionErrors;
      const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
      if (!andThrow) {
        return hasErrors;
      }
      if (shorthandAssignLoc != null) {
        this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
      }
      if (doubleProtoLoc != null) {
        this.raise(Errors.DuplicateProto, doubleProtoLoc);
      }
      if (privateKeyLoc != null) {
        this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
      }
      if (optionalParametersLoc != null) {
        this.unexpected(optionalParametersLoc);
      }
    }
    isLiteralPropertyName() {
      return tokenIsLiteralPropertyName(this.state.type);
    }
    isPrivateName(node) {
      return node.type === "PrivateName";
    }
    getPrivateNameSV(node) {
      return node.id.name;
    }
    hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    }
    isObjectProperty(node) {
      return node.type === "ObjectProperty";
    }
    isObjectMethod(node) {
      return node.type === "ObjectMethod";
    }
    initializeScopes(inModule = this.options.sourceType === "module") {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set;
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope;
      const ScopeHandler2 = this.getScopeHandler();
      this.scope = new ScopeHandler2(this, inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler;
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this);
      const oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this);
      return () => {
        this.state.labels = oldLabels;
        this.exportedIdentifiers = oldExportedIdentifiers;
        this.inModule = oldInModule;
        this.scope = oldScope;
        this.prodParam = oldProdParam;
        this.classScope = oldClassScope;
        this.expressionScope = oldExpressionScope;
      };
    }
    enterInitialScopes() {
      let paramFlags = 0;
      if (this.inModule) {
        paramFlags |= 2;
      }
      this.scope.enter(1);
      this.prodParam.enter(paramFlags);
    }
    checkDestructuringPrivate(refExpressionErrors) {
      const {
        privateKeyLoc
      } = refExpressionErrors;
      if (privateKeyLoc !== null) {
        this.expectPlugin("destructuringPrivate", privateKeyLoc);
      }
    }
  }

  class ExpressionErrors {
    constructor() {
      this.shorthandAssignLoc = null;
      this.doubleProtoLoc = null;
      this.privateKeyLoc = null;
      this.optionalParametersLoc = null;
    }
  }

  class Node {
    constructor(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser != null && parser.options.ranges)
        this.range = [pos, 0];
      if (parser != null && parser.filename)
        this.loc.filename = parser.filename;
    }
  }
  var NodePrototype = Node.prototype;
  {
    NodePrototype.__clone = function() {
      const newNode = new Node(undefined, this.start, this.loc.start);
      const keys = Object.keys(this);
      for (let i = 0, length = keys.length;i < length; i++) {
        const key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }
      return newNode;
    };
  }

  class NodeUtils extends UtilParser {
    startNode() {
      const loc = this.state.startLoc;
      return new Node(this, loc.index, loc);
    }
    startNodeAt(loc) {
      return new Node(this, loc.index, loc);
    }
    startNodeAtNode(type) {
      return this.startNodeAt(type.loc.start);
    }
    finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
    }
    finishNodeAt(node, type, endLoc) {
      node.type = type;
      node.end = endLoc.index;
      node.loc.end = endLoc;
      if (this.options.ranges)
        node.range[1] = endLoc.index;
      if (this.options.attachComment)
        this.processComment(node);
      return node;
    }
    resetStartLocation(node, startLoc) {
      node.start = startLoc.index;
      node.loc.start = startLoc;
      if (this.options.ranges)
        node.range[0] = startLoc.index;
    }
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
      node.end = endLoc.index;
      node.loc.end = endLoc;
      if (this.options.ranges)
        node.range[1] = endLoc.index;
    }
    resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.loc.start);
    }
  }
  var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  var FlowErrors = ParseErrorEnum`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType
    }) => `Cannot overwrite reserved type ${reservedType}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName,
      enumName
    }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
    EnumDuplicateMemberName: ({
      memberName,
      enumName
    }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
    EnumInconsistentMemberValues: ({
      enumName
    }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType,
      enumName
    }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName,
      memberName,
      explicitType
    }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName,
      memberName
    }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName,
      memberName
    }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
    EnumInvalidMemberName: ({
      enumName,
      memberName,
      suggestion
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName,
      memberName
    }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType
    }) => `Unexpected reserved type ${reservedType}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind,
      suggestion
    }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  var exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (superClass) => class FlowParserMixin extends superClass {
    constructor(...args) {
      super(...args);
      this.flowPragma = undefined;
    }
    getScopeHandler() {
      return FlowScopeHandler;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(type, val) {
      if (type !== 133 && type !== 13 && type !== 28) {
        if (this.flowPragma === undefined) {
          this.flowPragma = null;
        }
      }
      super.finishToken(type, val);
    }
    addComment(comment) {
      if (this.flowPragma === undefined) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
        if (!matches)
          ;
        else if (matches[1] === "flow") {
          this.flowPragma = "flow";
        } else if (matches[1] === "noflow") {
          this.flowPragma = "noflow";
        } else {
          throw new Error("Unexpected flow pragma");
        }
      }
      super.addComment(comment);
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || 14);
      const type = this.flowParseType();
      this.state.inType = oldInType;
      return type;
    }
    flowParsePredicate() {
      const node = this.startNode();
      const moduloLoc = this.state.startLoc;
      this.next();
      this.expectContextual(110);
      if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
      }
      if (this.eat(10)) {
        node.value = super.parseExpression();
        this.expect(11);
        return this.finishNode(node, "DeclaredPredicate");
      } else {
        return this.finishNode(node, "InferredPredicate");
      }
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(14);
      let type = null;
      let predicate = null;
      if (this.match(54)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type = this.flowParseType();
        this.state.inType = oldInType;
        if (this.match(54)) {
          predicate = this.flowParsePredicate();
        }
      }
      return [type, predicate];
    }
    flowParseDeclareClass(node) {
      this.next();
      this.flowParseInterfaceish(node, true);
      return this.finishNode(node, "DeclareClass");
    }
    flowParseDeclareFunction(node) {
      this.next();
      const id = node.id = this.parseIdentifier();
      const typeNode = this.startNode();
      const typeContainer = this.startNode();
      if (this.match(47)) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }
      this.expect(10);
      const tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      typeNode.this = tmp._this;
      this.expect(11);
      [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.resetEndLocation(id);
      this.semicolon();
      this.scope.declareName(node.id.name, 2048, node.id.loc.start);
      return this.finishNode(node, "DeclareFunction");
    }
    flowParseDeclare(node, insideModule) {
      if (this.match(80)) {
        return this.flowParseDeclareClass(node);
      } else if (this.match(68)) {
        return this.flowParseDeclareFunction(node);
      } else if (this.match(74)) {
        return this.flowParseDeclareVariable(node);
      } else if (this.eatContextual(127)) {
        if (this.match(16)) {
          return this.flowParseDeclareModuleExports(node);
        } else {
          if (insideModule) {
            this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
          }
          return this.flowParseDeclareModule(node);
        }
      } else if (this.isContextual(130)) {
        return this.flowParseDeclareTypeAlias(node);
      } else if (this.isContextual(131)) {
        return this.flowParseDeclareOpaqueType(node);
      } else if (this.isContextual(129)) {
        return this.flowParseDeclareInterface(node);
      } else if (this.match(82)) {
        return this.flowParseDeclareExportDeclaration(node, insideModule);
      } else {
        this.unexpected();
      }
    }
    flowParseDeclareVariable(node) {
      this.next();
      node.id = this.flowParseTypeAnnotatableIdentifier(true);
      this.scope.declareName(node.id.name, 5, node.id.loc.start);
      this.semicolon();
      return this.finishNode(node, "DeclareVariable");
    }
    flowParseDeclareModule(node) {
      this.scope.enter(0);
      if (this.match(133)) {
        node.id = super.parseExprAtom();
      } else {
        node.id = this.parseIdentifier();
      }
      const bodyNode = node.body = this.startNode();
      const body = bodyNode.body = [];
      this.expect(5);
      while (!this.match(8)) {
        let bodyNode2 = this.startNode();
        if (this.match(83)) {
          this.next();
          if (!this.isContextual(130) && !this.match(87)) {
            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
          }
          super.parseImport(bodyNode2);
        } else {
          this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
          bodyNode2 = this.flowParseDeclare(bodyNode2, true);
        }
        body.push(bodyNode2);
      }
      this.scope.exit();
      this.expect(8);
      this.finishNode(bodyNode, "BlockStatement");
      let kind = null;
      let hasModuleExport = false;
      body.forEach((bodyElement) => {
        if (isEsModuleType(bodyElement)) {
          if (kind === "CommonJS") {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
          }
          kind = "ES";
        } else if (bodyElement.type === "DeclareModuleExports") {
          if (hasModuleExport) {
            this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
          }
          if (kind === "ES") {
            this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
          }
          kind = "CommonJS";
          hasModuleExport = true;
        }
      });
      node.kind = kind || "CommonJS";
      return this.finishNode(node, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(node, insideModule) {
      this.expect(82);
      if (this.eat(65)) {
        if (this.match(68) || this.match(80)) {
          node.declaration = this.flowParseDeclare(this.startNode());
        } else {
          node.declaration = this.flowParseType();
          this.semicolon();
        }
        node.default = true;
        return this.finishNode(node, "DeclareExportDeclaration");
      } else {
        if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
          const label = this.state.value;
          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
            unsupportedExportKind: label,
            suggestion: exportSuggestions[label]
          });
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
          node.declaration = this.flowParseDeclare(this.startNode());
          node.default = false;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
          node = this.parseExport(node, null);
          if (node.type === "ExportNamedDeclaration") {
            node.type = "ExportDeclaration";
            node.default = false;
            delete node.exportKind;
          }
          node.type = "Declare" + node.type;
          return node;
        }
      }
      this.unexpected();
    }
    flowParseDeclareModuleExports(node) {
      this.next();
      this.expectContextual(111);
      node.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(node) {
      this.next();
      const finished = this.flowParseTypeAlias(node);
      finished.type = "DeclareTypeAlias";
      return finished;
    }
    flowParseDeclareOpaqueType(node) {
      this.next();
      const finished = this.flowParseOpaqueType(node, true);
      finished.type = "DeclareOpaqueType";
      return finished;
    }
    flowParseDeclareInterface(node) {
      this.next();
      this.flowParseInterfaceish(node, false);
      return this.finishNode(node, "DeclareInterface");
    }
    flowParseInterfaceish(node, isClass) {
      node.id = this.flowParseRestrictedIdentifier(!isClass, true);
      this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
      if (this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.extends = [];
      if (this.eat(81)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(12));
      }
      if (isClass) {
        node.implements = [];
        node.mixins = [];
        if (this.eatContextual(117)) {
          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        if (this.eatContextual(113)) {
          do {
            node.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
      }
      node.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const node = this.startNode();
      node.id = this.flowParseQualifiedTypeIdentifier();
      if (this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node.typeParameters = null;
      }
      return this.finishNode(node, "InterfaceExtends");
    }
    flowParseInterface(node) {
      this.flowParseInterfaceish(node, false);
      return this.finishNode(node, "InterfaceDeclaration");
    }
    checkNotUnderscore(word) {
      if (word === "_") {
        this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
      }
    }
    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes.has(word))
        return;
      this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
        reservedType: word
      });
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.startLoc, declaration);
      return this.parseIdentifier(liberal);
    }
    flowParseTypeAlias(node) {
      node.id = this.flowParseRestrictedIdentifier(false, true);
      this.scope.declareName(node.id.name, 8201, node.id.loc.start);
      if (this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.right = this.flowParseTypeInitialiser(29);
      this.semicolon();
      return this.finishNode(node, "TypeAlias");
    }
    flowParseOpaqueType(node, declare) {
      this.expectContextual(130);
      node.id = this.flowParseRestrictedIdentifier(true, true);
      this.scope.declareName(node.id.name, 8201, node.id.loc.start);
      if (this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.supertype = null;
      if (this.match(14)) {
        node.supertype = this.flowParseTypeInitialiser(14);
      }
      node.impltype = null;
      if (!declare) {
        node.impltype = this.flowParseTypeInitialiser(29);
      }
      this.semicolon();
      return this.finishNode(node, "OpaqueType");
    }
    flowParseTypeParameter(requireDefault = false) {
      const nodeStartLoc = this.state.startLoc;
      const node = this.startNode();
      const variance = this.flowParseVariance();
      const ident = this.flowParseTypeAnnotatableIdentifier();
      node.name = ident.name;
      node.variance = variance;
      node.bound = ident.typeAnnotation;
      if (this.match(29)) {
        this.eat(29);
        node.default = this.flowParseType();
      } else {
        if (requireDefault) {
          this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
        }
      }
      return this.finishNode(node, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType;
      const node = this.startNode();
      node.params = [];
      this.state.inType = true;
      if (this.match(47) || this.match(142)) {
        this.next();
      } else {
        this.unexpected();
      }
      let defaultRequired = false;
      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node.params.push(typeParameter);
        if (typeParameter.default) {
          defaultRequired = true;
        }
        if (!this.match(48)) {
          this.expect(12);
        }
      } while (!this.match(48));
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expect(47);
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = false;
      while (!this.match(48)) {
        node.params.push(this.flowParseType());
        if (!this.match(48)) {
          this.expect(12);
        }
      }
      this.state.noAnonFunctionType = oldNoAnonFunctionType;
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expect(47);
      while (!this.match(48)) {
        node.params.push(this.flowParseTypeOrImplicitInstantiation());
        if (!this.match(48)) {
          this.expect(12);
        }
      }
      this.expect(48);
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const node = this.startNode();
      this.expectContextual(129);
      node.extends = [];
      if (this.eat(81)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
      }
      node.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      });
      return this.finishNode(node, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(node, isStatic, variance) {
      node.static = isStatic;
      if (this.lookahead().type === 14) {
        node.id = this.flowParseObjectPropertyKey();
        node.key = this.flowParseTypeInitialiser();
      } else {
        node.id = null;
        node.key = this.flowParseType();
      }
      this.expect(3);
      node.value = this.flowParseTypeInitialiser();
      node.variance = variance;
      return this.finishNode(node, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(node, isStatic) {
      node.static = isStatic;
      node.id = this.flowParseObjectPropertyKey();
      this.expect(3);
      this.expect(3);
      if (this.match(47) || this.match(10)) {
        node.method = true;
        node.optional = false;
        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
      } else {
        node.method = false;
        if (this.eat(17)) {
          node.optional = true;
        }
        node.value = this.flowParseTypeInitialiser();
      }
      return this.finishNode(node, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(node) {
      node.params = [];
      node.rest = null;
      node.typeParameters = null;
      node.this = null;
      if (this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.expect(10);
      if (this.match(78)) {
        node.this = this.flowParseFunctionTypeParam(true);
        node.this.name = null;
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      while (!this.match(11) && !this.match(21)) {
        node.params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      if (this.eat(21)) {
        node.rest = this.flowParseFunctionTypeParam(false);
      }
      this.expect(11);
      node.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(node, isStatic) {
      const valueNode = this.startNode();
      node.static = isStatic;
      node.value = this.flowParseObjectTypeMethodish(valueNode);
      return this.finishNode(node, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      nodeStart.internalSlots = [];
      let endDelim;
      let exact;
      let inexact = false;
      if (allowExact && this.match(6)) {
        this.expect(6);
        endDelim = 9;
        exact = true;
      } else {
        this.expect(5);
        endDelim = 8;
        exact = false;
      }
      nodeStart.exact = exact;
      while (!this.match(endDelim)) {
        let isStatic = false;
        let protoStartLoc = null;
        let inexactStartLoc = null;
        const node = this.startNode();
        if (allowProto && this.isContextual(118)) {
          const lookahead = this.lookahead();
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next();
            protoStartLoc = this.state.startLoc;
            allowStatic = false;
          }
        }
        if (allowStatic && this.isContextual(106)) {
          const lookahead = this.lookahead();
          if (lookahead.type !== 14 && lookahead.type !== 17) {
            this.next();
            isStatic = true;
          }
        }
        const variance = this.flowParseVariance();
        if (this.eat(0)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (this.eat(0)) {
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
          }
        } else if (this.match(10) || this.match(47)) {
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.unexpected(variance.loc.start);
          }
          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
        } else {
          let kind = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const lookahead = this.lookahead();
            if (tokenIsLiteralPropertyName(lookahead.type)) {
              kind = this.state.value;
              this.next();
            }
          }
          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
          if (propOrInexact === null) {
            inexact = true;
            inexactStartLoc = this.state.lastTokStartLoc;
          } else {
            nodeStart.properties.push(propOrInexact);
          }
        }
        this.flowObjectTypeSemicolon();
        if (inexactStartLoc && !this.match(8) && !this.match(9)) {
          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
        }
      }
      this.expect(endDelim);
      if (allowSpread) {
        nodeStart.inexact = inexact;
      }
      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    }
    flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
      if (this.eat(21)) {
        const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
          } else if (!allowInexact) {
            this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.InexactVariance, variance);
          }
          return null;
        }
        if (!allowSpread) {
          this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
        }
        if (protoStartLoc != null) {
          this.unexpected(protoStartLoc);
        }
        if (variance) {
          this.raise(FlowErrors.SpreadVariance, variance);
        }
        node.argument = this.flowParseType();
        return this.finishNode(node, "ObjectTypeSpreadProperty");
      } else {
        node.key = this.flowParseObjectPropertyKey();
        node.static = isStatic;
        node.proto = protoStartLoc != null;
        node.kind = kind;
        let optional = false;
        if (this.match(47) || this.match(10)) {
          node.method = true;
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.unexpected(variance.loc.start);
          }
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
          if (kind === "get" || kind === "set") {
            this.flowCheckGetterSetterParams(node);
          }
          if (!allowSpread && node.key.name === "constructor" && node.value.this) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
          }
        } else {
          if (kind !== "init")
            this.unexpected();
          node.method = false;
          if (this.eat(17)) {
            optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
        }
        node.optional = optional;
        return this.finishNode(node, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === "get" ? 0 : 1;
      const length = property.value.params.length + (property.value.rest ? 1 : 0);
      if (property.value.this) {
        this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
      }
      if (length !== paramCount) {
        this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
      }
      if (property.kind === "set" && property.value.rest) {
        this.raise(Errors.BadSetterRestParameter, property);
      }
    }
    flowObjectTypeSemicolon() {
      if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
        this.unexpected();
      }
    }
    flowParseQualifiedTypeIdentifier(startLoc, id) {
      var _startLoc;
      (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
      let node = id || this.flowParseRestrictedIdentifier(true);
      while (this.eat(16)) {
        const node2 = this.startNodeAt(startLoc);
        node2.qualification = node;
        node2.id = this.flowParseRestrictedIdentifier(true);
        node = this.finishNode(node2, "QualifiedTypeIdentifier");
      }
      return node;
    }
    flowParseGenericType(startLoc, id) {
      const node = this.startNodeAt(startLoc);
      node.typeParameters = null;
      node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
      if (this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      }
      return this.finishNode(node, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const node = this.startNode();
      this.expect(87);
      node.argument = this.flowParsePrimaryType();
      return this.finishNode(node, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const node = this.startNode();
      node.types = [];
      this.expect(0);
      while (this.state.pos < this.length && !this.match(3)) {
        node.types.push(this.flowParseType());
        if (this.match(3))
          break;
        this.expect(12);
      }
      this.expect(3);
      return this.finishNode(node, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(first) {
      let name = null;
      let optional = false;
      let typeAnnotation = null;
      const node = this.startNode();
      const lh = this.lookahead();
      const isThis = this.state.type === 78;
      if (lh.type === 14 || lh.type === 17) {
        if (isThis && !first) {
          this.raise(FlowErrors.ThisParamMustBeFirst, node);
        }
        name = this.parseIdentifier(isThis);
        if (this.eat(17)) {
          optional = true;
          if (isThis) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
          }
        }
        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }
      node.name = name;
      node.optional = optional;
      node.typeAnnotation = typeAnnotation;
      return this.finishNode(node, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(type) {
      const node = this.startNodeAt(type.loc.start);
      node.name = null;
      node.optional = false;
      node.typeAnnotation = type;
      return this.finishNode(node, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null;
      let _this = null;
      if (this.match(78)) {
        _this = this.flowParseFunctionTypeParam(true);
        _this.name = null;
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      while (!this.match(11) && !this.match(21)) {
        params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(11)) {
          this.expect(12);
        }
      }
      if (this.eat(21)) {
        rest = this.flowParseFunctionTypeParam(false);
      }
      return {
        params,
        rest,
        _this
      };
    }
    flowIdentToTypeAnnotation(startLoc, node, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(node, "SymbolTypeAnnotation");
        default:
          this.checkNotUnderscore(id.name);
          return this.flowParseGenericType(startLoc, id);
      }
    }
    flowParsePrimaryType() {
      const startLoc = this.state.startLoc;
      const node = this.startNode();
      let tmp;
      let type;
      let isGroupedType = false;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case 0:
          this.state.noAnonFunctionType = false;
          type = this.flowParseTupleType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          return type;
        case 47:
          node.typeParameters = this.flowParseTypeParameterDeclaration();
          this.expect(10);
          tmp = this.flowParseFunctionTypeParams();
          node.params = tmp.params;
          node.rest = tmp.rest;
          node.this = tmp._this;
          this.expect(11);
          this.expect(19);
          node.returnType = this.flowParseType();
          return this.finishNode(node, "FunctionTypeAnnotation");
        case 10:
          this.next();
          if (!this.match(11) && !this.match(21)) {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
              const token = this.lookahead().type;
              isGroupedType = token !== 17 && token !== 14;
            } else {
              isGroupedType = true;
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
              this.expect(11);
              return type;
            } else {
              this.eat(12);
            }
          }
          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }
          node.params = tmp.params;
          node.rest = tmp.rest;
          node.this = tmp._this;
          this.expect(11);
          this.expect(19);
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          node.value = this.match(85);
          this.next();
          return this.finishNode(node, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            this.next();
            if (this.match(134)) {
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
            }
            if (this.match(135)) {
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
            }
            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          this.next();
          return this.finishNode(node, "VoidTypeAnnotation");
        case 84:
          this.next();
          return this.finishNode(node, "NullLiteralTypeAnnotation");
        case 78:
          this.next();
          return this.finishNode(node, "ThisTypeAnnotation");
        case 55:
          this.next();
          return this.finishNode(node, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (tokenIsKeyword(this.state.type)) {
            const label = tokenLabelName(this.state.type);
            this.next();
            return super.createIdentifier(node, label);
          } else if (tokenIsIdentifier(this.state.type)) {
            if (this.isContextual(129)) {
              return this.flowParseInterfaceType();
            }
            return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
          }
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const startLoc = this.state.startLoc;
      let type = this.flowParsePrimaryType();
      let seenOptionalIndexedAccess = false;
      while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
        const node = this.startNodeAt(startLoc);
        const optional = this.eat(18);
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
        this.expect(0);
        if (!optional && this.match(3)) {
          node.elementType = type;
          this.next();
          type = this.finishNode(node, "ArrayTypeAnnotation");
        } else {
          node.objectType = type;
          node.indexType = this.flowParseType();
          this.expect(3);
          if (seenOptionalIndexedAccess) {
            node.optional = optional;
            type = this.finishNode(node, "OptionalIndexedAccessType");
          } else {
            type = this.finishNode(node, "IndexedAccessType");
          }
        }
      }
      return type;
    }
    flowParsePrefixType() {
      const node = this.startNode();
      if (this.eat(17)) {
        node.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const node = this.startNodeAt(param.loc.start);
        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node.rest = null;
        node.this = null;
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      return param;
    }
    flowParseIntersectionType() {
      const node = this.startNode();
      this.eat(45);
      const type = this.flowParseAnonFunctionWithoutParens();
      node.types = [type];
      while (this.eat(45)) {
        node.types.push(this.flowParseAnonFunctionWithoutParens());
      }
      return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const node = this.startNode();
      this.eat(43);
      const type = this.flowParseIntersectionType();
      node.types = [type];
      while (this.eat(43)) {
        node.types.push(this.flowParseIntersectionType());
      }
      return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
    }
    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const type = this.flowParseUnionType();
      this.state.inType = oldInType;
      return type;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const startLoc = this.state.startLoc;
        const node = this.parseIdentifier();
        return this.flowParseGenericType(startLoc, node);
      } else {
        return this.flowParseType();
      }
    }
    flowParseTypeAnnotation() {
      const node = this.startNode();
      node.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      if (this.match(14)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(ident);
      }
      return ident;
    }
    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
      return node.expression;
    }
    flowParseVariance() {
      let variance = null;
      if (this.match(53)) {
        variance = this.startNode();
        if (this.state.value === "+") {
          variance.kind = "plus";
        } else {
          variance.kind = "minus";
        }
        this.next();
        return this.finishNode(variance, "Variance");
      }
      return variance;
    }
    parseFunctionBody(node, allowExpressionBody, isMethod = false) {
      if (allowExpressionBody) {
        this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
        return;
      }
      super.parseFunctionBody(node, false, isMethod);
    }
    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(14)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(node, type, isMethod);
    }
    parseStatementLike(flags) {
      if (this.state.strict && this.isContextual(129)) {
        const lookahead = this.lookahead();
        if (tokenIsKeywordOrIdentifier(lookahead.type)) {
          const node = this.startNode();
          this.next();
          return this.flowParseInterface(node);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      }
      const stmt = super.parseStatementLike(flags);
      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
        this.flowPragma = null;
      }
      return stmt;
    }
    parseExpressionStatement(node, expr, decorators) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
            return this.flowParseDeclare(node);
          }
        } else if (tokenIsIdentifier(this.state.type)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node, false);
          }
        }
      }
      return super.parseExpressionStatement(node, expr, decorators);
    }
    shouldParseExportDeclaration() {
      const {
        type
      } = this.state;
      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
        return !this.state.containsEsc;
      }
      return super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type
      } = this.state;
      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
        return this.state.containsEsc;
      }
      return super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.match(17))
        return expr;
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode();
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
          this.setOptionalParametersError(refExpressionErrors);
          return expr;
        }
      }
      this.expect(17);
      const state = this.state.clone();
      const originalNoArrowAt = this.state.noArrowAt;
      const node = this.startNodeAt(startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent();
      let [valid, invalid] = this.getArrowLikeExpressions(consequent);
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];
        if (invalid.length > 0) {
          this.state = state;
          this.state.noArrowAt = noArrowAt;
          for (let i = 0;i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start);
          }
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
          [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }
        if (failed && valid.length > 1) {
          this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
        }
        if (failed && valid.length === 1) {
          this.state = state;
          noArrowAt.push(valid[0].start);
          this.state.noArrowAt = noArrowAt;
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
        }
      }
      this.getArrowLikeExpressions(consequent, true);
      this.state.noArrowAt = originalNoArrowAt;
      this.expect(14);
      node.test = expr;
      node.consequent = consequent;
      node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));
      return this.finishNode(node, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn();
      const failed = !this.match(14);
      this.state.noArrowParamsConversionAt.pop();
      return {
        consequent,
        failed
      };
    }
    getArrowLikeExpressions(node, disallowInvalid) {
      const stack = [node];
      const arrows = [];
      while (stack.length !== 0) {
        const node2 = stack.pop();
        if (node2.type === "ArrowFunctionExpression") {
          if (node2.typeParameters || !node2.returnType) {
            this.finishArrowValidation(node2);
          } else {
            arrows.push(node2);
          }
          stack.push(node2.body);
        } else if (node2.type === "ConditionalExpression") {
          stack.push(node2.consequent);
          stack.push(node2.alternate);
        }
      }
      if (disallowInvalid) {
        arrows.forEach((node2) => this.finishArrowValidation(node2));
        return [arrows, []];
      }
      return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
    }
    finishArrowValidation(node) {
      var _node$extra;
      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? undefined : _node$extra.trailingCommaLoc, false);
      this.scope.enter(2 | 4);
      super.checkParams(node, false, true);
      this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(node, parse2) {
      let result;
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        result = parse2();
        this.state.noArrowParamsConversionAt.pop();
      } else {
        result = parse2();
      }
      return result;
    }
    parseParenItem(node, startLoc) {
      node = super.parseParenItem(node, startLoc);
      if (this.eat(17)) {
        node.optional = true;
        this.resetEndLocation(node);
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TypeCastExpression");
      }
      return node;
    }
    assertModuleNodeAllowed(node) {
      if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
        return;
      }
      super.assertModuleNodeAllowed(node);
    }
    parseExportDeclaration(node) {
      if (this.isContextual(130)) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        if (this.match(5)) {
          node.specifiers = this.parseExportSpecifiers(true);
          super.parseExportFrom(node);
          return null;
        } else {
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual(131)) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseOpaqueType(declarationNode, false);
      } else if (this.isContextual(129)) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(declarationNode);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        node.exportKind = "value";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(declarationNode);
      } else {
        return super.parseExportDeclaration(node);
      }
    }
    eatExportStar(node) {
      if (super.eatExportStar(node))
        return true;
      if (this.isContextual(130) && this.lookahead().type === 55) {
        node.exportKind = "type";
        this.next();
        this.next();
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node) {
      const {
        startLoc
      } = this.state;
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
      if (hasNamespace && node.exportKind === "type") {
        this.unexpected(startLoc);
      }
      return hasNamespace;
    }
    parseClassId(node, isStatement, optionalId) {
      super.parseClassId(node, isStatement, optionalId);
      if (this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    }
    parseClassMember(classBody, member, state) {
      const {
        startLoc
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        member.declare = true;
      }
      super.parseClassMember(classBody, member, state);
      if (member.declare) {
        if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
          this.raise(FlowErrors.DeclareClassElement, startLoc);
        } else if (member.value) {
          this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
        }
      }
    }
    isIterator(word) {
      return word === "iterator" || word === "asyncIterator";
    }
    readIterator() {
      const word = super.readWord1();
      const fullWord = "@@" + word;
      if (!this.isIterator(word) || !this.state.inType) {
        this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
          identifierName: fullWord
        });
      }
      this.finishToken(132, fullWord);
    }
    getTokenFromCode(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 123 && next === 124) {
        this.finishOp(6, 2);
      } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
        this.finishOp(code2 === 62 ? 48 : 47, 1);
      } else if (this.state.inType && code2 === 63) {
        if (next === 46) {
          this.finishOp(18, 2);
        } else {
          this.finishOp(17, 1);
        }
      } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
        this.state.pos += 2;
        this.readIterator();
      } else {
        super.getTokenFromCode(code2);
      }
    }
    isAssignable(node, isBinding) {
      if (node.type === "TypeCastExpression") {
        return this.isAssignable(node.expression, isBinding);
      } else {
        return super.isAssignable(node, isBinding);
      }
    }
    toAssignable(node, isLHS = false) {
      if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
        node.left = this.typeCastToParameter(node.left);
      }
      super.toAssignable(node, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0;i < exprList.length; i++) {
        const expr = exprList[i];
        if ((expr == null ? undefined : expr.type) === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0;i < exprList.length; i++) {
        var _expr$extra;
        const expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
          this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
        }
      }
      return exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      if (canBePattern && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node.elements);
      }
      return node;
    }
    isValidLVal(type, isParenthesized, binding) {
      return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
    }
    parseClassProperty(node) {
      if (this.match(14)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassProperty(node);
    }
    parseClassPrivateProperty(node) {
      if (this.match(14)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassPrivateProperty(node);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(method) {
      return !this.match(14) && super.isNonstaticConstructor(method);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start);
      }
      delete method.variance;
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      if (method.params && isConstructor) {
        const params = method.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, method);
        }
      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
        const params = method.value.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(FlowErrors.ThisParamBannedInConstructor, method);
        }
      }
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variance.loc.start);
      }
      delete method.variance;
      if (this.match(47)) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    parseClassSuper(node) {
      super.parseClassSuper(node);
      if (node.superClass && this.match(47)) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual(113)) {
        this.next();
        const implemented = node.implements = [];
        do {
          const node2 = this.startNode();
          node2.id = this.flowParseRestrictedIdentifier(true);
          if (this.match(47)) {
            node2.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node2.typeParameters = null;
          }
          implemented.push(this.finishNode(node2, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length > 0) {
        const param = params[0];
        if (this.isThisParam(param) && method.kind === "get") {
          this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
        }
      }
    }
    parsePropertyNamePrefixOperator(node) {
      node.variance = this.flowParseVariance();
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.loc.start);
      }
      delete prop.variance;
      let typeParameters;
      if (this.match(47) && !isAccessor) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(10))
          this.unexpected();
      }
      const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      if (typeParameters) {
        (result.value || result).typeParameters = typeParameters;
      }
      return result;
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(17)) {
        if (param.type !== "Identifier") {
          this.raise(FlowErrors.PatternIsOptional, param);
        }
        if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
        }
        param.optional = true;
      }
      if (this.match(14)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      } else if (this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamAnnotationRequired, param);
      }
      if (this.match(29) && this.isThisParam(param)) {
        this.raise(FlowErrors.ThisParamNoDefault, param);
      }
      this.resetEndLocation(param);
      return param;
    }
    parseMaybeDefault(startLoc, left) {
      const node = super.parseMaybeDefault(startLoc, left);
      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
      }
      return node;
    }
    checkImportReflection(node) {
      super.checkImportReflection(node);
      if (node.module && node.importKind !== "value") {
        this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
      }
    }
    parseImportSpecifierLocal(node, specifier, type) {
      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
      node.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport))
        return true;
      if (this.isContextual(130)) {
        if (!isExport)
          return true;
        const ch = this.lookaheadCharCode();
        return ch === 123 || ch === 42;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node, isExport, phase, loc) {
      super.applyImportPhase(node, isExport, phase, loc);
      if (isExport) {
        if (!phase && this.match(65)) {
          return;
        }
        node.exportKind = phase === "type" ? phase : "value";
      } else {
        if (phase === "type" && this.match(55))
          this.unexpected();
        node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      const firstIdent = specifier.imported;
      let specifierTypeKind = null;
      if (firstIdent.type === "Identifier") {
        if (firstIdent.name === "type") {
          specifierTypeKind = "type";
        } else if (firstIdent.name === "typeof") {
          specifierTypeKind = "typeof";
        }
      }
      let isBinding = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = cloneIdentifier(as_ident);
        } else {
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else {
        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;
        } else {
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: firstIdent.value
            });
          }
          specifier.imported = firstIdent;
          specifier.importKind = null;
        }
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = cloneIdentifier(specifier.imported);
        }
      }
      const specifierIsTypeImport = hasTypeImportKind(specifier);
      if (isInTypeOnlyImport && specifierIsTypeImport) {
        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
      }
      if (isInTypeOnlyImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
      }
      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(node, isConstructor) {
      const kind = node.kind;
      if (kind !== "get" && kind !== "set" && this.match(47)) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.parseFunctionParams(node, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (this.match(14)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(14)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
      return super.parseAsyncArrowFromCallExpression(node, call);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx;
      let state = null;
      let jsx2;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        state = this.state.clone();
        jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx2.error)
          return jsx2.node;
        const {
          context
        } = this.state;
        const currentContext = context[context.length - 1];
        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
          context.pop();
        }
      }
      if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
        var _jsx2, _jsx3;
        state = state || this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _arrowExpression$extr;
          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            this.resetStartLocationFromNode(result, typeParameters);
            return result;
          });
          if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
            abort();
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
          if (expr.type !== "ArrowFunctionExpression")
            abort();
          expr.typeParameters = typeParameters;
          this.resetStartLocationFromNode(expr, typeParameters);
          return arrowExpression2;
        }, state);
        let arrowExpression = null;
        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
            }
            return arrow.node;
          }
          arrowExpression = arrow.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrowExpression) {
          this.state = arrow.failState;
          return arrowExpression;
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown)
          throw jsx2.error;
        if (arrow.thrown)
          throw arrow.error;
        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }
    parseArrow(node) {
      if (this.match(14)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.canInsertSemicolon())
            this.unexpected();
          if (!this.match(19))
            this.unexpected();
          return typeNode;
        });
        if (result.thrown)
          return null;
        if (result.error)
          this.state = result.failState;
        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(node);
    }
    shouldParseArrow(params) {
      return this.match(14) || super.shouldParseArrow(params);
    }
    setArrowFunctionParameters(node, params) {
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        node.params = params;
      } else {
        super.setArrowFunctionParameters(node, params);
      }
    }
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        return;
      }
      for (let i = 0;i < node.params.length; i++) {
        if (this.isThisParam(node.params[i]) && i > 0) {
          this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
        }
      }
      super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(base, startLoc, noCalls) {
      if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        node.arguments = super.parseCallExpressionArguments(11, false);
        base = this.finishNode(node, "CallExpression");
      } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
        const state = this.state.clone();
        const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
        if (!arrow.error && !arrow.aborted)
          return arrow.node;
        const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
        if (result.node && !result.error)
          return result.node;
        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }
        if (result.node) {
          this.state = result.failState;
          return result.node;
        }
        throw arrow.error || result.error;
      }
      return super.parseSubscripts(base, startLoc, noCalls);
    }
    parseSubscript(base, startLoc, noCalls, subscriptState) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true;
        if (noCalls) {
          subscriptState.stop = true;
          return base;
        }
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        node.typeArguments = this.flowParseTypeParameterInstantiation();
        this.expect(10);
        node.arguments = this.parseCallExpressionArguments(11, false);
        node.optional = true;
        return this.finishCallExpression(node, true);
      } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const result = this.tryParse(() => {
          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
          this.expect(10);
          node.arguments = super.parseCallExpressionArguments(11, false);
          if (subscriptState.optionalChainMember) {
            node.optional = false;
          }
          return this.finishCallExpression(node, subscriptState.optionalChainMember);
        });
        if (result.node) {
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
      }
      return super.parseSubscript(base, startLoc, noCalls, subscriptState);
    }
    parseNewCallee(node) {
      super.parseNewCallee(node);
      let targs = null;
      if (this.shouldParseTypes() && this.match(47)) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
      }
      node.typeArguments = targs;
    }
    parseAsyncArrowWithTypeParameters(startLoc) {
      const node = this.startNodeAt(startLoc);
      this.parseFunctionParams(node, false);
      if (!this.parseArrow(node))
        return;
      return super.parseArrowExpression(node, undefined, true);
    }
    readToken_mult_modulo(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false;
        this.state.pos += 2;
        this.nextToken();
        return;
      }
      super.readToken_mult_modulo(code2);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 124 && next === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(code2);
    }
    parseTopLevel(file, program) {
      const fileNode = super.parseTopLevel(file, program);
      if (this.state.hasFlowComment) {
        this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
      }
      return fileNode;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
        }
        this.hasFlowCommentCompletion();
        const commentSkip = this.skipFlowComment();
        if (commentSkip) {
          this.state.pos += commentSkip;
          this.state.hasFlowComment = true;
        }
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;
      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++;
      }
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2;
      }
      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
        return shiftToFirstNonWhiteSpace + 12;
      }
      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace;
      }
      return false;
    }
    hasFlowCommentCompletion() {
      const end = this.input.indexOf("*/", this.state.pos);
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      }
    }
    flowEnumErrorBooleanMemberNotInitialized(loc, {
      enumName,
      memberName
    }) {
      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
        memberName,
        enumName
      });
    }
    flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
      return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
    }
    flowEnumErrorNumberMemberNotInitialized(loc, details) {
      this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
    }
    flowEnumMemberInit() {
      const startLoc = this.state.startLoc;
      const endOfInit = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          const literal = this.parseNumericLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "number",
              loc: literal.loc.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        case 133: {
          const literal = this.parseStringLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "string",
              loc: literal.loc.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        case 85:
        case 86: {
          const literal = this.parseBooleanLiteral(this.match(85));
          if (endOfInit()) {
            return {
              type: "boolean",
              loc: literal.loc.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            loc: startLoc
          };
        }
        default:
          return {
            type: "invalid",
            loc: startLoc
          };
      }
    }
    flowEnumMemberRaw() {
      const loc = this.state.startLoc;
      const id = this.parseIdentifier(true);
      const init = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc
      };
      return {
        id,
        init
      };
    }
    flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
      const {
        explicitType
      } = context;
      if (explicitType === null) {
        return;
      }
      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(loc, context);
      }
    }
    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = new Set;
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let hasUnknownMembers = false;
      while (!this.match(8)) {
        if (this.eat(21)) {
          hasUnknownMembers = true;
          break;
        }
        const memberNode = this.startNode();
        const {
          id,
          init
        } = this.flowEnumMemberRaw();
        const memberName = id.name;
        if (memberName === "") {
          continue;
        }
        if (/^[a-z]/.test(memberName)) {
          this.raise(FlowErrors.EnumInvalidMemberName, id, {
            memberName,
            suggestion: memberName[0].toUpperCase() + memberName.slice(1),
            enumName
          });
        }
        if (seenNames.has(memberName)) {
          this.raise(FlowErrors.EnumDuplicateMemberName, id, {
            memberName,
            enumName
          });
        }
        seenNames.add(memberName);
        const context = {
          enumName,
          explicitType,
          memberName
        };
        memberNode.id = id;
        switch (init.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
            memberNode.init = init.value;
            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
            memberNode.init = init.value;
            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
            memberNode.init = init.value;
            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;
          }
          case "invalid": {
            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
          }
          case "none": {
            switch (explicitType) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                break;
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
          }
        }
        if (!this.match(8)) {
          this.expect(12);
        }
      }
      return {
        members,
        hasUnknownMembers
      };
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers;
      } else if (defaultedMembers.length === 0) {
        return initializedMembers;
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        }
        return defaultedMembers;
      } else {
        for (const member of defaultedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        }
        return initializedMembers;
      }
    }
    flowEnumParseExplicitType({
      enumName
    }) {
      if (!this.eatContextual(102))
        return null;
      if (!tokenIsIdentifier(this.state.type)) {
        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName
        });
      }
      const {
        value
      } = this.state;
      this.next();
      if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
        this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
          enumName,
          invalidEnumType: value
        });
      }
      return value;
    }
    flowEnumBody(node, id) {
      const enumName = id.name;
      const nameLoc = id.loc.start;
      const explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(5);
      const {
        members,
        hasUnknownMembers
      } = this.flowEnumMembers({
        enumName,
        explicitType
      });
      node.hasUnknownMembers = hasUnknownMembers;
      switch (explicitType) {
        case "boolean":
          node.explicitType = true;
          node.members = members.booleanMembers;
          this.expect(8);
          return this.finishNode(node, "EnumBooleanBody");
        case "number":
          node.explicitType = true;
          node.members = members.numberMembers;
          this.expect(8);
          return this.finishNode(node, "EnumNumberBody");
        case "string":
          node.explicitType = true;
          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          });
          this.expect(8);
          return this.finishNode(node, "EnumStringBody");
        case "symbol":
          node.members = members.defaultedMembers;
          this.expect(8);
          return this.finishNode(node, "EnumSymbolBody");
        default: {
          const empty = () => {
            node.members = [];
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          };
          node.explicitType = false;
          const boolsLen = members.booleanMembers.length;
          const numsLen = members.numberMembers.length;
          const strsLen = members.stringMembers.length;
          const defaultedLen = members.defaultedMembers.length;
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty();
          } else if (!boolsLen && !numsLen) {
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          } else {
            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
              enumName
            });
            return empty();
          }
        }
      }
    }
    flowParseEnumDeclaration(node) {
      const id = this.parseIdentifier();
      node.id = id;
      node.body = this.flowEnumBody(this.startNode(), id);
      return this.finishNode(node, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart();
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(node) {
      return node.type === "TypeCastExpression" ? node.expression : node;
    }
  };
  var entities = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };
  var JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName
    }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected,
      HTMLEntity
    }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  var jsx = (superClass) => class JSXParserMixin extends superClass {
    jsxReadToken() {
      let out = "";
      let chunkStart = this.state.pos;
      for (;; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.canStartJSXElement) {
                ++this.state.pos;
                this.finishToken(142);
              } else {
                super.getTokenFromCode(ch);
              }
              return;
            }
            out += this.input.slice(chunkStart, this.state.pos);
            this.finishToken(141, out);
            return;
          case 38:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      ++this.state.pos;
      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    }
    jsxReadString(quote) {
      let out = "";
      let chunkStart = ++this.state.pos;
      for (;; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(Errors.UnterminatedString, this.state.startLoc);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote)
          break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(133, out);
    }
    jsxReadEntity() {
      const startPos = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let radix = 10;
        if (this.codePointAtPos(this.state.pos) === 120) {
          radix = 16;
          ++this.state.pos;
        }
        const codePoint = this.readInt(radix, undefined, false, "bail");
        if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
          ++this.state.pos;
          return String.fromCodePoint(codePoint);
        }
      } else {
        let count = 0;
        let semi = false;
        while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
          ++this.state.pos;
        }
        if (semi) {
          const desc = this.input.slice(startPos, this.state.pos);
          const entity = entities[desc];
          ++this.state.pos;
          if (entity) {
            return entity;
          }
        }
      }
      this.state.pos = startPos;
      return "&";
    }
    jsxReadWord() {
      let ch;
      const start = this.state.pos;
      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar(ch) || ch === 45);
      this.finishToken(140, this.input.slice(start, this.state.pos));
    }
    jsxParseIdentifier() {
      const node = this.startNode();
      if (this.match(140)) {
        node.name = this.state.value;
      } else if (tokenIsKeyword(this.state.type)) {
        node.name = tokenLabelName(this.state.type);
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const startLoc = this.state.startLoc;
      const name = this.jsxParseIdentifier();
      if (!this.eat(14))
        return name;
      const node = this.startNodeAt(startLoc);
      node.namespace = name;
      node.name = this.jsxParseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const startLoc = this.state.startLoc;
      let node = this.jsxParseNamespacedName();
      if (node.type === "JSXNamespacedName") {
        return node;
      }
      while (this.eat(16)) {
        const newNode = this.startNodeAt(startLoc);
        newNode.object = node;
        newNode.property = this.jsxParseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    }
    jsxParseAttributeValue() {
      let node;
      switch (this.state.type) {
        case 5:
          node = this.startNode();
          this.setContext(types.brace);
          this.next();
          node = this.jsxParseExpressionContainer(node, types.j_oTag);
          if (node.expression.type === "JSXEmptyExpression") {
            this.raise(JsxErrors.AttributeIsEmpty, node);
          }
          return node;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const node = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(node) {
      this.next();
      node.expression = this.parseExpression();
      this.setContext(types.j_expr);
      this.state.canStartJSXElement = true;
      this.expect(8);
      return this.finishNode(node, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(node, previousContext) {
      if (this.match(8)) {
        node.expression = this.jsxParseEmptyExpression();
      } else {
        const expression = this.parseExpression();
        node.expression = expression;
      }
      this.setContext(previousContext);
      this.state.canStartJSXElement = true;
      this.expect(8);
      return this.finishNode(node, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const node = this.startNode();
      if (this.match(5)) {
        this.setContext(types.brace);
        this.next();
        this.expect(21);
        node.argument = this.parseMaybeAssignAllowIn();
        this.setContext(types.j_oTag);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadAttribute");
      }
      node.name = this.jsxParseNamespacedName();
      node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }
    jsxParseOpeningElementAt(startLoc) {
      const node = this.startNodeAt(startLoc);
      if (this.eat(143)) {
        return this.finishNode(node, "JSXOpeningFragment");
      }
      node.name = this.jsxParseElementName();
      return this.jsxParseOpeningElementAfterName(node);
    }
    jsxParseOpeningElementAfterName(node) {
      const attributes = [];
      while (!this.match(56) && !this.match(143)) {
        attributes.push(this.jsxParseAttribute());
      }
      node.attributes = attributes;
      node.selfClosing = this.eat(56);
      this.expect(143);
      return this.finishNode(node, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(startLoc) {
      const node = this.startNodeAt(startLoc);
      if (this.eat(143)) {
        return this.finishNode(node, "JSXClosingFragment");
      }
      node.name = this.jsxParseElementName();
      this.expect(143);
      return this.finishNode(node, "JSXClosingElement");
    }
    jsxParseElementAt(startLoc) {
      const node = this.startNodeAt(startLoc);
      const children = [];
      const openingElement = this.jsxParseOpeningElementAt(startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents:
          for (;; ) {
            switch (this.state.type) {
              case 142:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 141:
                children.push(this.parseExprAtom());
                break;
              case 5: {
                const node2 = this.startNode();
                this.setContext(types.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node2));
                } else {
                  children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
        if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
          this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
            openingTagName: getQualifiedJSXName(openingElement.name)
          });
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          }
        }
      }
      if (isFragment(openingElement)) {
        node.openingFragment = openingElement;
        node.closingFragment = closingElement;
      } else {
        node.openingElement = openingElement;
        node.closingElement = closingElement;
      }
      node.children = children;
      if (this.match(47)) {
        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
      }
      return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
    }
    jsxParseElement() {
      const startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startLoc);
    }
    setContext(newContext) {
      const {
        context
      } = this.state;
      context[context.length - 1] = newContext;
    }
    parseExprAtom(refExpressionErrors) {
      if (this.match(141)) {
        return this.parseLiteral(this.state.value, "JSXText");
      } else if (this.match(142)) {
        return this.jsxParseElement();
      } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
        this.replaceToken(142);
        return this.jsxParseElement();
      } else {
        return super.parseExprAtom(refExpressionErrors);
      }
    }
    skipSpace() {
      const curContext = this.curContext();
      if (!curContext.preserveSpace)
        super.skipSpace();
    }
    getTokenFromCode(code2) {
      const context = this.curContext();
      if (context === types.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (context === types.j_oTag || context === types.j_cTag) {
        if (isIdentifierStart(code2)) {
          this.jsxReadWord();
          return;
        }
        if (code2 === 62) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
          this.jsxReadString(code2);
          return;
        }
      }
      if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos;
        this.finishToken(142);
        return;
      }
      super.getTokenFromCode(code2);
    }
    updateContext(prevType) {
      const {
        context,
        type
      } = this.state;
      if (type === 56 && prevType === 142) {
        context.splice(-2, 2, types.j_cTag);
        this.state.canStartJSXElement = false;
      } else if (type === 142) {
        context.push(types.j_oTag);
      } else if (type === 143) {
        const out = context[context.length - 1];
        if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
          context.pop();
          this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
        } else {
          this.setContext(types.j_expr);
          this.state.canStartJSXElement = true;
        }
      } else {
        this.state.canStartJSXElement = tokenComesBeforeExpression(type);
      }
    }
  };

  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args);
      this.tsNames = new Map;
    }
  }

  class TypeScriptScopeHandler extends ScopeHandler {
    constructor(...args) {
      super(...args);
      this.importsStack = [];
    }
    createScope(flags) {
      this.importsStack.push(new Set);
      return new TypeScriptScope(flags);
    }
    enter(flags) {
      if (flags == 256) {
        this.importsStack.push(new Set);
      }
      super.enter(flags);
    }
    exit() {
      const flags = super.exit();
      if (flags == 256) {
        this.importsStack.pop();
      }
      return flags;
    }
    hasImport(name, allowShadow) {
      const len = this.importsStack.length;
      if (this.importsStack[len - 1].has(name)) {
        return true;
      }
      if (!allowShadow && len > 1) {
        for (let i = 0;i < len - 1; i++) {
          if (this.importsStack[i].has(name))
            return true;
        }
      }
      return false;
    }
    declareName(name, bindingType, loc) {
      if (bindingType & 4096) {
        if (this.hasImport(name, true)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          });
        }
        this.importsStack[this.importsStack.length - 1].add(name);
        return;
      }
      const scope = this.currentScope();
      let type = scope.tsNames.get(name) || 0;
      if (bindingType & 1024) {
        this.maybeExportDefined(scope, name);
        scope.tsNames.set(name, type | 16);
        return;
      }
      super.declareName(name, bindingType, loc);
      if (bindingType & 2) {
        if (!(bindingType & 1)) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
        }
        type = type | 1;
      }
      if (bindingType & 256) {
        type = type | 2;
      }
      if (bindingType & 512) {
        type = type | 4;
      }
      if (bindingType & 128) {
        type = type | 8;
      }
      if (type)
        scope.tsNames.set(name, type);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      const type = scope.tsNames.get(name);
      if ((type & 2) > 0) {
        if (bindingType & 256) {
          const isConst = !!(bindingType & 512);
          const wasConst = (type & 4) > 0;
          return isConst !== wasConst;
        }
        return true;
      }
      if (bindingType & 128 && (type & 8) > 0) {
        if (scope.names.get(name) & 2) {
          return !!(bindingType & 1);
        } else {
          return false;
        }
      }
      if (bindingType & 2 && (type & 1) > 0) {
        return true;
      }
      return super.isRedeclaredInScope(scope, name, bindingType);
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      if (this.hasImport(name))
        return;
      const len = this.scopeStack.length;
      for (let i = len - 1;i >= 0; i--) {
        const scope = this.scopeStack[i];
        const type = scope.tsNames.get(name);
        if ((type & 1) > 0 || (type & 16) > 0) {
          return;
        }
      }
      super.checkLocalExport(id);
    }
  }
  var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
  var unwrapParenthesizedExpression = (node) => {
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  };

  class LValParser extends NodeUtils {
    toAssignable(node, isLHS = false) {
      var _node$extra, _node$extra3;
      let parenthesized = undefined;
      if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node);
        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
          } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        } else {
          this.raise(Errors.InvalidParenthesizedAssignment, node);
        }
      }
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node.type = "ObjectPattern";
          for (let i = 0, length = node.properties.length, last = length - 1;i < length; i++) {
            var _node$extra2;
            const prop = node.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
            if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
            }
          }
          break;
        case "ObjectProperty": {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
          break;
        }
        case "SpreadElement": {
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        }
        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? undefined : _node$extra3.trailingCommaLoc, isLHS);
          break;
        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
          }
          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
      } else if (prop.type === "SpreadElement") {
        prop.type = "RestElement";
        const arg = prop.argument;
        this.checkToRestConversion(arg, false);
        this.toAssignable(arg, isLHS);
        if (!isLast) {
          this.raise(Errors.RestTrailingComma, prop);
        }
      } else {
        this.toAssignable(prop, isLHS);
      }
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      const end = exprList.length - 1;
      for (let i = 0;i <= end; i++) {
        const elt = exprList[i];
        if (!elt)
          continue;
        if (elt.type === "SpreadElement") {
          elt.type = "RestElement";
          const arg = elt.argument;
          this.checkToRestConversion(arg, true);
          this.toAssignable(arg, isLHS);
        } else {
          this.toAssignable(elt, isLHS);
        }
        if (elt.type === "RestElement") {
          if (i < end) {
            this.raise(Errors.RestTrailingComma, elt);
          } else if (trailingCommaLoc) {
            this.raise(Errors.RestTrailingComma, trailingCommaLoc);
          }
        }
      }
    }
    isAssignable(node, isBinding) {
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const last = node.properties.length - 1;
          return node.properties.every((prop, i) => {
            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
          });
        }
        case "ObjectProperty":
          return this.isAssignable(node.value);
        case "SpreadElement":
          return this.isAssignable(node.argument);
        case "ArrayExpression":
          return node.elements.every((element) => element === null || this.isAssignable(element));
        case "AssignmentExpression":
          return node.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(node.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;
        default:
          return false;
      }
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (const expr of exprList) {
        if ((expr == null ? undefined : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    }
    parseSpread(refExpressionErrors) {
      const node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
      return this.finishNode(node, "SpreadElement");
    }
    parseRestBinding() {
      const node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(3, 93, 1);
          return this.finishNode(node, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, flags) {
      const allowEmpty = flags & 1;
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
        }
        if (allowEmpty && this.match(12)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(21)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
          if (!this.checkCommaAfterRest(closeCharCode)) {
            this.expect(close);
            break;
          }
        } else {
          const decorators = [];
          if (this.match(26) && this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
          elts.push(this.parseAssignableListItem(flags, decorators));
        }
      }
      return elts;
    }
    parseBindingRestProperty(prop) {
      this.next();
      prop.argument = this.parseIdentifier();
      this.checkCommaAfterRest(125);
      return this.finishNode(prop, "RestElement");
    }
    parseBindingProperty() {
      const prop = this.startNode();
      const {
        type,
        startLoc
      } = this.state;
      if (type === 21) {
        return this.parseBindingRestProperty(prop);
      } else if (type === 138) {
        this.expectPlugin("destructuringPrivate", startLoc);
        this.classScope.usePrivateName(this.state.value, startLoc);
        prop.key = this.parsePrivateName();
      } else {
        this.parsePropertyName(prop);
      }
      prop.method = false;
      return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    }
    parseAssignableListItem(flags, decorators) {
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left, flags);
      const elt = this.parseMaybeDefault(left.loc.start, left);
      if (decorators.length) {
        left.decorators = decorators;
      }
      return elt;
    }
    parseAssignableListItemTypes(param, flags) {
      return param;
    }
    parseMaybeDefault(startLoc, left) {
      var _startLoc, _left;
      (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(29))
        return left;
      const node = this.startNodeAt(startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
      return getOwn$1({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, type);
    }
    isOptionalMemberExpression(expression) {
      return expression.type === "OptionalMemberExpression";
    }
    checkLVal(expression, {
      in: ancestor,
      binding = 64,
      checkClashes = false,
      strictModeChanged = false,
      hasParenthesizedAncestor = false
    }) {
      var _expression$extra;
      const type = expression.type;
      if (this.isObjectMethod(expression))
        return;
      const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
      if (isOptionalMemberExpression || type === "MemberExpression") {
        if (isOptionalMemberExpression) {
          this.expectPlugin("optionalChainingAssign", expression.loc.start);
          if (ancestor.type !== "AssignmentExpression") {
            this.raise(Errors.InvalidLhsOptionalChaining, expression, {
              ancestor
            });
          }
        }
        if (binding !== 64) {
          this.raise(Errors.InvalidPropertyBindingPattern, expression);
        }
        return;
      }
      if (type === "Identifier") {
        this.checkIdentifier(expression, binding, strictModeChanged);
        const {
          name
        } = expression;
        if (checkClashes) {
          if (checkClashes.has(name)) {
            this.raise(Errors.ParamDupe, expression);
          } else {
            checkClashes.add(name);
          }
        }
        return;
      }
      const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
      if (validity === true)
        return;
      if (validity === false) {
        const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
        this.raise(ParseErrorClass, expression, {
          ancestor
        });
        return;
      }
      const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
      const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
        type
      } : ancestor;
      for (const child of [].concat(expression[key])) {
        if (child) {
          this.checkLVal(child, {
            in: nextAncestor,
            binding,
            checkClashes,
            strictModeChanged,
            hasParenthesizedAncestor: isParenthesizedExpression
          });
        }
      }
    }
    checkIdentifier(at, bindingType, strictModeChanged = false) {
      if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
        if (bindingType === 64) {
          this.raise(Errors.StrictEvalArguments, at, {
            referenceName: at.name
          });
        } else {
          this.raise(Errors.StrictEvalArgumentsBinding, at, {
            bindingName: at.name
          });
        }
      }
      if (bindingType & 8192 && at.name === "let") {
        this.raise(Errors.LetInLexicalBinding, at);
      }
      if (!(bindingType & 64)) {
        this.declareNameFromIdentifier(at, bindingType);
      }
    }
    declareNameFromIdentifier(identifier, binding) {
      this.scope.declareName(identifier.name, binding, identifier.loc.start);
    }
    checkToRestConversion(node, allowPattern) {
      switch (node.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(node.expression, allowPattern);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (allowPattern)
            break;
        default:
          this.raise(Errors.InvalidRestAssignmentPattern, node);
      }
    }
    checkCommaAfterRest(close) {
      if (!this.match(12)) {
        return false;
      }
      this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
      return true;
    }
  }
  var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
  var TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({
      methodName
    }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName
    }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind
    }) => `'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier
    }) => `Accessibility modifier already seen.`,
    DuplicateModifier: ({
      modifier
    }) => `Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({
      token
    }) => `'${token}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers
    }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier
    }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier
    }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifiersOrder: ({
      orderedModifiers
    }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier
    }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName
    }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
  });
  var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
    constructor(...args) {
      super(...args);
      this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
      this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      });
      this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }
    tsIsIdentifier() {
      return tokenIsIdentifier(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      this.next();
      return this.tsTokenCanFollowModifier();
    }
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
      if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
        return;
      }
      const modifier = this.state.value;
      if (allowedModifiers.indexOf(modifier) !== -1) {
        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
          return;
        }
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }
      }
      return;
    }
    tsParseModifiers({
      allowedModifiers,
      disallowedModifiers,
      stopOnStartOfClassStaticBlock,
      errorTemplate = TSErrors.InvalidModifierOnTypeMember
    }, modified) {
      const enforceOrder = (loc, modifier, before, after) => {
        if (modifier === before && modified[after]) {
          this.raise(TSErrors.InvalidModifiersOrder, loc, {
            orderedModifiers: [before, after]
          });
        }
      };
      const incompatible = (loc, modifier, mod1, mod2) => {
        if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
          this.raise(TSErrors.IncompatibleModifiers, loc, {
            modifiers: [mod1, mod2]
          });
        }
      };
      for (;; ) {
        const {
          startLoc
        } = this.state;
        const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
        if (!modifier)
          break;
        if (tsIsAccessModifier(modifier)) {
          if (modified.accessibility) {
            this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
              modifier
            });
          } else {
            enforceOrder(startLoc, modifier, modifier, "override");
            enforceOrder(startLoc, modifier, modifier, "static");
            enforceOrder(startLoc, modifier, modifier, "readonly");
            modified.accessibility = modifier;
          }
        } else if (tsIsVarianceAnnotations(modifier)) {
          if (modified[modifier]) {
            this.raise(TSErrors.DuplicateModifier, startLoc, {
              modifier
            });
          }
          modified[modifier] = true;
          enforceOrder(startLoc, modifier, "in", "out");
        } else {
          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(TSErrors.DuplicateModifier, startLoc, {
              modifier
            });
          } else {
            enforceOrder(startLoc, modifier, "static", "readonly");
            enforceOrder(startLoc, modifier, "static", "override");
            enforceOrder(startLoc, modifier, "override", "readonly");
            enforceOrder(startLoc, modifier, "abstract", "override");
            incompatible(startLoc, modifier, "declare", "override");
            incompatible(startLoc, modifier, "static", "abstract");
          }
          modified[modifier] = true;
        }
        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
          this.raise(errorTemplate, startLoc, {
            modifier
          });
        }
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(kind, parseElement) {
      const result = [];
      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement());
      }
      return result;
    }
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
      const result = [];
      let trailingCommaPos = -1;
      for (;; ) {
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        trailingCommaPos = -1;
        const element = parseElement();
        if (element == null) {
          return;
        }
        result.push(element);
        if (this.eat(12)) {
          trailingCommaPos = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        if (expectSuccess) {
          this.expect(12);
        }
        return;
      }
      if (refTrailingCommaPos) {
        refTrailingCommaPos.value = trailingCommaPos;
      }
      return result;
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(0);
        } else {
          this.expect(47);
        }
      }
      const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
      if (bracket) {
        this.expect(3);
      } else {
        this.expect(48);
      }
      return result;
    }
    tsParseImportType() {
      const node = this.startNode();
      this.expect(83);
      this.expect(10);
      if (!this.match(133)) {
        this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
      }
      node.argument = super.parseExprAtom();
      this.expect(11);
      if (this.eat(16)) {
        node.qualifier = this.tsParseEntityName();
      }
      if (this.match(47)) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSImportType");
    }
    tsParseEntityName(allowReservedWords = true) {
      let entity = this.parseIdentifier(allowReservedWords);
      while (this.eat(16)) {
        const node = this.startNodeAtNode(entity);
        node.left = entity;
        node.right = this.parseIdentifier(allowReservedWords);
        entity = this.finishNode(node, "TSQualifiedName");
      }
      return entity;
    }
    tsParseTypeReference() {
      const node = this.startNode();
      node.typeName = this.tsParseEntityName();
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSTypeReference");
    }
    tsParseThisTypePredicate(lhs) {
      this.next();
      const node = this.startNodeAtNode(lhs);
      node.parameterName = lhs;
      node.typeAnnotation = this.tsParseTypeAnnotation(false);
      node.asserts = false;
      return this.finishNode(node, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const node = this.startNode();
      this.next();
      return this.finishNode(node, "TSThisType");
    }
    tsParseTypeQuery() {
      const node = this.startNode();
      this.expect(87);
      if (this.match(83)) {
        node.exprName = this.tsParseImportType();
      } else {
        node.exprName = this.tsParseEntityName();
      }
      if (!this.hasPrecedingLineBreak() && this.match(47)) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSTypeQuery");
    }
    tsParseTypeParameter(parseModifiers) {
      const node = this.startNode();
      parseModifiers(node);
      node.name = this.tsParseTypeParameterName();
      node.constraint = this.tsEatThenParseType(81);
      node.default = this.tsEatThenParseType(29);
      return this.finishNode(node, "TSTypeParameter");
    }
    tsTryParseTypeParameters(parseModifiers) {
      if (this.match(47)) {
        return this.tsParseTypeParameters(parseModifiers);
      }
    }
    tsParseTypeParameters(parseModifiers) {
      const node = this.startNode();
      if (this.match(47) || this.match(142)) {
        this.next();
      } else {
        this.unexpected();
      }
      const refTrailingCommaPos = {
        value: -1
      };
      node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
      if (node.params.length === 0) {
        this.raise(TSErrors.EmptyTypeParameters, node);
      }
      if (refTrailingCommaPos.value !== -1) {
        this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
      }
      return this.finishNode(node, "TSTypeParameterDeclaration");
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === 19;
      const paramsKey = "parameters";
      const returnTypeKey = "typeAnnotation";
      signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      this.expect(10);
      signature[paramsKey] = this.tsParseBindingListForSignature();
      if (returnTokenRequired) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      } else if (this.match(returnToken)) {
        signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      }
    }
    tsParseBindingListForSignature() {
      const list = super.parseBindingList(11, 41, 2);
      for (const pattern of list) {
        const {
          type
        } = pattern;
        if (type === "AssignmentPattern" || type === "TSParameterProperty") {
          this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
            type
          });
        }
      }
      return list;
    }
    tsParseTypeMemberSemicolon() {
      if (!this.eat(12) && !this.isLineTerminator()) {
        this.expect(13);
      }
    }
    tsParseSignatureMember(kind, node) {
      this.tsFillSignature(14, node);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, kind);
    }
    tsIsUnambiguouslyIndexSignature() {
      this.next();
      if (tokenIsIdentifier(this.state.type)) {
        this.next();
        return this.match(14);
      }
      return false;
    }
    tsTryParseIndexSignature(node) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return;
      }
      this.expect(0);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation();
      this.resetEndLocation(id);
      this.expect(3);
      node.parameters = [id];
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        node.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(node, readonly) {
      if (this.eat(17))
        node.optional = true;
      const nodeAny = node;
      if (this.match(10) || this.match(47)) {
        if (readonly) {
          this.raise(TSErrors.ReadonlyForMethodSignature, node);
        }
        const method = nodeAny;
        if (method.kind && this.match(47)) {
          this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition());
        }
        this.tsFillSignature(14, method);
        this.tsParseTypeMemberSemicolon();
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        if (method.kind === "get") {
          if (method[paramsKey].length > 0) {
            this.raise(Errors.BadGetterArity, this.state.curPosition());
            if (this.isThisParam(method[paramsKey][0])) {
              this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());
            }
          }
        } else if (method.kind === "set") {
          if (method[paramsKey].length !== 1) {
            this.raise(Errors.BadSetterArity, this.state.curPosition());
          } else {
            const firstParameter = method[paramsKey][0];
            if (this.isThisParam(firstParameter)) {
              this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());
            }
            if (firstParameter.type === "Identifier" && firstParameter.optional) {
              this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());
            }
            if (firstParameter.type === "RestElement") {
              this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());
            }
          }
          if (method[returnTypeKey]) {
            this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);
          }
        } else {
          method.kind = "method";
        }
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property = nodeAny;
        if (readonly)
          property.readonly = true;
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          property.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(property, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const node = this.startNode();
      if (this.match(10) || this.match(47)) {
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
      }
      if (this.match(77)) {
        const id = this.startNode();
        this.next();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
        } else {
          node.key = this.createIdentifier(id, "new");
          return this.tsParsePropertyOrMethodSignature(node, false);
        }
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, node);
      const idx = this.tsTryParseIndexSignature(node);
      if (idx) {
        return idx;
      }
      super.parsePropertyName(node);
      if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
        node.kind = node.key.name;
        super.parsePropertyName(node);
      }
      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
    }
    tsParseTypeLiteral() {
      const node = this.startNode();
      node.members = this.tsParseObjectTypeMembers();
      return this.finishNode(node, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      this.expect(8);
      return members;
    }
    tsIsStartOfMappedType() {
      this.next();
      if (this.eat(53)) {
        return this.isContextual(122);
      }
      if (this.isContextual(122)) {
        this.next();
      }
      if (!this.match(0)) {
        return false;
      }
      this.next();
      if (!this.tsIsIdentifier()) {
        return false;
      }
      this.next();
      return this.match(58);
    }
    tsParseMappedTypeParameter() {
      const node = this.startNode();
      node.name = this.tsParseTypeParameterName();
      node.constraint = this.tsExpectThenParseType(58);
      return this.finishNode(node, "TSTypeParameter");
    }
    tsParseMappedType() {
      const node = this.startNode();
      this.expect(5);
      if (this.match(53)) {
        node.readonly = this.state.value;
        this.next();
        this.expectContextual(122);
      } else if (this.eatContextual(122)) {
        node.readonly = true;
      }
      this.expect(0);
      node.typeParameter = this.tsParseMappedTypeParameter();
      node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
      this.expect(3);
      if (this.match(53)) {
        node.optional = this.state.value;
        this.next();
        this.expect(17);
      } else if (this.eat(17)) {
        node.optional = true;
      }
      node.typeAnnotation = this.tsTryParseType();
      this.semicolon();
      this.expect(8);
      return this.finishNode(node, "TSMappedType");
    }
    tsParseTupleType() {
      const node = this.startNode();
      node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let seenOptionalElement = false;
      node.elementTypes.forEach((elementNode) => {
        const {
          type
        } = elementNode;
        if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
          this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
        }
        seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
      });
      return this.finishNode(node, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        startLoc
      } = this.state;
      const rest = this.eat(21);
      let labeled;
      let label;
      let optional;
      let type;
      const isWord = tokenIsKeywordOrIdentifier(this.state.type);
      const chAfterWord = isWord ? this.lookaheadCharCode() : null;
      if (chAfterWord === 58) {
        labeled = true;
        optional = false;
        label = this.parseIdentifier(true);
        this.expect(14);
        type = this.tsParseType();
      } else if (chAfterWord === 63) {
        optional = true;
        const startLoc2 = this.state.startLoc;
        const wordName = this.state.value;
        const typeOrLabel = this.tsParseNonArrayType();
        if (this.lookaheadCharCode() === 58) {
          labeled = true;
          label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
          this.expect(17);
          this.expect(14);
          type = this.tsParseType();
        } else {
          labeled = false;
          type = typeOrLabel;
          this.expect(17);
        }
      } else {
        type = this.tsParseType();
        optional = this.eat(17);
        labeled = this.eat(14);
      }
      if (labeled) {
        let labeledNode;
        if (label) {
          labeledNode = this.startNodeAtNode(label);
          labeledNode.optional = optional;
          labeledNode.label = label;
          labeledNode.elementType = type;
          if (this.eat(17)) {
            labeledNode.optional = true;
            this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
          }
        } else {
          labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          this.raise(TSErrors.InvalidTupleMemberLabel, type);
          labeledNode.label = type;
          labeledNode.elementType = this.tsParseType();
        }
        type = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type);
        optionalTypeNode.typeAnnotation = type;
        type = this.finishNode(optionalTypeNode, "TSOptionalType");
      }
      if (rest) {
        const restNode = this.startNodeAt(startLoc);
        restNode.typeAnnotation = type;
        type = this.finishNode(restNode, "TSRestType");
      }
      return type;
    }
    tsParseParenthesizedType() {
      const node = this.startNode();
      this.expect(10);
      node.typeAnnotation = this.tsParseType();
      this.expect(11);
      return this.finishNode(node, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(type, abstract) {
      const node = this.startNode();
      if (type === "TSConstructorType") {
        node.abstract = !!abstract;
        if (abstract)
          this.next();
        this.next();
      }
      this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
      return this.finishNode(node, type);
    }
    tsParseLiteralTypeNode() {
      const node = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          node.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(node, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const node = this.startNode();
      node.literal = super.parseTemplate(false);
      return this.finishNode(node, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      if (this.state.inType)
        return this.tsParseType();
      return super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword);
      } else {
        return thisKeyword;
      }
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const node = this.startNode();
            const nextToken = this.lookahead();
            if (nextToken.type !== 134 && nextToken.type !== 135) {
              this.unexpected();
            }
            node.literal = this.parseMaybeUnary();
            return this.finishNode(node, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type) || type === 88 || type === 84) {
            const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
              const node = this.startNode();
              this.next();
              return this.finishNode(node, nodeType);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let type = this.tsParseNonArrayType();
      while (!this.hasPrecedingLineBreak() && this.eat(0)) {
        if (this.match(3)) {
          const node = this.startNodeAtNode(type);
          node.elementType = type;
          this.expect(3);
          type = this.finishNode(node, "TSArrayType");
        } else {
          const node = this.startNodeAtNode(type);
          node.objectType = type;
          node.indexType = this.tsParseType();
          this.expect(3);
          type = this.finishNode(node, "TSIndexedAccessType");
        }
      }
      return type;
    }
    tsParseTypeOperator() {
      const node = this.startNode();
      const operator = this.state.value;
      this.next();
      node.operator = operator;
      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
      if (operator === "readonly") {
        this.tsCheckTypeAnnotationForReadOnly(node);
      }
      return this.finishNode(node, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(node) {
      switch (node.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(TSErrors.UnexpectedReadonly, node);
      }
    }
    tsParseInferType() {
      const node = this.startNode();
      this.expectContextual(115);
      const typeParameter = this.startNode();
      typeParameter.name = this.tsParseTypeParameterName();
      typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      return this.finishNode(node, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
          return constraint;
        }
      }
    }
    tsParseTypeOperatorOrHigher() {
      const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
      return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node = this.startNode();
      const hasLeadingOperator = this.eat(operator);
      const types2 = [];
      do {
        types2.push(parseConstituentType());
      } while (this.eat(operator));
      if (types2.length === 1 && !hasLeadingOperator) {
        return types2[0];
      }
      node.types = types2;
      return this.finishNode(node, kind);
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      if (this.match(47)) {
        return true;
      }
      return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (tokenIsIdentifier(this.state.type) || this.match(78)) {
        this.next();
        return true;
      }
      if (this.match(5)) {
        const {
          errors
        } = this.state;
        const previousErrorCount = errors.length;
        try {
          this.parseObjectLike(8, true);
          return errors.length === previousErrorCount;
        } catch (_unused) {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors
        } = this.state;
        const previousErrorCount = errors.length;
        try {
          super.parseBindingList(3, 93, 1);
          return errors.length === previousErrorCount;
        } catch (_unused2) {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      this.next();
      if (this.match(11) || this.match(21)) {
        return true;
      }
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
          return true;
        }
        if (this.match(11)) {
          this.next();
          if (this.match(19)) {
            return true;
          }
        }
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const node = this.startNode();
        const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (asserts && this.match(78)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
          if (thisTypePredicate.type === "TSThisType") {
            node.parameterName = thisTypePredicate;
            node.asserts = true;
            node.typeAnnotation = null;
            thisTypePredicate = this.finishNode(node, "TSTypePredicate");
          } else {
            this.resetStartLocationFromNode(thisTypePredicate, node);
            thisTypePredicate.asserts = true;
          }
          t.typeAnnotation = thisTypePredicate;
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t);
          }
          node.parameterName = this.parseIdentifier();
          node.asserts = asserts;
          node.typeAnnotation = null;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const type = this.tsParseTypeAnnotation(false);
        node.parameterName = typePredicateVariable;
        node.typeAnnotation = type;
        node.asserts = asserts;
        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14)) {
        return this.tsParseTypeOrTypePredicateAnnotation(14);
      }
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14)) {
        return this.tsParseTypeAnnotation();
      }
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
        this.next();
        return id;
      }
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109) {
        return false;
      }
      const containsEsc = this.state.containsEsc;
      this.next();
      if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
        return false;
      }
      if (containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
          reservedWord: "asserts"
        });
      }
      return true;
    }
    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
      this.tsInType(() => {
        if (eatColon)
          this.expect(14);
        t.typeAnnotation = this.tsParseType();
      });
      return this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      assert(this.state.inType);
      const type = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
        return type;
      }
      const node = this.startNodeAtNode(type);
      node.checkType = type;
      node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
      this.expect(17);
      node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
      this.expect(14);
      node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
      return this.finishNode(node, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      }
      if (this.match(77)) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      } else if (this.isAbstractConstructorSignature()) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
      }
      return this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
        this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
      }
      const node = this.startNode();
      node.typeAnnotation = this.tsInType(() => {
        this.next();
        return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
      });
      this.expect(48);
      node.expression = this.parseMaybeUnary();
      return this.finishNode(node, "TSTypeAssertion");
    }
    tsParseHeritageClause(token) {
      const originalStartLoc = this.state.startLoc;
      const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const node = this.startNode();
        node.expression = this.tsParseEntityName();
        if (this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSExpressionWithTypeArguments");
      });
      if (!delimitedList.length) {
        this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
          token
        });
      }
      return delimitedList;
    }
    tsParseInterfaceDeclaration(node, properties = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(129);
      if (properties.declare)
        node.declare = true;
      if (tokenIsIdentifier(this.state.type)) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 130);
      } else {
        node.id = null;
        this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
      }
      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      if (this.eat(81)) {
        node.extends = this.tsParseHeritageClause("extends");
      }
      const body = this.startNode();
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
      node.body = this.finishNode(body, "TSInterfaceBody");
      return this.finishNode(node, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(node) {
      node.id = this.parseIdentifier();
      this.checkIdentifier(node.id, 2);
      node.typeAnnotation = this.tsInType(() => {
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
        this.expect(29);
        if (this.isContextual(114) && this.lookahead().type !== 16) {
          const node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      });
      this.semicolon();
      return this.finishNode(node, "TSTypeAliasDeclaration");
    }
    tsInNoContext(cb) {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];
      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }
    tsInDisallowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsInAllowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsEatThenParseType(token) {
      if (this.match(token)) {
        return this.tsNextThenParseType();
      }
    }
    tsExpectThenParseType(token) {
      return this.tsInType(() => {
        this.expect(token);
        return this.tsParseType();
      });
    }
    tsNextThenParseType() {
      return this.tsInType(() => {
        this.next();
        return this.tsParseType();
      });
    }
    tsParseEnumMember() {
      const node = this.startNode();
      node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
      if (this.eat(29)) {
        node.initializer = super.parseMaybeAssignAllowIn();
      }
      return this.finishNode(node, "TSEnumMember");
    }
    tsParseEnumDeclaration(node, properties = {}) {
      if (properties.const)
        node.const = true;
      if (properties.declare)
        node.declare = true;
      this.expectContextual(126);
      node.id = this.parseIdentifier();
      this.checkIdentifier(node.id, node.const ? 8971 : 8459);
      this.expect(5);
      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
      this.expect(8);
      return this.finishNode(node, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const node = this.startNode();
      this.scope.enter(0);
      this.expect(5);
      super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
      this.scope.exit();
      return this.finishNode(node, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(node, nested = false) {
      node.id = this.parseIdentifier();
      if (!nested) {
        this.checkIdentifier(node.id, 1024);
      }
      if (this.eat(16)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, true);
        node.body = inner;
      } else {
        this.scope.enter(256);
        this.prodParam.enter(0);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      }
      return this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(node) {
      if (this.isContextual(112)) {
        node.global = true;
        node.id = this.parseIdentifier();
      } else if (this.match(133)) {
        node.id = super.parseStringLiteral(this.state.value);
      } else {
        this.unexpected();
      }
      if (this.match(5)) {
        this.scope.enter(256);
        this.prodParam.enter(0);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      } else {
        this.semicolon();
      }
      return this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
      node.isExport = isExport || false;
      node.id = maybeDefaultIdentifier || this.parseIdentifier();
      this.checkIdentifier(node.id, 4096);
      this.expect(29);
      const moduleReference = this.tsParseModuleReference();
      if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
        this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
      }
      node.moduleReference = moduleReference;
      this.semicolon();
      return this.finishNode(node, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const node = this.startNode();
      this.expectContextual(119);
      this.expect(10);
      if (!this.match(133)) {
        this.unexpected();
      }
      node.expression = super.parseExprAtom();
      this.expect(11);
      this.sawUnambiguousESM = true;
      return this.finishNode(node, "TSExternalModuleReference");
    }
    tsLookAhead(f) {
      const state = this.state.clone();
      const res = f();
      this.state = state;
      return res;
    }
    tsTryParseAndCatch(f) {
      const result = this.tryParse((abort) => f() || abort());
      if (result.aborted || !result.node)
        return;
      if (result.error)
        this.state = result.failState;
      return result.node;
    }
    tsTryParse(f) {
      const state = this.state.clone();
      const result = f();
      if (result !== undefined && result !== false) {
        return result;
      }
      this.state = state;
    }
    tsTryParseDeclare(nany) {
      if (this.isLineTerminator()) {
        return;
      }
      let startType = this.state.type;
      let kind;
      if (this.isContextual(100)) {
        startType = 74;
        kind = "let";
      }
      return this.tsInAmbientContext(() => {
        switch (startType) {
          case 68:
            nany.declare = true;
            return super.parseFunctionStatement(nany, false, false);
          case 80:
            nany.declare = true;
            return this.parseClass(nany, true, false);
          case 126:
            return this.tsParseEnumDeclaration(nany, {
              declare: true
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          case 75:
          case 74:
            if (!this.match(75) || !this.isLookaheadContextual("enum")) {
              nany.declare = true;
              return this.parseVarStatement(nany, kind || this.state.value, true);
            }
            this.expect(75);
            return this.tsParseEnumDeclaration(nany, {
              const: true,
              declare: true
            });
          case 129: {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: true
            });
            if (result)
              return result;
          }
          default:
            if (tokenIsIdentifier(startType)) {
              return this.tsParseDeclaration(nany, this.state.value, true, null);
            }
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
    }
    tsParseExpressionStatement(node, expr, decorators) {
      switch (expr.name) {
        case "declare": {
          const declaration = this.tsTryParseDeclare(node);
          if (declaration) {
            declaration.declare = true;
          }
          return declaration;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256);
            this.prodParam.enter(0);
            const mod = node;
            mod.global = true;
            mod.id = expr;
            mod.body = this.tsParseModuleBlock();
            this.scope.exit();
            this.prodParam.exit();
            return this.finishNode(mod, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(node, expr.name, false, decorators);
      }
    }
    tsParseDeclaration(node, value, next, decorators) {
      switch (value) {
        case "abstract":
          if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
            return this.tsParseAbstractDeclaration(node, decorators);
          }
          break;
        case "module":
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(133)) {
              return this.tsParseAmbientExternalModuleDeclaration(node);
            } else if (tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }
          break;
        case "type":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
            return this.tsParseTypeAliasDeclaration(node);
          }
          break;
      }
    }
    tsCheckLineTerminator(next) {
      if (next) {
        if (this.hasFollowingLineBreak())
          return false;
        this.next();
        return true;
      }
      return !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(startLoc) {
      if (!this.match(47))
        return;
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const res = this.tsTryParseAndCatch(() => {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        super.parseFunctionParams(node);
        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
        this.expect(19);
        return node;
      });
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      if (!res)
        return;
      return super.parseArrowExpression(res, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() !== 47)
        return;
      return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const node = this.startNode();
      node.params = this.tsInType(() => this.tsInNoContext(() => {
        this.expect(47);
        return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
      }));
      if (node.params.length === 0) {
        this.raise(TSErrors.EmptyTypeArguments, node);
      } else if (!this.state.inType && this.curContext() === types.brace) {
        this.reScan_lt_gt();
      }
      this.expect(48);
      return this.finishNode(node, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return tokenIsTSDeclarationStart(this.state.type);
    }
    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart())
        return false;
      return super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(flags, decorators) {
      const startLoc = this.state.startLoc;
      const modified = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, modified);
      const accessibility = modified.accessibility;
      const override = modified.override;
      const readonly = modified.readonly;
      if (!(flags & 4) && (accessibility || readonly || override)) {
        this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
      }
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left, flags);
      const elt = this.parseMaybeDefault(left.loc.start, left);
      if (accessibility || readonly || override) {
        const pp = this.startNodeAt(startLoc);
        if (decorators.length) {
          pp.decorators = decorators;
        }
        if (accessibility)
          pp.accessibility = accessibility;
        if (readonly)
          pp.readonly = readonly;
        if (override)
          pp.override = override;
        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
          this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
        }
        pp.parameter = elt;
        return this.finishNode(pp, "TSParameterProperty");
      }
      if (decorators.length) {
        left.decorators = decorators;
      }
      return elt;
    }
    isSimpleParameter(node) {
      return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
    }
    tsDisallowOptionalPattern(node) {
      for (const param of node.params) {
        if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
          this.raise(TSErrors.PatternIsOptional, param);
        }
      }
    }
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
      super.setArrowFunctionParameters(node, params, trailingCommaLoc);
      this.tsDisallowOptionalPattern(node);
    }
    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(14)) {
        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
      }
      const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
      if (bodilessType && !this.match(5) && this.isLineTerminator()) {
        return this.finishNode(node, bodilessType);
      }
      if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
        this.raise(TSErrors.DeclareFunctionHasImplementation, node);
        if (node.declare) {
          return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
        }
      }
      this.tsDisallowOptionalPattern(node);
      return super.parseFunctionBodyAndFinish(node, type, isMethod);
    }
    registerFunctionStatementId(node) {
      if (!node.body && node.id) {
        this.checkIdentifier(node.id, 1024);
      } else {
        super.registerFunctionStatementId(node);
      }
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node) => {
        if ((node == null ? undefined : node.type) === "TSTypeCastExpression") {
          this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
        }
      });
    }
    toReferencedList(exprList, isInParens) {
      this.tsCheckForInvalidTypeCasts(exprList);
      return exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      if (node.type === "ArrayExpression") {
        this.tsCheckForInvalidTypeCasts(node.elements);
      }
      return node;
    }
    parseSubscript(base, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false;
        this.next();
        const nonNullExpression = this.startNodeAt(startLoc);
        nonNullExpression.expression = base;
        return this.finishNode(nonNullExpression, "TSNonNullExpression");
      }
      let isOptionalCall = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (noCalls) {
          state.stop = true;
          return base;
        }
        state.optionalChainMember = isOptionalCall = true;
        this.next();
      }
      if (this.match(47) || this.match(51)) {
        let missingParenErrorLoc;
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
            if (asyncArrowFn) {
              return asyncArrowFn;
            }
          }
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (!typeArguments)
            return;
          if (isOptionalCall && !this.match(10)) {
            missingParenErrorLoc = this.state.curPosition();
            return;
          }
          if (tokenIsTemplate(this.state.type)) {
            const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
            result2.typeParameters = typeArguments;
            return result2;
          }
          if (!noCalls && this.eat(10)) {
            const node2 = this.startNodeAt(startLoc);
            node2.callee = base;
            node2.arguments = this.parseCallExpressionArguments(11, false);
            this.tsCheckForInvalidTypeCasts(node2.arguments);
            node2.typeParameters = typeArguments;
            if (state.optionalChainMember) {
              node2.optional = isOptionalCall;
            }
            return this.finishCallExpression(node2, state.optionalChainMember);
          }
          const tokenType = this.state.type;
          if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
            return;
          }
          const node = this.startNodeAt(startLoc);
          node.expression = base;
          node.typeParameters = typeArguments;
          return this.finishNode(node, "TSInstantiationExpression");
        });
        if (missingParenErrorLoc) {
          this.unexpected(missingParenErrorLoc, 10);
        }
        if (result) {
          if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
          }
          return result;
        }
      }
      return super.parseSubscript(base, startLoc, noCalls, state);
    }
    parseNewCallee(node) {
      var _callee$extra;
      super.parseNewCallee(node);
      const {
        callee
      } = node;
      if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
        node.typeParameters = callee.typeParameters;
        node.callee = callee.expression;
      }
    }
    parseExprOp(left, leftStartLoc, minPrec) {
      let isSatisfies;
      if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
        const node = this.startNodeAt(leftStartLoc);
        node.expression = left;
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          if (this.match(75)) {
            if (isSatisfies) {
              this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                keyword: "const"
              });
            }
            return this.tsParseTypeReference();
          }
          return this.tsParseType();
        });
        this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
        this.reScan_lt_gt();
        return this.parseExprOp(node, leftStartLoc, minPrec);
      }
      return super.parseExprOp(left, leftStartLoc, minPrec);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (!this.state.isAmbientContext) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
      }
    }
    checkImportReflection(node) {
      super.checkImportReflection(node);
      if (node.module && node.importKind !== "value") {
        this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
      }
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport))
        return true;
      if (this.isContextual(130)) {
        const ch = this.lookaheadCharCode();
        return isExport ? ch === 123 || ch === 42 : ch !== 61;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node, isExport, phase, loc) {
      super.applyImportPhase(node, isExport, phase, loc);
      if (isExport) {
        node.exportKind = phase === "type" ? "type" : "value";
      } else {
        node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
    }
    parseImport(node) {
      if (this.match(133)) {
        node.importKind = "value";
        return super.parseImport(node);
      }
      let importNode;
      if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
        node.importKind = "value";
        return this.tsParseImportEqualsDeclaration(node);
      } else if (this.isContextual(130)) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
        if (this.lookaheadCharCode() === 61) {
          return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
        } else {
          importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
        }
      } else {
        importNode = super.parseImport(node);
      }
      if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
      }
      return importNode;
    }
    parseExport(node, decorators) {
      if (this.match(83)) {
        this.next();
        let maybeDefaultIdentifier = null;
        if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
          maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
        } else {
          node.importKind = "value";
        }
        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);
      } else if (this.eat(29)) {
        const assign = node;
        assign.expression = super.parseExpression();
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const decl = node;
        this.expectContextual(128);
        decl.id = this.parseIdentifier();
        this.semicolon();
        return this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else {
        return super.parseExport(node, decorators);
      }
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        this.next();
        cls.abstract = true;
        return this.parseClass(cls, true, true);
      }
      if (this.match(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result)
          return result;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(node, kind, allowMissingInitializer = false) {
      const {
        isAmbientContext
      } = this.state;
      const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
      if (!isAmbientContext)
        return declaration;
      for (const {
        id,
        init
      } of declaration.declarations) {
        if (!init)
          continue;
        if (kind !== "const" || !!id.typeAnnotation) {
          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
        } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
          this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
        }
      }
      return declaration;
    }
    parseStatementContent(flags, decorators) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const node = this.startNode();
        this.expect(75);
        return this.tsParseEnumDeclaration(node, {
          const: true
        });
      }
      if (this.isContextual(126)) {
        return this.tsParseEnumDeclaration(this.startNode());
      }
      if (this.isContextual(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result)
          return result;
      }
      return super.parseStatementContent(flags, decorators);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => {
        if (tsIsAccessModifier(modifier)) {
          return member.accessibility === modifier;
        }
        return !!member[modifier];
      });
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(classBody, member, state) {
      const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: modifiers,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: true,
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      }, member);
      const callParseClassMemberWithIsStatic = () => {
        if (this.tsIsStartOfStaticBlocks()) {
          this.next();
          this.next();
          if (this.tsHasSomeModifiers(member, modifiers)) {
            this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
          }
          super.parseClassStaticBlock(classBody, member);
        } else {
          this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
        }
      };
      if (member.declare) {
        this.tsInAmbientContext(callParseClassMemberWithIsStatic);
      } else {
        callParseClassMemberWithIsStatic();
      }
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const idx = this.tsTryParseIndexSignature(member);
      if (idx) {
        classBody.body.push(idx);
        if (member.abstract) {
          this.raise(TSErrors.IndexSignatureHasAbstract, member);
        }
        if (member.accessibility) {
          this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
            modifier: member.accessibility
          });
        }
        if (member.declare) {
          this.raise(TSErrors.IndexSignatureHasDeclare, member);
        }
        if (member.override) {
          this.raise(TSErrors.IndexSignatureHasOverride, member);
        }
        return;
      }
      if (!this.state.inAbstractClass && member.abstract) {
        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
      }
      if (member.override) {
        if (!state.hadSuperClass) {
          this.raise(TSErrors.OverrideNotInSubClass, member);
        }
      }
      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(17);
      if (optional)
        methodOrProp.optional = true;
      if (methodOrProp.readonly && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
      }
      if (methodOrProp.declare && this.match(10)) {
        this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
      }
    }
    parseExpressionStatement(node, expr, decorators) {
      const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;
      return decl || super.parseExpressionStatement(node, expr, decorators);
    }
    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart())
        return true;
      return super.shouldParseExportDeclaration();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(17)) {
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      }
      const result = this.tryParse(() => super.parseConditional(expr, startLoc));
      if (!result.node) {
        if (result.error) {
          super.setOptionalParametersError(refExpressionErrors, result.error);
        }
        return expr;
      }
      if (result.error)
        this.state = result.failState;
      return result.node;
    }
    parseParenItem(node, startLoc) {
      node = super.parseParenItem(node, startLoc);
      if (this.eat(17)) {
        node.optional = true;
        this.resetEndLocation(node);
      }
      if (this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TSTypeCastExpression");
      }
      return node;
    }
    parseExportDeclaration(node) {
      if (!this.state.isAmbientContext && this.isContextual(125)) {
        return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
      }
      const startLoc = this.state.startLoc;
      const isDeclare = this.eatContextual(125);
      if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      }
      const isIdentifier = tokenIsIdentifier(this.state.type);
      const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
      if (!declaration)
        return null;
      if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
        node.exportKind = "type";
      }
      if (isDeclare) {
        this.resetStartLocation(declaration, startLoc);
        declaration.declare = true;
      }
      return declaration;
    }
    parseClassId(node, isStatement, optionalId, bindingType) {
      if ((!isStatement || optionalId) && this.isContextual(113)) {
        return;
      }
      super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      if (typeParameters)
        node.typeParameters = typeParameters;
    }
    parseClassPropertyAnnotation(node) {
      if (!node.optional) {
        if (this.eat(35)) {
          node.definite = true;
        } else if (this.eat(17)) {
          node.optional = true;
        }
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        node.typeAnnotation = type;
    }
    parseClassProperty(node) {
      this.parseClassPropertyAnnotation(node);
      if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
        this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
      }
      if (node.abstract && this.match(29)) {
        const {
          key
        } = node;
        this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
        });
      }
      return super.parseClassProperty(node);
    }
    parseClassPrivateProperty(node) {
      if (node.abstract) {
        this.raise(TSErrors.PrivateElementHasAbstract, node);
      }
      if (node.accessibility) {
        this.raise(TSErrors.PrivateElementHasAccessibility, node, {
          modifier: node.accessibility
        });
      }
      this.parseClassPropertyAnnotation(node);
      return super.parseClassPrivateProperty(node);
    }
    parseClassAccessorProperty(node) {
      this.parseClassPropertyAnnotation(node);
      if (node.optional) {
        this.raise(TSErrors.AccessorCannotBeOptional, node);
      }
      return super.parseClassAccessorProperty(node);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters && isConstructor) {
        this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
      }
      const {
        declare = false,
        kind
      } = method;
      if (declare && (kind === "get" || kind === "set")) {
        this.raise(TSErrors.DeclareAccessor, method, {
          kind
        });
      }
      if (typeParameters)
        method.typeParameters = typeParameters;
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters)
        method.typeParameters = typeParameters;
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    declareClassPrivateMethodInScope(node, kind) {
      if (node.type === "TSDeclareMethod")
        return;
      if (node.type === "MethodDefinition" && !node.value.body)
        return;
      super.declareClassPrivateMethodInScope(node, kind);
    }
    parseClassSuper(node) {
      super.parseClassSuper(node);
      if (node.superClass && (this.match(47) || this.match(51))) {
        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
      }
      if (this.eatContextual(113)) {
        node.implements = this.tsParseHeritageClause("implements");
      }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters)
        prop.typeParameters = typeParameters;
      return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
    }
    parseFunctionParams(node, isConstructor) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      if (typeParameters)
        node.typeParameters = typeParameters;
      super.parseFunctionParams(node, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
        decl.definite = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        decl.id.typeAnnotation = type;
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(14)) {
        node.returnType = this.tsParseTypeAnnotation();
      }
      return super.parseAsyncArrowFromCallExpression(node, call);
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
      let state;
      let jsx2;
      let typeCast;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        state = this.state.clone();
        jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx2.error)
          return jsx2.node;
        const {
          context
        } = this.state;
        const currentContext = context[context.length - 1];
        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
          context.pop();
        }
      }
      if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      if (!state || state === this.state)
        state = this.state.clone();
      let typeParameters;
      const arrow = this.tryParse((abort) => {
        var _expr$extra, _typeParameters;
        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          abort();
        }
        if (((_typeParameters = typeParameters) == null ? undefined : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters);
        }
        expr.typeParameters = typeParameters;
        return expr;
      }, state);
      if (!arrow.error && !arrow.aborted) {
        if (typeParameters)
          this.reportReservedArrowTypeParam(typeParameters);
        return arrow.node;
      }
      if (!jsx2) {
        assert(!this.hasPlugin("jsx"));
        typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!typeCast.error)
          return typeCast.node;
      }
      if ((_jsx2 = jsx2) != null && _jsx2.node) {
        this.state = jsx2.failState;
        return jsx2.node;
      }
      if (arrow.node) {
        this.state = arrow.failState;
        if (typeParameters)
          this.reportReservedArrowTypeParam(typeParameters);
        return arrow.node;
      }
      if ((_typeCast = typeCast) != null && _typeCast.node) {
        this.state = typeCast.failState;
        return typeCast.node;
      }
      throw ((_jsx3 = jsx2) == null ? undefined : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? undefined : _typeCast2.error);
    }
    reportReservedArrowTypeParam(node) {
      var _node$extra;
      if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
        this.raise(TSErrors.ReservedArrowTypeParam, node);
      }
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      if (!this.hasPlugin("jsx") && this.match(47)) {
        return this.tsParseTypeAssertion();
      }
      return super.parseMaybeUnary(refExpressionErrors, sawUnary);
    }
    parseArrow(node) {
      if (this.match(14)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          if (this.canInsertSemicolon() || !this.match(19))
            abort();
          return returnType;
        });
        if (result.aborted)
          return;
        if (!result.thrown) {
          if (result.error)
            this.state = result.failState;
          node.returnType = result.node;
        }
      }
      return super.parseArrow(node);
    }
    parseAssignableListItemTypes(param, flags) {
      if (!(flags & 2))
        return param;
      if (this.eat(17)) {
        param.optional = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        param.typeAnnotation = type;
      this.resetEndLocation(param);
      return param;
    }
    isAssignable(node, isBinding) {
      switch (node.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(node.expression, isBinding);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(node, isBinding);
      }
    }
    toAssignable(node, isLHS = false) {
      switch (node.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(node, isLHS);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          if (isLHS) {
            this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
          } else {
            this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
          }
          this.toAssignable(node.expression, isLHS);
          break;
        case "AssignmentExpression":
          if (!isLHS && node.left.type === "TSTypeCastExpression") {
            node.left = this.typeCastToParameter(node.left);
          }
        default:
          super.toAssignable(node, isLHS);
      }
    }
    toAssignableParenthesizedExpression(node, isLHS) {
      switch (node.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isLHS);
          break;
        default:
          super.toAssignable(node, isLHS);
      }
    }
    checkToRestConversion(node, allowPattern) {
      switch (node.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(node.expression, false);
          break;
        default:
          super.checkToRestConversion(node, allowPattern);
      }
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
      return getOwn({
        TSTypeCastExpression: true,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
        TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
        TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true]
      }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
    }
    parseBindingAtom() {
      if (this.state.type === 78) {
        return this.parseIdentifier(true);
      }
      return super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const call = super.parseMaybeDecoratorArguments(expr);
          call.typeParameters = typeArguments;
          return call;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(expr);
    }
    checkCommaAfterRest(close) {
      if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
        this.next();
        return false;
      }
      return super.checkCommaAfterRest(close);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(startLoc, left) {
      const node = super.parseMaybeDefault(startLoc, left);
      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
      }
      return node;
    }
    getTokenFromCode(code2) {
      if (this.state.inType) {
        if (code2 === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (code2 === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(code2);
    }
    reScan_lt_gt() {
      const {
        type
      } = this.state;
      if (type === 47) {
        this.state.pos -= 1;
        this.readToken_lt();
      } else if (type === 48) {
        this.state.pos -= 1;
        this.readToken_gt();
      }
    }
    reScan_lt() {
      const {
        type
      } = this.state;
      if (type === 51) {
        this.state.pos -= 2;
        this.finishOp(47, 1);
        return 47;
      }
      return type;
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i = 0;i < exprList.length; i++) {
        const expr = exprList[i];
        if ((expr == null ? undefined : expr.type) === "TSTypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
      return node.expression;
    }
    shouldParseArrow(params) {
      if (this.match(14)) {
        return params.every((expr) => this.isAssignable(expr, true));
      }
      return super.shouldParseArrow(params);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(node) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        if (typeArguments)
          node.typeParameters = typeArguments;
      }
      return super.jsxParseOpeningElementAfterName(node);
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const firstParam = params[0];
      const hasContextParam = firstParam && this.isThisParam(firstParam);
      return hasContextParam ? baseCount + 1 : baseCount;
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam();
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        param.typeAnnotation = type;
        this.resetEndLocation(param);
      }
      return param;
    }
    tsInAmbientContext(cb) {
      const oldIsAmbientContext = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return cb();
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext;
      }
    }
    parseClass(node, isStatement, optionalId) {
      const oldInAbstractClass = this.state.inAbstractClass;
      this.state.inAbstractClass = !!node.abstract;
      try {
        return super.parseClass(node, isStatement, optionalId);
      } finally {
        this.state.inAbstractClass = oldInAbstractClass;
      }
    }
    tsParseAbstractDeclaration(node, decorators) {
      if (this.match(80)) {
        node.abstract = true;
        return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
      } else if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak()) {
          node.abstract = true;
          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);
          return this.tsParseInterfaceDeclaration(node);
        }
      } else {
        this.unexpected(null, 80);
      }
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
      const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
      if (method.abstract) {
        const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
        if (hasBody) {
          const {
            key
          } = method;
          this.raise(TSErrors.AbstractMethodHasImplementation, method, {
            methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
          });
        }
      }
      return method;
    }
    tsParseTypeParameterName() {
      const typeName = this.parseIdentifier();
      return typeName.name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.parse();
    }
    getExpression() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.getExpression();
    }
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
      if (!isString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
        return this.finishNode(node, "ExportSpecifier");
      }
      node.exportKind = "value";
      return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (!importedIsString && isMaybeTypeOnly) {
        this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
        return this.finishNode(specifier, "ImportSpecifier");
      }
      specifier.importKind = "value";
      return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
    }
    parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
      const leftOfAsKey = isImport ? "imported" : "local";
      const rightOfAsKey = isImport ? "local" : "exported";
      let leftOfAs = node[leftOfAsKey];
      let rightOfAs;
      let hasTypeSpecifier = false;
      let canParseAsKeyword = true;
      const loc = leftOfAs.loc.start;
      if (this.isContextual(93)) {
        const firstAs = this.parseIdentifier();
        if (this.isContextual(93)) {
          const secondAs = this.parseIdentifier();
          if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            canParseAsKeyword = false;
          } else {
            rightOfAs = secondAs;
            canParseAsKeyword = false;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          canParseAsKeyword = false;
          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        } else {
          hasTypeSpecifier = true;
          leftOfAs = firstAs;
        }
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        hasTypeSpecifier = true;
        if (isImport) {
          leftOfAs = this.parseIdentifier(true);
          if (!this.isContextual(93)) {
            this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
          }
        } else {
          leftOfAs = this.parseModuleExportName();
        }
      }
      if (hasTypeSpecifier && isInTypeOnlyImportExport) {
        this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
      }
      node[leftOfAsKey] = leftOfAs;
      node[rightOfAsKey] = rightOfAs;
      const kindKey = isImport ? "importKind" : "exportKind";
      node[kindKey] = hasTypeSpecifier ? "type" : "value";
      if (canParseAsKeyword && this.eatContextual(93)) {
        node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
      }
      if (!node[rightOfAsKey]) {
        node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
      }
      if (isImport) {
        this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
      }
    }
  };
  var PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(144)) {
        const node = this.startNode();
        this.next();
        this.assertNoSpace();
        node.name = super.parseIdentifier(true);
        this.assertNoSpace();
        this.expect(144);
        return this.finishPlaceholder(node, expectedNode);
      }
    }
    finishPlaceholder(node, expectedNode) {
      const isFinished = !!(node.expectedNode && node.type === "Placeholder");
      node.expectedNode = expectedNode;
      return isFinished ? node : this.finishNode(node, "Placeholder");
    }
    getTokenFromCode(code2) {
      if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        this.finishOp(144, 2);
      } else {
        super.getTokenFromCode(code2);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
    }
    parseIdentifier(liberal) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word !== undefined) {
        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
      }
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(type, isParenthesized, binding) {
      return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
    }
    toAssignable(node, isLHS) {
      if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
        node.expectedNode = "Pattern";
      } else {
        super.toAssignable(node, isLHS);
      }
    }
    chStartsBindingIdentifier(ch, pos) {
      if (super.chStartsBindingIdentifier(ch, pos)) {
        return true;
      }
      const nextToken = this.lookahead();
      if (nextToken.type === 144) {
        return true;
      }
      return false;
    }
    verifyBreakContinue(node, isBreak) {
      if (node.label && node.label.type === "Placeholder")
        return;
      super.verifyBreakContinue(node, isBreak);
    }
    parseExpressionStatement(node, expr) {
      var _expr$extra;
      if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
        return super.parseExpressionStatement(node, expr);
      }
      if (this.match(14)) {
        const stmt = node;
        stmt.label = this.finishPlaceholder(expr, "Identifier");
        this.next();
        stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
        return this.finishNode(stmt, "LabeledStatement");
      }
      this.semicolon();
      node.name = expr.name;
      return this.finishPlaceholder(node, "Statement");
    }
    parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    }
    parseFunctionId(requireId) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
    }
    parseClass(node, isStatement, optionalId) {
      const type = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const oldStrict = this.state.strict;
      const placeholder = this.parsePlaceholder("Identifier");
      if (placeholder) {
        if (this.match(81) || this.match(144) || this.match(5)) {
          node.id = placeholder;
        } else if (optionalId || !isStatement) {
          node.id = null;
          node.body = this.finishPlaceholder(placeholder, "ClassBody");
          return this.finishNode(node, type);
        } else {
          throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
        }
      } else {
        this.parseClassId(node, isStatement, optionalId);
      }
      super.parseClassSuper(node);
      node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, type);
    }
    parseExport(node, decorators) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder)
        return super.parseExport(node, decorators);
      if (!this.isContextual(98) && !this.match(12)) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.finishPlaceholder(placeholder, "Declaration");
        return this.finishNode(node, "ExportNamedDeclaration");
      }
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = placeholder;
      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return super.parseExport(node, decorators);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const next = this.nextTokenStart();
        if (this.isUnparsedContextual(next, "from")) {
          if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
            return true;
          }
        }
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
      var _specifiers;
      if ((_specifiers = node.specifiers) != null && _specifiers.length) {
        return true;
      }
      return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
    }
    checkExport(node) {
      const {
        specifiers
      } = node;
      if (specifiers != null && specifiers.length) {
        node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
      }
      super.checkExport(node);
      node.specifiers = specifiers;
    }
    parseImport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder)
        return super.parseImport(node);
      node.specifiers = [];
      if (!this.isContextual(98) && !this.match(12)) {
        node.source = this.finishPlaceholder(placeholder, "StringLiteral");
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      const specifier = this.startNodeAtNode(placeholder);
      specifier.local = placeholder;
      node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
      if (this.eat(12)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node);
        if (!hasStarImport)
          this.parseNamedImportSpecifiers(node);
      }
      this.expectContextual(98);
      node.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      if (this.state.start > this.state.lastTokEndLoc.index) {
        this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
      }
    }
  };
  var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const v8IntrinsicStartLoc = this.state.startLoc;
        const node = this.startNode();
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          const name = this.parseIdentifierName();
          const identifier = this.createIdentifier(node, name);
          identifier.type = "V8IntrinsicIdentifier";
          if (this.match(10)) {
            return identifier;
          }
        }
        this.unexpected(v8IntrinsicStartLoc);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    }
  };
  var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
  var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
  var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  var mixinPlugins = {
    estree,
    jsx,
    flow,
    typescript,
    v8intrinsic,
    placeholders
  };
  var mixinPluginNames = Object.keys(mixinPlugins);
  var defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowNewTargetOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createImportExpressions: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true,
    annexB: true
  };

  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }
      const key = prop.key;
      const name = key.type === "Identifier" ? key.name : key.value;
      if (name === "__proto__") {
        if (isRecord) {
          this.raise(Errors.RecordNoProto, key);
          return;
        }
        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProtoLoc === null) {
              refExpressionErrors.doubleProtoLoc = key.loc.start;
            }
          } else {
            this.raise(Errors.DuplicateProto, key);
          }
        }
        protoRef.used = true;
      }
    }
    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }
    getExpression() {
      this.enterInitialScopes();
      this.nextToken();
      const expr = this.parseExpression();
      if (!this.match(139)) {
        this.unexpected();
      }
      this.finalizeRemainingComments();
      expr.comments = this.comments;
      expr.errors = this.state.errors;
      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }
      return expr;
    }
    parseExpression(disallowIn, refExpressionErrors) {
      if (disallowIn) {
        return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    parseExpressionBase(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const expr = this.parseMaybeAssign(refExpressionErrors);
      if (this.match(12)) {
        const node = this.startNodeAt(startLoc);
        node.expressions = [expr];
        while (this.eat(12)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }
        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$loc;
      refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? undefined : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      const startLoc = this.state.startLoc;
      if (this.isContextual(108)) {
        if (this.prodParam.hasYield) {
          let left2 = this.parseYield();
          if (afterLeftParse) {
            left2 = afterLeftParse.call(this, left2, startLoc);
          }
          return left2;
        }
      }
      let ownExpressionErrors;
      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors;
        ownExpressionErrors = true;
      }
      const {
        type
      } = this.state;
      if (type === 10 || tokenIsIdentifier(type)) {
        this.state.potentialArrowAt = this.state.start;
      }
      let left = this.parseMaybeConditional(refExpressionErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startLoc);
      }
      if (tokenIsAssignment(this.state.type)) {
        const node = this.startNodeAt(startLoc);
        const operator = this.state.value;
        node.operator = operator;
        if (this.match(29)) {
          this.toAssignable(left, true);
          node.left = left;
          const startIndex = startLoc.index;
          if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
            refExpressionErrors.doubleProtoLoc = null;
          }
          if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
            refExpressionErrors.shorthandAssignLoc = null;
          }
          if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
            this.checkDestructuringPrivate(refExpressionErrors);
            refExpressionErrors.privateKeyLoc = null;
          }
        } else {
          node.left = left;
        }
        this.next();
        node.right = this.parseMaybeAssign();
        this.checkLVal(left, {
          in: this.finishNode(node, "AssignmentExpression")
        });
        return node;
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      return left;
    }
    parseMaybeConditional(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprOps(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (this.eat(17)) {
        const node = this.startNodeAt(startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(14);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    }
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    parseExprOps(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseExprOp(expr, startLoc, -1);
    }
    parseExprOp(left, leftStartLoc, minPrec) {
      if (this.isPrivateName(left)) {
        const value = this.getPrivateNameSV(left);
        if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
          this.raise(Errors.PrivateInExpectedIn, left, {
            identifierName: value
          });
        }
        this.classScope.usePrivateName(value, left.loc.start);
      }
      const op = this.state.type;
      if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
        let prec = tokenOperatorPrecedence(op);
        if (prec > minPrec) {
          if (op === 39) {
            this.expectPlugin("pipelineOperator");
            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }
            this.checkPipelineAtInfixOperator(left, leftStartLoc);
          }
          const node = this.startNodeAt(leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          const logical = op === 41 || op === 42;
          const coalesce = op === 40;
          if (coalesce) {
            prec = tokenOperatorPrecedence(42);
          }
          this.next();
          if (op === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }])) {
            if (this.state.type === 96 && this.prodParam.hasAwait) {
              throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
            }
          }
          node.right = this.parseExprOpRightExpr(op, prec);
          const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          const nextOp = this.state.type;
          if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
            throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
          }
          return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
        }
      }
      return left;
    }
    parseExprOpRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      switch (op) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => {
                return this.parseHackPipeBody();
              });
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) {
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                }
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(prec);
              });
          }
        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
    parseExprOpBaseRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
    parseHackPipeBody() {
      var _body$extra;
      const {
        startLoc
      } = this.state;
      const body = this.parseMaybeAssign();
      const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
      if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
        this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
          type: body.type
        });
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipeTopicUnused, startLoc);
      }
      return body;
    }
    checkExponentialAfterUnary(node) {
      if (this.match(57)) {
        this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
      }
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startLoc = this.state.startLoc;
      const isAwait = this.isContextual(96);
      if (isAwait && this.isAwaitAllowed()) {
        this.next();
        const expr2 = this.parseAwait(startLoc);
        if (!sawUnary)
          this.checkExponentialAfterUnary(expr2);
        return expr2;
      }
      const update = this.match(34);
      const node = this.startNode();
      if (tokenIsPrefix(this.state.type)) {
        node.operator = this.state.value;
        node.prefix = true;
        if (this.match(72)) {
          this.expectPlugin("throwExpressions");
        }
        const isDelete = this.match(89);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);
        if (this.state.strict && isDelete) {
          const arg = node.argument;
          if (arg.type === "Identifier") {
            this.raise(Errors.StrictDelete, node);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(Errors.DeletePrivateField, node);
          }
        }
        if (!update) {
          if (!sawUnary) {
            this.checkExponentialAfterUnary(node);
          }
          return this.finishNode(node, "UnaryExpression");
        }
      }
      const expr = this.parseUpdate(node, update, refExpressionErrors);
      if (isAwait) {
        const {
          type
        } = this.state;
        const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
        if (startsExpr2 && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
          return this.parseAwait(startLoc);
        }
      }
      return expr;
    }
    parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        const updateExpressionNode = node;
        this.checkLVal(updateExpressionNode.argument, {
          in: this.finishNode(updateExpressionNode, "UpdateExpression")
        });
        return node;
      }
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false))
        return expr;
      while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
        const node2 = this.startNodeAt(startLoc);
        node2.operator = this.state.value;
        node2.prefix = false;
        node2.argument = expr;
        this.next();
        this.checkLVal(expr, {
          in: expr = this.finishNode(node2, "UpdateExpression")
        });
      }
      return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprAtom(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseSubscripts(expr, startLoc);
    }
    parseSubscripts(base, startLoc, noCalls) {
      const state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };
      do {
        base = this.parseSubscript(base, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);
      return base;
    }
    parseSubscript(base, startLoc, noCalls, state) {
      const {
        type
      } = this.state;
      if (!noCalls && type === 15) {
        return this.parseBind(base, startLoc, noCalls, state);
      } else if (tokenIsTemplate(type)) {
        return this.parseTaggedTemplateExpression(base, startLoc, state);
      }
      let optional = false;
      if (type === 18) {
        if (noCalls) {
          this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
          if (this.lookaheadCharCode() === 40) {
            state.stop = true;
            return base;
          }
        }
        state.optionalChainMember = optional = true;
        this.next();
      }
      if (!noCalls && this.match(10)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
      } else {
        const computed = this.eat(0);
        if (computed || optional || this.eat(16)) {
          return this.parseMember(base, startLoc, state, computed, optional);
        } else {
          state.stop = true;
          return base;
        }
      }
    }
    parseMember(base, startLoc, state, computed, optional) {
      const node = this.startNodeAt(startLoc);
      node.object = base;
      node.computed = computed;
      if (computed) {
        node.property = this.parseExpression();
        this.expect(3);
      } else if (this.match(138)) {
        if (base.type === "Super") {
          this.raise(Errors.SuperPrivateField, startLoc);
        }
        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
        node.property = this.parsePrivateName();
      } else {
        node.property = this.parseIdentifier(true);
      }
      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    }
    parseBind(base, startLoc, noCalls, state) {
      const node = this.startNodeAt(startLoc);
      node.object = base;
      this.next();
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
    }
    parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      let refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      const node = this.startNodeAt(startLoc);
      node.callee = base;
      const {
        maybeAsyncArrow,
        optionalChainMember
      } = state;
      if (maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors;
      }
      if (optionalChainMember) {
        node.optional = optional;
      }
      if (optional) {
        node.arguments = this.parseCallExpressionArguments(11);
      } else {
        node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
      }
      let finishedNode = this.finishCallExpression(node, optionalChainMember);
      if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
      } else {
        if (maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }
        this.toReferencedArguments(finishedNode);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return finishedNode;
    }
    toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
    parseTaggedTemplateExpression(base, startLoc, state) {
      const node = this.startNodeAt(startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);
      if (state.optionalChainMember) {
        this.raise(Errors.OptionalChainingNoTemplate, startLoc);
      }
      return this.finishNode(node, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      if (!this.hasPlugin("importAssertions")) {
        this.expectPlugin("importAttributes");
      }
    }
    finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          {
            if (!this.hasPlugin("moduleAttributes")) {
              this.expectImportAttributesPlugin();
            }
          }
        }
        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(Errors.ImportCallArity, node, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        } else {
          for (const arg of node.arguments) {
            if (arg.type === "SpreadElement") {
              this.raise(Errors.ImportCallSpreadArgument, arg);
            }
          }
        }
      }
      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      const elts = [];
      let first = true;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);
            }
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
      }
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;
      this.resetPreviousNodeTrailingComments(call);
      this.expect(19);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? undefined : _call$extra.trailingCommaLoc);
      if (call.innerComments) {
        setInnerComments(node, call.innerComments);
      }
      if (call.callee.trailingComments) {
        setInnerComments(node, call.callee.trailingComments);
      }
      return node;
    }
    parseNoCallExpr() {
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    }
    parseExprAtom(refExpressionErrors) {
      let node;
      let decorators = null;
      const {
        type
      } = this.state;
      switch (type) {
        case 79:
          return this.parseSuper();
        case 83:
          node = this.startNode();
          this.next();
          if (this.match(16)) {
            return this.parseImportMetaProperty(node);
          }
          if (this.match(10)) {
            if (this.options.createImportExpressions) {
              return this.parseImportCall(node);
            } else {
              return this.finishNode(node, "Import");
            }
          } else {
            this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
            return this.finishNode(node, "Import");
          }
        case 78:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case 90: {
          return this.parseDo(this.startNode(), false);
        }
        case 56:
        case 31: {
          this.readRegexp();
          return this.parseRegExpLiteral(this.state.value);
        }
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        case 2:
        case 1: {
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        }
        case 0: {
          return this.parseArrayLike(3, true, false, refExpressionErrors);
        }
        case 6:
        case 7: {
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        }
        case 5: {
          return this.parseObjectLike(8, false, false, refExpressionErrors);
        }
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          decorators = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          node = this.startNode();
          this.next();
          node.object = null;
          const callee = node.callee = this.parseNoCallExpr();
          if (callee.type === "MemberExpression") {
            return this.finishNode(node, "BindExpression");
          } else {
            throw this.raise(Errors.UnsupportedBind, callee);
          }
        }
        case 138: {
          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          });
          return this.parsePrivateName();
        }
        case 33: {
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        }
        case 32: {
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        }
        case 37:
        case 38: {
          return this.parseTopicReference("hack");
        }
        case 44:
        case 54:
        case 27: {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            return this.parseTopicReference(pipeProposal);
          }
          this.unexpected();
          break;
        }
        case 47: {
          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
            this.expectOnePlugin(["jsx", "flow", "typescript"]);
          } else {
            this.unexpected();
          }
          break;
        }
        default:
          if (tokenIsIdentifier(type)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
              return this.parseModuleExpression();
            }
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            const containsEsc = this.state.containsEsc;
            const id = this.parseIdentifier();
            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: type2
              } = this.state;
              if (type2 === 68) {
                this.resetPreviousNodeTrailingComments(id);
                this.next();
                return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
              } else if (tokenIsIdentifier(type2)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                } else {
                  return id;
                }
              } else if (type2 === 90) {
                this.resetPreviousNodeTrailingComments(id);
                return this.parseDo(this.startNodeAtNode(id), true);
              }
            }
            if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }
            return id;
          } else {
            this.unexpected();
          }
      }
    }
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
      const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
      if (pipeProposal) {
        this.state.type = topicTokenType;
        this.state.value = topicTokenValue;
        this.state.pos--;
        this.state.end--;
        this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
        return this.parseTopicReference(pipeProposal);
      } else {
        this.unexpected();
      }
    }
    parseTopicReference(pipeProposal) {
      const node = this.startNode();
      const startLoc = this.state.startLoc;
      const tokenType = this.state.type;
      this.next();
      return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    }
    finishTopicReference(node, startLoc, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
        const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        if (!this.topicReferenceIsAllowedInCurrentContext()) {
          this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);
        }
        this.registerTopicReference();
        return this.finishNode(node, nodeType);
      } else {
        throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
          token: tokenLabelName(tokenType)
        });
      }
    }
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
      switch (pipeProposal) {
        case "hack": {
          return this.hasPlugin(["pipelineOperator", {
            topicToken: tokenLabelName(tokenType)
          }]);
        }
        case "smart":
          return tokenType === 27;
        default:
          throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
      }
    }
    parseAsyncArrowUnaryFunction(node) {
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      this.prodParam.exit();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
      }
      this.expect(19);
      return this.parseArrowExpression(node, params, true);
    }
    parseDo(node, isAsync) {
      this.expectPlugin("doExpressions");
      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }
      node.async = isAsync;
      this.next();
      const oldLabels = this.state.labels;
      this.state.labels = [];
      if (isAsync) {
        this.prodParam.enter(2);
        node.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node.body = this.parseBlock();
      }
      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    }
    parseSuper() {
      const node = this.startNode();
      this.next();
      if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(Errors.SuperNotAllowed, node);
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(Errors.UnexpectedSuper, node);
      }
      if (!this.match(10) && !this.match(0) && !this.match(16)) {
        this.raise(Errors.UnsupportedSuper, node);
      }
      return this.finishNode(node, "Super");
    }
    parsePrivateName() {
      const node = this.startNode();
      const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
      const name = this.state.value;
      this.next();
      node.id = this.createIdentifier(id, name);
      return this.finishNode(node, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const node = this.startNode();
      this.next();
      if (this.prodParam.hasYield && this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        if (this.match(103)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
        return this.parseMetaProperty(node, meta, "sent");
      }
      return this.parseFunction(node);
    }
    parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;
      const containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);
      if (node.property.name !== propertyName || containsEsc) {
        this.raise(Errors.UnsupportedMetaProperty, node.property, {
          target: meta.name,
          onlyValidPropertyName: propertyName
        });
      }
      return this.finishNode(node, "MetaProperty");
    }
    parseImportMetaProperty(node) {
      const id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();
      if (this.isContextual(101)) {
        if (!this.inModule) {
          this.raise(Errors.ImportMetaOutsideModule, id);
        }
        this.sawUnambiguousESM = true;
      } else if (this.isContextual(105) || this.isContextual(97)) {
        const isSource = this.isContextual(105);
        if (!isSource)
          this.unexpected();
        this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
        if (!this.options.createImportExpressions) {
          throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        }
        this.next();
        node.phase = isSource ? "source" : "defer";
        return this.parseImportCall(node);
      }
      return this.parseMetaProperty(node, id, "meta");
    }
    parseLiteralAtNode(value, type, node) {
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }
    parseLiteral(value, type) {
      const node = this.startNode();
      return this.parseLiteralAtNode(value, type, node);
    }
    parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }
    parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }
    parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    }
    parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }
    parseRegExpLiteral(value) {
      const node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;
    }
    parseBooleanLiteral(value) {
      const node = this.startNode();
      node.value = value;
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }
    parseNullLiteral() {
      const node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      const startLoc = this.state.startLoc;
      let val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      const innerStartLoc = this.state.startLoc;
      const exprList = [];
      const refExpressionErrors = new ExpressionErrors;
      let first = true;
      let spreadStartLoc;
      let optionalCommaStartLoc;
      while (!this.match(11)) {
        if (first) {
          first = false;
        } else {
          this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
          if (this.match(11)) {
            optionalCommaStartLoc = this.state.startLoc;
            break;
          }
        }
        if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          spreadStartLoc = this.state.startLoc;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
          if (!this.checkCommaAfterRest(41)) {
            break;
          }
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
      }
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(11);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startLoc);
      if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }
      this.expressionScope.exit();
      if (!exprList.length) {
        this.unexpected(this.state.lastTokStartLoc);
      }
      if (optionalCommaStartLoc)
        this.unexpected(optionalCommaStartLoc);
      if (spreadStartLoc)
        this.unexpected(spreadStartLoc);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartLoc);
        val.expressions = exprList;
        this.finishNode(val, "SequenceExpression");
        this.resetEndLocation(val, innerEndLoc);
      } else {
        val = exprList[0];
      }
      return this.wrapParenthesis(startLoc, val);
    }
    wrapParenthesis(startLoc, expression) {
      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(expression, "parenthesized", true);
        this.addExtra(expression, "parenStart", startLoc.index);
        this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
        return expression;
      }
      const parenExpression = this.startNodeAt(startLoc);
      parenExpression.expression = expression;
      return this.finishNode(parenExpression, "ParenthesizedExpression");
    }
    shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
    parseArrow(node) {
      if (this.eat(19)) {
        return node;
      }
    }
    parseParenItem(node, startLoc) {
      return node;
    }
    parseNewOrNewTarget() {
      const node = this.startNode();
      this.next();
      if (this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node, meta, "target");
        if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
          this.raise(Errors.UnexpectedNewTarget, metaProp);
        }
        return metaProp;
      }
      return this.parseNew(node);
    }
    parseNew(node) {
      this.parseNewCallee(node);
      if (this.eat(10)) {
        const args = this.parseExprList(11);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
      return this.finishNode(node, "NewExpression");
    }
    parseNewCallee(node) {
      const isImport = this.match(83);
      const callee = this.parseNoCallExpr();
      node.callee = callee;
      if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
        this.raise(Errors.ImportCallNotNewExpression, callee);
      }
    }
    parseTemplateElement(isTagged) {
      const {
        start,
        startLoc,
        end,
        value
      } = this.state;
      const elemStart = start + 1;
      const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
      if (value === null) {
        if (!isTagged) {
          this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
        }
      }
      const isTail = this.match(24);
      const endOffset = isTail ? -1 : -2;
      const elemEnd = end + endOffset;
      elem.value = {
        raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
        cooked: value === null ? null : value.slice(1, endOffset)
      };
      elem.tail = isTail;
      this.next();
      const finishedNode = this.finishNode(elem, "TemplateElement");
      this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
      return finishedNode;
    }
    parseTemplate(isTagged) {
      const node = this.startNode();
      node.expressions = [];
      let curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];
      while (!curElt.tail) {
        node.expressions.push(this.parseTemplateSubstitution());
        this.readTemplateContinuation();
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }
      return this.finishNode(node, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const propHash = Object.create(null);
      let first = true;
      const node = this.startNode();
      node.properties = [];
      this.next();
      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            this.addTrailingCommaExtraToNode(node);
            break;
          }
        }
        let prop;
        if (isPattern) {
          prop = this.parseBindingProperty();
        } else {
          prop = this.parsePropertyDefinition(refExpressionErrors);
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }
        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(Errors.InvalidRecordProperty, prop);
        }
        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }
        node.properties.push(prop);
      }
      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type = "ObjectExpression";
      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }
      return this.finishNode(node, type);
    }
    addTrailingCommaExtraToNode(node) {
      this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
      this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(refExpressionErrors) {
      let decorators = [];
      if (this.match(26)) {
        if (this.hasPlugin("decorators")) {
          this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
        }
        while (this.match(26)) {
          decorators.push(this.parseDecorator());
        }
      }
      const prop = this.startNode();
      let isAsync = false;
      let isAccessor = false;
      let startLoc;
      if (this.match(21)) {
        if (decorators.length)
          this.unexpected();
        return this.parseSpread();
      }
      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }
      prop.method = false;
      if (refExpressionErrors) {
        startLoc = this.state.startLoc;
      }
      let isGenerator = this.eat(55);
      this.parsePropertyNamePrefixOperator(prop);
      const containsEsc = this.state.containsEsc;
      const key = this.parsePropertyName(prop, refExpressionErrors);
      if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const keyName = key.name;
        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          this.resetPreviousNodeTrailingComments(key);
          isGenerator = this.eat(55);
          this.parsePropertyName(prop);
        }
        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          this.resetPreviousNodeTrailingComments(key);
          prop.kind = keyName;
          if (this.match(55)) {
            isGenerator = true;
            this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
              kind: keyName
            });
            this.next();
          }
          this.parsePropertyName(prop);
        }
      }
      return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
    }
    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method) {
      return method.params;
    }
    checkGetterSetterParams(method) {
      var _params;
      const paramCount = this.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length !== paramCount) {
        this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
      }
      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? undefined : _params.type) === "RestElement") {
        this.raise(Errors.BadSetterRestParameter, method);
      }
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(finishedProp);
        return finishedProp;
      }
      if (isAsync || isGenerator || this.match(10)) {
        if (isPattern)
          this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;
      if (this.eat(14)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }
      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        } else if (this.match(29)) {
          const shorthandAssignLoc = this.state.startLoc;
          if (refExpressionErrors != null) {
            if (refExpressionErrors.shorthandAssignLoc === null) {
              refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
            }
          } else {
            this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
          }
          prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        } else {
          prop.value = cloneIdentifier(prop.key);
        }
        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      if (!node)
        this.unexpected();
      return node;
    }
    parsePropertyName(prop, refExpressionErrors) {
      if (this.eat(0)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(3);
      } else {
        const {
          type,
          value
        } = this.state;
        let key;
        if (tokenIsKeywordOrIdentifier(type)) {
          key = this.parseIdentifier(true);
        } else {
          switch (type) {
            case 134:
              key = this.parseNumericLiteral(value);
              break;
            case 133:
              key = this.parseStringLiteral(value);
              break;
            case 135:
              key = this.parseBigIntLiteral(value);
              break;
            case 136:
              key = this.parseDecimalLiteral(value);
              break;
            case 138: {
              const privateKeyLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.privateKeyLoc === null) {
                  refExpressionErrors.privateKeyLoc = privateKeyLoc;
                }
              } else {
                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
              }
              key = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        }
        prop.key = key;
        if (type !== 138) {
          prop.computed = false;
        }
      }
      return prop.key;
    }
    initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = isAsync;
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      this.initFunction(node, isAsync);
      node.generator = isGenerator;
      this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, isConstructor);
      const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return finishedNode;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
      this.scope.enter(2 | 4);
      let flags = functionFlags(isAsync, false);
      if (!this.match(5) && this.prodParam.hasIn) {
        flags |= 8;
      }
      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaLoc);
      }
      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
      this.toAssignableList(params, trailingCommaLoc, false);
      node.params = params;
    }
    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      this.parseFunctionBody(node, false, isMethod);
      return this.finishNode(node, type);
    }
    parseFunctionBody(node, allowExpression, isMethod = false) {
      const isExpression = allowExpression && !this.match(5);
      this.expressionScope.enter(newExpressionScope());
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        const oldStrict = this.state.strict;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | 4);
        node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
          const nonSimple = !this.isSimpleParamList(node.params);
          if (hasStrictModeDirective && nonSimple) {
            this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
          }
          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
          if (this.state.strict && node.id) {
            this.checkIdentifier(node.id, 65, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.state.labels = oldLabels;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(node) {
      return node.type === "Identifier";
    }
    isSimpleParamList(params) {
      for (let i = 0, len = params.length;i < len; i++) {
        if (!this.isSimpleParameter(params[i]))
          return false;
      }
      return true;
    }
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      const checkClashes = !allowDuplicates && new Set;
      const formalParameters = {
        type: "FormalParameters"
      };
      for (const param of node.params) {
        this.checkLVal(param, {
          in: formalParameters,
          binding: 5,
          checkClashes,
          strictModeChanged
        });
      }
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }
      return elts;
    }
    parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      let elt;
      if (this.match(12)) {
        if (!allowEmpty) {
          this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
            unexpected: ","
          });
        }
        elt = null;
      } else if (this.match(21)) {
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication");
        if (!allowPlaceholder) {
          this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
        }
        const node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      }
      return elt;
    }
    parseIdentifier(liberal) {
      const node = this.startNode();
      const name = this.parseIdentifierName(liberal);
      return this.createIdentifier(node, name);
    }
    createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }
    parseIdentifierName(liberal) {
      let name;
      const {
        startLoc,
        type
      } = this.state;
      if (tokenIsKeywordOrIdentifier(type)) {
        name = this.state.value;
      } else {
        this.unexpected();
      }
      const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
      if (liberal) {
        if (tokenIsKeyword2) {
          this.replaceToken(132);
        }
      } else {
        this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
      }
      this.next();
      return name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }
      if (!canBeReservedWord(word)) {
        return;
      }
      if (checkKeywords && isKeyword(word)) {
        this.raise(Errors.UnexpectedKeyword, startLoc, {
          keyword: word
        });
        return;
      }
      const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
      if (reservedTest(word, this.inModule)) {
        this.raise(Errors.UnexpectedReservedWord, startLoc, {
          reservedWord: word
        });
        return;
      } else if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Errors.YieldBindingIdentifier, startLoc);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Errors.AwaitBindingIdentifier, startLoc);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(startLoc);
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(Errors.ArgumentsInClass, startLoc);
          return;
        }
      }
    }
    isAwaitAllowed() {
      if (this.prodParam.hasAwait)
        return true;
      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }
      return false;
    }
    parseAwait(startLoc) {
      const node = this.startNodeAt(startLoc);
      this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
      if (this.eat(55)) {
        this.raise(Errors.ObsoleteAwaitStar, node);
      }
      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }
      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }
      return this.finishNode(node, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return true;
      const {
        type
      } = this.state;
      return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
    }
    parseYield() {
      const node = this.startNode();
      this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
      this.next();
      let delegating = false;
      let argument = null;
      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(55);
        switch (this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!delegating)
              break;
          default:
            argument = this.parseMaybeAssign();
        }
      }
      node.delegate = delegating;
      node.argument = argument;
      return this.finishNode(node, "YieldExpression");
    }
    parseImportCall(node) {
      this.next();
      node.source = this.parseMaybeAssignAllowIn();
      if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        node.options = null;
      }
      if (this.eat(12)) {
        this.expectImportAttributesPlugin();
        if (!this.match(11)) {
          node.options = this.parseMaybeAssignAllowIn();
          this.eat(12);
        }
      }
      this.expect(11);
      return this.finishNode(node, "ImportExpression");
    }
    checkPipelineAtInfixOperator(left, leftStartLoc) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        if (left.type === "SequenceExpression") {
          this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
        }
      }
    }
    parseSmartPipelineBodyInStyle(childExpr, startLoc) {
      if (this.isSimpleReference(childExpr)) {
        const bodyNode = this.startNodeAt(startLoc);
        bodyNode.callee = childExpr;
        return this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        const bodyNode = this.startNodeAt(startLoc);
        this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
        bodyNode.expression = childExpr;
        return this.finishNode(bodyNode, "PipelineTopicExpression");
      }
    }
    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(startLoc) {
      if (this.match(19)) {
        throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipelineTopicUnused, startLoc);
      }
    }
    withTopicBindingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withSmartMixTopicForbiddingContext(callback) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else {
        return callback();
      }
    }
    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToSet = 8 & ~flags;
      if (prodParamToSet) {
        this.prodParam.enter(flags | 8);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToClear = 8 & flags;
      if (prodParamToClear) {
        this.prodParam.enter(flags & ~8);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec) {
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const node = this.startNode();
      this.next();
      if (!this.match(5)) {
        this.unexpected(null, 5);
      }
      const program = this.startNodeAt(this.state.endLoc);
      this.next();
      const revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      try {
        node.body = this.parseProgram(program, 8, "module");
      } finally {
        revertScopes();
      }
      return this.finishNode(node, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(prop) {
    }
  }
  var loopLabel = {
    kind: 1
  };
  var switchLabel = {
    kind: 2
  };
  var loneSurrogate = /[\uD800-\uDFFF]/u;
  var keywordRelationalOperator = /in(?:stanceof)?/y;

  class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.comments;
      if (this.options.tokens) {
        file.tokens = babel7CompatTokens(this.tokens, this.input);
      }
      return this.finishNode(file, "File");
    }
    parseProgram(program, end = 139, sourceType = this.options.sourceType) {
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);
      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
          this.raise(Errors.ModuleExportUndefined, at, {
            localName
          });
        }
      }
      let finishedProgram;
      if (end === 139) {
        finishedProgram = this.finishNode(program, "Program");
      } else {
        finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
      }
      return finishedProgram;
    }
    stmtToDirective(stmt) {
      const directive = stmt;
      directive.type = "Directive";
      directive.value = directive.expression;
      delete directive.expression;
      const directiveLiteral = directive.value;
      const expressionValue = directiveLiteral.value;
      const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
      const val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      this.addExtra(directiveLiteral, "expressionValue", expressionValue);
      directiveLiteral.type = "DirectiveLiteral";
      return directive;
    }
    parseInterpreterDirective() {
      if (!this.match(28)) {
        return null;
      }
      const node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }
    isLet() {
      if (!this.isContextual(100)) {
        return false;
      }
      return this.hasFollowingBindingAtom();
    }
    chStartsBindingIdentifier(ch, pos) {
      if (isIdentifierStart(ch)) {
        keywordRelationalOperator.lastIndex = pos;
        if (keywordRelationalOperator.test(this.input)) {
          const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }
        return true;
      } else if (ch === 92) {
        return true;
      } else {
        return false;
      }
    }
    chStartsBindingPattern(ch) {
      return ch === 91 || ch === 123;
    }
    hasFollowingBindingAtom() {
      const next = this.nextTokenStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    hasInLineFollowingBindingIdentifier() {
      const next = this.nextTokenInLineStart();
      const nextCh = this.codePointAtPos(next);
      return this.chStartsBindingIdentifier(nextCh, next);
    }
    startsUsingForOf() {
      const {
        type,
        containsEsc
      } = this.lookahead();
      if (type === 102 && !containsEsc) {
        return false;
      } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
        this.expectPlugin("explicitResourceManagement");
        return true;
      }
    }
    startsAwaitUsing() {
      let next = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(next, "using")) {
        next = this.nextTokenInLineStartSince(next + 5);
        const nextCh = this.codePointAtPos(next);
        if (this.chStartsBindingIdentifier(nextCh, next)) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      return false;
    }
    parseModuleItem() {
      return this.parseStatementLike(1 | 2 | 4 | 8);
    }
    parseStatementListItem() {
      return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
      let flags = 0;
      if (this.options.annexB && !this.state.strict) {
        flags |= 4;
        if (allowLabeledFunction) {
          flags |= 8;
        }
      }
      return this.parseStatementLike(flags);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(flags) {
      let decorators = null;
      if (this.match(26)) {
        decorators = this.parseDecorators(true);
      }
      return this.parseStatementContent(flags, decorators);
    }
    parseStatementContent(flags, decorators) {
      const starttype = this.state.type;
      const node = this.startNode();
      const allowDeclaration = !!(flags & 2);
      const allowFunctionDeclaration = !!(flags & 4);
      const topLevel = flags & 1;
      switch (starttype) {
        case 60:
          return this.parseBreakContinueStatement(node, true);
        case 63:
          return this.parseBreakContinueStatement(node, false);
        case 64:
          return this.parseDebuggerStatement(node);
        case 90:
          return this.parseDoWhileStatement(node);
        case 91:
          return this.parseForStatement(node);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          if (!allowFunctionDeclaration) {
            this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
          }
          return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
        case 80:
          if (!allowDeclaration)
            this.unexpected();
          return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
        case 69:
          return this.parseIfStatement(node);
        case 70:
          return this.parseReturnStatement(node);
        case 71:
          return this.parseSwitchStatement(node);
        case 72:
          return this.parseThrowStatement(node);
        case 73:
          return this.parseTryStatement(node);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing()) {
            if (!this.isAwaitAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, node);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, node);
            }
            this.next();
            return this.parseVarStatement(node, "await using");
          }
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
            break;
          }
          this.expectPlugin("explicitResourceManagement");
          if (!this.scope.inModule && this.scope.inTopLevel) {
            this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
          } else if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
          }
          return this.parseVarStatement(node, "using");
        case 100: {
          if (this.state.containsEsc) {
            break;
          }
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          if (nextCh !== 91) {
            if (!allowDeclaration && this.hasFollowingLineBreak())
              break;
            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
              break;
            }
          }
        }
        case 75: {
          if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
          }
        }
        case 74: {
          const kind = this.state.value;
          return this.parseVarStatement(node, kind);
        }
        case 92:
          return this.parseWhileStatement(node);
        case 76:
          return this.parseWithStatement(node);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(node);
        case 83: {
          const nextTokenCharCode = this.lookaheadCharCode();
          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }
        case 82: {
          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
          }
          this.next();
          let result;
          if (starttype === 83) {
            result = this.parseImport(node);
            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node, decorators);
            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
              this.sawUnambiguousESM = true;
            }
          }
          this.assertModuleNodeAllowed(result);
          return result;
        }
        default: {
          if (this.isAsyncFunction()) {
            if (!allowDeclaration) {
              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
            }
            this.next();
            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
          }
        }
      }
      const maybeName = this.state.value;
      const expr = this.parseExpression();
      if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
        return this.parseLabeledStatement(node, maybeName, expr, flags);
      } else {
        return this.parseExpressionStatement(node, expr, decorators);
      }
    }
    assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(Errors.ImportOutsideModule, node);
      }
    }
    decoratorsEnabledBeforeExport() {
      if (this.hasPlugin("decorators-legacy"))
        return true;
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
    }
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
      if (maybeDecorators) {
        if (classNode.decorators && classNode.decorators.length > 0) {
          if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
            this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
          }
          classNode.decorators.unshift(...maybeDecorators);
        } else {
          classNode.decorators = maybeDecorators;
        }
        this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
        if (exportNode)
          this.resetStartLocationFromNode(exportNode, classNode);
      }
      return classNode;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(allowExport) {
      const decorators = [];
      do {
        decorators.push(this.parseDecorator());
      } while (this.match(26));
      if (this.match(82)) {
        if (!allowExport) {
          this.unexpected();
        }
        if (!this.decoratorsEnabledBeforeExport()) {
          this.raise(Errors.DecoratorExportClass, this.state.startLoc);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
      }
      return decorators;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const node = this.startNode();
      this.next();
      if (this.hasPlugin("decorators")) {
        const startLoc = this.state.startLoc;
        let expr;
        if (this.match(10)) {
          const startLoc2 = this.state.startLoc;
          this.next();
          expr = this.parseExpression();
          this.expect(11);
          expr = this.wrapParenthesis(startLoc2, expr);
          const paramsStartLoc = this.state.startLoc;
          node.expression = this.parseMaybeDecoratorArguments(expr);
          if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
            this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
          }
        } else {
          expr = this.parseIdentifier(false);
          while (this.eat(16)) {
            const node2 = this.startNodeAt(startLoc);
            node2.object = expr;
            if (this.match(138)) {
              this.classScope.usePrivateName(this.state.value, this.state.startLoc);
              node2.property = this.parsePrivateName();
            } else {
              node2.property = this.parseIdentifier(true);
            }
            node2.computed = false;
            expr = this.finishNode(node2, "MemberExpression");
          }
          node.expression = this.parseMaybeDecoratorArguments(expr);
        }
      } else {
        node.expression = this.parseExprSubscripts();
      }
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(10)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(11, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }
      return expr;
    }
    parseBreakContinueStatement(node, isBreak) {
      this.next();
      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }
      this.verifyBreakContinue(node, isBreak);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node, isBreak) {
      let i;
      for (i = 0;i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === 1)) {
            break;
          }
          if (node.label && isBreak)
            break;
        }
      }
      if (i === this.state.labels.length) {
        const type = isBreak ? "BreakStatement" : "ContinueStatement";
        this.raise(Errors.IllegalBreakContinue, node, {
          type
        });
      }
    }
    parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const val = this.parseExpression();
      this.expect(11);
      return val;
    }
    parseDoWhileStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.state.labels.pop();
      this.expect(92);
      node.test = this.parseHeaderExpression();
      this.eat(13);
      return this.finishNode(node, "DoWhileStatement");
    }
    parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      let awaitAt = null;
      if (this.isAwaitAllowed() && this.eatContextual(96)) {
        awaitAt = this.state.lastTokStartLoc;
      }
      this.scope.enter(0);
      this.expect(10);
      if (this.match(13)) {
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, null);
      }
      const startsWithLet = this.isContextual(100);
      {
        const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
        const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
        const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
        if (this.match(74) || this.match(75) || isLetOrUsing) {
          const initNode = this.startNode();
          let kind;
          if (startsWithAwaitUsing) {
            kind = "await using";
            if (!this.isAwaitAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
            }
            this.next();
          } else {
            kind = this.state.value;
          }
          this.next();
          this.parseVar(initNode, true, kind);
          const init2 = this.finishNode(initNode, "VariableDeclaration");
          const isForIn = this.match(58);
          if (isForIn && starsWithUsingDeclaration) {
            this.raise(Errors.ForInUsing, init2);
          }
          if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
            return this.parseForIn(node, init2, awaitAt);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init2);
        }
      }
      const startsWithAsync = this.isContextual(95);
      const refExpressionErrors = new ExpressionErrors;
      const init = this.parseExpression(true, refExpressionErrors);
      const isForOf = this.isContextual(102);
      if (isForOf) {
        if (startsWithLet) {
          this.raise(Errors.ForOfLet, init);
        }
        if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
          this.raise(Errors.ForOfAsync, init);
        }
      }
      if (isForOf || this.match(58)) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.toAssignable(init, true);
        const type = isForOf ? "ForOfStatement" : "ForInStatement";
        this.checkLVal(init, {
          in: {
            type
          }
        });
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    }
    parseFunctionStatement(node, isAsync, isHangingDeclaration) {
      this.next();
      return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    }
    parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
      node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
      return this.finishNode(node, "IfStatement");
    }
    parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(Errors.IllegalReturn, this.state.startLoc);
      }
      this.next();
      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    }
    parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      const cases = node.cases = [];
      this.expect(5);
      this.state.labels.push(switchLabel);
      this.scope.enter(0);
      let cur;
      for (let sawDefault;!this.match(8); ) {
        if (this.match(61) || this.match(65)) {
          const isCase = this.match(61);
          if (cur)
            this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(14);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatementListItem());
          } else {
            this.unexpected();
          }
        }
      }
      this.scope.exit();
      if (cur)
        this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }
    parseThrowStatement(node) {
      this.next();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
      }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
      this.checkLVal(param, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      });
      return param;
    }
    parseTryStatement(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.match(62)) {
        const clause = this.startNode();
        this.next();
        if (this.match(10)) {
          this.expect(10);
          clause.param = this.parseCatchClauseParam();
          this.expect(11);
        } else {
          clause.param = null;
          this.scope.enter(0);
        }
        clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(67) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(Errors.NoCatchOrFinally, node);
      }
      return this.finishNode(node, "TryStatement");
    }
    parseVarStatement(node, kind, allowMissingInitializer = false) {
      this.next();
      this.parseVar(node, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }
    parseWhileStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }
    parseWithStatement(node) {
      if (this.state.strict) {
        this.raise(Errors.StrictWith, this.state.startLoc);
      }
      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      return this.finishNode(node, "WithStatement");
    }
    parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }
    parseLabeledStatement(node, maybeName, expr, flags) {
      for (const label of this.state.labels) {
        if (label.name === maybeName) {
          this.raise(Errors.LabelRedeclaration, expr, {
            labelName: maybeName
          });
        }
      }
      const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let i = this.state.labels.length - 1;i >= 0; i--) {
        const label = this.state.labels[i];
        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }
      this.state.labels.push({
        name: maybeName,
        kind,
        statementStart: this.state.start
      });
      node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }
    parseExpressionStatement(node, expr, decorators) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
      const node = this.startNode();
      if (allowDirectives) {
        this.state.strictErrors.clear();
      }
      this.expect(5);
      if (createNewLexicalScope) {
        this.scope.enter(0);
      }
      this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
      if (createNewLexicalScope) {
        this.scope.exit();
      }
      return this.finishNode(node, "BlockStatement");
    }
    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node.body = [];
      const directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = false;
      let parsedNonDirective = false;
      while (!this.match(end)) {
        const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive);
            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }
            continue;
          }
          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }
        body.push(stmt);
      }
      afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
      if (!oldStrict) {
        this.setStrict(false);
      }
      this.next();
    }
    parseFor(node, init) {
      node.init = init;
      this.semicolon(false);
      node.test = this.match(13) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(11) ? null : this.parseExpression();
      this.expect(11);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }
    parseForIn(node, init, awaitAt) {
      const isForIn = this.match(58);
      this.next();
      if (isForIn) {
        if (awaitAt !== null)
          this.unexpected(awaitAt);
      } else {
        node.await = awaitAt !== null;
      }
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(Errors.ForInOfLoopInitializer, init, {
          type: isForIn ? "ForInStatement" : "ForOfStatement"
        });
      }
      if (init.type === "AssignmentPattern") {
        this.raise(Errors.InvalidLhs, init, {
          ancestor: {
            type: "ForStatement"
          }
        });
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(11);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node, isFor, kind, allowMissingInitializer = false) {
      const declarations = node.declarations = [];
      node.kind = kind;
      for (;; ) {
        const decl = this.startNode();
        this.parseVarId(decl, kind);
        decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        if (decl.init === null && !allowMissingInitializer) {
          if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
            this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind: "destructuring"
            });
          } else if (kind === "const" && !(this.match(58) || this.isContextual(102))) {
            this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind: "const"
            });
          }
        }
        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(12))
          break;
      }
      return node;
    }
    parseVarId(decl, kind) {
      const id = this.parseBindingAtom();
      this.checkLVal(id, {
        in: {
          type: "VariableDeclarator"
        },
        binding: kind === "var" ? 5 : 8201
      });
      decl.id = id;
    }
    parseAsyncFunctionExpression(node) {
      return this.parseFunction(node, 8);
    }
    parseFunction(node, flags = 0) {
      const hangingDeclaration = flags & 2;
      const isDeclaration = !!(flags & 1);
      const requireId = isDeclaration && !(flags & 4);
      const isAsync = !!(flags & 8);
      this.initFunction(node, isAsync);
      if (this.match(55)) {
        if (hangingDeclaration) {
          this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
        }
        this.next();
        node.generator = true;
      }
      if (isDeclaration) {
        node.id = this.parseFunctionId(requireId);
      }
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(2);
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      if (!isDeclaration) {
        node.id = this.parseFunctionId();
      }
      this.parseFunctionParams(node, false);
      this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();
      if (isDeclaration && !hangingDeclaration) {
        this.registerFunctionStatementId(node);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }
    parseFunctionId(requireId) {
      return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node, isConstructor) {
      this.expect(10);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
      this.expressionScope.exit();
    }
    registerFunctionStatementId(node) {
      if (!node.id)
        return;
      this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
    }
    parseClass(node, isStatement, optionalId) {
      this.next();
      const oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }
    parseClassBody(hadSuperClass, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: false,
        hadSuperClass
      };
      let decorators = [];
      const classBody = this.startNode();
      classBody.body = [];
      this.expect(5);
      this.withSmartMixTopicForbiddingContext(() => {
        while (!this.match(8)) {
          if (this.eat(13)) {
            if (decorators.length > 0) {
              throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
            }
            continue;
          }
          if (this.match(26)) {
            decorators.push(this.parseDecorator());
            continue;
          }
          const member = this.startNode();
          if (decorators.length) {
            member.decorators = decorators;
            this.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }
          this.parseClassMember(classBody, member, state);
          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            this.raise(Errors.DecoratorConstructor, member);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();
      if (decorators.length) {
        throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
      }
      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
      const key = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }
      this.resetPreviousNodeTrailingComments(key);
      return false;
    }
    parseClassMember(classBody, member, state) {
      const isStatic = this.isContextual(106);
      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        if (this.eat(5)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const publicMethod = member;
      const privateMethod = member;
      const publicProp = member;
      const privateProp = member;
      const accessorProp = member;
      const method = publicMethod;
      const publicMember = publicMethod;
      member.static = isStatic;
      this.parsePropertyNamePrefixOperator(member);
      if (this.eat(55)) {
        method.kind = "method";
        const isPrivateName = this.match(138);
        this.parseClassElementName(method);
        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
        }
        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }
      const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
      const isPrivate = this.match(138);
      const key = this.parseClassElementName(member);
      const maybeQuestionTokenStartLoc = this.state.startLoc;
      this.parsePostMemberNameModifiers(publicMember);
      if (this.isClassMethod()) {
        method.kind = "method";
        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }
        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = false;
        if (isConstructor) {
          publicMethod.kind = "constructor";
          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(Errors.DuplicateConstructor, key);
          }
          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(Errors.OverrideOnConstructor, key);
          }
          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }
        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key);
        const isGenerator = this.eat(55);
        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStartLoc);
        }
        method.kind = "method";
        const isPrivate2 = this.match(138);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAsync, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key);
        method.kind = key.name;
        const isPrivate2 = this.match(138);
        this.parseClassElementName(publicMethod);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }
        this.checkGetterSetterParams(publicMethod);
      } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors");
        this.resetPreviousNodeTrailingComments(key);
        const isPrivate2 = this.match(138);
        this.parseClassElementName(publicProp);
        this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
    parseClassElementName(member) {
      const {
        type,
        value
      } = this.state;
      if ((type === 132 || type === 133) && member.static && value === "prototype") {
        this.raise(Errors.StaticPrototype, this.state.startLoc);
      }
      if (type === 138) {
        if (value === "constructor") {
          this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
        }
        const key = this.parsePrivateName();
        member.key = key;
        return key;
      }
      return this.parsePropertyName(member);
    }
    parseClassStaticBlock(classBody, member) {
      var _member$decorators;
      this.scope.enter(64 | 128 | 16);
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(0);
      const body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));
      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(Errors.DecoratorStaticBlock, member);
      }
    }
    pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(Errors.ConstructorClassField, prop.key);
      }
      classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
      const node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    }
    pushClassAccessorProperty(classBody, prop, isPrivate) {
      if (!isPrivate && !prop.computed) {
        const key = prop.key;
        if (key.name === "constructor" || key.value === "constructor") {
          this.raise(Errors.ConstructorClassField, key);
        }
      }
      const node = this.parseClassAccessorProperty(prop);
      classBody.body.push(node);
      if (isPrivate) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(node, kind);
    }
    declareClassPrivateMethodInScope(node, kind) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {
    }
    parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    }
    parseClassProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    }
    parseClassAccessorProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassAccessorProperty");
    }
    parseInitializer(node) {
      this.scope.enter(64 | 16);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(0);
      node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }
    parseClassId(node, isStatement, optionalId, bindingType = 8331) {
      if (tokenIsIdentifier(this.state.type)) {
        node.id = this.parseIdentifier();
        if (isStatement) {
          this.declareNameFromIdentifier(node.id, bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          throw this.raise(Errors.MissingClassName, this.state.startLoc);
        }
      }
    }
    parseClassSuper(node) {
      node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(node, decorators) {
      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
      const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      const parseAfterDefault = !hasDefault || this.eat(12);
      const hasStar = parseAfterDefault && this.eatExportStar(node);
      const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
      const isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) {
        if (hasDefault)
          this.unexpected();
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }
      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
        this.unexpected(null, 5);
      }
      if (hasNamespace && parseAfterNamespace) {
        this.unexpected(null, 98);
      }
      let hasDeclaration;
      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }
      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        var _node2$declaration;
        const node2 = node;
        this.checkExport(node2, true, false, !!node2.source);
        if (((_node2$declaration = node2.declaration) == null ? undefined : _node2$declaration.type) === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, node2.declaration, node2);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        return this.finishNode(node2, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const node2 = node;
        const decl = this.parseExportDefaultExpression();
        node2.declaration = decl;
        if (decl.type === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, decl, node2);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        this.checkExport(node2, true, true);
        return this.finishNode(node2, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(node) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? undefined : maybeDefaultIdentifier.loc.start);
        const id = maybeDefaultIdentifier || this.parseIdentifier(true);
        const specifier = this.startNodeAtNode(id);
        specifier.exported = id;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual(93)) {
        if (!node.specifiers)
          node.specifiers = [];
        const specifier = this.startNodeAt(this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(node) {
      if (this.match(5)) {
        if (!node.specifiers)
          node.specifiers = [];
        const isTypeExport = node.exportKind === "type";
        node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
        node.source = null;
        node.declaration = null;
        if (this.hasPlugin("importAssertions")) {
          node.assertions = [];
        }
        return true;
      }
      return false;
    }
    maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        if (this.hasPlugin("importAssertions")) {
          node.assertions = [];
        }
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }
      return false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return false;
      const next = this.nextTokenInLineStart();
      return this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
      const expr = this.startNode();
      if (this.match(68)) {
        this.next();
        return this.parseFunction(expr, 1 | 4);
      } else if (this.isAsyncFunction()) {
        this.next();
        this.next();
        return this.parseFunction(expr, 1 | 4 | 8);
      }
      if (this.match(80)) {
        return this.parseClass(expr, true, true);
      }
      if (this.match(26)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
        }
        return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
      }
      if (this.match(75) || this.match(74) || this.isLet()) {
        throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
      }
      const res = this.parseMaybeAssignAllowIn();
      this.semicolon();
      return res;
    }
    parseExportDeclaration(node) {
      if (this.match(80)) {
        const node2 = this.parseClass(this.startNode(), true, false);
        return node2;
      }
      return this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type
      } = this.state;
      if (tokenIsIdentifier(type)) {
        if (type === 95 && !this.state.containsEsc || type === 100) {
          return false;
        }
        if ((type === 130 || type === 129) && !this.state.containsEsc) {
          const {
            type: nextType
          } = this.lookahead();
          if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(65)) {
        return false;
      }
      const next = this.nextTokenStart();
      const hasFrom = this.isUnparsedContextual(next, "from");
      if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
        return true;
      }
      if (this.match(65) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }
      return false;
    }
    parseExportFrom(node, expect) {
      if (this.eatContextual(98)) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        this.maybeParseImportAttributes(node);
        this.checkJSONModuleImport(node);
      } else if (expect) {
        this.unexpected();
      }
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type
      } = this.state;
      if (type === 26) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return true;
        }
      }
      return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        var _node$specifiers;
        if (isDefault) {
          this.checkDuplicateExports(node, "default");
          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;
            const declaration = node.declaration;
            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
            }
          }
        } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
          for (const specifier of node.specifiers) {
            const {
              exported
            } = specifier;
            const exportName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportName);
            if (!isFrom && specifier.local) {
              const {
                local
              } = specifier;
              if (local.type !== "Identifier") {
                this.raise(Errors.ExportBindingIsString, specifier, {
                  localName: local.value,
                  exportName
                });
              } else {
                this.checkReservedWord(local.name, local.loc.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            const id = node.declaration.id;
            if (!id)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (const declaration of node.declaration.declarations) {
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }
    }
    checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (const prop of node.properties) {
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (const elem of node.elements) {
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }
    checkDuplicateExports(node, exportName) {
      if (this.exportedIdentifiers.has(exportName)) {
        if (exportName === "default") {
          this.raise(Errors.DuplicateDefaultExport, node);
        } else {
          this.raise(Errors.DuplicateExport, node, {
            exportName
          });
        }
      }
      this.exportedIdentifiers.add(exportName);
    }
    parseExportSpecifiers(isInTypeExport) {
      const nodes = [];
      let first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.eat(8))
            break;
        }
        const isMaybeTypeOnly = this.isContextual(130);
        const isString = this.match(133);
        const node = this.startNode();
        node.local = this.parseModuleExportName();
        nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
      }
      return nodes;
    }
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
      if (this.eatContextual(93)) {
        node.exported = this.parseModuleExportName();
      } else if (isString) {
        node.exported = cloneStringLiteral(node.local);
      } else if (!node.exported) {
        node.exported = cloneIdentifier(node.local);
      }
      return this.finishNode(node, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        const result = this.parseStringLiteral(this.state.value);
        const surrogate = result.value.match(loneSurrogate);
        if (surrogate) {
          this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
            surrogateCharCode: surrogate[0].charCodeAt(0)
          });
        }
        return result;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(node) {
      if (node.assertions != null) {
        return node.assertions.some(({
          key,
          value
        }) => {
          return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
        });
      }
      return false;
    }
    checkImportReflection(node) {
      const {
        specifiers
      } = node;
      const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
      if (node.phase === "source") {
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
        }
      } else if (node.phase === "defer") {
        if (singleBindingType !== "ImportNamespaceSpecifier") {
          this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
        }
      } else if (node.module) {
        var _node$assertions;
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
        }
        if (((_node$assertions = node.assertions) == null ? undefined : _node$assertions.length) > 0) {
          this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
        }
      }
    }
    checkJSONModuleImport(node) {
      if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
        const {
          specifiers
        } = node;
        if (specifiers != null) {
          const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
            let imported;
            if (specifier.type === "ExportSpecifier") {
              imported = specifier.local;
            } else if (specifier.type === "ImportSpecifier") {
              imported = specifier.imported;
            }
            if (imported !== undefined) {
              return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
            }
          });
          if (nonDefaultNamedSpecifier !== undefined) {
            this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
          }
        }
      }
    }
    isPotentialImportPhase(isExport) {
      if (isExport)
        return false;
      return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(node, isExport, phase, loc) {
      if (isExport) {
        return;
      }
      if (phase === "module") {
        this.expectPlugin("importReflection", loc);
        node.module = true;
      } else if (this.hasPlugin("importReflection")) {
        node.module = false;
      }
      if (phase === "source") {
        this.expectPlugin("sourcePhaseImports", loc);
        node.phase = "source";
      } else if (phase === "defer") {
        this.expectPlugin("deferredImportEvaluation", loc);
        node.phase = "defer";
      } else if (this.hasPlugin("sourcePhaseImports")) {
        node.phase = null;
      }
    }
    parseMaybeImportPhase(node, isExport) {
      if (!this.isPotentialImportPhase(isExport)) {
        this.applyImportPhase(node, isExport, null);
        return null;
      }
      const phaseIdentifier = this.parseIdentifier(true);
      const {
        type
      } = this.state;
      const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      if (isImportPhase) {
        this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
        this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
        return null;
      } else {
        this.applyImportPhase(node, isExport, null);
        return phaseIdentifier;
      }
    }
    isPrecedingIdImportPhase(phase) {
      const {
        type
      } = this.state;
      return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    }
    parseImport(node) {
      if (this.match(133)) {
        return this.parseImportSourceAndAttributes(node);
      }
      return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
    }
    parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
      node.specifiers = [];
      const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
      const parseNext = !hasDefault || this.eat(12);
      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
      if (parseNext && !hasStar)
        this.parseNamedImportSpecifiers(node);
      this.expectContextual(98);
      return this.parseImportSourceAndAttributes(node);
    }
    parseImportSourceAndAttributes(node) {
      var _node$specifiers2;
      (_node$specifiers2 = node.specifiers) != null || (node.specifiers = []);
      node.source = this.parseImportSource();
      this.maybeParseImportAttributes(node);
      this.checkImportReflection(node);
      this.checkJSONModuleImport(node);
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
      if (!this.match(133))
        this.unexpected();
      return this.parseExprAtom();
    }
    parseImportSpecifierLocal(node, specifier, type) {
      specifier.local = this.parseIdentifier();
      node.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    finishImportSpecifier(specifier, type, bindingType = 8201) {
      this.checkLVal(specifier.local, {
        in: {
          type
        },
        binding: bindingType
      });
      return this.finishNode(specifier, type);
    }
    parseImportAttributes() {
      this.expect(5);
      const attrs = [];
      const attrNames = new Set;
      do {
        if (this.match(8)) {
          break;
        }
        const node = this.startNode();
        const keyName = this.state.value;
        if (attrNames.has(keyName)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
            key: keyName
          });
        }
        attrNames.add(keyName);
        if (this.match(133)) {
          node.key = this.parseStringLiteral(keyName);
        } else {
          node.key = this.parseIdentifier(true);
        }
        this.expect(14);
        if (!this.match(133)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        }
        node.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(12));
      this.expect(8);
      return attrs;
    }
    parseModuleAttributes() {
      const attrs = [];
      const attributes = new Set;
      do {
        const node = this.startNode();
        node.key = this.parseIdentifier(true);
        if (node.key.name !== "type") {
          this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
        }
        if (attributes.has(node.key.name)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
            key: node.key.name
          });
        }
        attributes.add(node.key.name);
        this.expect(14);
        if (!this.match(133)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        }
        node.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(12));
      return attrs;
    }
    maybeParseImportAttributes(node) {
      let attributes;
      let useWith = false;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
          return;
        }
        this.next();
        {
          if (this.hasPlugin("moduleAttributes")) {
            attributes = this.parseModuleAttributes();
          } else {
            this.expectImportAttributesPlugin();
            attributes = this.parseImportAttributes();
          }
        }
        useWith = true;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
        if (this.hasPlugin("importAttributes")) {
          if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
            this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
          }
          this.addExtra(node, "deprecatedAssertSyntax", true);
        } else {
          this.expectOnePlugin(["importAttributes", "importAssertions"]);
        }
        this.next();
        attributes = this.parseImportAttributes();
      } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        attributes = [];
      } else {
        if (this.hasPlugin("moduleAttributes")) {
          attributes = [];
        } else
          return;
      }
      if (!useWith && this.hasPlugin("importAssertions")) {
        node.assertions = attributes;
      } else {
        node.attributes = attributes;
      }
    }
    maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier) {
        const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
        specifier.local = maybeDefaultIdentifier;
        node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
        return true;
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
        return true;
      }
      return false;
    }
    maybeParseStarImportSpecifier(node) {
      if (this.match(55)) {
        const specifier = this.startNode();
        this.next();
        this.expectContextual(93);
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
        return true;
      }
      return false;
    }
    parseNamedImportSpecifiers(node) {
      let first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(14)) {
            throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
          }
          this.expect(12);
          if (this.eat(8))
            break;
        }
        const specifier = this.startNode();
        const importedIsString = this.match(133);
        const isMaybeTypeOnly = this.isContextual(130);
        specifier.imported = this.parseModuleExportName();
        const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);
        node.specifiers.push(importSpecifier);
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        const {
          imported
        } = specifier;
        if (importedIsString) {
          throw this.raise(Errors.ImportBindingIsString, specifier, {
            importName: imported.value
          });
        }
        this.checkReservedWord(imported.name, specifier.loc.start, true, true);
        if (!specifier.local) {
          specifier.local = cloneIdentifier(imported);
        }
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    }
    isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  }

  class Parser extends StatementParser {
    constructor(options, input) {
      options = getOptions(options);
      super(options, input);
      this.options = options;
      this.initializeScopes();
      this.plugins = pluginsMap(this.options.plugins);
      this.filename = options.sourceFilename;
    }
    getScopeHandler() {
      return ScopeHandler;
    }
    parse() {
      this.enterInitialScopes();
      const file = this.startNode();
      const program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      file.comments.length = this.state.commentsLen;
      return file;
    }
  }
  var tokTypes = generateExportedTokenTypes(tt);
  var parserClassCache = {};
  exports.parse = parse;
  exports.parseExpression = parseExpression;
  exports.tokTypes = tokTypes;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS((exports) => {
  var shallowEqual = function(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = shallowEqual;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS((exports) => {
  var deprecationWarning = function(oldName, newName, prefix = "") {
    if (warnings.has(oldName))
      return;
    warnings.add(oldName);
    const {
      internal,
      trace
    } = captureShortStackTrace(1, 2);
    if (internal) {
      return;
    }
    console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);
  };
  var captureShortStackTrace = function(skip, length) {
    const {
      stackTraceLimit,
      prepareStackTrace
    } = Error;
    let stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function(err, stack) {
      stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace)
      return {
        internal: false,
        trace: ""
      };
    const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
      internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
      trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = deprecationWarning;
  var warnings = new Set;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS((exports) => {
  var isArrayExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrayExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isAssignmentExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AssignmentExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBinaryExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BinaryExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isInterpreterDirective = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterpreterDirective")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDirective = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Directive")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDirectiveLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DirectiveLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBlockStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BlockStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBreakStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BreakStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isCallExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "CallExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isCatchClause = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "CatchClause")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isConditionalExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ConditionalExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isContinueStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ContinueStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDebuggerStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DebuggerStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDoWhileStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DoWhileStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEmptyStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EmptyStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExpressionStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExpressionStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFile = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "File")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isForInStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ForInStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isForStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ForStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFunctionDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFunctionExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isIdentifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Identifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isIfStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "IfStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isLabeledStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "LabeledStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isStringLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StringLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNumericLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NumericLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNullLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NullLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBooleanLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BooleanLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isRegExpLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "RegExpLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isLogicalExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "LogicalExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isMemberExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "MemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNewExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NewExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isProgram = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Program")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectMethod = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isRestElement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "RestElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isReturnStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ReturnStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isSequenceExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SequenceExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isParenthesizedExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ParenthesizedExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isSwitchCase = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SwitchCase")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isSwitchStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SwitchStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isThisExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ThisExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isThrowStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ThrowStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTryStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TryStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isUnaryExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "UnaryExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isUpdateExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "UpdateExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isVariableDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "VariableDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isVariableDeclarator = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "VariableDeclarator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isWhileStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "WhileStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isWithStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "WithStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isAssignmentPattern = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AssignmentPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isArrayPattern = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrayPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isArrowFunctionExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrowFunctionExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassBody = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExportAllDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportAllDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExportDefaultDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportDefaultDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExportNamedDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportNamedDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExportSpecifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isForOfStatement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ForOfStatement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImportDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImportDefaultSpecifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportDefaultSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImportNamespaceSpecifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportNamespaceSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImportSpecifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImportExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isMetaProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "MetaProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassMethod = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectPattern = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectPattern")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isSpreadElement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SpreadElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isSuper = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Super")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTaggedTemplateExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TaggedTemplateExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTemplateElement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TemplateElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTemplateLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TemplateLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isYieldExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "YieldExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isAwaitExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AwaitExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImport = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Import")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBigIntLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BigIntLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExportNamespaceSpecifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportNamespaceSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isOptionalMemberExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OptionalMemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isOptionalCallExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OptionalCallExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassAccessorProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassAccessorProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassPrivateProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassPrivateProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassPrivateMethod = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassPrivateMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPrivateName = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PrivateName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isStaticBlock = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StaticBlock")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isAnyTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "AnyTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isArrayTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArrayTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBooleanTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BooleanTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBooleanLiteralTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BooleanLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNullLiteralTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NullLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClassImplements = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ClassImplements")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareClass = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareClass")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareFunction = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareInterface = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareInterface")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareModule = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareModule")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareModuleExports = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareModuleExports")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareTypeAlias = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareTypeAlias")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareOpaqueType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareOpaqueType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareVariable = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareVariable")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareExportDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareExportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclareExportAllDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclareExportAllDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclaredPredicate = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DeclaredPredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExistsTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExistsTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFunctionTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFunctionTypeParam = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "FunctionTypeParam")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isGenericTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "GenericTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isInferredPredicate = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InferredPredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isInterfaceExtends = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterfaceExtends")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isInterfaceDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterfaceDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isInterfaceTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "InterfaceTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isIntersectionTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "IntersectionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isMixedTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "MixedTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEmptyTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EmptyTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNullableTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NullableTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNumberLiteralTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NumberLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNumberTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "NumberTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectTypeInternalSlot = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeInternalSlot")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectTypeCallProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeCallProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectTypeIndexer = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeIndexer")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectTypeProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectTypeSpreadProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ObjectTypeSpreadProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isOpaqueType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OpaqueType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isQualifiedTypeIdentifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "QualifiedTypeIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isStringLiteralTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StringLiteralTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isStringTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "StringTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isSymbolTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "SymbolTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isThisTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ThisTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTupleTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TupleTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeofTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeofTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeAlias = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeAlias")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeCastExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeCastExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeParameter = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeParameter")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeParameterDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeParameterDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeParameterInstantiation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TypeParameterInstantiation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isUnionTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "UnionTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isVariance = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Variance")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isVoidTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "VoidTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumBooleanBody = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumBooleanBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumNumberBody = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumNumberBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumStringBody = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumStringBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumSymbolBody = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumSymbolBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumBooleanMember = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumBooleanMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumNumberMember = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumNumberMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumStringMember = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumStringMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumDefaultedMember = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "EnumDefaultedMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isIndexedAccessType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "IndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isOptionalIndexedAccessType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "OptionalIndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXAttribute = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXClosingElement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXClosingElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXElement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXEmptyExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXEmptyExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXExpressionContainer = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXExpressionContainer")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXSpreadChild = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXSpreadChild")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXIdentifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXMemberExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXMemberExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXNamespacedName = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXNamespacedName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXOpeningElement = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXOpeningElement")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXSpreadAttribute = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXSpreadAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXText = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXText")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXFragment = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXOpeningFragment = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXOpeningFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSXClosingFragment = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "JSXClosingFragment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNoop = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Noop")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPlaceholder = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Placeholder")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isV8IntrinsicIdentifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "V8IntrinsicIdentifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isArgumentPlaceholder = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ArgumentPlaceholder")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBindExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "BindExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImportAttribute = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ImportAttribute")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDecorator = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "Decorator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDoExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DoExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExportDefaultSpecifier = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ExportDefaultSpecifier")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isRecordExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "RecordExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTupleExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TupleExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDecimalLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "DecimalLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isModuleExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "ModuleExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTopicReference = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TopicReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPipelineTopicExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PipelineTopicExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPipelineBareFunction = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PipelineBareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPipelinePrimaryTopicReference = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "PipelinePrimaryTopicReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSParameterProperty = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSParameterProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSDeclareFunction = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSDeclareFunction")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSDeclareMethod = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSDeclareMethod")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSQualifiedName = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSQualifiedName")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSCallSignatureDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSCallSignatureDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSConstructSignatureDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSConstructSignatureDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSPropertySignature = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSPropertySignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSMethodSignature = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSMethodSignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSIndexSignature = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIndexSignature")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSAnyKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSAnyKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSBooleanKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSBooleanKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSBigIntKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSBigIntKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSIntrinsicKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIntrinsicKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSNeverKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNeverKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSNullKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNullKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSNumberKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNumberKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSObjectKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSObjectKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSStringKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSStringKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSSymbolKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSSymbolKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSUndefinedKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSUndefinedKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSUnknownKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSUnknownKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSVoidKeyword = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSVoidKeyword")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSThisType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSThisType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSFunctionType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSFunctionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSConstructorType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSConstructorType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeReference = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypePredicate = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypePredicate")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeQuery = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeQuery")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeLiteral = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSArrayType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSArrayType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTupleType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTupleType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSOptionalType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSOptionalType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSRestType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSRestType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSNamedTupleMember = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNamedTupleMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSUnionType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSUnionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSIntersectionType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIntersectionType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSConditionalType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSConditionalType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSInferType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInferType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSParenthesizedType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSParenthesizedType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeOperator = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeOperator")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSIndexedAccessType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSIndexedAccessType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSMappedType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSMappedType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSLiteralType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSLiteralType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSExpressionWithTypeArguments = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSExpressionWithTypeArguments")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSInterfaceDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInterfaceDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSInterfaceBody = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInterfaceBody")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeAliasDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeAliasDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSInstantiationExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSInstantiationExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSAsExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSAsExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSSatisfiesExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSSatisfiesExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeAssertion = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeAssertion")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSEnumDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSEnumDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSEnumMember = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSEnumMember")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSModuleDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSModuleDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSModuleBlock = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSModuleBlock")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSImportType = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSImportType")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSImportEqualsDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSImportEqualsDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSExternalModuleReference = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSExternalModuleReference")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSNonNullExpression = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNonNullExpression")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSExportAssignment = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSExportAssignment")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSNamespaceExportDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSNamespaceExportDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeAnnotation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeAnnotation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeParameterInstantiation = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeParameterInstantiation")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeParameterDeclaration = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeParameterDeclaration")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeParameter = function(node, opts) {
    if (!node)
      return false;
    if (node.type !== "TSTypeParameter")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isStandardized = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExpression = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBinary = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isScopable = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBlockParent = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isBlock = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isStatement = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTerminatorless = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isCompletionStatement = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isConditional = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isLoop = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isWhile = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExpressionWrapper = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFor = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isForXStatement = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFunction = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFunctionParent = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPureish = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isDeclaration = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (node.expectedNode === "Declaration")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPatternLike = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isLVal = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSEntityName = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (node.expectedNode === "Identifier")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isLiteral = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImmutable = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isUserWhitespacable = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isMethod = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isObjectMember = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isProperty = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isUnaryLike = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPattern = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (node.expectedNode === "Pattern")
          break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isClass = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isImportOrExportDeclaration = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isExportDeclaration = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isModuleSpecifier = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isAccessor = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isPrivate = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFlow = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFlowType = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFlowBaseAnnotation = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFlowDeclaration = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isFlowPredicate = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumBody = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isEnumMember = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isJSX = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isMiscellaneous = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTypeScript = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSTypeElement = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSType = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isTSBaseType = function(node, opts) {
    if (!node)
      return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isNumberLiteral = function(node, opts) {
    (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
    if (!node)
      return false;
    if (node.type !== "NumberLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isRegexLiteral = function(node, opts) {
    (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
    if (!node)
      return false;
    if (node.type !== "RegexLiteral")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isRestProperty = function(node, opts) {
    (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
    if (!node)
      return false;
    if (node.type !== "RestProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isSpreadProperty = function(node, opts) {
    (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
    if (!node)
      return false;
    if (node.type !== "SpreadProperty")
      return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
  };
  var isModuleDeclaration = function(node, opts) {
    (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node, opts);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAccessor = isAccessor;
  exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
  exports.isArgumentPlaceholder = isArgumentPlaceholder;
  exports.isArrayExpression = isArrayExpression;
  exports.isArrayPattern = isArrayPattern;
  exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
  exports.isArrowFunctionExpression = isArrowFunctionExpression;
  exports.isAssignmentExpression = isAssignmentExpression;
  exports.isAssignmentPattern = isAssignmentPattern;
  exports.isAwaitExpression = isAwaitExpression;
  exports.isBigIntLiteral = isBigIntLiteral;
  exports.isBinary = isBinary;
  exports.isBinaryExpression = isBinaryExpression;
  exports.isBindExpression = isBindExpression;
  exports.isBlock = isBlock;
  exports.isBlockParent = isBlockParent;
  exports.isBlockStatement = isBlockStatement;
  exports.isBooleanLiteral = isBooleanLiteral;
  exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  exports.isBreakStatement = isBreakStatement;
  exports.isCallExpression = isCallExpression;
  exports.isCatchClause = isCatchClause;
  exports.isClass = isClass;
  exports.isClassAccessorProperty = isClassAccessorProperty;
  exports.isClassBody = isClassBody;
  exports.isClassDeclaration = isClassDeclaration;
  exports.isClassExpression = isClassExpression;
  exports.isClassImplements = isClassImplements;
  exports.isClassMethod = isClassMethod;
  exports.isClassPrivateMethod = isClassPrivateMethod;
  exports.isClassPrivateProperty = isClassPrivateProperty;
  exports.isClassProperty = isClassProperty;
  exports.isCompletionStatement = isCompletionStatement;
  exports.isConditional = isConditional;
  exports.isConditionalExpression = isConditionalExpression;
  exports.isContinueStatement = isContinueStatement;
  exports.isDebuggerStatement = isDebuggerStatement;
  exports.isDecimalLiteral = isDecimalLiteral;
  exports.isDeclaration = isDeclaration;
  exports.isDeclareClass = isDeclareClass;
  exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
  exports.isDeclareFunction = isDeclareFunction;
  exports.isDeclareInterface = isDeclareInterface;
  exports.isDeclareModule = isDeclareModule;
  exports.isDeclareModuleExports = isDeclareModuleExports;
  exports.isDeclareOpaqueType = isDeclareOpaqueType;
  exports.isDeclareTypeAlias = isDeclareTypeAlias;
  exports.isDeclareVariable = isDeclareVariable;
  exports.isDeclaredPredicate = isDeclaredPredicate;
  exports.isDecorator = isDecorator;
  exports.isDirective = isDirective;
  exports.isDirectiveLiteral = isDirectiveLiteral;
  exports.isDoExpression = isDoExpression;
  exports.isDoWhileStatement = isDoWhileStatement;
  exports.isEmptyStatement = isEmptyStatement;
  exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  exports.isEnumBody = isEnumBody;
  exports.isEnumBooleanBody = isEnumBooleanBody;
  exports.isEnumBooleanMember = isEnumBooleanMember;
  exports.isEnumDeclaration = isEnumDeclaration;
  exports.isEnumDefaultedMember = isEnumDefaultedMember;
  exports.isEnumMember = isEnumMember;
  exports.isEnumNumberBody = isEnumNumberBody;
  exports.isEnumNumberMember = isEnumNumberMember;
  exports.isEnumStringBody = isEnumStringBody;
  exports.isEnumStringMember = isEnumStringMember;
  exports.isEnumSymbolBody = isEnumSymbolBody;
  exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
  exports.isExportAllDeclaration = isExportAllDeclaration;
  exports.isExportDeclaration = isExportDeclaration;
  exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
  exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
  exports.isExportNamedDeclaration = isExportNamedDeclaration;
  exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  exports.isExportSpecifier = isExportSpecifier;
  exports.isExpression = isExpression;
  exports.isExpressionStatement = isExpressionStatement;
  exports.isExpressionWrapper = isExpressionWrapper;
  exports.isFile = isFile;
  exports.isFlow = isFlow;
  exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
  exports.isFlowDeclaration = isFlowDeclaration;
  exports.isFlowPredicate = isFlowPredicate;
  exports.isFlowType = isFlowType;
  exports.isFor = isFor;
  exports.isForInStatement = isForInStatement;
  exports.isForOfStatement = isForOfStatement;
  exports.isForStatement = isForStatement;
  exports.isForXStatement = isForXStatement;
  exports.isFunction = isFunction;
  exports.isFunctionDeclaration = isFunctionDeclaration;
  exports.isFunctionExpression = isFunctionExpression;
  exports.isFunctionParent = isFunctionParent;
  exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  exports.isFunctionTypeParam = isFunctionTypeParam;
  exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
  exports.isIdentifier = isIdentifier;
  exports.isIfStatement = isIfStatement;
  exports.isImmutable = isImmutable;
  exports.isImport = isImport;
  exports.isImportAttribute = isImportAttribute;
  exports.isImportDeclaration = isImportDeclaration;
  exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
  exports.isImportExpression = isImportExpression;
  exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
  exports.isImportSpecifier = isImportSpecifier;
  exports.isIndexedAccessType = isIndexedAccessType;
  exports.isInferredPredicate = isInferredPredicate;
  exports.isInterfaceDeclaration = isInterfaceDeclaration;
  exports.isInterfaceExtends = isInterfaceExtends;
  exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  exports.isInterpreterDirective = isInterpreterDirective;
  exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  exports.isJSX = isJSX;
  exports.isJSXAttribute = isJSXAttribute;
  exports.isJSXClosingElement = isJSXClosingElement;
  exports.isJSXClosingFragment = isJSXClosingFragment;
  exports.isJSXElement = isJSXElement;
  exports.isJSXEmptyExpression = isJSXEmptyExpression;
  exports.isJSXExpressionContainer = isJSXExpressionContainer;
  exports.isJSXFragment = isJSXFragment;
  exports.isJSXIdentifier = isJSXIdentifier;
  exports.isJSXMemberExpression = isJSXMemberExpression;
  exports.isJSXNamespacedName = isJSXNamespacedName;
  exports.isJSXOpeningElement = isJSXOpeningElement;
  exports.isJSXOpeningFragment = isJSXOpeningFragment;
  exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
  exports.isJSXSpreadChild = isJSXSpreadChild;
  exports.isJSXText = isJSXText;
  exports.isLVal = isLVal;
  exports.isLabeledStatement = isLabeledStatement;
  exports.isLiteral = isLiteral;
  exports.isLogicalExpression = isLogicalExpression;
  exports.isLoop = isLoop;
  exports.isMemberExpression = isMemberExpression;
  exports.isMetaProperty = isMetaProperty;
  exports.isMethod = isMethod;
  exports.isMiscellaneous = isMiscellaneous;
  exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
  exports.isModuleDeclaration = isModuleDeclaration;
  exports.isModuleExpression = isModuleExpression;
  exports.isModuleSpecifier = isModuleSpecifier;
  exports.isNewExpression = isNewExpression;
  exports.isNoop = isNoop;
  exports.isNullLiteral = isNullLiteral;
  exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
  exports.isNumberLiteral = isNumberLiteral;
  exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
  exports.isNumericLiteral = isNumericLiteral;
  exports.isObjectExpression = isObjectExpression;
  exports.isObjectMember = isObjectMember;
  exports.isObjectMethod = isObjectMethod;
  exports.isObjectPattern = isObjectPattern;
  exports.isObjectProperty = isObjectProperty;
  exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
  exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
  exports.isObjectTypeIndexer = isObjectTypeIndexer;
  exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  exports.isObjectTypeProperty = isObjectTypeProperty;
  exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  exports.isOpaqueType = isOpaqueType;
  exports.isOptionalCallExpression = isOptionalCallExpression;
  exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  exports.isOptionalMemberExpression = isOptionalMemberExpression;
  exports.isParenthesizedExpression = isParenthesizedExpression;
  exports.isPattern = isPattern;
  exports.isPatternLike = isPatternLike;
  exports.isPipelineBareFunction = isPipelineBareFunction;
  exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  exports.isPipelineTopicExpression = isPipelineTopicExpression;
  exports.isPlaceholder = isPlaceholder;
  exports.isPrivate = isPrivate;
  exports.isPrivateName = isPrivateName;
  exports.isProgram = isProgram;
  exports.isProperty = isProperty;
  exports.isPureish = isPureish;
  exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  exports.isRecordExpression = isRecordExpression;
  exports.isRegExpLiteral = isRegExpLiteral;
  exports.isRegexLiteral = isRegexLiteral;
  exports.isRestElement = isRestElement;
  exports.isRestProperty = isRestProperty;
  exports.isReturnStatement = isReturnStatement;
  exports.isScopable = isScopable;
  exports.isSequenceExpression = isSequenceExpression;
  exports.isSpreadElement = isSpreadElement;
  exports.isSpreadProperty = isSpreadProperty;
  exports.isStandardized = isStandardized;
  exports.isStatement = isStatement;
  exports.isStaticBlock = isStaticBlock;
  exports.isStringLiteral = isStringLiteral;
  exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  exports.isStringTypeAnnotation = isStringTypeAnnotation;
  exports.isSuper = isSuper;
  exports.isSwitchCase = isSwitchCase;
  exports.isSwitchStatement = isSwitchStatement;
  exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  exports.isTSAnyKeyword = isTSAnyKeyword;
  exports.isTSArrayType = isTSArrayType;
  exports.isTSAsExpression = isTSAsExpression;
  exports.isTSBaseType = isTSBaseType;
  exports.isTSBigIntKeyword = isTSBigIntKeyword;
  exports.isTSBooleanKeyword = isTSBooleanKeyword;
  exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  exports.isTSConditionalType = isTSConditionalType;
  exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
  exports.isTSConstructorType = isTSConstructorType;
  exports.isTSDeclareFunction = isTSDeclareFunction;
  exports.isTSDeclareMethod = isTSDeclareMethod;
  exports.isTSEntityName = isTSEntityName;
  exports.isTSEnumDeclaration = isTSEnumDeclaration;
  exports.isTSEnumMember = isTSEnumMember;
  exports.isTSExportAssignment = isTSExportAssignment;
  exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  exports.isTSExternalModuleReference = isTSExternalModuleReference;
  exports.isTSFunctionType = isTSFunctionType;
  exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  exports.isTSImportType = isTSImportType;
  exports.isTSIndexSignature = isTSIndexSignature;
  exports.isTSIndexedAccessType = isTSIndexedAccessType;
  exports.isTSInferType = isTSInferType;
  exports.isTSInstantiationExpression = isTSInstantiationExpression;
  exports.isTSInterfaceBody = isTSInterfaceBody;
  exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  exports.isTSIntersectionType = isTSIntersectionType;
  exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  exports.isTSLiteralType = isTSLiteralType;
  exports.isTSMappedType = isTSMappedType;
  exports.isTSMethodSignature = isTSMethodSignature;
  exports.isTSModuleBlock = isTSModuleBlock;
  exports.isTSModuleDeclaration = isTSModuleDeclaration;
  exports.isTSNamedTupleMember = isTSNamedTupleMember;
  exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  exports.isTSNeverKeyword = isTSNeverKeyword;
  exports.isTSNonNullExpression = isTSNonNullExpression;
  exports.isTSNullKeyword = isTSNullKeyword;
  exports.isTSNumberKeyword = isTSNumberKeyword;
  exports.isTSObjectKeyword = isTSObjectKeyword;
  exports.isTSOptionalType = isTSOptionalType;
  exports.isTSParameterProperty = isTSParameterProperty;
  exports.isTSParenthesizedType = isTSParenthesizedType;
  exports.isTSPropertySignature = isTSPropertySignature;
  exports.isTSQualifiedName = isTSQualifiedName;
  exports.isTSRestType = isTSRestType;
  exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
  exports.isTSStringKeyword = isTSStringKeyword;
  exports.isTSSymbolKeyword = isTSSymbolKeyword;
  exports.isTSThisType = isTSThisType;
  exports.isTSTupleType = isTSTupleType;
  exports.isTSType = isTSType;
  exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  exports.isTSTypeAnnotation = isTSTypeAnnotation;
  exports.isTSTypeAssertion = isTSTypeAssertion;
  exports.isTSTypeElement = isTSTypeElement;
  exports.isTSTypeLiteral = isTSTypeLiteral;
  exports.isTSTypeOperator = isTSTypeOperator;
  exports.isTSTypeParameter = isTSTypeParameter;
  exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  exports.isTSTypePredicate = isTSTypePredicate;
  exports.isTSTypeQuery = isTSTypeQuery;
  exports.isTSTypeReference = isTSTypeReference;
  exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
  exports.isTSUnionType = isTSUnionType;
  exports.isTSUnknownKeyword = isTSUnknownKeyword;
  exports.isTSVoidKeyword = isTSVoidKeyword;
  exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
  exports.isTemplateElement = isTemplateElement;
  exports.isTemplateLiteral = isTemplateLiteral;
  exports.isTerminatorless = isTerminatorless;
  exports.isThisExpression = isThisExpression;
  exports.isThisTypeAnnotation = isThisTypeAnnotation;
  exports.isThrowStatement = isThrowStatement;
  exports.isTopicReference = isTopicReference;
  exports.isTryStatement = isTryStatement;
  exports.isTupleExpression = isTupleExpression;
  exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
  exports.isTypeAlias = isTypeAlias;
  exports.isTypeAnnotation = isTypeAnnotation;
  exports.isTypeCastExpression = isTypeCastExpression;
  exports.isTypeParameter = isTypeParameter;
  exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
  exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
  exports.isTypeScript = isTypeScript;
  exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  exports.isUnaryExpression = isUnaryExpression;
  exports.isUnaryLike = isUnaryLike;
  exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
  exports.isUpdateExpression = isUpdateExpression;
  exports.isUserWhitespacable = isUserWhitespacable;
  exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  exports.isVariableDeclaration = isVariableDeclaration;
  exports.isVariableDeclarator = isVariableDeclarator;
  exports.isVariance = isVariance;
  exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
  exports.isWhile = isWhile;
  exports.isWhileStatement = isWhileStatement;
  exports.isWithStatement = isWithStatement;
  exports.isYieldExpression = isYieldExpression;
  var _shallowEqual = require_shallowEqual();
  var _deprecationWarning = require_deprecationWarning();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS((exports) => {
  var matchesPattern = function(member, match, allowPartial) {
    if (!(0, _index.isMemberExpression)(member))
      return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;
    for (node = member;(0, _index.isMemberExpression)(node); node = node.object) {
      nodes.push(node.property);
    }
    nodes.push(node);
    if (nodes.length < parts.length)
      return false;
    if (!allowPartial && nodes.length > parts.length)
      return false;
    for (let i = 0, j = nodes.length - 1;i < parts.length; i++, j--) {
      const node2 = nodes[j];
      let value;
      if ((0, _index.isIdentifier)(node2)) {
        value = node2.name;
      } else if ((0, _index.isStringLiteral)(node2)) {
        value = node2.value;
      } else if ((0, _index.isThisExpression)(node2)) {
        value = "this";
      } else {
        return false;
      }
      if (parts[i] !== value)
        return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = matchesPattern;
  var _index = require_generated();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS((exports) => {
  var buildMatchMemberExpression = function(match, allowPartial) {
    const parts = match.split(".");
    return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildMatchMemberExpression;
  var _matchesPattern = require_matchesPattern();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _buildMatchMemberExpression = require_buildMatchMemberExpression();
  var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
  var _default = exports.default = isReactComponent;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS((exports) => {
  var isCompatTag = function(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCompatTag;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/@babel+types@7.23.9/node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS((exports, module) => {
  var FastObject = function(o) {
    if (fastProto !== null && typeof fastProto.property) {
      const result = fastProto;
      fastProto = FastObject.prototype = null;
      return result;
    }
    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject;
  };
  var fastProto = null;
  FastObject();
  module.exports = function toFastproperties(o) {
    return FastObject(o);
  };
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS((exports) => {
  var isType = function(nodeType, targetType) {
    if (nodeType === targetType)
      return true;
    if (nodeType == null)
      return false;
    if (_index.ALIAS_KEYS[targetType])
      return false;
    const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
      if (aliases[0] === nodeType)
        return true;
      for (const alias of aliases) {
        if (nodeType === alias)
          return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isType;
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS((exports) => {
  var isPlaceholderType = function(placeholderType, targetType) {
    if (placeholderType === targetType)
      return true;
    const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) {
      for (const alias of aliases) {
        if (targetType === alias)
          return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPlaceholderType;
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS((exports) => {
  var is = function(type, node, opts) {
    if (!node)
      return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
        return (0, _isPlaceholderType.default)(node.expectedNode, type);
      }
      return false;
    }
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = is;
  var _shallowEqual = require_shallowEqual();
  var _isType = require_isType();
  var _isPlaceholderType = require_isPlaceholderType();
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS((exports) => {
  var isInAstralSet = function(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length;i < length; i += 2) {
      pos += set[i];
      if (pos > code)
        return false;
      pos += set[i + 1];
      if (pos >= code)
        return true;
    }
    return false;
  };
  var isIdentifierStart = function(code) {
    if (code < 65)
      return code === 36;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  };
  var isIdentifierChar = function(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  };
  var isIdentifierName = function(name) {
    let isFirst = true;
    for (let i = 0;i < name.length; i++) {
      let cp = name.charCodeAt(i);
      if ((cp & 64512) === 55296 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierName = isIdentifierName;
  exports.isIdentifierStart = isIdentifierStart;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
});

// node_modules/.pnpm/@babel+helper-validator-identifier@7.22.20/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS((exports) => {
  var isReservedWord = function(word, inModule) {
    return inModule && word === "await" || word === "enum";
  };
  var isStrictReservedWord = function(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  };
  var isStrictBindOnlyReservedWord = function(word) {
    return reservedWordsStrictBindSet.has(word);
  };
  var isStrictBindReservedWord = function(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  };
  var isKeyword = function(word) {
    return keywords.has(word);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isKeyword = isKeyword;
  exports.isReservedWord = isReservedWord;
  exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  exports.isStrictBindReservedWord = isStrictBindReservedWord;
  exports.isStrictReservedWord = isStrictReservedWord;
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  });
  var _identifier = require_identifier();
  var _keyword = require_keyword();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS((exports) => {
  var isValidIdentifier = function(name, reserved = true) {
    if (typeof name !== "string")
      return false;
    if (reserved) {
      if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
        return false;
      }
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isValidIdentifier;
  var _helperValidatorIdentifier = require_lib3();
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/helper-string-parser/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var readStringContents = function(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const {
      length
    } = input;
    for (;; ) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          };
        } else {
          out += res.ch;
        }
        ({
          pos,
          lineStart,
          curLine
        } = res);
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  };
  var isStringEnd = function(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  };
  var readEscapedChar = function(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch2) => ({
      pos,
      ch: ch2,
      lineStart,
      curLine
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCharCode(code));
      }
      case 117: {
        let code;
        ({
          code,
          pos
        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCodePoint(code));
      }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  };
  var readHexChar = function(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({
      n,
      pos
    } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos
    };
  };
  var readInt = function(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len;i < e; ++i) {
      const code = input.charCodeAt(pos);
      let val;
      if (code === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError)
            return {
              n: null,
              pos
            };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos
      };
    }
    return {
      n: total,
      pos
    };
  };
  var readCodePoint = function(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
      ++pos;
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
      ++pos;
      if (code !== null && code > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos
          };
        }
      }
    } else {
      ({
        code,
        pos
      } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    return {
      code,
      pos
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.readCodePoint = readCodePoint;
  exports.readInt = readInt;
  exports.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  };
  var isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = undefined;
  var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];
  var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];
  var COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"];
  var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
  var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
  var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  var BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
  var ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
  var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];
  var UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
  var INHERIT_KEYS = exports.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  var BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  var NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/utils.js
var require_utils2 = __commonJS((exports) => {
  var getType = function(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  };
  var validate = function(validate2) {
    return {
      validate: validate2
    };
  };
  var typeIs = function(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
  };
  var validateType = function(typeName) {
    return validate(typeIs(typeName));
  };
  var validateOptional = function(validate2) {
    return {
      validate: validate2,
      optional: true
    };
  };
  var validateOptionalType = function(typeName) {
    return {
      validate: typeIs(typeName),
      optional: true
    };
  };
  var arrayOf = function(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  };
  var arrayOfType = function(typeName) {
    return arrayOf(typeIs(typeName));
  };
  var validateArrayOfType = function(typeName) {
    return validate(arrayOfType(typeName));
  };
  var assertEach = function(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val))
        return;
      for (let i = 0;i < val.length; i++) {
        const subkey = `${key}[${i}]`;
        const v = val[i];
        callback(node, subkey, v);
        if (process.env.BABEL_TYPES_8_BREAKING)
          (0, _validate.validateChild)(node, subkey, v);
      }
    }
    validator.each = callback;
    return validator;
  };
  var assertOneOf = function(...values) {
    function validate2(node, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
      }
    }
    validate2.oneOf = values;
    return validate2;
  };
  var assertNodeType = function(...types) {
    function validate2(node, key, val) {
      for (const type of types) {
        if ((0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
      }
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? undefined : val.type)}`);
    }
    validate2.oneOfNodeTypes = types;
    return validate2;
  };
  var assertNodeOrValueType = function(...types) {
    function validate2(node, key, val) {
      for (const type of types) {
        if (getType(val) === type || (0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
      }
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? undefined : val.type)}`);
    }
    validate2.oneOfNodeOrValueTypes = types;
    return validate2;
  };
  var assertValueType = function(type) {
    function validate2(node, key, val) {
      const valid = getType(val) === type;
      if (!valid) {
        throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
      }
    }
    validate2.type = type;
    return validate2;
  };
  var assertShape = function(shape) {
    function validate2(node, key, val) {
      const errors = [];
      for (const property of Object.keys(shape)) {
        try {
          (0, _validate.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
      }
    }
    validate2.shapeOf = shape;
    return validate2;
  };
  var assertOptionalChainStart = function() {
    function validate2(node) {
      var _current;
      let current = node;
      while (node) {
        const {
          type
        } = current;
        if (type === "OptionalCallExpression") {
          if (current.optional)
            return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional)
            return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? undefined : _current.type}`);
    }
    return validate2;
  };
  var chain = function(...fns) {
    function validate2(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }
    validate2.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }
    return validate2;
  };
  var defineAliasedType = function(...aliases) {
    return (type, opts = {}) => {
      let defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$, _defined;
        if (opts.inherits)
          defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? undefined : _store$opts$inherits$.slice();
        (_defined = defined) != null || (defined = []);
        opts.aliases = defined;
      }
      const additional = aliases.filter((a) => !defined.includes(a));
      defined.unshift(...additional);
      defineType(type, opts);
    };
  };
  var defineType = function(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits.fields) {
        const keys = Object.getOwnPropertyNames(inherits.fields);
        for (const key of keys) {
          const field = inherits.fields[key];
          const def = field.default;
          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            deprecated: field.deprecated,
            validate: field.validate
          };
        }
      }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)) {
      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error(`Unknown type option "${k}" on ${type}`);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (const key of visitor.concat(builder)) {
      fields[key] = fields[key] || {};
    }
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      if (field.default !== undefined && builder.indexOf(key) === -1) {
        field.optional = true;
      }
      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }
      for (const k of Object.keys(field)) {
        if (validFieldKeys.indexOf(k) === -1) {
          throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias) => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    store[type] = opts;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = undefined;
  exports.arrayOf = arrayOf;
  exports.arrayOfType = arrayOfType;
  exports.assertEach = assertEach;
  exports.assertNodeOrValueType = assertNodeOrValueType;
  exports.assertNodeType = assertNodeType;
  exports.assertOneOf = assertOneOf;
  exports.assertOptionalChainStart = assertOptionalChainStart;
  exports.assertShape = assertShape;
  exports.assertValueType = assertValueType;
  exports.chain = chain;
  exports.default = defineType;
  exports.defineAliasedType = defineAliasedType;
  exports.typeIs = typeIs;
  exports.validate = validate;
  exports.validateArrayOfType = validateArrayOfType;
  exports.validateOptional = validateOptional;
  exports.validateOptionalType = validateOptionalType;
  exports.validateType = validateType;
  var _is = require_is();
  var _validate = require_validate();
  var VISITOR_KEYS = exports.VISITOR_KEYS = {};
  var ALIAS_KEYS = exports.ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};
  var NODE_FIELDS = exports.NODE_FIELDS = {};
  var BUILDER_KEYS = exports.BUILDER_KEYS = {};
  var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};
  var NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};
  var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
  var validFieldKeys = ["default", "optional", "deprecated", "validate"];
  var store = {};
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/core.js
var require_core5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = undefined;
  var _is = require_is();
  var _isValidIdentifier = require_isValidIdentifier();
  var _helperValidatorIdentifier = require_lib3();
  var _helperStringParser = require_lib4();
  var _index = require_constants();
  var _utils = require_utils2();
  var defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertValueType)("string");
          }
          const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
          const pattern = (0, _utils.assertOneOf)("=");
          return function(node, key, val) {
            const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }()
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const expression = (0, _utils.assertNodeType)("Expression");
          const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          const validator = Object.assign(function(node, key, val) {
            const validator2 = node.operator === "in" ? inOp : expression;
            validator2(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
          return validator;
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertOneOf)(true, false),
        optional: true
      }
    } : {}, {
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, _utils.assertNodeType)("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: (0, _utils.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  var functionCommon = () => ({
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: false
    },
    async: {
      default: false
    }
  });
  exports.functionCommon = functionCommon;
  var functionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  });
  exports.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return () => {
        };
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  var patternLikeCommon = () => ({
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  });
  exports.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!(0, _isValidIdentifier.default)(val, false)) {
            throw new TypeError(`"${val}" is not a valid identifier name`);
          }
        }, {
          type: "string"
        }))
      }
    }),
    validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const match = /\.(\w+)$/.exec(key);
      if (!match)
        return;
      const [, parentKey] = match;
      const nonComp = {
        computed: false
      };
      if (parentKey === "property") {
        if ((0, _is.default)("MemberExpression", parent, nonComp))
          return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
          return;
      } else if (parentKey === "key") {
        if ((0, _is.default)("Property", parent, nonComp))
          return;
        if ((0, _is.default)("Method", parent, nonComp))
          return;
      } else if (parentKey === "exported") {
        if ((0, _is.default)("ExportSpecifier", parent))
          return;
      } else if (parentKey === "imported") {
        if ((0, _is.default)("ImportSpecifier", parent, {
          imported: node
        }))
          return;
      } else if (parentKey === "meta") {
        if ((0, _is.default)("MetaProperty", parent, {
          meta: node
        }))
          return;
      }
      if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
        throw new TypeError(`"${node.name}" is not a valid identifier`);
      }
    }
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node, key, val) {
          if (1 / val < 0 || !Number.isFinite(val)) {
            const error = new Error("NumericLiterals must be non-negative finite numbers. " + `You can use t.valueToNode(${val}) instead.`);
            {
            }
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, _utils.assertValueType)("string")
      },
      flags: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const invalid = /[^gimsuy]/.exec(val);
          if (invalid) {
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
          }
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, _utils.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        default: false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertOneOf)(true, false),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true
      },
      directives: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  });
  defineType("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      kind: Object.assign({
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        default: "method"
      } : {}),
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
    fields: {
      computed: {
        default: false
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
          return validator;
        }()
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
        }, {
          type: "boolean"
        }), function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && !(0, _is.default)("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }),
        default: false
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
      const expression = (0, _utils.assertNodeType)("Expression");
      return function(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate(parent, key) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match)
        throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > +index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    }
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      consequent: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
      }
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: true
      },
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      if (!(0, _is.default)("ForXStatement", parent, {
        left: node
      }))
        return;
      if (node.declarations.length !== 1) {
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
      }
    }
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("LVal");
          }
          const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
          const without = (0, _utils.assertNodeType)("Identifier");
          return function(node, key, val) {
            const validator = node.init ? normal : without;
            validator(node, key, val);
          };
        }()
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      expression: {
        validate: (0, _utils.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    },
    validate: function() {
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
      attributes: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      }
    }
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
  });
  defineType("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        })
      },
      attributes: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return sourced;
          return function(node, key, val) {
            const validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          };
        }()))
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(node, key, val) {
            if ((0, _is.default)("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          };
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      await: {
        default: false
      }
    }
  });
  defineType("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      options: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          let property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
              break;
          }
          if (!(0, _is.default)("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = () => ({
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    static: {
      default: false
    },
    override: {
      default: false
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    key: {
      validate: (0, _utils.chain)(function() {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function(node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  });
  exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertShape)({
          raw: {
            validate: (0, _utils.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils.assertValueType)("string"),
            optional: true
          }
        }), function templateElementCookedValidator(node) {
          const raw = node.value.raw;
          let unterminatedCalled = false;
          const error = () => {
            throw new Error("Internal @babel/types error.");
          };
          const {
            str,
            firstInvalidLoc
          } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
            unterminated() {
              unterminatedCalled = true;
            },
            strictNumericEscape: error,
            invalidEscapeSequence: error,
            numericSeparatorInEscapeSequence: error,
            unexpectedNumericSeparator: error,
            invalidDigit: error,
            invalidCodePoint: error
          });
          if (!unterminatedCalled)
            throw new Error("Invalid raw");
          node.value.cooked = firstInvalidLoc ? null : str;
        })
      },
      tail: {
        default: false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(function(node, key, val) {
            const validator2 = node.computed ? computed : normal;
            validator2(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
          return validator;
        }()
      },
      computed: {
        default: false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS(() => {
  var _utils = require_utils2();
  var defineType = (0, _utils.defineAliasedType)("Flow");
  var defineInterfaceishType = (name) => {
    const isDeclareClass = name === "DeclareClass";
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
      }, isDeclareClass ? {
        mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, _utils.validateType)("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: []
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: []
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: []
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      },
      inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS(() => {
  var _utils = require_utils2();
  var defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, _utils.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: false
      },
      attributes: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = undefined;
  var _utils = require_utils2();
  var PLACEHOLDERS = exports.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length)
      PLACEHOLDERS_ALIAS[type] = alias;
  }
  var PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
    PLACEHOLDERS_ALIAS[type].forEach((alias) => {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS(() => {
  var _utils = require_utils2();
  var _placeholders = require_placeholders();
  var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", {
      visitor: []
    });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
      }
    }
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS(() => {
  var _utils = require_utils2();
  (0, _utils.default)("ArgumentPlaceholder", {});
  (0, _utils.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, _utils.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, _utils.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS(() => {
  var _utils = require_utils2();
  var _core = require_core5();
  var _is = require_is();
  var defineType = (0, _utils.defineAliasedType)("TypeScript");
  var bool = (0, _utils.assertValueType)("boolean");
  var tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  });
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  var signatureDeclarationCommon = () => ({
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    ["parameters"]: (0, _utils.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  });
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon()
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = () => ({
    key: (0, _utils.validateType)("Expression"),
    computed: {
      default: false
    },
    optional: (0, _utils.validateOptional)(bool)
  });
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set")
      }
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const type of tsKeywordTypes) {
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
      abstract: (0, _utils.validateOptional)(bool)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: {
        validate: bool,
        default: false
      },
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeParameter: (0, _utils.validateType)("TSTypeParameter"),
      optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType")
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
          const unaryOperator = (0, _utils.assertOneOf)("-");
          const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function validator(parent, key, node) {
            if ((0, _is.default)("UnaryExpression", node)) {
              unaryOperator(node, "operator", node.operator);
              unaryExpression(node, "argument", node.argument);
            } else {
              literal(parent, key, node);
            }
          }
          validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
          return validator;
        }()
      }
    }
  });
  defineType("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var TSTypeExpression = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  };
  defineType("TSAsExpression", TSTypeExpression);
  defineType("TSSatisfiesExpression", TSTypeExpression);
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      const: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      members: (0, _utils.validateArrayOfType)("TSEnumMember"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      global: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, _utils.validate)(bool),
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
      }
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      in: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      out: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      const: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      }
    }
  });
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEPRECATED_ALIASES = undefined;
  var DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.BUILDER_KEYS;
    }
  });
  Object.defineProperty(exports, "DEPRECATED_ALIASES", {
    enumerable: true,
    get: function() {
      return _deprecatedAliases.DEPRECATED_ALIASES;
    }
  });
  Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.DEPRECATED_KEYS;
    }
  });
  Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.FLIPPED_ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function() {
      return _utils.NODE_FIELDS;
    }
  });
  Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function() {
      return _utils.NODE_PARENT_VALIDATIONS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS_ALIAS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function() {
      return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
  });
  exports.TYPES = undefined;
  Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function() {
      return _utils.VISITOR_KEYS;
    }
  });
  var _toFastProperties = require_to_fast_properties();
  require_core5();
  require_flow();
  require_jsx();
  require_misc();
  require_experimental();
  require_typescript();
  var _utils = require_utils2();
  var _placeholders = require_placeholders();
  var _deprecatedAliases = require_deprecated_aliases();
  Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
    _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
  });
  _toFastProperties(_utils.VISITOR_KEYS);
  _toFastProperties(_utils.ALIAS_KEYS);
  _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
  _toFastProperties(_utils.NODE_FIELDS);
  _toFastProperties(_utils.BUILDER_KEYS);
  _toFastProperties(_utils.DEPRECATED_KEYS);
  _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
  _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
  var TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS((exports) => {
  var validate = function(node, key, val) {
    if (!node)
      return;
    const fields = _index.NODE_FIELDS[node.type];
    if (!fields)
      return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  };
  var validateField = function(node, key, val, field) {
    if (!(field != null && field.validate))
      return;
    if (field.optional && val == null)
      return;
    field.validate(node, key, val);
  };
  var validateChild = function(node, key, val) {
    if (val == null)
      return;
    const validate2 = _index.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate2)
      return;
    validate2(node, key, val);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = validate;
  exports.validateChild = validateChild;
  exports.validateField = validateField;
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/validateNode.js
var require_validateNode = __commonJS((exports) => {
  var validateNode = function(node) {
    const keys = _index.BUILDER_KEYS[node.type];
    for (const key of keys) {
      (0, _validate.default)(node, key, node[key]);
    }
    return node;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = validateNode;
  var _validate = require_validate();
  var _index = require_lib5();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS((exports) => {
  var arrayExpression = function(elements = []) {
    return (0, _validateNode.default)({
      type: "ArrayExpression",
      elements
    });
  };
  var assignmentExpression = function(operator, left, right) {
    return (0, _validateNode.default)({
      type: "AssignmentExpression",
      operator,
      left,
      right
    });
  };
  var binaryExpression = function(operator, left, right) {
    return (0, _validateNode.default)({
      type: "BinaryExpression",
      operator,
      left,
      right
    });
  };
  var interpreterDirective = function(value) {
    return (0, _validateNode.default)({
      type: "InterpreterDirective",
      value
    });
  };
  var directive = function(value) {
    return (0, _validateNode.default)({
      type: "Directive",
      value
    });
  };
  var directiveLiteral = function(value) {
    return (0, _validateNode.default)({
      type: "DirectiveLiteral",
      value
    });
  };
  var blockStatement = function(body, directives = []) {
    return (0, _validateNode.default)({
      type: "BlockStatement",
      body,
      directives
    });
  };
  var breakStatement = function(label = null) {
    return (0, _validateNode.default)({
      type: "BreakStatement",
      label
    });
  };
  var callExpression = function(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "CallExpression",
      callee,
      arguments: _arguments
    });
  };
  var catchClause = function(param = null, body) {
    return (0, _validateNode.default)({
      type: "CatchClause",
      param,
      body
    });
  };
  var conditionalExpression = function(test, consequent, alternate) {
    return (0, _validateNode.default)({
      type: "ConditionalExpression",
      test,
      consequent,
      alternate
    });
  };
  var continueStatement = function(label = null) {
    return (0, _validateNode.default)({
      type: "ContinueStatement",
      label
    });
  };
  var debuggerStatement = function() {
    return {
      type: "DebuggerStatement"
    };
  };
  var doWhileStatement = function(test, body) {
    return (0, _validateNode.default)({
      type: "DoWhileStatement",
      test,
      body
    });
  };
  var emptyStatement = function() {
    return {
      type: "EmptyStatement"
    };
  };
  var expressionStatement = function(expression) {
    return (0, _validateNode.default)({
      type: "ExpressionStatement",
      expression
    });
  };
  var file = function(program2, comments = null, tokens = null) {
    return (0, _validateNode.default)({
      type: "File",
      program: program2,
      comments,
      tokens
    });
  };
  var forInStatement = function(left, right, body) {
    return (0, _validateNode.default)({
      type: "ForInStatement",
      left,
      right,
      body
    });
  };
  var forStatement = function(init = null, test = null, update = null, body) {
    return (0, _validateNode.default)({
      type: "ForStatement",
      init,
      test,
      update,
      body
    });
  };
  var functionDeclaration = function(id = null, params, body, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "FunctionDeclaration",
      id,
      params,
      body,
      generator,
      async
    });
  };
  var functionExpression = function(id = null, params, body, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "FunctionExpression",
      id,
      params,
      body,
      generator,
      async
    });
  };
  var identifier = function(name) {
    return (0, _validateNode.default)({
      type: "Identifier",
      name
    });
  };
  var ifStatement = function(test, consequent, alternate = null) {
    return (0, _validateNode.default)({
      type: "IfStatement",
      test,
      consequent,
      alternate
    });
  };
  var labeledStatement = function(label, body) {
    return (0, _validateNode.default)({
      type: "LabeledStatement",
      label,
      body
    });
  };
  var stringLiteral = function(value) {
    return (0, _validateNode.default)({
      type: "StringLiteral",
      value
    });
  };
  var numericLiteral = function(value) {
    return (0, _validateNode.default)({
      type: "NumericLiteral",
      value
    });
  };
  var nullLiteral = function() {
    return {
      type: "NullLiteral"
    };
  };
  var booleanLiteral = function(value) {
    return (0, _validateNode.default)({
      type: "BooleanLiteral",
      value
    });
  };
  var regExpLiteral = function(pattern, flags = "") {
    return (0, _validateNode.default)({
      type: "RegExpLiteral",
      pattern,
      flags
    });
  };
  var logicalExpression = function(operator, left, right) {
    return (0, _validateNode.default)({
      type: "LogicalExpression",
      operator,
      left,
      right
    });
  };
  var memberExpression = function(object, property, computed = false, optional = null) {
    return (0, _validateNode.default)({
      type: "MemberExpression",
      object,
      property,
      computed,
      optional
    });
  };
  var newExpression = function(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "NewExpression",
      callee,
      arguments: _arguments
    });
  };
  var program = function(body, directives = [], sourceType = "script", interpreter = null) {
    return (0, _validateNode.default)({
      type: "Program",
      body,
      directives,
      sourceType,
      interpreter
    });
  };
  var objectExpression = function(properties) {
    return (0, _validateNode.default)({
      type: "ObjectExpression",
      properties
    });
  };
  var objectMethod = function(kind = "method", key, params, body, computed = false, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "ObjectMethod",
      kind,
      key,
      params,
      body,
      computed,
      generator,
      async
    });
  };
  var objectProperty = function(key, value, computed = false, shorthand = false, decorators = null) {
    return (0, _validateNode.default)({
      type: "ObjectProperty",
      key,
      value,
      computed,
      shorthand,
      decorators
    });
  };
  var restElement = function(argument) {
    return (0, _validateNode.default)({
      type: "RestElement",
      argument
    });
  };
  var returnStatement = function(argument = null) {
    return (0, _validateNode.default)({
      type: "ReturnStatement",
      argument
    });
  };
  var sequenceExpression = function(expressions) {
    return (0, _validateNode.default)({
      type: "SequenceExpression",
      expressions
    });
  };
  var parenthesizedExpression = function(expression) {
    return (0, _validateNode.default)({
      type: "ParenthesizedExpression",
      expression
    });
  };
  var switchCase = function(test = null, consequent) {
    return (0, _validateNode.default)({
      type: "SwitchCase",
      test,
      consequent
    });
  };
  var switchStatement = function(discriminant, cases) {
    return (0, _validateNode.default)({
      type: "SwitchStatement",
      discriminant,
      cases
    });
  };
  var thisExpression = function() {
    return {
      type: "ThisExpression"
    };
  };
  var throwStatement = function(argument) {
    return (0, _validateNode.default)({
      type: "ThrowStatement",
      argument
    });
  };
  var tryStatement = function(block, handler = null, finalizer = null) {
    return (0, _validateNode.default)({
      type: "TryStatement",
      block,
      handler,
      finalizer
    });
  };
  var unaryExpression = function(operator, argument, prefix = true) {
    return (0, _validateNode.default)({
      type: "UnaryExpression",
      operator,
      argument,
      prefix
    });
  };
  var updateExpression = function(operator, argument, prefix = false) {
    return (0, _validateNode.default)({
      type: "UpdateExpression",
      operator,
      argument,
      prefix
    });
  };
  var variableDeclaration = function(kind, declarations) {
    return (0, _validateNode.default)({
      type: "VariableDeclaration",
      kind,
      declarations
    });
  };
  var variableDeclarator = function(id, init = null) {
    return (0, _validateNode.default)({
      type: "VariableDeclarator",
      id,
      init
    });
  };
  var whileStatement = function(test, body) {
    return (0, _validateNode.default)({
      type: "WhileStatement",
      test,
      body
    });
  };
  var withStatement = function(object, body) {
    return (0, _validateNode.default)({
      type: "WithStatement",
      object,
      body
    });
  };
  var assignmentPattern = function(left, right) {
    return (0, _validateNode.default)({
      type: "AssignmentPattern",
      left,
      right
    });
  };
  var arrayPattern = function(elements) {
    return (0, _validateNode.default)({
      type: "ArrayPattern",
      elements
    });
  };
  var arrowFunctionExpression = function(params, body, async = false) {
    return (0, _validateNode.default)({
      type: "ArrowFunctionExpression",
      params,
      body,
      async,
      expression: null
    });
  };
  var classBody = function(body) {
    return (0, _validateNode.default)({
      type: "ClassBody",
      body
    });
  };
  var classExpression = function(id = null, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
      type: "ClassExpression",
      id,
      superClass,
      body,
      decorators
    });
  };
  var classDeclaration = function(id = null, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
      type: "ClassDeclaration",
      id,
      superClass,
      body,
      decorators
    });
  };
  var exportAllDeclaration = function(source) {
    return (0, _validateNode.default)({
      type: "ExportAllDeclaration",
      source
    });
  };
  var exportDefaultDeclaration = function(declaration) {
    return (0, _validateNode.default)({
      type: "ExportDefaultDeclaration",
      declaration
    });
  };
  var exportNamedDeclaration = function(declaration = null, specifiers = [], source = null) {
    return (0, _validateNode.default)({
      type: "ExportNamedDeclaration",
      declaration,
      specifiers,
      source
    });
  };
  var exportSpecifier = function(local, exported) {
    return (0, _validateNode.default)({
      type: "ExportSpecifier",
      local,
      exported
    });
  };
  var forOfStatement = function(left, right, body, _await = false) {
    return (0, _validateNode.default)({
      type: "ForOfStatement",
      left,
      right,
      body,
      await: _await
    });
  };
  var importDeclaration = function(specifiers, source) {
    return (0, _validateNode.default)({
      type: "ImportDeclaration",
      specifiers,
      source
    });
  };
  var importDefaultSpecifier = function(local) {
    return (0, _validateNode.default)({
      type: "ImportDefaultSpecifier",
      local
    });
  };
  var importNamespaceSpecifier = function(local) {
    return (0, _validateNode.default)({
      type: "ImportNamespaceSpecifier",
      local
    });
  };
  var importSpecifier = function(local, imported) {
    return (0, _validateNode.default)({
      type: "ImportSpecifier",
      local,
      imported
    });
  };
  var importExpression = function(source, options = null) {
    return (0, _validateNode.default)({
      type: "ImportExpression",
      source,
      options
    });
  };
  var metaProperty = function(meta, property) {
    return (0, _validateNode.default)({
      type: "MetaProperty",
      meta,
      property
    });
  };
  var classMethod = function(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
    return (0, _validateNode.default)({
      type: "ClassMethod",
      kind,
      key,
      params,
      body,
      computed,
      static: _static,
      generator,
      async
    });
  };
  var objectPattern = function(properties) {
    return (0, _validateNode.default)({
      type: "ObjectPattern",
      properties
    });
  };
  var spreadElement = function(argument) {
    return (0, _validateNode.default)({
      type: "SpreadElement",
      argument
    });
  };
  var _super = function() {
    return {
      type: "Super"
    };
  };
  var taggedTemplateExpression = function(tag, quasi) {
    return (0, _validateNode.default)({
      type: "TaggedTemplateExpression",
      tag,
      quasi
    });
  };
  var templateElement = function(value, tail = false) {
    return (0, _validateNode.default)({
      type: "TemplateElement",
      value,
      tail
    });
  };
  var templateLiteral = function(quasis, expressions) {
    return (0, _validateNode.default)({
      type: "TemplateLiteral",
      quasis,
      expressions
    });
  };
  var yieldExpression = function(argument = null, delegate = false) {
    return (0, _validateNode.default)({
      type: "YieldExpression",
      argument,
      delegate
    });
  };
  var awaitExpression = function(argument) {
    return (0, _validateNode.default)({
      type: "AwaitExpression",
      argument
    });
  };
  var _import = function() {
    return {
      type: "Import"
    };
  };
  var bigIntLiteral = function(value) {
    return (0, _validateNode.default)({
      type: "BigIntLiteral",
      value
    });
  };
  var exportNamespaceSpecifier = function(exported) {
    return (0, _validateNode.default)({
      type: "ExportNamespaceSpecifier",
      exported
    });
  };
  var optionalMemberExpression = function(object, property, computed = false, optional) {
    return (0, _validateNode.default)({
      type: "OptionalMemberExpression",
      object,
      property,
      computed,
      optional
    });
  };
  var optionalCallExpression = function(callee, _arguments, optional) {
    return (0, _validateNode.default)({
      type: "OptionalCallExpression",
      callee,
      arguments: _arguments,
      optional
    });
  };
  var classProperty = function(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    });
  };
  var classAccessorProperty = function(key, value = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassAccessorProperty",
      key,
      value,
      typeAnnotation: typeAnnotation2,
      decorators,
      computed,
      static: _static
    });
  };
  var classPrivateProperty = function(key, value = null, decorators = null, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassPrivateProperty",
      key,
      value,
      decorators,
      static: _static
    });
  };
  var classPrivateMethod = function(kind = "method", key, params, body, _static = false) {
    return (0, _validateNode.default)({
      type: "ClassPrivateMethod",
      kind,
      key,
      params,
      body,
      static: _static
    });
  };
  var privateName = function(id) {
    return (0, _validateNode.default)({
      type: "PrivateName",
      id
    });
  };
  var staticBlock = function(body) {
    return (0, _validateNode.default)({
      type: "StaticBlock",
      body
    });
  };
  var anyTypeAnnotation = function() {
    return {
      type: "AnyTypeAnnotation"
    };
  };
  var arrayTypeAnnotation = function(elementType) {
    return (0, _validateNode.default)({
      type: "ArrayTypeAnnotation",
      elementType
    });
  };
  var booleanTypeAnnotation = function() {
    return {
      type: "BooleanTypeAnnotation"
    };
  };
  var booleanLiteralTypeAnnotation = function(value) {
    return (0, _validateNode.default)({
      type: "BooleanLiteralTypeAnnotation",
      value
    });
  };
  var nullLiteralTypeAnnotation = function() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  };
  var classImplements = function(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "ClassImplements",
      id,
      typeParameters
    });
  };
  var declareClass = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareClass",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var declareFunction = function(id) {
    return (0, _validateNode.default)({
      type: "DeclareFunction",
      id
    });
  };
  var declareInterface = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareInterface",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var declareModule = function(id, body, kind = null) {
    return (0, _validateNode.default)({
      type: "DeclareModule",
      id,
      body,
      kind
    });
  };
  var declareModuleExports = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation2
    });
  };
  var declareTypeAlias = function(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
      type: "DeclareTypeAlias",
      id,
      typeParameters,
      right
    });
  };
  var declareOpaqueType = function(id, typeParameters = null, supertype = null) {
    return (0, _validateNode.default)({
      type: "DeclareOpaqueType",
      id,
      typeParameters,
      supertype
    });
  };
  var declareVariable = function(id) {
    return (0, _validateNode.default)({
      type: "DeclareVariable",
      id
    });
  };
  var declareExportDeclaration = function(declaration = null, specifiers = null, source = null) {
    return (0, _validateNode.default)({
      type: "DeclareExportDeclaration",
      declaration,
      specifiers,
      source
    });
  };
  var declareExportAllDeclaration = function(source) {
    return (0, _validateNode.default)({
      type: "DeclareExportAllDeclaration",
      source
    });
  };
  var declaredPredicate = function(value) {
    return (0, _validateNode.default)({
      type: "DeclaredPredicate",
      value
    });
  };
  var existsTypeAnnotation = function() {
    return {
      type: "ExistsTypeAnnotation"
    };
  };
  var functionTypeAnnotation = function(typeParameters = null, params, rest = null, returnType) {
    return (0, _validateNode.default)({
      type: "FunctionTypeAnnotation",
      typeParameters,
      params,
      rest,
      returnType
    });
  };
  var functionTypeParam = function(name = null, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "FunctionTypeParam",
      name,
      typeAnnotation: typeAnnotation2
    });
  };
  var genericTypeAnnotation = function(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "GenericTypeAnnotation",
      id,
      typeParameters
    });
  };
  var inferredPredicate = function() {
    return {
      type: "InferredPredicate"
    };
  };
  var interfaceExtends = function(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "InterfaceExtends",
      id,
      typeParameters
    });
  };
  var interfaceDeclaration = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "InterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var interfaceTypeAnnotation = function(_extends = null, body) {
    return (0, _validateNode.default)({
      type: "InterfaceTypeAnnotation",
      extends: _extends,
      body
    });
  };
  var intersectionTypeAnnotation = function(types) {
    return (0, _validateNode.default)({
      type: "IntersectionTypeAnnotation",
      types
    });
  };
  var mixedTypeAnnotation = function() {
    return {
      type: "MixedTypeAnnotation"
    };
  };
  var emptyTypeAnnotation = function() {
    return {
      type: "EmptyTypeAnnotation"
    };
  };
  var nullableTypeAnnotation = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation2
    });
  };
  var numberLiteralTypeAnnotation = function(value) {
    return (0, _validateNode.default)({
      type: "NumberLiteralTypeAnnotation",
      value
    });
  };
  var numberTypeAnnotation = function() {
    return {
      type: "NumberTypeAnnotation"
    };
  };
  var objectTypeAnnotation = function(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    return (0, _validateNode.default)({
      type: "ObjectTypeAnnotation",
      properties,
      indexers,
      callProperties,
      internalSlots,
      exact
    });
  };
  var objectTypeInternalSlot = function(id, value, optional, _static, method) {
    return (0, _validateNode.default)({
      type: "ObjectTypeInternalSlot",
      id,
      value,
      optional,
      static: _static,
      method
    });
  };
  var objectTypeCallProperty = function(value) {
    return (0, _validateNode.default)({
      type: "ObjectTypeCallProperty",
      value,
      static: null
    });
  };
  var objectTypeIndexer = function(id = null, key, value, variance2 = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeIndexer",
      id,
      key,
      value,
      variance: variance2,
      static: null
    });
  };
  var objectTypeProperty = function(key, value, variance2 = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeProperty",
      key,
      value,
      variance: variance2,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  };
  var objectTypeSpreadProperty = function(argument) {
    return (0, _validateNode.default)({
      type: "ObjectTypeSpreadProperty",
      argument
    });
  };
  var opaqueType = function(id, typeParameters = null, supertype = null, impltype) {
    return (0, _validateNode.default)({
      type: "OpaqueType",
      id,
      typeParameters,
      supertype,
      impltype
    });
  };
  var qualifiedTypeIdentifier = function(id, qualification) {
    return (0, _validateNode.default)({
      type: "QualifiedTypeIdentifier",
      id,
      qualification
    });
  };
  var stringLiteralTypeAnnotation = function(value) {
    return (0, _validateNode.default)({
      type: "StringLiteralTypeAnnotation",
      value
    });
  };
  var stringTypeAnnotation = function() {
    return {
      type: "StringTypeAnnotation"
    };
  };
  var symbolTypeAnnotation = function() {
    return {
      type: "SymbolTypeAnnotation"
    };
  };
  var thisTypeAnnotation = function() {
    return {
      type: "ThisTypeAnnotation"
    };
  };
  var tupleTypeAnnotation = function(types) {
    return (0, _validateNode.default)({
      type: "TupleTypeAnnotation",
      types
    });
  };
  var typeofTypeAnnotation = function(argument) {
    return (0, _validateNode.default)({
      type: "TypeofTypeAnnotation",
      argument
    });
  };
  var typeAlias = function(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
      type: "TypeAlias",
      id,
      typeParameters,
      right
    });
  };
  var typeAnnotation = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation2
    });
  };
  var typeCastExpression = function(expression, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TypeCastExpression",
      expression,
      typeAnnotation: typeAnnotation2
    });
  };
  var typeParameter = function(bound = null, _default = null, variance2 = null) {
    return (0, _validateNode.default)({
      type: "TypeParameter",
      bound,
      default: _default,
      variance: variance2,
      name: null
    });
  };
  var typeParameterDeclaration = function(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterDeclaration",
      params
    });
  };
  var typeParameterInstantiation = function(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterInstantiation",
      params
    });
  };
  var unionTypeAnnotation = function(types) {
    return (0, _validateNode.default)({
      type: "UnionTypeAnnotation",
      types
    });
  };
  var variance = function(kind) {
    return (0, _validateNode.default)({
      type: "Variance",
      kind
    });
  };
  var voidTypeAnnotation = function() {
    return {
      type: "VoidTypeAnnotation"
    };
  };
  var enumDeclaration = function(id, body) {
    return (0, _validateNode.default)({
      type: "EnumDeclaration",
      id,
      body
    });
  };
  var enumBooleanBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumBooleanBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    });
  };
  var enumNumberBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumNumberBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    });
  };
  var enumStringBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumStringBody",
      members,
      explicitType: null,
      hasUnknownMembers: null
    });
  };
  var enumSymbolBody = function(members) {
    return (0, _validateNode.default)({
      type: "EnumSymbolBody",
      members,
      hasUnknownMembers: null
    });
  };
  var enumBooleanMember = function(id) {
    return (0, _validateNode.default)({
      type: "EnumBooleanMember",
      id,
      init: null
    });
  };
  var enumNumberMember = function(id, init) {
    return (0, _validateNode.default)({
      type: "EnumNumberMember",
      id,
      init
    });
  };
  var enumStringMember = function(id, init) {
    return (0, _validateNode.default)({
      type: "EnumStringMember",
      id,
      init
    });
  };
  var enumDefaultedMember = function(id) {
    return (0, _validateNode.default)({
      type: "EnumDefaultedMember",
      id
    });
  };
  var indexedAccessType = function(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "IndexedAccessType",
      objectType,
      indexType
    });
  };
  var optionalIndexedAccessType = function(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "OptionalIndexedAccessType",
      objectType,
      indexType,
      optional: null
    });
  };
  var jsxAttribute = function(name, value = null) {
    return (0, _validateNode.default)({
      type: "JSXAttribute",
      name,
      value
    });
  };
  var jsxClosingElement = function(name) {
    return (0, _validateNode.default)({
      type: "JSXClosingElement",
      name
    });
  };
  var jsxElement = function(openingElement, closingElement = null, children, selfClosing = null) {
    return (0, _validateNode.default)({
      type: "JSXElement",
      openingElement,
      closingElement,
      children,
      selfClosing
    });
  };
  var jsxEmptyExpression = function() {
    return {
      type: "JSXEmptyExpression"
    };
  };
  var jsxExpressionContainer = function(expression) {
    return (0, _validateNode.default)({
      type: "JSXExpressionContainer",
      expression
    });
  };
  var jsxSpreadChild = function(expression) {
    return (0, _validateNode.default)({
      type: "JSXSpreadChild",
      expression
    });
  };
  var jsxIdentifier = function(name) {
    return (0, _validateNode.default)({
      type: "JSXIdentifier",
      name
    });
  };
  var jsxMemberExpression = function(object, property) {
    return (0, _validateNode.default)({
      type: "JSXMemberExpression",
      object,
      property
    });
  };
  var jsxNamespacedName = function(namespace, name) {
    return (0, _validateNode.default)({
      type: "JSXNamespacedName",
      namespace,
      name
    });
  };
  var jsxOpeningElement = function(name, attributes, selfClosing = false) {
    return (0, _validateNode.default)({
      type: "JSXOpeningElement",
      name,
      attributes,
      selfClosing
    });
  };
  var jsxSpreadAttribute = function(argument) {
    return (0, _validateNode.default)({
      type: "JSXSpreadAttribute",
      argument
    });
  };
  var jsxText = function(value) {
    return (0, _validateNode.default)({
      type: "JSXText",
      value
    });
  };
  var jsxFragment = function(openingFragment, closingFragment, children) {
    return (0, _validateNode.default)({
      type: "JSXFragment",
      openingFragment,
      closingFragment,
      children
    });
  };
  var jsxOpeningFragment = function() {
    return {
      type: "JSXOpeningFragment"
    };
  };
  var jsxClosingFragment = function() {
    return {
      type: "JSXClosingFragment"
    };
  };
  var noop = function() {
    return {
      type: "Noop"
    };
  };
  var placeholder = function(expectedNode, name) {
    return (0, _validateNode.default)({
      type: "Placeholder",
      expectedNode,
      name
    });
  };
  var v8IntrinsicIdentifier = function(name) {
    return (0, _validateNode.default)({
      type: "V8IntrinsicIdentifier",
      name
    });
  };
  var argumentPlaceholder = function() {
    return {
      type: "ArgumentPlaceholder"
    };
  };
  var bindExpression = function(object, callee) {
    return (0, _validateNode.default)({
      type: "BindExpression",
      object,
      callee
    });
  };
  var importAttribute = function(key, value) {
    return (0, _validateNode.default)({
      type: "ImportAttribute",
      key,
      value
    });
  };
  var decorator = function(expression) {
    return (0, _validateNode.default)({
      type: "Decorator",
      expression
    });
  };
  var doExpression = function(body, async = false) {
    return (0, _validateNode.default)({
      type: "DoExpression",
      body,
      async
    });
  };
  var exportDefaultSpecifier = function(exported) {
    return (0, _validateNode.default)({
      type: "ExportDefaultSpecifier",
      exported
    });
  };
  var recordExpression = function(properties) {
    return (0, _validateNode.default)({
      type: "RecordExpression",
      properties
    });
  };
  var tupleExpression = function(elements = []) {
    return (0, _validateNode.default)({
      type: "TupleExpression",
      elements
    });
  };
  var decimalLiteral = function(value) {
    return (0, _validateNode.default)({
      type: "DecimalLiteral",
      value
    });
  };
  var moduleExpression = function(body) {
    return (0, _validateNode.default)({
      type: "ModuleExpression",
      body
    });
  };
  var topicReference = function() {
    return {
      type: "TopicReference"
    };
  };
  var pipelineTopicExpression = function(expression) {
    return (0, _validateNode.default)({
      type: "PipelineTopicExpression",
      expression
    });
  };
  var pipelineBareFunction = function(callee) {
    return (0, _validateNode.default)({
      type: "PipelineBareFunction",
      callee
    });
  };
  var pipelinePrimaryTopicReference = function() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  };
  var tsParameterProperty = function(parameter) {
    return (0, _validateNode.default)({
      type: "TSParameterProperty",
      parameter
    });
  };
  var tsDeclareFunction = function(id = null, typeParameters = null, params, returnType = null) {
    return (0, _validateNode.default)({
      type: "TSDeclareFunction",
      id,
      typeParameters,
      params,
      returnType
    });
  };
  var tsDeclareMethod = function(decorators = null, key, typeParameters = null, params, returnType = null) {
    return (0, _validateNode.default)({
      type: "TSDeclareMethod",
      decorators,
      key,
      typeParameters,
      params,
      returnType
    });
  };
  var tsQualifiedName = function(left, right) {
    return (0, _validateNode.default)({
      type: "TSQualifiedName",
      left,
      right
    });
  };
  var tsCallSignatureDeclaration = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsConstructSignatureDeclaration = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsPropertySignature = function(key, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSPropertySignature",
      key,
      typeAnnotation: typeAnnotation2,
      kind: null
    });
  };
  var tsMethodSignature = function(key, typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSMethodSignature",
      key,
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2,
      kind: null
    });
  };
  var tsIndexSignature = function(parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSIndexSignature",
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsAnyKeyword = function() {
    return {
      type: "TSAnyKeyword"
    };
  };
  var tsBooleanKeyword = function() {
    return {
      type: "TSBooleanKeyword"
    };
  };
  var tsBigIntKeyword = function() {
    return {
      type: "TSBigIntKeyword"
    };
  };
  var tsIntrinsicKeyword = function() {
    return {
      type: "TSIntrinsicKeyword"
    };
  };
  var tsNeverKeyword = function() {
    return {
      type: "TSNeverKeyword"
    };
  };
  var tsNullKeyword = function() {
    return {
      type: "TSNullKeyword"
    };
  };
  var tsNumberKeyword = function() {
    return {
      type: "TSNumberKeyword"
    };
  };
  var tsObjectKeyword = function() {
    return {
      type: "TSObjectKeyword"
    };
  };
  var tsStringKeyword = function() {
    return {
      type: "TSStringKeyword"
    };
  };
  var tsSymbolKeyword = function() {
    return {
      type: "TSSymbolKeyword"
    };
  };
  var tsUndefinedKeyword = function() {
    return {
      type: "TSUndefinedKeyword"
    };
  };
  var tsUnknownKeyword = function() {
    return {
      type: "TSUnknownKeyword"
    };
  };
  var tsVoidKeyword = function() {
    return {
      type: "TSVoidKeyword"
    };
  };
  var tsThisType = function() {
    return {
      type: "TSThisType"
    };
  };
  var tsFunctionType = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSFunctionType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsConstructorType = function(typeParameters = null, parameters, typeAnnotation2 = null) {
    return (0, _validateNode.default)({
      type: "TSConstructorType",
      typeParameters,
      parameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeReference = function(typeName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeReference",
      typeName,
      typeParameters
    });
  };
  var tsTypePredicate = function(parameterName, typeAnnotation2 = null, asserts = null) {
    return (0, _validateNode.default)({
      type: "TSTypePredicate",
      parameterName,
      typeAnnotation: typeAnnotation2,
      asserts
    });
  };
  var tsTypeQuery = function(exprName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeQuery",
      exprName,
      typeParameters
    });
  };
  var tsTypeLiteral = function(members) {
    return (0, _validateNode.default)({
      type: "TSTypeLiteral",
      members
    });
  };
  var tsArrayType = function(elementType) {
    return (0, _validateNode.default)({
      type: "TSArrayType",
      elementType
    });
  };
  var tsTupleType = function(elementTypes) {
    return (0, _validateNode.default)({
      type: "TSTupleType",
      elementTypes
    });
  };
  var tsOptionalType = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsRestType = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSRestType",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsNamedTupleMember = function(label, elementType, optional = false) {
    return (0, _validateNode.default)({
      type: "TSNamedTupleMember",
      label,
      elementType,
      optional
    });
  };
  var tsUnionType = function(types) {
    return (0, _validateNode.default)({
      type: "TSUnionType",
      types
    });
  };
  var tsIntersectionType = function(types) {
    return (0, _validateNode.default)({
      type: "TSIntersectionType",
      types
    });
  };
  var tsConditionalType = function(checkType, extendsType, trueType, falseType) {
    return (0, _validateNode.default)({
      type: "TSConditionalType",
      checkType,
      extendsType,
      trueType,
      falseType
    });
  };
  var tsInferType = function(typeParameter2) {
    return (0, _validateNode.default)({
      type: "TSInferType",
      typeParameter: typeParameter2
    });
  };
  var tsParenthesizedType = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeOperator = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation2,
      operator: null
    });
  };
  var tsIndexedAccessType = function(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "TSIndexedAccessType",
      objectType,
      indexType
    });
  };
  var tsMappedType = function(typeParameter2, typeAnnotation2 = null, nameType = null) {
    return (0, _validateNode.default)({
      type: "TSMappedType",
      typeParameter: typeParameter2,
      typeAnnotation: typeAnnotation2,
      nameType
    });
  };
  var tsLiteralType = function(literal) {
    return (0, _validateNode.default)({
      type: "TSLiteralType",
      literal
    });
  };
  var tsExpressionWithTypeArguments = function(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSExpressionWithTypeArguments",
      expression,
      typeParameters
    });
  };
  var tsInterfaceDeclaration = function(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "TSInterfaceDeclaration",
      id,
      typeParameters,
      extends: _extends,
      body
    });
  };
  var tsInterfaceBody = function(body) {
    return (0, _validateNode.default)({
      type: "TSInterfaceBody",
      body
    });
  };
  var tsTypeAliasDeclaration = function(id, typeParameters = null, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSTypeAliasDeclaration",
      id,
      typeParameters,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsInstantiationExpression = function(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSInstantiationExpression",
      expression,
      typeParameters
    });
  };
  var tsAsExpression = function(expression, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSAsExpression",
      expression,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsSatisfiesExpression = function(expression, typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSSatisfiesExpression",
      expression,
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeAssertion = function(typeAnnotation2, expression) {
    return (0, _validateNode.default)({
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation2,
      expression
    });
  };
  var tsEnumDeclaration = function(id, members) {
    return (0, _validateNode.default)({
      type: "TSEnumDeclaration",
      id,
      members
    });
  };
  var tsEnumMember = function(id, initializer = null) {
    return (0, _validateNode.default)({
      type: "TSEnumMember",
      id,
      initializer
    });
  };
  var tsModuleDeclaration = function(id, body) {
    return (0, _validateNode.default)({
      type: "TSModuleDeclaration",
      id,
      body
    });
  };
  var tsModuleBlock = function(body) {
    return (0, _validateNode.default)({
      type: "TSModuleBlock",
      body
    });
  };
  var tsImportType = function(argument, qualifier = null, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSImportType",
      argument,
      qualifier,
      typeParameters
    });
  };
  var tsImportEqualsDeclaration = function(id, moduleReference) {
    return (0, _validateNode.default)({
      type: "TSImportEqualsDeclaration",
      id,
      moduleReference,
      isExport: null
    });
  };
  var tsExternalModuleReference = function(expression) {
    return (0, _validateNode.default)({
      type: "TSExternalModuleReference",
      expression
    });
  };
  var tsNonNullExpression = function(expression) {
    return (0, _validateNode.default)({
      type: "TSNonNullExpression",
      expression
    });
  };
  var tsExportAssignment = function(expression) {
    return (0, _validateNode.default)({
      type: "TSExportAssignment",
      expression
    });
  };
  var tsNamespaceExportDeclaration = function(id) {
    return (0, _validateNode.default)({
      type: "TSNamespaceExportDeclaration",
      id
    });
  };
  var tsTypeAnnotation = function(typeAnnotation2) {
    return (0, _validateNode.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation2
    });
  };
  var tsTypeParameterInstantiation = function(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterInstantiation",
      params
    });
  };
  var tsTypeParameterDeclaration = function(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterDeclaration",
      params
    });
  };
  var tsTypeParameter = function(constraint = null, _default = null, name) {
    return (0, _validateNode.default)({
      type: "TSTypeParameter",
      constraint,
      default: _default,
      name
    });
  };
  var NumberLiteral = function(value) {
    (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral(value);
  };
  var RegexLiteral = function(pattern, flags = "") {
    (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
  };
  var RestProperty = function(argument) {
    (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
    return restElement(argument);
  };
  var SpreadProperty = function(argument) {
    (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement(argument);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.anyTypeAnnotation = anyTypeAnnotation;
  exports.argumentPlaceholder = argumentPlaceholder;
  exports.arrayExpression = arrayExpression;
  exports.arrayPattern = arrayPattern;
  exports.arrayTypeAnnotation = arrayTypeAnnotation;
  exports.arrowFunctionExpression = arrowFunctionExpression;
  exports.assignmentExpression = assignmentExpression;
  exports.assignmentPattern = assignmentPattern;
  exports.awaitExpression = awaitExpression;
  exports.bigIntLiteral = bigIntLiteral;
  exports.binaryExpression = binaryExpression;
  exports.bindExpression = bindExpression;
  exports.blockStatement = blockStatement;
  exports.booleanLiteral = booleanLiteral;
  exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  exports.booleanTypeAnnotation = booleanTypeAnnotation;
  exports.breakStatement = breakStatement;
  exports.callExpression = callExpression;
  exports.catchClause = catchClause;
  exports.classAccessorProperty = classAccessorProperty;
  exports.classBody = classBody;
  exports.classDeclaration = classDeclaration;
  exports.classExpression = classExpression;
  exports.classImplements = classImplements;
  exports.classMethod = classMethod;
  exports.classPrivateMethod = classPrivateMethod;
  exports.classPrivateProperty = classPrivateProperty;
  exports.classProperty = classProperty;
  exports.conditionalExpression = conditionalExpression;
  exports.continueStatement = continueStatement;
  exports.debuggerStatement = debuggerStatement;
  exports.decimalLiteral = decimalLiteral;
  exports.declareClass = declareClass;
  exports.declareExportAllDeclaration = declareExportAllDeclaration;
  exports.declareExportDeclaration = declareExportDeclaration;
  exports.declareFunction = declareFunction;
  exports.declareInterface = declareInterface;
  exports.declareModule = declareModule;
  exports.declareModuleExports = declareModuleExports;
  exports.declareOpaqueType = declareOpaqueType;
  exports.declareTypeAlias = declareTypeAlias;
  exports.declareVariable = declareVariable;
  exports.declaredPredicate = declaredPredicate;
  exports.decorator = decorator;
  exports.directive = directive;
  exports.directiveLiteral = directiveLiteral;
  exports.doExpression = doExpression;
  exports.doWhileStatement = doWhileStatement;
  exports.emptyStatement = emptyStatement;
  exports.emptyTypeAnnotation = emptyTypeAnnotation;
  exports.enumBooleanBody = enumBooleanBody;
  exports.enumBooleanMember = enumBooleanMember;
  exports.enumDeclaration = enumDeclaration;
  exports.enumDefaultedMember = enumDefaultedMember;
  exports.enumNumberBody = enumNumberBody;
  exports.enumNumberMember = enumNumberMember;
  exports.enumStringBody = enumStringBody;
  exports.enumStringMember = enumStringMember;
  exports.enumSymbolBody = enumSymbolBody;
  exports.existsTypeAnnotation = existsTypeAnnotation;
  exports.exportAllDeclaration = exportAllDeclaration;
  exports.exportDefaultDeclaration = exportDefaultDeclaration;
  exports.exportDefaultSpecifier = exportDefaultSpecifier;
  exports.exportNamedDeclaration = exportNamedDeclaration;
  exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
  exports.exportSpecifier = exportSpecifier;
  exports.expressionStatement = expressionStatement;
  exports.file = file;
  exports.forInStatement = forInStatement;
  exports.forOfStatement = forOfStatement;
  exports.forStatement = forStatement;
  exports.functionDeclaration = functionDeclaration;
  exports.functionExpression = functionExpression;
  exports.functionTypeAnnotation = functionTypeAnnotation;
  exports.functionTypeParam = functionTypeParam;
  exports.genericTypeAnnotation = genericTypeAnnotation;
  exports.identifier = identifier;
  exports.ifStatement = ifStatement;
  exports.import = _import;
  exports.importAttribute = importAttribute;
  exports.importDeclaration = importDeclaration;
  exports.importDefaultSpecifier = importDefaultSpecifier;
  exports.importExpression = importExpression;
  exports.importNamespaceSpecifier = importNamespaceSpecifier;
  exports.importSpecifier = importSpecifier;
  exports.indexedAccessType = indexedAccessType;
  exports.inferredPredicate = inferredPredicate;
  exports.interfaceDeclaration = interfaceDeclaration;
  exports.interfaceExtends = interfaceExtends;
  exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
  exports.interpreterDirective = interpreterDirective;
  exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
  exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
  exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
  exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
  exports.jSXElement = exports.jsxElement = jsxElement;
  exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
  exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
  exports.jSXFragment = exports.jsxFragment = jsxFragment;
  exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
  exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
  exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
  exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
  exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
  exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
  exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
  exports.jSXText = exports.jsxText = jsxText;
  exports.labeledStatement = labeledStatement;
  exports.logicalExpression = logicalExpression;
  exports.memberExpression = memberExpression;
  exports.metaProperty = metaProperty;
  exports.mixedTypeAnnotation = mixedTypeAnnotation;
  exports.moduleExpression = moduleExpression;
  exports.newExpression = newExpression;
  exports.noop = noop;
  exports.nullLiteral = nullLiteral;
  exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  exports.nullableTypeAnnotation = nullableTypeAnnotation;
  exports.numberLiteral = NumberLiteral;
  exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  exports.numberTypeAnnotation = numberTypeAnnotation;
  exports.numericLiteral = numericLiteral;
  exports.objectExpression = objectExpression;
  exports.objectMethod = objectMethod;
  exports.objectPattern = objectPattern;
  exports.objectProperty = objectProperty;
  exports.objectTypeAnnotation = objectTypeAnnotation;
  exports.objectTypeCallProperty = objectTypeCallProperty;
  exports.objectTypeIndexer = objectTypeIndexer;
  exports.objectTypeInternalSlot = objectTypeInternalSlot;
  exports.objectTypeProperty = objectTypeProperty;
  exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
  exports.opaqueType = opaqueType;
  exports.optionalCallExpression = optionalCallExpression;
  exports.optionalIndexedAccessType = optionalIndexedAccessType;
  exports.optionalMemberExpression = optionalMemberExpression;
  exports.parenthesizedExpression = parenthesizedExpression;
  exports.pipelineBareFunction = pipelineBareFunction;
  exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  exports.pipelineTopicExpression = pipelineTopicExpression;
  exports.placeholder = placeholder;
  exports.privateName = privateName;
  exports.program = program;
  exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  exports.recordExpression = recordExpression;
  exports.regExpLiteral = regExpLiteral;
  exports.regexLiteral = RegexLiteral;
  exports.restElement = restElement;
  exports.restProperty = RestProperty;
  exports.returnStatement = returnStatement;
  exports.sequenceExpression = sequenceExpression;
  exports.spreadElement = spreadElement;
  exports.spreadProperty = SpreadProperty;
  exports.staticBlock = staticBlock;
  exports.stringLiteral = stringLiteral;
  exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  exports.stringTypeAnnotation = stringTypeAnnotation;
  exports.super = _super;
  exports.switchCase = switchCase;
  exports.switchStatement = switchStatement;
  exports.symbolTypeAnnotation = symbolTypeAnnotation;
  exports.taggedTemplateExpression = taggedTemplateExpression;
  exports.templateElement = templateElement;
  exports.templateLiteral = templateLiteral;
  exports.thisExpression = thisExpression;
  exports.thisTypeAnnotation = thisTypeAnnotation;
  exports.throwStatement = throwStatement;
  exports.topicReference = topicReference;
  exports.tryStatement = tryStatement;
  exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
  exports.tSArrayType = exports.tsArrayType = tsArrayType;
  exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
  exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
  exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
  exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
  exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
  exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
  exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
  exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
  exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
  exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
  exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
  exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
  exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
  exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  exports.tSImportType = exports.tsImportType = tsImportType;
  exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
  exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
  exports.tSInferType = exports.tsInferType = tsInferType;
  exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
  exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
  exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
  exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
  exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
  exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
  exports.tSMappedType = exports.tsMappedType = tsMappedType;
  exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
  exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
  exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
  exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
  exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
  exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
  exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
  exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
  exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
  exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
  exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
  exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
  exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
  exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
  exports.tSRestType = exports.tsRestType = tsRestType;
  exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
  exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
  exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
  exports.tSThisType = exports.tsThisType = tsThisType;
  exports.tSTupleType = exports.tsTupleType = tsTupleType;
  exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
  exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
  exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
  exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
  exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
  exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
  exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
  exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
  exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
  exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
  exports.tSUnionType = exports.tsUnionType = tsUnionType;
  exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
  exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
  exports.tupleExpression = tupleExpression;
  exports.tupleTypeAnnotation = tupleTypeAnnotation;
  exports.typeAlias = typeAlias;
  exports.typeAnnotation = typeAnnotation;
  exports.typeCastExpression = typeCastExpression;
  exports.typeParameter = typeParameter;
  exports.typeParameterDeclaration = typeParameterDeclaration;
  exports.typeParameterInstantiation = typeParameterInstantiation;
  exports.typeofTypeAnnotation = typeofTypeAnnotation;
  exports.unaryExpression = unaryExpression;
  exports.unionTypeAnnotation = unionTypeAnnotation;
  exports.updateExpression = updateExpression;
  exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  exports.variableDeclaration = variableDeclaration;
  exports.variableDeclarator = variableDeclarator;
  exports.variance = variance;
  exports.voidTypeAnnotation = voidTypeAnnotation;
  exports.whileStatement = whileStatement;
  exports.withStatement = withStatement;
  exports.yieldExpression = yieldExpression;
  var _validateNode = require_validateNode();
  var _deprecationWarning = require_deprecationWarning();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS((exports) => {
  var cleanJSXElementLiteralChild = function(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0;i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }
    let str = "";
    for (let i = 0;i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str)
      args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cleanJSXElementLiteralChild;
  var _index = require_generated2();
  var _index2 = require_lib5();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS((exports) => {
  var buildChildren = function(node) {
    const elements = [];
    for (let i = 0;i < node.children.length; i++) {
      let child = node.children[i];
      if ((0, _index.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }
      if ((0, _index.isJSXExpressionContainer)(child))
        child = child.expression;
      if ((0, _index.isJSXEmptyExpression)(child))
        continue;
      elements.push(child);
    }
    return elements;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildChildren;
  var _index = require_generated();
  var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS((exports) => {
  var isNode = function(node) {
    return !!(node && _index.VISITOR_KEYS[node.type]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNode;
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS((exports) => {
  var assertNode = function(node) {
    if (!(0, _isNode.default)(node)) {
      var _node$type;
      const type = (_node$type = node == null ? undefined : node.type) != null ? _node$type : JSON.stringify(node);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertNode;
  var _isNode = require_isNode();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS((exports) => {
  var assert = function(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) {
      throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
    }
  };
  var assertArrayExpression = function(node, opts) {
    assert("ArrayExpression", node, opts);
  };
  var assertAssignmentExpression = function(node, opts) {
    assert("AssignmentExpression", node, opts);
  };
  var assertBinaryExpression = function(node, opts) {
    assert("BinaryExpression", node, opts);
  };
  var assertInterpreterDirective = function(node, opts) {
    assert("InterpreterDirective", node, opts);
  };
  var assertDirective = function(node, opts) {
    assert("Directive", node, opts);
  };
  var assertDirectiveLiteral = function(node, opts) {
    assert("DirectiveLiteral", node, opts);
  };
  var assertBlockStatement = function(node, opts) {
    assert("BlockStatement", node, opts);
  };
  var assertBreakStatement = function(node, opts) {
    assert("BreakStatement", node, opts);
  };
  var assertCallExpression = function(node, opts) {
    assert("CallExpression", node, opts);
  };
  var assertCatchClause = function(node, opts) {
    assert("CatchClause", node, opts);
  };
  var assertConditionalExpression = function(node, opts) {
    assert("ConditionalExpression", node, opts);
  };
  var assertContinueStatement = function(node, opts) {
    assert("ContinueStatement", node, opts);
  };
  var assertDebuggerStatement = function(node, opts) {
    assert("DebuggerStatement", node, opts);
  };
  var assertDoWhileStatement = function(node, opts) {
    assert("DoWhileStatement", node, opts);
  };
  var assertEmptyStatement = function(node, opts) {
    assert("EmptyStatement", node, opts);
  };
  var assertExpressionStatement = function(node, opts) {
    assert("ExpressionStatement", node, opts);
  };
  var assertFile = function(node, opts) {
    assert("File", node, opts);
  };
  var assertForInStatement = function(node, opts) {
    assert("ForInStatement", node, opts);
  };
  var assertForStatement = function(node, opts) {
    assert("ForStatement", node, opts);
  };
  var assertFunctionDeclaration = function(node, opts) {
    assert("FunctionDeclaration", node, opts);
  };
  var assertFunctionExpression = function(node, opts) {
    assert("FunctionExpression", node, opts);
  };
  var assertIdentifier = function(node, opts) {
    assert("Identifier", node, opts);
  };
  var assertIfStatement = function(node, opts) {
    assert("IfStatement", node, opts);
  };
  var assertLabeledStatement = function(node, opts) {
    assert("LabeledStatement", node, opts);
  };
  var assertStringLiteral = function(node, opts) {
    assert("StringLiteral", node, opts);
  };
  var assertNumericLiteral = function(node, opts) {
    assert("NumericLiteral", node, opts);
  };
  var assertNullLiteral = function(node, opts) {
    assert("NullLiteral", node, opts);
  };
  var assertBooleanLiteral = function(node, opts) {
    assert("BooleanLiteral", node, opts);
  };
  var assertRegExpLiteral = function(node, opts) {
    assert("RegExpLiteral", node, opts);
  };
  var assertLogicalExpression = function(node, opts) {
    assert("LogicalExpression", node, opts);
  };
  var assertMemberExpression = function(node, opts) {
    assert("MemberExpression", node, opts);
  };
  var assertNewExpression = function(node, opts) {
    assert("NewExpression", node, opts);
  };
  var assertProgram = function(node, opts) {
    assert("Program", node, opts);
  };
  var assertObjectExpression = function(node, opts) {
    assert("ObjectExpression", node, opts);
  };
  var assertObjectMethod = function(node, opts) {
    assert("ObjectMethod", node, opts);
  };
  var assertObjectProperty = function(node, opts) {
    assert("ObjectProperty", node, opts);
  };
  var assertRestElement = function(node, opts) {
    assert("RestElement", node, opts);
  };
  var assertReturnStatement = function(node, opts) {
    assert("ReturnStatement", node, opts);
  };
  var assertSequenceExpression = function(node, opts) {
    assert("SequenceExpression", node, opts);
  };
  var assertParenthesizedExpression = function(node, opts) {
    assert("ParenthesizedExpression", node, opts);
  };
  var assertSwitchCase = function(node, opts) {
    assert("SwitchCase", node, opts);
  };
  var assertSwitchStatement = function(node, opts) {
    assert("SwitchStatement", node, opts);
  };
  var assertThisExpression = function(node, opts) {
    assert("ThisExpression", node, opts);
  };
  var assertThrowStatement = function(node, opts) {
    assert("ThrowStatement", node, opts);
  };
  var assertTryStatement = function(node, opts) {
    assert("TryStatement", node, opts);
  };
  var assertUnaryExpression = function(node, opts) {
    assert("UnaryExpression", node, opts);
  };
  var assertUpdateExpression = function(node, opts) {
    assert("UpdateExpression", node, opts);
  };
  var assertVariableDeclaration = function(node, opts) {
    assert("VariableDeclaration", node, opts);
  };
  var assertVariableDeclarator = function(node, opts) {
    assert("VariableDeclarator", node, opts);
  };
  var assertWhileStatement = function(node, opts) {
    assert("WhileStatement", node, opts);
  };
  var assertWithStatement = function(node, opts) {
    assert("WithStatement", node, opts);
  };
  var assertAssignmentPattern = function(node, opts) {
    assert("AssignmentPattern", node, opts);
  };
  var assertArrayPattern = function(node, opts) {
    assert("ArrayPattern", node, opts);
  };
  var assertArrowFunctionExpression = function(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
  };
  var assertClassBody = function(node, opts) {
    assert("ClassBody", node, opts);
  };
  var assertClassExpression = function(node, opts) {
    assert("ClassExpression", node, opts);
  };
  var assertClassDeclaration = function(node, opts) {
    assert("ClassDeclaration", node, opts);
  };
  var assertExportAllDeclaration = function(node, opts) {
    assert("ExportAllDeclaration", node, opts);
  };
  var assertExportDefaultDeclaration = function(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
  };
  var assertExportNamedDeclaration = function(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
  };
  var assertExportSpecifier = function(node, opts) {
    assert("ExportSpecifier", node, opts);
  };
  var assertForOfStatement = function(node, opts) {
    assert("ForOfStatement", node, opts);
  };
  var assertImportDeclaration = function(node, opts) {
    assert("ImportDeclaration", node, opts);
  };
  var assertImportDefaultSpecifier = function(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
  };
  var assertImportNamespaceSpecifier = function(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
  };
  var assertImportSpecifier = function(node, opts) {
    assert("ImportSpecifier", node, opts);
  };
  var assertImportExpression = function(node, opts) {
    assert("ImportExpression", node, opts);
  };
  var assertMetaProperty = function(node, opts) {
    assert("MetaProperty", node, opts);
  };
  var assertClassMethod = function(node, opts) {
    assert("ClassMethod", node, opts);
  };
  var assertObjectPattern = function(node, opts) {
    assert("ObjectPattern", node, opts);
  };
  var assertSpreadElement = function(node, opts) {
    assert("SpreadElement", node, opts);
  };
  var assertSuper = function(node, opts) {
    assert("Super", node, opts);
  };
  var assertTaggedTemplateExpression = function(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
  };
  var assertTemplateElement = function(node, opts) {
    assert("TemplateElement", node, opts);
  };
  var assertTemplateLiteral = function(node, opts) {
    assert("TemplateLiteral", node, opts);
  };
  var assertYieldExpression = function(node, opts) {
    assert("YieldExpression", node, opts);
  };
  var assertAwaitExpression = function(node, opts) {
    assert("AwaitExpression", node, opts);
  };
  var assertImport = function(node, opts) {
    assert("Import", node, opts);
  };
  var assertBigIntLiteral = function(node, opts) {
    assert("BigIntLiteral", node, opts);
  };
  var assertExportNamespaceSpecifier = function(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
  };
  var assertOptionalMemberExpression = function(node, opts) {
    assert("OptionalMemberExpression", node, opts);
  };
  var assertOptionalCallExpression = function(node, opts) {
    assert("OptionalCallExpression", node, opts);
  };
  var assertClassProperty = function(node, opts) {
    assert("ClassProperty", node, opts);
  };
  var assertClassAccessorProperty = function(node, opts) {
    assert("ClassAccessorProperty", node, opts);
  };
  var assertClassPrivateProperty = function(node, opts) {
    assert("ClassPrivateProperty", node, opts);
  };
  var assertClassPrivateMethod = function(node, opts) {
    assert("ClassPrivateMethod", node, opts);
  };
  var assertPrivateName = function(node, opts) {
    assert("PrivateName", node, opts);
  };
  var assertStaticBlock = function(node, opts) {
    assert("StaticBlock", node, opts);
  };
  var assertAnyTypeAnnotation = function(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
  };
  var assertArrayTypeAnnotation = function(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
  };
  var assertBooleanTypeAnnotation = function(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
  };
  var assertBooleanLiteralTypeAnnotation = function(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
  };
  var assertNullLiteralTypeAnnotation = function(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
  };
  var assertClassImplements = function(node, opts) {
    assert("ClassImplements", node, opts);
  };
  var assertDeclareClass = function(node, opts) {
    assert("DeclareClass", node, opts);
  };
  var assertDeclareFunction = function(node, opts) {
    assert("DeclareFunction", node, opts);
  };
  var assertDeclareInterface = function(node, opts) {
    assert("DeclareInterface", node, opts);
  };
  var assertDeclareModule = function(node, opts) {
    assert("DeclareModule", node, opts);
  };
  var assertDeclareModuleExports = function(node, opts) {
    assert("DeclareModuleExports", node, opts);
  };
  var assertDeclareTypeAlias = function(node, opts) {
    assert("DeclareTypeAlias", node, opts);
  };
  var assertDeclareOpaqueType = function(node, opts) {
    assert("DeclareOpaqueType", node, opts);
  };
  var assertDeclareVariable = function(node, opts) {
    assert("DeclareVariable", node, opts);
  };
  var assertDeclareExportDeclaration = function(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
  };
  var assertDeclareExportAllDeclaration = function(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
  };
  var assertDeclaredPredicate = function(node, opts) {
    assert("DeclaredPredicate", node, opts);
  };
  var assertExistsTypeAnnotation = function(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
  };
  var assertFunctionTypeAnnotation = function(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
  };
  var assertFunctionTypeParam = function(node, opts) {
    assert("FunctionTypeParam", node, opts);
  };
  var assertGenericTypeAnnotation = function(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
  };
  var assertInferredPredicate = function(node, opts) {
    assert("InferredPredicate", node, opts);
  };
  var assertInterfaceExtends = function(node, opts) {
    assert("InterfaceExtends", node, opts);
  };
  var assertInterfaceDeclaration = function(node, opts) {
    assert("InterfaceDeclaration", node, opts);
  };
  var assertInterfaceTypeAnnotation = function(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
  };
  var assertIntersectionTypeAnnotation = function(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
  };
  var assertMixedTypeAnnotation = function(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
  };
  var assertEmptyTypeAnnotation = function(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
  };
  var assertNullableTypeAnnotation = function(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
  };
  var assertNumberLiteralTypeAnnotation = function(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
  };
  var assertNumberTypeAnnotation = function(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
  };
  var assertObjectTypeAnnotation = function(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
  };
  var assertObjectTypeInternalSlot = function(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
  };
  var assertObjectTypeCallProperty = function(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
  };
  var assertObjectTypeIndexer = function(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
  };
  var assertObjectTypeProperty = function(node, opts) {
    assert("ObjectTypeProperty", node, opts);
  };
  var assertObjectTypeSpreadProperty = function(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
  };
  var assertOpaqueType = function(node, opts) {
    assert("OpaqueType", node, opts);
  };
  var assertQualifiedTypeIdentifier = function(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
  };
  var assertStringLiteralTypeAnnotation = function(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
  };
  var assertStringTypeAnnotation = function(node, opts) {
    assert("StringTypeAnnotation", node, opts);
  };
  var assertSymbolTypeAnnotation = function(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
  };
  var assertThisTypeAnnotation = function(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
  };
  var assertTupleTypeAnnotation = function(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
  };
  var assertTypeofTypeAnnotation = function(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
  };
  var assertTypeAlias = function(node, opts) {
    assert("TypeAlias", node, opts);
  };
  var assertTypeAnnotation = function(node, opts) {
    assert("TypeAnnotation", node, opts);
  };
  var assertTypeCastExpression = function(node, opts) {
    assert("TypeCastExpression", node, opts);
  };
  var assertTypeParameter = function(node, opts) {
    assert("TypeParameter", node, opts);
  };
  var assertTypeParameterDeclaration = function(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
  };
  var assertTypeParameterInstantiation = function(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
  };
  var assertUnionTypeAnnotation = function(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
  };
  var assertVariance = function(node, opts) {
    assert("Variance", node, opts);
  };
  var assertVoidTypeAnnotation = function(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
  };
  var assertEnumDeclaration = function(node, opts) {
    assert("EnumDeclaration", node, opts);
  };
  var assertEnumBooleanBody = function(node, opts) {
    assert("EnumBooleanBody", node, opts);
  };
  var assertEnumNumberBody = function(node, opts) {
    assert("EnumNumberBody", node, opts);
  };
  var assertEnumStringBody = function(node, opts) {
    assert("EnumStringBody", node, opts);
  };
  var assertEnumSymbolBody = function(node, opts) {
    assert("EnumSymbolBody", node, opts);
  };
  var assertEnumBooleanMember = function(node, opts) {
    assert("EnumBooleanMember", node, opts);
  };
  var assertEnumNumberMember = function(node, opts) {
    assert("EnumNumberMember", node, opts);
  };
  var assertEnumStringMember = function(node, opts) {
    assert("EnumStringMember", node, opts);
  };
  var assertEnumDefaultedMember = function(node, opts) {
    assert("EnumDefaultedMember", node, opts);
  };
  var assertIndexedAccessType = function(node, opts) {
    assert("IndexedAccessType", node, opts);
  };
  var assertOptionalIndexedAccessType = function(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
  };
  var assertJSXAttribute = function(node, opts) {
    assert("JSXAttribute", node, opts);
  };
  var assertJSXClosingElement = function(node, opts) {
    assert("JSXClosingElement", node, opts);
  };
  var assertJSXElement = function(node, opts) {
    assert("JSXElement", node, opts);
  };
  var assertJSXEmptyExpression = function(node, opts) {
    assert("JSXEmptyExpression", node, opts);
  };
  var assertJSXExpressionContainer = function(node, opts) {
    assert("JSXExpressionContainer", node, opts);
  };
  var assertJSXSpreadChild = function(node, opts) {
    assert("JSXSpreadChild", node, opts);
  };
  var assertJSXIdentifier = function(node, opts) {
    assert("JSXIdentifier", node, opts);
  };
  var assertJSXMemberExpression = function(node, opts) {
    assert("JSXMemberExpression", node, opts);
  };
  var assertJSXNamespacedName = function(node, opts) {
    assert("JSXNamespacedName", node, opts);
  };
  var assertJSXOpeningElement = function(node, opts) {
    assert("JSXOpeningElement", node, opts);
  };
  var assertJSXSpreadAttribute = function(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
  };
  var assertJSXText = function(node, opts) {
    assert("JSXText", node, opts);
  };
  var assertJSXFragment = function(node, opts) {
    assert("JSXFragment", node, opts);
  };
  var assertJSXOpeningFragment = function(node, opts) {
    assert("JSXOpeningFragment", node, opts);
  };
  var assertJSXClosingFragment = function(node, opts) {
    assert("JSXClosingFragment", node, opts);
  };
  var assertNoop = function(node, opts) {
    assert("Noop", node, opts);
  };
  var assertPlaceholder = function(node, opts) {
    assert("Placeholder", node, opts);
  };
  var assertV8IntrinsicIdentifier = function(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
  };
  var assertArgumentPlaceholder = function(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
  };
  var assertBindExpression = function(node, opts) {
    assert("BindExpression", node, opts);
  };
  var assertImportAttribute = function(node, opts) {
    assert("ImportAttribute", node, opts);
  };
  var assertDecorator = function(node, opts) {
    assert("Decorator", node, opts);
  };
  var assertDoExpression = function(node, opts) {
    assert("DoExpression", node, opts);
  };
  var assertExportDefaultSpecifier = function(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
  };
  var assertRecordExpression = function(node, opts) {
    assert("RecordExpression", node, opts);
  };
  var assertTupleExpression = function(node, opts) {
    assert("TupleExpression", node, opts);
  };
  var assertDecimalLiteral = function(node, opts) {
    assert("DecimalLiteral", node, opts);
  };
  var assertModuleExpression = function(node, opts) {
    assert("ModuleExpression", node, opts);
  };
  var assertTopicReference = function(node, opts) {
    assert("TopicReference", node, opts);
  };
  var assertPipelineTopicExpression = function(node, opts) {
    assert("PipelineTopicExpression", node, opts);
  };
  var assertPipelineBareFunction = function(node, opts) {
    assert("PipelineBareFunction", node, opts);
  };
  var assertPipelinePrimaryTopicReference = function(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
  };
  var assertTSParameterProperty = function(node, opts) {
    assert("TSParameterProperty", node, opts);
  };
  var assertTSDeclareFunction = function(node, opts) {
    assert("TSDeclareFunction", node, opts);
  };
  var assertTSDeclareMethod = function(node, opts) {
    assert("TSDeclareMethod", node, opts);
  };
  var assertTSQualifiedName = function(node, opts) {
    assert("TSQualifiedName", node, opts);
  };
  var assertTSCallSignatureDeclaration = function(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
  };
  var assertTSConstructSignatureDeclaration = function(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
  };
  var assertTSPropertySignature = function(node, opts) {
    assert("TSPropertySignature", node, opts);
  };
  var assertTSMethodSignature = function(node, opts) {
    assert("TSMethodSignature", node, opts);
  };
  var assertTSIndexSignature = function(node, opts) {
    assert("TSIndexSignature", node, opts);
  };
  var assertTSAnyKeyword = function(node, opts) {
    assert("TSAnyKeyword", node, opts);
  };
  var assertTSBooleanKeyword = function(node, opts) {
    assert("TSBooleanKeyword", node, opts);
  };
  var assertTSBigIntKeyword = function(node, opts) {
    assert("TSBigIntKeyword", node, opts);
  };
  var assertTSIntrinsicKeyword = function(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
  };
  var assertTSNeverKeyword = function(node, opts) {
    assert("TSNeverKeyword", node, opts);
  };
  var assertTSNullKeyword = function(node, opts) {
    assert("TSNullKeyword", node, opts);
  };
  var assertTSNumberKeyword = function(node, opts) {
    assert("TSNumberKeyword", node, opts);
  };
  var assertTSObjectKeyword = function(node, opts) {
    assert("TSObjectKeyword", node, opts);
  };
  var assertTSStringKeyword = function(node, opts) {
    assert("TSStringKeyword", node, opts);
  };
  var assertTSSymbolKeyword = function(node, opts) {
    assert("TSSymbolKeyword", node, opts);
  };
  var assertTSUndefinedKeyword = function(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
  };
  var assertTSUnknownKeyword = function(node, opts) {
    assert("TSUnknownKeyword", node, opts);
  };
  var assertTSVoidKeyword = function(node, opts) {
    assert("TSVoidKeyword", node, opts);
  };
  var assertTSThisType = function(node, opts) {
    assert("TSThisType", node, opts);
  };
  var assertTSFunctionType = function(node, opts) {
    assert("TSFunctionType", node, opts);
  };
  var assertTSConstructorType = function(node, opts) {
    assert("TSConstructorType", node, opts);
  };
  var assertTSTypeReference = function(node, opts) {
    assert("TSTypeReference", node, opts);
  };
  var assertTSTypePredicate = function(node, opts) {
    assert("TSTypePredicate", node, opts);
  };
  var assertTSTypeQuery = function(node, opts) {
    assert("TSTypeQuery", node, opts);
  };
  var assertTSTypeLiteral = function(node, opts) {
    assert("TSTypeLiteral", node, opts);
  };
  var assertTSArrayType = function(node, opts) {
    assert("TSArrayType", node, opts);
  };
  var assertTSTupleType = function(node, opts) {
    assert("TSTupleType", node, opts);
  };
  var assertTSOptionalType = function(node, opts) {
    assert("TSOptionalType", node, opts);
  };
  var assertTSRestType = function(node, opts) {
    assert("TSRestType", node, opts);
  };
  var assertTSNamedTupleMember = function(node, opts) {
    assert("TSNamedTupleMember", node, opts);
  };
  var assertTSUnionType = function(node, opts) {
    assert("TSUnionType", node, opts);
  };
  var assertTSIntersectionType = function(node, opts) {
    assert("TSIntersectionType", node, opts);
  };
  var assertTSConditionalType = function(node, opts) {
    assert("TSConditionalType", node, opts);
  };
  var assertTSInferType = function(node, opts) {
    assert("TSInferType", node, opts);
  };
  var assertTSParenthesizedType = function(node, opts) {
    assert("TSParenthesizedType", node, opts);
  };
  var assertTSTypeOperator = function(node, opts) {
    assert("TSTypeOperator", node, opts);
  };
  var assertTSIndexedAccessType = function(node, opts) {
    assert("TSIndexedAccessType", node, opts);
  };
  var assertTSMappedType = function(node, opts) {
    assert("TSMappedType", node, opts);
  };
  var assertTSLiteralType = function(node, opts) {
    assert("TSLiteralType", node, opts);
  };
  var assertTSExpressionWithTypeArguments = function(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
  };
  var assertTSInterfaceDeclaration = function(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
  };
  var assertTSInterfaceBody = function(node, opts) {
    assert("TSInterfaceBody", node, opts);
  };
  var assertTSTypeAliasDeclaration = function(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
  };
  var assertTSInstantiationExpression = function(node, opts) {
    assert("TSInstantiationExpression", node, opts);
  };
  var assertTSAsExpression = function(node, opts) {
    assert("TSAsExpression", node, opts);
  };
  var assertTSSatisfiesExpression = function(node, opts) {
    assert("TSSatisfiesExpression", node, opts);
  };
  var assertTSTypeAssertion = function(node, opts) {
    assert("TSTypeAssertion", node, opts);
  };
  var assertTSEnumDeclaration = function(node, opts) {
    assert("TSEnumDeclaration", node, opts);
  };
  var assertTSEnumMember = function(node, opts) {
    assert("TSEnumMember", node, opts);
  };
  var assertTSModuleDeclaration = function(node, opts) {
    assert("TSModuleDeclaration", node, opts);
  };
  var assertTSModuleBlock = function(node, opts) {
    assert("TSModuleBlock", node, opts);
  };
  var assertTSImportType = function(node, opts) {
    assert("TSImportType", node, opts);
  };
  var assertTSImportEqualsDeclaration = function(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
  };
  var assertTSExternalModuleReference = function(node, opts) {
    assert("TSExternalModuleReference", node, opts);
  };
  var assertTSNonNullExpression = function(node, opts) {
    assert("TSNonNullExpression", node, opts);
  };
  var assertTSExportAssignment = function(node, opts) {
    assert("TSExportAssignment", node, opts);
  };
  var assertTSNamespaceExportDeclaration = function(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
  };
  var assertTSTypeAnnotation = function(node, opts) {
    assert("TSTypeAnnotation", node, opts);
  };
  var assertTSTypeParameterInstantiation = function(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
  };
  var assertTSTypeParameterDeclaration = function(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
  };
  var assertTSTypeParameter = function(node, opts) {
    assert("TSTypeParameter", node, opts);
  };
  var assertStandardized = function(node, opts) {
    assert("Standardized", node, opts);
  };
  var assertExpression = function(node, opts) {
    assert("Expression", node, opts);
  };
  var assertBinary = function(node, opts) {
    assert("Binary", node, opts);
  };
  var assertScopable = function(node, opts) {
    assert("Scopable", node, opts);
  };
  var assertBlockParent = function(node, opts) {
    assert("BlockParent", node, opts);
  };
  var assertBlock = function(node, opts) {
    assert("Block", node, opts);
  };
  var assertStatement = function(node, opts) {
    assert("Statement", node, opts);
  };
  var assertTerminatorless = function(node, opts) {
    assert("Terminatorless", node, opts);
  };
  var assertCompletionStatement = function(node, opts) {
    assert("CompletionStatement", node, opts);
  };
  var assertConditional = function(node, opts) {
    assert("Conditional", node, opts);
  };
  var assertLoop = function(node, opts) {
    assert("Loop", node, opts);
  };
  var assertWhile = function(node, opts) {
    assert("While", node, opts);
  };
  var assertExpressionWrapper = function(node, opts) {
    assert("ExpressionWrapper", node, opts);
  };
  var assertFor = function(node, opts) {
    assert("For", node, opts);
  };
  var assertForXStatement = function(node, opts) {
    assert("ForXStatement", node, opts);
  };
  var assertFunction = function(node, opts) {
    assert("Function", node, opts);
  };
  var assertFunctionParent = function(node, opts) {
    assert("FunctionParent", node, opts);
  };
  var assertPureish = function(node, opts) {
    assert("Pureish", node, opts);
  };
  var assertDeclaration = function(node, opts) {
    assert("Declaration", node, opts);
  };
  var assertPatternLike = function(node, opts) {
    assert("PatternLike", node, opts);
  };
  var assertLVal = function(node, opts) {
    assert("LVal", node, opts);
  };
  var assertTSEntityName = function(node, opts) {
    assert("TSEntityName", node, opts);
  };
  var assertLiteral = function(node, opts) {
    assert("Literal", node, opts);
  };
  var assertImmutable = function(node, opts) {
    assert("Immutable", node, opts);
  };
  var assertUserWhitespacable = function(node, opts) {
    assert("UserWhitespacable", node, opts);
  };
  var assertMethod = function(node, opts) {
    assert("Method", node, opts);
  };
  var assertObjectMember = function(node, opts) {
    assert("ObjectMember", node, opts);
  };
  var assertProperty = function(node, opts) {
    assert("Property", node, opts);
  };
  var assertUnaryLike = function(node, opts) {
    assert("UnaryLike", node, opts);
  };
  var assertPattern = function(node, opts) {
    assert("Pattern", node, opts);
  };
  var assertClass = function(node, opts) {
    assert("Class", node, opts);
  };
  var assertImportOrExportDeclaration = function(node, opts) {
    assert("ImportOrExportDeclaration", node, opts);
  };
  var assertExportDeclaration = function(node, opts) {
    assert("ExportDeclaration", node, opts);
  };
  var assertModuleSpecifier = function(node, opts) {
    assert("ModuleSpecifier", node, opts);
  };
  var assertAccessor = function(node, opts) {
    assert("Accessor", node, opts);
  };
  var assertPrivate = function(node, opts) {
    assert("Private", node, opts);
  };
  var assertFlow = function(node, opts) {
    assert("Flow", node, opts);
  };
  var assertFlowType = function(node, opts) {
    assert("FlowType", node, opts);
  };
  var assertFlowBaseAnnotation = function(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
  };
  var assertFlowDeclaration = function(node, opts) {
    assert("FlowDeclaration", node, opts);
  };
  var assertFlowPredicate = function(node, opts) {
    assert("FlowPredicate", node, opts);
  };
  var assertEnumBody = function(node, opts) {
    assert("EnumBody", node, opts);
  };
  var assertEnumMember = function(node, opts) {
    assert("EnumMember", node, opts);
  };
  var assertJSX = function(node, opts) {
    assert("JSX", node, opts);
  };
  var assertMiscellaneous = function(node, opts) {
    assert("Miscellaneous", node, opts);
  };
  var assertTypeScript = function(node, opts) {
    assert("TypeScript", node, opts);
  };
  var assertTSTypeElement = function(node, opts) {
    assert("TSTypeElement", node, opts);
  };
  var assertTSType = function(node, opts) {
    assert("TSType", node, opts);
  };
  var assertTSBaseType = function(node, opts) {
    assert("TSBaseType", node, opts);
  };
  var assertNumberLiteral = function(node, opts) {
    (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
    assert("NumberLiteral", node, opts);
  };
  var assertRegexLiteral = function(node, opts) {
    (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
    assert("RegexLiteral", node, opts);
  };
  var assertRestProperty = function(node, opts) {
    (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
    assert("RestProperty", node, opts);
  };
  var assertSpreadProperty = function(node, opts) {
    (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
    assert("SpreadProperty", node, opts);
  };
  var assertModuleDeclaration = function(node, opts) {
    (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert("ModuleDeclaration", node, opts);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.assertAccessor = assertAccessor;
  exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
  exports.assertArrayExpression = assertArrayExpression;
  exports.assertArrayPattern = assertArrayPattern;
  exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
  exports.assertAssignmentExpression = assertAssignmentExpression;
  exports.assertAssignmentPattern = assertAssignmentPattern;
  exports.assertAwaitExpression = assertAwaitExpression;
  exports.assertBigIntLiteral = assertBigIntLiteral;
  exports.assertBinary = assertBinary;
  exports.assertBinaryExpression = assertBinaryExpression;
  exports.assertBindExpression = assertBindExpression;
  exports.assertBlock = assertBlock;
  exports.assertBlockParent = assertBlockParent;
  exports.assertBlockStatement = assertBlockStatement;
  exports.assertBooleanLiteral = assertBooleanLiteral;
  exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
  exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  exports.assertBreakStatement = assertBreakStatement;
  exports.assertCallExpression = assertCallExpression;
  exports.assertCatchClause = assertCatchClause;
  exports.assertClass = assertClass;
  exports.assertClassAccessorProperty = assertClassAccessorProperty;
  exports.assertClassBody = assertClassBody;
  exports.assertClassDeclaration = assertClassDeclaration;
  exports.assertClassExpression = assertClassExpression;
  exports.assertClassImplements = assertClassImplements;
  exports.assertClassMethod = assertClassMethod;
  exports.assertClassPrivateMethod = assertClassPrivateMethod;
  exports.assertClassPrivateProperty = assertClassPrivateProperty;
  exports.assertClassProperty = assertClassProperty;
  exports.assertCompletionStatement = assertCompletionStatement;
  exports.assertConditional = assertConditional;
  exports.assertConditionalExpression = assertConditionalExpression;
  exports.assertContinueStatement = assertContinueStatement;
  exports.assertDebuggerStatement = assertDebuggerStatement;
  exports.assertDecimalLiteral = assertDecimalLiteral;
  exports.assertDeclaration = assertDeclaration;
  exports.assertDeclareClass = assertDeclareClass;
  exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
  exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  exports.assertDeclareFunction = assertDeclareFunction;
  exports.assertDeclareInterface = assertDeclareInterface;
  exports.assertDeclareModule = assertDeclareModule;
  exports.assertDeclareModuleExports = assertDeclareModuleExports;
  exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
  exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
  exports.assertDeclareVariable = assertDeclareVariable;
  exports.assertDeclaredPredicate = assertDeclaredPredicate;
  exports.assertDecorator = assertDecorator;
  exports.assertDirective = assertDirective;
  exports.assertDirectiveLiteral = assertDirectiveLiteral;
  exports.assertDoExpression = assertDoExpression;
  exports.assertDoWhileStatement = assertDoWhileStatement;
  exports.assertEmptyStatement = assertEmptyStatement;
  exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  exports.assertEnumBody = assertEnumBody;
  exports.assertEnumBooleanBody = assertEnumBooleanBody;
  exports.assertEnumBooleanMember = assertEnumBooleanMember;
  exports.assertEnumDeclaration = assertEnumDeclaration;
  exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
  exports.assertEnumMember = assertEnumMember;
  exports.assertEnumNumberBody = assertEnumNumberBody;
  exports.assertEnumNumberMember = assertEnumNumberMember;
  exports.assertEnumStringBody = assertEnumStringBody;
  exports.assertEnumStringMember = assertEnumStringMember;
  exports.assertEnumSymbolBody = assertEnumSymbolBody;
  exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  exports.assertExportAllDeclaration = assertExportAllDeclaration;
  exports.assertExportDeclaration = assertExportDeclaration;
  exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
  exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  exports.assertExportSpecifier = assertExportSpecifier;
  exports.assertExpression = assertExpression;
  exports.assertExpressionStatement = assertExpressionStatement;
  exports.assertExpressionWrapper = assertExpressionWrapper;
  exports.assertFile = assertFile;
  exports.assertFlow = assertFlow;
  exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  exports.assertFlowDeclaration = assertFlowDeclaration;
  exports.assertFlowPredicate = assertFlowPredicate;
  exports.assertFlowType = assertFlowType;
  exports.assertFor = assertFor;
  exports.assertForInStatement = assertForInStatement;
  exports.assertForOfStatement = assertForOfStatement;
  exports.assertForStatement = assertForStatement;
  exports.assertForXStatement = assertForXStatement;
  exports.assertFunction = assertFunction;
  exports.assertFunctionDeclaration = assertFunctionDeclaration;
  exports.assertFunctionExpression = assertFunctionExpression;
  exports.assertFunctionParent = assertFunctionParent;
  exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  exports.assertFunctionTypeParam = assertFunctionTypeParam;
  exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  exports.assertIdentifier = assertIdentifier;
  exports.assertIfStatement = assertIfStatement;
  exports.assertImmutable = assertImmutable;
  exports.assertImport = assertImport;
  exports.assertImportAttribute = assertImportAttribute;
  exports.assertImportDeclaration = assertImportDeclaration;
  exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  exports.assertImportExpression = assertImportExpression;
  exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
  exports.assertImportSpecifier = assertImportSpecifier;
  exports.assertIndexedAccessType = assertIndexedAccessType;
  exports.assertInferredPredicate = assertInferredPredicate;
  exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
  exports.assertInterfaceExtends = assertInterfaceExtends;
  exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  exports.assertInterpreterDirective = assertInterpreterDirective;
  exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
  exports.assertJSX = assertJSX;
  exports.assertJSXAttribute = assertJSXAttribute;
  exports.assertJSXClosingElement = assertJSXClosingElement;
  exports.assertJSXClosingFragment = assertJSXClosingFragment;
  exports.assertJSXElement = assertJSXElement;
  exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
  exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
  exports.assertJSXFragment = assertJSXFragment;
  exports.assertJSXIdentifier = assertJSXIdentifier;
  exports.assertJSXMemberExpression = assertJSXMemberExpression;
  exports.assertJSXNamespacedName = assertJSXNamespacedName;
  exports.assertJSXOpeningElement = assertJSXOpeningElement;
  exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
  exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  exports.assertJSXSpreadChild = assertJSXSpreadChild;
  exports.assertJSXText = assertJSXText;
  exports.assertLVal = assertLVal;
  exports.assertLabeledStatement = assertLabeledStatement;
  exports.assertLiteral = assertLiteral;
  exports.assertLogicalExpression = assertLogicalExpression;
  exports.assertLoop = assertLoop;
  exports.assertMemberExpression = assertMemberExpression;
  exports.assertMetaProperty = assertMetaProperty;
  exports.assertMethod = assertMethod;
  exports.assertMiscellaneous = assertMiscellaneous;
  exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  exports.assertModuleDeclaration = assertModuleDeclaration;
  exports.assertModuleExpression = assertModuleExpression;
  exports.assertModuleSpecifier = assertModuleSpecifier;
  exports.assertNewExpression = assertNewExpression;
  exports.assertNoop = assertNoop;
  exports.assertNullLiteral = assertNullLiteral;
  exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  exports.assertNumberLiteral = assertNumberLiteral;
  exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
  exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  exports.assertNumericLiteral = assertNumericLiteral;
  exports.assertObjectExpression = assertObjectExpression;
  exports.assertObjectMember = assertObjectMember;
  exports.assertObjectMethod = assertObjectMethod;
  exports.assertObjectPattern = assertObjectPattern;
  exports.assertObjectProperty = assertObjectProperty;
  exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
  exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  exports.assertObjectTypeProperty = assertObjectTypeProperty;
  exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  exports.assertOpaqueType = assertOpaqueType;
  exports.assertOptionalCallExpression = assertOptionalCallExpression;
  exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
  exports.assertParenthesizedExpression = assertParenthesizedExpression;
  exports.assertPattern = assertPattern;
  exports.assertPatternLike = assertPatternLike;
  exports.assertPipelineBareFunction = assertPipelineBareFunction;
  exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
  exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
  exports.assertPlaceholder = assertPlaceholder;
  exports.assertPrivate = assertPrivate;
  exports.assertPrivateName = assertPrivateName;
  exports.assertProgram = assertProgram;
  exports.assertProperty = assertProperty;
  exports.assertPureish = assertPureish;
  exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  exports.assertRecordExpression = assertRecordExpression;
  exports.assertRegExpLiteral = assertRegExpLiteral;
  exports.assertRegexLiteral = assertRegexLiteral;
  exports.assertRestElement = assertRestElement;
  exports.assertRestProperty = assertRestProperty;
  exports.assertReturnStatement = assertReturnStatement;
  exports.assertScopable = assertScopable;
  exports.assertSequenceExpression = assertSequenceExpression;
  exports.assertSpreadElement = assertSpreadElement;
  exports.assertSpreadProperty = assertSpreadProperty;
  exports.assertStandardized = assertStandardized;
  exports.assertStatement = assertStatement;
  exports.assertStaticBlock = assertStaticBlock;
  exports.assertStringLiteral = assertStringLiteral;
  exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
  exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
  exports.assertSuper = assertSuper;
  exports.assertSwitchCase = assertSwitchCase;
  exports.assertSwitchStatement = assertSwitchStatement;
  exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  exports.assertTSAnyKeyword = assertTSAnyKeyword;
  exports.assertTSArrayType = assertTSArrayType;
  exports.assertTSAsExpression = assertTSAsExpression;
  exports.assertTSBaseType = assertTSBaseType;
  exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
  exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
  exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
  exports.assertTSConditionalType = assertTSConditionalType;
  exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
  exports.assertTSConstructorType = assertTSConstructorType;
  exports.assertTSDeclareFunction = assertTSDeclareFunction;
  exports.assertTSDeclareMethod = assertTSDeclareMethod;
  exports.assertTSEntityName = assertTSEntityName;
  exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
  exports.assertTSEnumMember = assertTSEnumMember;
  exports.assertTSExportAssignment = assertTSExportAssignment;
  exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
  exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
  exports.assertTSFunctionType = assertTSFunctionType;
  exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  exports.assertTSImportType = assertTSImportType;
  exports.assertTSIndexSignature = assertTSIndexSignature;
  exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
  exports.assertTSInferType = assertTSInferType;
  exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
  exports.assertTSInterfaceBody = assertTSInterfaceBody;
  exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  exports.assertTSIntersectionType = assertTSIntersectionType;
  exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  exports.assertTSLiteralType = assertTSLiteralType;
  exports.assertTSMappedType = assertTSMappedType;
  exports.assertTSMethodSignature = assertTSMethodSignature;
  exports.assertTSModuleBlock = assertTSModuleBlock;
  exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
  exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
  exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
  exports.assertTSNeverKeyword = assertTSNeverKeyword;
  exports.assertTSNonNullExpression = assertTSNonNullExpression;
  exports.assertTSNullKeyword = assertTSNullKeyword;
  exports.assertTSNumberKeyword = assertTSNumberKeyword;
  exports.assertTSObjectKeyword = assertTSObjectKeyword;
  exports.assertTSOptionalType = assertTSOptionalType;
  exports.assertTSParameterProperty = assertTSParameterProperty;
  exports.assertTSParenthesizedType = assertTSParenthesizedType;
  exports.assertTSPropertySignature = assertTSPropertySignature;
  exports.assertTSQualifiedName = assertTSQualifiedName;
  exports.assertTSRestType = assertTSRestType;
  exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
  exports.assertTSStringKeyword = assertTSStringKeyword;
  exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
  exports.assertTSThisType = assertTSThisType;
  exports.assertTSTupleType = assertTSTupleType;
  exports.assertTSType = assertTSType;
  exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
  exports.assertTSTypeAssertion = assertTSTypeAssertion;
  exports.assertTSTypeElement = assertTSTypeElement;
  exports.assertTSTypeLiteral = assertTSTypeLiteral;
  exports.assertTSTypeOperator = assertTSTypeOperator;
  exports.assertTSTypeParameter = assertTSTypeParameter;
  exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
  exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
  exports.assertTSTypePredicate = assertTSTypePredicate;
  exports.assertTSTypeQuery = assertTSTypeQuery;
  exports.assertTSTypeReference = assertTSTypeReference;
  exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  exports.assertTSUnionType = assertTSUnionType;
  exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
  exports.assertTSVoidKeyword = assertTSVoidKeyword;
  exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  exports.assertTemplateElement = assertTemplateElement;
  exports.assertTemplateLiteral = assertTemplateLiteral;
  exports.assertTerminatorless = assertTerminatorless;
  exports.assertThisExpression = assertThisExpression;
  exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
  exports.assertThrowStatement = assertThrowStatement;
  exports.assertTopicReference = assertTopicReference;
  exports.assertTryStatement = assertTryStatement;
  exports.assertTupleExpression = assertTupleExpression;
  exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  exports.assertTypeAlias = assertTypeAlias;
  exports.assertTypeAnnotation = assertTypeAnnotation;
  exports.assertTypeCastExpression = assertTypeCastExpression;
  exports.assertTypeParameter = assertTypeParameter;
  exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
  exports.assertTypeScript = assertTypeScript;
  exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  exports.assertUnaryExpression = assertUnaryExpression;
  exports.assertUnaryLike = assertUnaryLike;
  exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  exports.assertUpdateExpression = assertUpdateExpression;
  exports.assertUserWhitespacable = assertUserWhitespacable;
  exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  exports.assertVariableDeclaration = assertVariableDeclaration;
  exports.assertVariableDeclarator = assertVariableDeclarator;
  exports.assertVariance = assertVariance;
  exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  exports.assertWhile = assertWhile;
  exports.assertWhileStatement = assertWhileStatement;
  exports.assertWithStatement = assertWithStatement;
  exports.assertYieldExpression = assertYieldExpression;
  var _is = require_is();
  var _deprecationWarning = require_deprecationWarning();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS((exports) => {
  var createTypeAnnotationBasedOnTypeof = function(type) {
    switch (type) {
      case "string":
        return (0, _index.stringTypeAnnotation)();
      case "number":
        return (0, _index.numberTypeAnnotation)();
      case "undefined":
        return (0, _index.voidTypeAnnotation)();
      case "boolean":
        return (0, _index.booleanTypeAnnotation)();
      case "function":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
      case "object":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
      case "symbol":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
      case "bigint":
        return (0, _index.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated2();
  var _default = exports.default = createTypeAnnotationBasedOnTypeof;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS((exports) => {
  var getQualifiedName = function(node) {
    return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
  };
  var removeTypeDuplicates = function(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map;
    const bases = new Map;
    const typeGroups = new Set;
    const types = [];
    for (let i = 0;i < nodes.length; i++) {
      const node = nodes[i];
      if (!node)
        continue;
      if (types.indexOf(node) >= 0) {
        continue;
      }
      if ((0, _index.isAnyTypeAnnotation)(node)) {
        return [node];
      }
      if ((0, _index.isFlowBaseAnnotation)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _index.isUnionTypeAnnotation)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push(...node.types);
          typeGroups.add(node.types);
        }
        continue;
      }
      if ((0, _index.isGenericTypeAnnotation)(node)) {
        const name = getQualifiedName(node.id);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params.push(...node.typeParameters.params);
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeTypeDuplicates;
  var _index = require_generated();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS((exports) => {
  var createFlowUnionType = function(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.unionTypeAnnotation)(flattened);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createFlowUnionType;
  var _index = require_generated2();
  var _removeTypeDuplicates = require_removeTypeDuplicates();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS((exports) => {
  var getQualifiedName = function(node) {
    return (0, _index.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
  };
  var removeTypeDuplicates = function(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map;
    const bases = new Map;
    const typeGroups = new Set;
    const types = [];
    for (let i = 0;i < nodes.length; i++) {
      const node = nodes[i];
      if (!node)
        continue;
      if (types.indexOf(node) >= 0) {
        continue;
      }
      if ((0, _index.isTSAnyKeyword)(node)) {
        return [node];
      }
      if ((0, _index.isTSBaseType)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _index.isTSUnionType)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push(...node.types);
          typeGroups.add(node.types);
        }
        continue;
      }
      if ((0, _index.isTSTypeReference)(node) && node.typeParameters) {
        const name = getQualifiedName(node.typeName);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params.push(...node.typeParameters.params);
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeTypeDuplicates;
  var _index = require_generated();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS((exports) => {
  var createTSUnionType = function(typeAnnotations) {
    const types = typeAnnotations.map((type) => {
      return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    });
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.tsUnionType)(flattened);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createTSUnionType;
  var _index = require_generated2();
  var _removeTypeDuplicates = require_removeTypeDuplicates2();
  var _index2 = require_generated();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "AnyTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.anyTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ArgumentPlaceholder", {
    enumerable: true,
    get: function() {
      return _index.argumentPlaceholder;
    }
  });
  Object.defineProperty(exports, "ArrayExpression", {
    enumerable: true,
    get: function() {
      return _index.arrayExpression;
    }
  });
  Object.defineProperty(exports, "ArrayPattern", {
    enumerable: true,
    get: function() {
      return _index.arrayPattern;
    }
  });
  Object.defineProperty(exports, "ArrayTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.arrayTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ArrowFunctionExpression", {
    enumerable: true,
    get: function() {
      return _index.arrowFunctionExpression;
    }
  });
  Object.defineProperty(exports, "AssignmentExpression", {
    enumerable: true,
    get: function() {
      return _index.assignmentExpression;
    }
  });
  Object.defineProperty(exports, "AssignmentPattern", {
    enumerable: true,
    get: function() {
      return _index.assignmentPattern;
    }
  });
  Object.defineProperty(exports, "AwaitExpression", {
    enumerable: true,
    get: function() {
      return _index.awaitExpression;
    }
  });
  Object.defineProperty(exports, "BigIntLiteral", {
    enumerable: true,
    get: function() {
      return _index.bigIntLiteral;
    }
  });
  Object.defineProperty(exports, "BinaryExpression", {
    enumerable: true,
    get: function() {
      return _index.binaryExpression;
    }
  });
  Object.defineProperty(exports, "BindExpression", {
    enumerable: true,
    get: function() {
      return _index.bindExpression;
    }
  });
  Object.defineProperty(exports, "BlockStatement", {
    enumerable: true,
    get: function() {
      return _index.blockStatement;
    }
  });
  Object.defineProperty(exports, "BooleanLiteral", {
    enumerable: true,
    get: function() {
      return _index.booleanLiteral;
    }
  });
  Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.booleanLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "BooleanTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.booleanTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "BreakStatement", {
    enumerable: true,
    get: function() {
      return _index.breakStatement;
    }
  });
  Object.defineProperty(exports, "CallExpression", {
    enumerable: true,
    get: function() {
      return _index.callExpression;
    }
  });
  Object.defineProperty(exports, "CatchClause", {
    enumerable: true,
    get: function() {
      return _index.catchClause;
    }
  });
  Object.defineProperty(exports, "ClassAccessorProperty", {
    enumerable: true,
    get: function() {
      return _index.classAccessorProperty;
    }
  });
  Object.defineProperty(exports, "ClassBody", {
    enumerable: true,
    get: function() {
      return _index.classBody;
    }
  });
  Object.defineProperty(exports, "ClassDeclaration", {
    enumerable: true,
    get: function() {
      return _index.classDeclaration;
    }
  });
  Object.defineProperty(exports, "ClassExpression", {
    enumerable: true,
    get: function() {
      return _index.classExpression;
    }
  });
  Object.defineProperty(exports, "ClassImplements", {
    enumerable: true,
    get: function() {
      return _index.classImplements;
    }
  });
  Object.defineProperty(exports, "ClassMethod", {
    enumerable: true,
    get: function() {
      return _index.classMethod;
    }
  });
  Object.defineProperty(exports, "ClassPrivateMethod", {
    enumerable: true,
    get: function() {
      return _index.classPrivateMethod;
    }
  });
  Object.defineProperty(exports, "ClassPrivateProperty", {
    enumerable: true,
    get: function() {
      return _index.classPrivateProperty;
    }
  });
  Object.defineProperty(exports, "ClassProperty", {
    enumerable: true,
    get: function() {
      return _index.classProperty;
    }
  });
  Object.defineProperty(exports, "ConditionalExpression", {
    enumerable: true,
    get: function() {
      return _index.conditionalExpression;
    }
  });
  Object.defineProperty(exports, "ContinueStatement", {
    enumerable: true,
    get: function() {
      return _index.continueStatement;
    }
  });
  Object.defineProperty(exports, "DebuggerStatement", {
    enumerable: true,
    get: function() {
      return _index.debuggerStatement;
    }
  });
  Object.defineProperty(exports, "DecimalLiteral", {
    enumerable: true,
    get: function() {
      return _index.decimalLiteral;
    }
  });
  Object.defineProperty(exports, "DeclareClass", {
    enumerable: true,
    get: function() {
      return _index.declareClass;
    }
  });
  Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    enumerable: true,
    get: function() {
      return _index.declareExportAllDeclaration;
    }
  });
  Object.defineProperty(exports, "DeclareExportDeclaration", {
    enumerable: true,
    get: function() {
      return _index.declareExportDeclaration;
    }
  });
  Object.defineProperty(exports, "DeclareFunction", {
    enumerable: true,
    get: function() {
      return _index.declareFunction;
    }
  });
  Object.defineProperty(exports, "DeclareInterface", {
    enumerable: true,
    get: function() {
      return _index.declareInterface;
    }
  });
  Object.defineProperty(exports, "DeclareModule", {
    enumerable: true,
    get: function() {
      return _index.declareModule;
    }
  });
  Object.defineProperty(exports, "DeclareModuleExports", {
    enumerable: true,
    get: function() {
      return _index.declareModuleExports;
    }
  });
  Object.defineProperty(exports, "DeclareOpaqueType", {
    enumerable: true,
    get: function() {
      return _index.declareOpaqueType;
    }
  });
  Object.defineProperty(exports, "DeclareTypeAlias", {
    enumerable: true,
    get: function() {
      return _index.declareTypeAlias;
    }
  });
  Object.defineProperty(exports, "DeclareVariable", {
    enumerable: true,
    get: function() {
      return _index.declareVariable;
    }
  });
  Object.defineProperty(exports, "DeclaredPredicate", {
    enumerable: true,
    get: function() {
      return _index.declaredPredicate;
    }
  });
  Object.defineProperty(exports, "Decorator", {
    enumerable: true,
    get: function() {
      return _index.decorator;
    }
  });
  Object.defineProperty(exports, "Directive", {
    enumerable: true,
    get: function() {
      return _index.directive;
    }
  });
  Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function() {
      return _index.directiveLiteral;
    }
  });
  Object.defineProperty(exports, "DoExpression", {
    enumerable: true,
    get: function() {
      return _index.doExpression;
    }
  });
  Object.defineProperty(exports, "DoWhileStatement", {
    enumerable: true,
    get: function() {
      return _index.doWhileStatement;
    }
  });
  Object.defineProperty(exports, "EmptyStatement", {
    enumerable: true,
    get: function() {
      return _index.emptyStatement;
    }
  });
  Object.defineProperty(exports, "EmptyTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.emptyTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "EnumBooleanBody", {
    enumerable: true,
    get: function() {
      return _index.enumBooleanBody;
    }
  });
  Object.defineProperty(exports, "EnumBooleanMember", {
    enumerable: true,
    get: function() {
      return _index.enumBooleanMember;
    }
  });
  Object.defineProperty(exports, "EnumDeclaration", {
    enumerable: true,
    get: function() {
      return _index.enumDeclaration;
    }
  });
  Object.defineProperty(exports, "EnumDefaultedMember", {
    enumerable: true,
    get: function() {
      return _index.enumDefaultedMember;
    }
  });
  Object.defineProperty(exports, "EnumNumberBody", {
    enumerable: true,
    get: function() {
      return _index.enumNumberBody;
    }
  });
  Object.defineProperty(exports, "EnumNumberMember", {
    enumerable: true,
    get: function() {
      return _index.enumNumberMember;
    }
  });
  Object.defineProperty(exports, "EnumStringBody", {
    enumerable: true,
    get: function() {
      return _index.enumStringBody;
    }
  });
  Object.defineProperty(exports, "EnumStringMember", {
    enumerable: true,
    get: function() {
      return _index.enumStringMember;
    }
  });
  Object.defineProperty(exports, "EnumSymbolBody", {
    enumerable: true,
    get: function() {
      return _index.enumSymbolBody;
    }
  });
  Object.defineProperty(exports, "ExistsTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.existsTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ExportAllDeclaration", {
    enumerable: true,
    get: function() {
      return _index.exportAllDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportDefaultDeclaration", {
    enumerable: true,
    get: function() {
      return _index.exportDefaultDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportDefaultSpecifier", {
    enumerable: true,
    get: function() {
      return _index.exportDefaultSpecifier;
    }
  });
  Object.defineProperty(exports, "ExportNamedDeclaration", {
    enumerable: true,
    get: function() {
      return _index.exportNamedDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
      return _index.exportNamespaceSpecifier;
    }
  });
  Object.defineProperty(exports, "ExportSpecifier", {
    enumerable: true,
    get: function() {
      return _index.exportSpecifier;
    }
  });
  Object.defineProperty(exports, "ExpressionStatement", {
    enumerable: true,
    get: function() {
      return _index.expressionStatement;
    }
  });
  Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
      return _index.file;
    }
  });
  Object.defineProperty(exports, "ForInStatement", {
    enumerable: true,
    get: function() {
      return _index.forInStatement;
    }
  });
  Object.defineProperty(exports, "ForOfStatement", {
    enumerable: true,
    get: function() {
      return _index.forOfStatement;
    }
  });
  Object.defineProperty(exports, "ForStatement", {
    enumerable: true,
    get: function() {
      return _index.forStatement;
    }
  });
  Object.defineProperty(exports, "FunctionDeclaration", {
    enumerable: true,
    get: function() {
      return _index.functionDeclaration;
    }
  });
  Object.defineProperty(exports, "FunctionExpression", {
    enumerable: true,
    get: function() {
      return _index.functionExpression;
    }
  });
  Object.defineProperty(exports, "FunctionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.functionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "FunctionTypeParam", {
    enumerable: true,
    get: function() {
      return _index.functionTypeParam;
    }
  });
  Object.defineProperty(exports, "GenericTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.genericTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
      return _index.identifier;
    }
  });
  Object.defineProperty(exports, "IfStatement", {
    enumerable: true,
    get: function() {
      return _index.ifStatement;
    }
  });
  Object.defineProperty(exports, "Import", {
    enumerable: true,
    get: function() {
      return _index.import;
    }
  });
  Object.defineProperty(exports, "ImportAttribute", {
    enumerable: true,
    get: function() {
      return _index.importAttribute;
    }
  });
  Object.defineProperty(exports, "ImportDeclaration", {
    enumerable: true,
    get: function() {
      return _index.importDeclaration;
    }
  });
  Object.defineProperty(exports, "ImportDefaultSpecifier", {
    enumerable: true,
    get: function() {
      return _index.importDefaultSpecifier;
    }
  });
  Object.defineProperty(exports, "ImportExpression", {
    enumerable: true,
    get: function() {
      return _index.importExpression;
    }
  });
  Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
      return _index.importNamespaceSpecifier;
    }
  });
  Object.defineProperty(exports, "ImportSpecifier", {
    enumerable: true,
    get: function() {
      return _index.importSpecifier;
    }
  });
  Object.defineProperty(exports, "IndexedAccessType", {
    enumerable: true,
    get: function() {
      return _index.indexedAccessType;
    }
  });
  Object.defineProperty(exports, "InferredPredicate", {
    enumerable: true,
    get: function() {
      return _index.inferredPredicate;
    }
  });
  Object.defineProperty(exports, "InterfaceDeclaration", {
    enumerable: true,
    get: function() {
      return _index.interfaceDeclaration;
    }
  });
  Object.defineProperty(exports, "InterfaceExtends", {
    enumerable: true,
    get: function() {
      return _index.interfaceExtends;
    }
  });
  Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.interfaceTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "InterpreterDirective", {
    enumerable: true,
    get: function() {
      return _index.interpreterDirective;
    }
  });
  Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.intersectionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "JSXAttribute", {
    enumerable: true,
    get: function() {
      return _index.jsxAttribute;
    }
  });
  Object.defineProperty(exports, "JSXClosingElement", {
    enumerable: true,
    get: function() {
      return _index.jsxClosingElement;
    }
  });
  Object.defineProperty(exports, "JSXClosingFragment", {
    enumerable: true,
    get: function() {
      return _index.jsxClosingFragment;
    }
  });
  Object.defineProperty(exports, "JSXElement", {
    enumerable: true,
    get: function() {
      return _index.jsxElement;
    }
  });
  Object.defineProperty(exports, "JSXEmptyExpression", {
    enumerable: true,
    get: function() {
      return _index.jsxEmptyExpression;
    }
  });
  Object.defineProperty(exports, "JSXExpressionContainer", {
    enumerable: true,
    get: function() {
      return _index.jsxExpressionContainer;
    }
  });
  Object.defineProperty(exports, "JSXFragment", {
    enumerable: true,
    get: function() {
      return _index.jsxFragment;
    }
  });
  Object.defineProperty(exports, "JSXIdentifier", {
    enumerable: true,
    get: function() {
      return _index.jsxIdentifier;
    }
  });
  Object.defineProperty(exports, "JSXMemberExpression", {
    enumerable: true,
    get: function() {
      return _index.jsxMemberExpression;
    }
  });
  Object.defineProperty(exports, "JSXNamespacedName", {
    enumerable: true,
    get: function() {
      return _index.jsxNamespacedName;
    }
  });
  Object.defineProperty(exports, "JSXOpeningElement", {
    enumerable: true,
    get: function() {
      return _index.jsxOpeningElement;
    }
  });
  Object.defineProperty(exports, "JSXOpeningFragment", {
    enumerable: true,
    get: function() {
      return _index.jsxOpeningFragment;
    }
  });
  Object.defineProperty(exports, "JSXSpreadAttribute", {
    enumerable: true,
    get: function() {
      return _index.jsxSpreadAttribute;
    }
  });
  Object.defineProperty(exports, "JSXSpreadChild", {
    enumerable: true,
    get: function() {
      return _index.jsxSpreadChild;
    }
  });
  Object.defineProperty(exports, "JSXText", {
    enumerable: true,
    get: function() {
      return _index.jsxText;
    }
  });
  Object.defineProperty(exports, "LabeledStatement", {
    enumerable: true,
    get: function() {
      return _index.labeledStatement;
    }
  });
  Object.defineProperty(exports, "LogicalExpression", {
    enumerable: true,
    get: function() {
      return _index.logicalExpression;
    }
  });
  Object.defineProperty(exports, "MemberExpression", {
    enumerable: true,
    get: function() {
      return _index.memberExpression;
    }
  });
  Object.defineProperty(exports, "MetaProperty", {
    enumerable: true,
    get: function() {
      return _index.metaProperty;
    }
  });
  Object.defineProperty(exports, "MixedTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.mixedTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ModuleExpression", {
    enumerable: true,
    get: function() {
      return _index.moduleExpression;
    }
  });
  Object.defineProperty(exports, "NewExpression", {
    enumerable: true,
    get: function() {
      return _index.newExpression;
    }
  });
  Object.defineProperty(exports, "Noop", {
    enumerable: true,
    get: function() {
      return _index.noop;
    }
  });
  Object.defineProperty(exports, "NullLiteral", {
    enumerable: true,
    get: function() {
      return _index.nullLiteral;
    }
  });
  Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.nullLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NullableTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.nullableTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumberLiteral", {
    enumerable: true,
    get: function() {
      return _index.numberLiteral;
    }
  });
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.numberLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumberTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.numberTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumericLiteral", {
    enumerable: true,
    get: function() {
      return _index.numericLiteral;
    }
  });
  Object.defineProperty(exports, "ObjectExpression", {
    enumerable: true,
    get: function() {
      return _index.objectExpression;
    }
  });
  Object.defineProperty(exports, "ObjectMethod", {
    enumerable: true,
    get: function() {
      return _index.objectMethod;
    }
  });
  Object.defineProperty(exports, "ObjectPattern", {
    enumerable: true,
    get: function() {
      return _index.objectPattern;
    }
  });
  Object.defineProperty(exports, "ObjectProperty", {
    enumerable: true,
    get: function() {
      return _index.objectProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.objectTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ObjectTypeCallProperty", {
    enumerable: true,
    get: function() {
      return _index.objectTypeCallProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeIndexer", {
    enumerable: true,
    get: function() {
      return _index.objectTypeIndexer;
    }
  });
  Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    enumerable: true,
    get: function() {
      return _index.objectTypeInternalSlot;
    }
  });
  Object.defineProperty(exports, "ObjectTypeProperty", {
    enumerable: true,
    get: function() {
      return _index.objectTypeProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    enumerable: true,
    get: function() {
      return _index.objectTypeSpreadProperty;
    }
  });
  Object.defineProperty(exports, "OpaqueType", {
    enumerable: true,
    get: function() {
      return _index.opaqueType;
    }
  });
  Object.defineProperty(exports, "OptionalCallExpression", {
    enumerable: true,
    get: function() {
      return _index.optionalCallExpression;
    }
  });
  Object.defineProperty(exports, "OptionalIndexedAccessType", {
    enumerable: true,
    get: function() {
      return _index.optionalIndexedAccessType;
    }
  });
  Object.defineProperty(exports, "OptionalMemberExpression", {
    enumerable: true,
    get: function() {
      return _index.optionalMemberExpression;
    }
  });
  Object.defineProperty(exports, "ParenthesizedExpression", {
    enumerable: true,
    get: function() {
      return _index.parenthesizedExpression;
    }
  });
  Object.defineProperty(exports, "PipelineBareFunction", {
    enumerable: true,
    get: function() {
      return _index.pipelineBareFunction;
    }
  });
  Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    enumerable: true,
    get: function() {
      return _index.pipelinePrimaryTopicReference;
    }
  });
  Object.defineProperty(exports, "PipelineTopicExpression", {
    enumerable: true,
    get: function() {
      return _index.pipelineTopicExpression;
    }
  });
  Object.defineProperty(exports, "Placeholder", {
    enumerable: true,
    get: function() {
      return _index.placeholder;
    }
  });
  Object.defineProperty(exports, "PrivateName", {
    enumerable: true,
    get: function() {
      return _index.privateName;
    }
  });
  Object.defineProperty(exports, "Program", {
    enumerable: true,
    get: function() {
      return _index.program;
    }
  });
  Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    enumerable: true,
    get: function() {
      return _index.qualifiedTypeIdentifier;
    }
  });
  Object.defineProperty(exports, "RecordExpression", {
    enumerable: true,
    get: function() {
      return _index.recordExpression;
    }
  });
  Object.defineProperty(exports, "RegExpLiteral", {
    enumerable: true,
    get: function() {
      return _index.regExpLiteral;
    }
  });
  Object.defineProperty(exports, "RegexLiteral", {
    enumerable: true,
    get: function() {
      return _index.regexLiteral;
    }
  });
  Object.defineProperty(exports, "RestElement", {
    enumerable: true,
    get: function() {
      return _index.restElement;
    }
  });
  Object.defineProperty(exports, "RestProperty", {
    enumerable: true,
    get: function() {
      return _index.restProperty;
    }
  });
  Object.defineProperty(exports, "ReturnStatement", {
    enumerable: true,
    get: function() {
      return _index.returnStatement;
    }
  });
  Object.defineProperty(exports, "SequenceExpression", {
    enumerable: true,
    get: function() {
      return _index.sequenceExpression;
    }
  });
  Object.defineProperty(exports, "SpreadElement", {
    enumerable: true,
    get: function() {
      return _index.spreadElement;
    }
  });
  Object.defineProperty(exports, "SpreadProperty", {
    enumerable: true,
    get: function() {
      return _index.spreadProperty;
    }
  });
  Object.defineProperty(exports, "StaticBlock", {
    enumerable: true,
    get: function() {
      return _index.staticBlock;
    }
  });
  Object.defineProperty(exports, "StringLiteral", {
    enumerable: true,
    get: function() {
      return _index.stringLiteral;
    }
  });
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.stringLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "StringTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.stringTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "Super", {
    enumerable: true,
    get: function() {
      return _index.super;
    }
  });
  Object.defineProperty(exports, "SwitchCase", {
    enumerable: true,
    get: function() {
      return _index.switchCase;
    }
  });
  Object.defineProperty(exports, "SwitchStatement", {
    enumerable: true,
    get: function() {
      return _index.switchStatement;
    }
  });
  Object.defineProperty(exports, "SymbolTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.symbolTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TSAnyKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsAnyKeyword;
    }
  });
  Object.defineProperty(exports, "TSArrayType", {
    enumerable: true,
    get: function() {
      return _index.tsArrayType;
    }
  });
  Object.defineProperty(exports, "TSAsExpression", {
    enumerable: true,
    get: function() {
      return _index.tsAsExpression;
    }
  });
  Object.defineProperty(exports, "TSBigIntKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsBigIntKeyword;
    }
  });
  Object.defineProperty(exports, "TSBooleanKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsBooleanKeyword;
    }
  });
  Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsCallSignatureDeclaration;
    }
  });
  Object.defineProperty(exports, "TSConditionalType", {
    enumerable: true,
    get: function() {
      return _index.tsConditionalType;
    }
  });
  Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsConstructSignatureDeclaration;
    }
  });
  Object.defineProperty(exports, "TSConstructorType", {
    enumerable: true,
    get: function() {
      return _index.tsConstructorType;
    }
  });
  Object.defineProperty(exports, "TSDeclareFunction", {
    enumerable: true,
    get: function() {
      return _index.tsDeclareFunction;
    }
  });
  Object.defineProperty(exports, "TSDeclareMethod", {
    enumerable: true,
    get: function() {
      return _index.tsDeclareMethod;
    }
  });
  Object.defineProperty(exports, "TSEnumDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsEnumDeclaration;
    }
  });
  Object.defineProperty(exports, "TSEnumMember", {
    enumerable: true,
    get: function() {
      return _index.tsEnumMember;
    }
  });
  Object.defineProperty(exports, "TSExportAssignment", {
    enumerable: true,
    get: function() {
      return _index.tsExportAssignment;
    }
  });
  Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    enumerable: true,
    get: function() {
      return _index.tsExpressionWithTypeArguments;
    }
  });
  Object.defineProperty(exports, "TSExternalModuleReference", {
    enumerable: true,
    get: function() {
      return _index.tsExternalModuleReference;
    }
  });
  Object.defineProperty(exports, "TSFunctionType", {
    enumerable: true,
    get: function() {
      return _index.tsFunctionType;
    }
  });
  Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsImportEqualsDeclaration;
    }
  });
  Object.defineProperty(exports, "TSImportType", {
    enumerable: true,
    get: function() {
      return _index.tsImportType;
    }
  });
  Object.defineProperty(exports, "TSIndexSignature", {
    enumerable: true,
    get: function() {
      return _index.tsIndexSignature;
    }
  });
  Object.defineProperty(exports, "TSIndexedAccessType", {
    enumerable: true,
    get: function() {
      return _index.tsIndexedAccessType;
    }
  });
  Object.defineProperty(exports, "TSInferType", {
    enumerable: true,
    get: function() {
      return _index.tsInferType;
    }
  });
  Object.defineProperty(exports, "TSInstantiationExpression", {
    enumerable: true,
    get: function() {
      return _index.tsInstantiationExpression;
    }
  });
  Object.defineProperty(exports, "TSInterfaceBody", {
    enumerable: true,
    get: function() {
      return _index.tsInterfaceBody;
    }
  });
  Object.defineProperty(exports, "TSInterfaceDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsInterfaceDeclaration;
    }
  });
  Object.defineProperty(exports, "TSIntersectionType", {
    enumerable: true,
    get: function() {
      return _index.tsIntersectionType;
    }
  });
  Object.defineProperty(exports, "TSIntrinsicKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsIntrinsicKeyword;
    }
  });
  Object.defineProperty(exports, "TSLiteralType", {
    enumerable: true,
    get: function() {
      return _index.tsLiteralType;
    }
  });
  Object.defineProperty(exports, "TSMappedType", {
    enumerable: true,
    get: function() {
      return _index.tsMappedType;
    }
  });
  Object.defineProperty(exports, "TSMethodSignature", {
    enumerable: true,
    get: function() {
      return _index.tsMethodSignature;
    }
  });
  Object.defineProperty(exports, "TSModuleBlock", {
    enumerable: true,
    get: function() {
      return _index.tsModuleBlock;
    }
  });
  Object.defineProperty(exports, "TSModuleDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsModuleDeclaration;
    }
  });
  Object.defineProperty(exports, "TSNamedTupleMember", {
    enumerable: true,
    get: function() {
      return _index.tsNamedTupleMember;
    }
  });
  Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsNamespaceExportDeclaration;
    }
  });
  Object.defineProperty(exports, "TSNeverKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsNeverKeyword;
    }
  });
  Object.defineProperty(exports, "TSNonNullExpression", {
    enumerable: true,
    get: function() {
      return _index.tsNonNullExpression;
    }
  });
  Object.defineProperty(exports, "TSNullKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsNullKeyword;
    }
  });
  Object.defineProperty(exports, "TSNumberKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsNumberKeyword;
    }
  });
  Object.defineProperty(exports, "TSObjectKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsObjectKeyword;
    }
  });
  Object.defineProperty(exports, "TSOptionalType", {
    enumerable: true,
    get: function() {
      return _index.tsOptionalType;
    }
  });
  Object.defineProperty(exports, "TSParameterProperty", {
    enumerable: true,
    get: function() {
      return _index.tsParameterProperty;
    }
  });
  Object.defineProperty(exports, "TSParenthesizedType", {
    enumerable: true,
    get: function() {
      return _index.tsParenthesizedType;
    }
  });
  Object.defineProperty(exports, "TSPropertySignature", {
    enumerable: true,
    get: function() {
      return _index.tsPropertySignature;
    }
  });
  Object.defineProperty(exports, "TSQualifiedName", {
    enumerable: true,
    get: function() {
      return _index.tsQualifiedName;
    }
  });
  Object.defineProperty(exports, "TSRestType", {
    enumerable: true,
    get: function() {
      return _index.tsRestType;
    }
  });
  Object.defineProperty(exports, "TSSatisfiesExpression", {
    enumerable: true,
    get: function() {
      return _index.tsSatisfiesExpression;
    }
  });
  Object.defineProperty(exports, "TSStringKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsStringKeyword;
    }
  });
  Object.defineProperty(exports, "TSSymbolKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsSymbolKeyword;
    }
  });
  Object.defineProperty(exports, "TSThisType", {
    enumerable: true,
    get: function() {
      return _index.tsThisType;
    }
  });
  Object.defineProperty(exports, "TSTupleType", {
    enumerable: true,
    get: function() {
      return _index.tsTupleType;
    }
  });
  Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsTypeAliasDeclaration;
    }
  });
  Object.defineProperty(exports, "TSTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.tsTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TSTypeAssertion", {
    enumerable: true,
    get: function() {
      return _index.tsTypeAssertion;
    }
  });
  Object.defineProperty(exports, "TSTypeLiteral", {
    enumerable: true,
    get: function() {
      return _index.tsTypeLiteral;
    }
  });
  Object.defineProperty(exports, "TSTypeOperator", {
    enumerable: true,
    get: function() {
      return _index.tsTypeOperator;
    }
  });
  Object.defineProperty(exports, "TSTypeParameter", {
    enumerable: true,
    get: function() {
      return _index.tsTypeParameter;
    }
  });
  Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    enumerable: true,
    get: function() {
      return _index.tsTypeParameterDeclaration;
    }
  });
  Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    enumerable: true,
    get: function() {
      return _index.tsTypeParameterInstantiation;
    }
  });
  Object.defineProperty(exports, "TSTypePredicate", {
    enumerable: true,
    get: function() {
      return _index.tsTypePredicate;
    }
  });
  Object.defineProperty(exports, "TSTypeQuery", {
    enumerable: true,
    get: function() {
      return _index.tsTypeQuery;
    }
  });
  Object.defineProperty(exports, "TSTypeReference", {
    enumerable: true,
    get: function() {
      return _index.tsTypeReference;
    }
  });
  Object.defineProperty(exports, "TSUndefinedKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsUndefinedKeyword;
    }
  });
  Object.defineProperty(exports, "TSUnionType", {
    enumerable: true,
    get: function() {
      return _index.tsUnionType;
    }
  });
  Object.defineProperty(exports, "TSUnknownKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsUnknownKeyword;
    }
  });
  Object.defineProperty(exports, "TSVoidKeyword", {
    enumerable: true,
    get: function() {
      return _index.tsVoidKeyword;
    }
  });
  Object.defineProperty(exports, "TaggedTemplateExpression", {
    enumerable: true,
    get: function() {
      return _index.taggedTemplateExpression;
    }
  });
  Object.defineProperty(exports, "TemplateElement", {
    enumerable: true,
    get: function() {
      return _index.templateElement;
    }
  });
  Object.defineProperty(exports, "TemplateLiteral", {
    enumerable: true,
    get: function() {
      return _index.templateLiteral;
    }
  });
  Object.defineProperty(exports, "ThisExpression", {
    enumerable: true,
    get: function() {
      return _index.thisExpression;
    }
  });
  Object.defineProperty(exports, "ThisTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.thisTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ThrowStatement", {
    enumerable: true,
    get: function() {
      return _index.throwStatement;
    }
  });
  Object.defineProperty(exports, "TopicReference", {
    enumerable: true,
    get: function() {
      return _index.topicReference;
    }
  });
  Object.defineProperty(exports, "TryStatement", {
    enumerable: true,
    get: function() {
      return _index.tryStatement;
    }
  });
  Object.defineProperty(exports, "TupleExpression", {
    enumerable: true,
    get: function() {
      return _index.tupleExpression;
    }
  });
  Object.defineProperty(exports, "TupleTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.tupleTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TypeAlias", {
    enumerable: true,
    get: function() {
      return _index.typeAlias;
    }
  });
  Object.defineProperty(exports, "TypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.typeAnnotation;
    }
  });
  Object.defineProperty(exports, "TypeCastExpression", {
    enumerable: true,
    get: function() {
      return _index.typeCastExpression;
    }
  });
  Object.defineProperty(exports, "TypeParameter", {
    enumerable: true,
    get: function() {
      return _index.typeParameter;
    }
  });
  Object.defineProperty(exports, "TypeParameterDeclaration", {
    enumerable: true,
    get: function() {
      return _index.typeParameterDeclaration;
    }
  });
  Object.defineProperty(exports, "TypeParameterInstantiation", {
    enumerable: true,
    get: function() {
      return _index.typeParameterInstantiation;
    }
  });
  Object.defineProperty(exports, "TypeofTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.typeofTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "UnaryExpression", {
    enumerable: true,
    get: function() {
      return _index.unaryExpression;
    }
  });
  Object.defineProperty(exports, "UnionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.unionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "UpdateExpression", {
    enumerable: true,
    get: function() {
      return _index.updateExpression;
    }
  });
  Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    enumerable: true,
    get: function() {
      return _index.v8IntrinsicIdentifier;
    }
  });
  Object.defineProperty(exports, "VariableDeclaration", {
    enumerable: true,
    get: function() {
      return _index.variableDeclaration;
    }
  });
  Object.defineProperty(exports, "VariableDeclarator", {
    enumerable: true,
    get: function() {
      return _index.variableDeclarator;
    }
  });
  Object.defineProperty(exports, "Variance", {
    enumerable: true,
    get: function() {
      return _index.variance;
    }
  });
  Object.defineProperty(exports, "VoidTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _index.voidTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "WhileStatement", {
    enumerable: true,
    get: function() {
      return _index.whileStatement;
    }
  });
  Object.defineProperty(exports, "WithStatement", {
    enumerable: true,
    get: function() {
      return _index.withStatement;
    }
  });
  Object.defineProperty(exports, "YieldExpression", {
    enumerable: true,
    get: function() {
      return _index.yieldExpression;
    }
  });
  var _index = require_generated2();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS((exports) => {
  var buildUndefinedNode = function() {
    return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.buildUndefinedNode = buildUndefinedNode;
  var _index = require_generated2();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS((exports) => {
  var cloneIfNode = function(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  };
  var cloneIfNodeOrArray = function(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache));
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  };
  var cloneNode = function(node, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node, deep, withoutLoc, new Map);
  };
  var cloneNodeInternal = function(node, deep = true, withoutLoc = false, commentsCache) {
    if (!node)
      return node;
    const {
      type
    } = node;
    const newNode = {
      type: node.type
    };
    if ((0, _index2.isIdentifier)(node)) {
      newNode.name = node.name;
      if (has(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }
      if (has(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
      }
    } else if (!has(_index.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(_index.NODE_FIELDS[type])) {
        if (has(node, field)) {
          if (deep) {
            newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }
    if (has(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }
    if (has(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    }
    if (has(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    }
    if (has(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    }
    if (has(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }
    return newNode;
  };
  var maybeCloneComments = function(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
      return comments;
    }
    return comments.map((comment) => {
      const cache = commentsCache.get(comment);
      if (cache)
        return cache;
      const {
        type,
        value,
        loc
      } = comment;
      const ret = {
        type,
        value,
        loc
      };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneNode;
  var _index = require_definitions();
  var _index2 = require_generated();
  var has = Function.call.bind(Object.prototype.hasOwnProperty);
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/clone/clone.js
var require_clone2 = __commonJS((exports) => {
  var clone = function(node) {
    return (0, _cloneNode.default)(node, false);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = clone;
  var _cloneNode = require_cloneNode();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS((exports) => {
  var cloneDeep = function(node) {
    return (0, _cloneNode.default)(node);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneDeep;
  var _cloneNode = require_cloneNode();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS((exports) => {
  var cloneDeepWithoutLoc = function(node) {
    return (0, _cloneNode.default)(node, true, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneDeepWithoutLoc;
  var _cloneNode = require_cloneNode();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS((exports) => {
  var cloneWithoutLoc = function(node) {
    return (0, _cloneNode.default)(node, false, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneWithoutLoc;
  var _cloneNode = require_cloneNode();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS((exports) => {
  var addComments = function(node, type, comments) {
    if (!comments || !node)
      return node;
    const key = `${type}Comments`;
    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        node[key].push(...comments);
      }
    } else {
      node[key] = comments;
    }
    return node;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addComments;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS((exports) => {
  var addComment = function(node, type, content, line) {
    return (0, _addComments.default)(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addComment;
  var _addComments = require_addComments();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS((exports) => {
  var inherit = function(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inherit;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS((exports) => {
  var inheritInnerComments = function(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritInnerComments;
  var _inherit = require_inherit();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS((exports) => {
  var inheritLeadingComments = function(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritLeadingComments;
  var _inherit = require_inherit();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS((exports) => {
  var inheritTrailingComments = function(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritTrailingComments;
  var _inherit = require_inherit();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS((exports) => {
  var inheritsComments = function(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inheritsComments;
  var _inheritTrailingComments = require_inheritTrailingComments();
  var _inheritLeadingComments = require_inheritLeadingComments();
  var _inheritInnerComments = require_inheritInnerComments();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS((exports) => {
  var removeComments = function(node) {
    _index.COMMENT_KEYS.forEach((key) => {
      node[key] = null;
    });
    return node;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeComments;
  var _index = require_constants();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = undefined;
  var _index = require_definitions();
  var STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
  var EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
  var BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
  var SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
  var BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
  var BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
  var STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
  var TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
  var COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  var CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
  var LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
  var WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
  var EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  var FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
  var FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
  var FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
  var FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
  var PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
  var DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
  var PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
  var LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
  var TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
  var LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
  var IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
  var USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  var METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
  var OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
  var PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
  var UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
  var PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
  var CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
  var IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
  var EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  var MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  var ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
  var PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
  var FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
  var FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
  var FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  var FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  var FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  var ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
  var ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
  var JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
  var MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
  var TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
  var TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  var TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
  var TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
  var MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS((exports) => {
  var toBlock = function(node, parent) {
    if ((0, _index.isBlockStatement)(node)) {
      return node;
    }
    let blockNodes = [];
    if ((0, _index.isEmptyStatement)(node)) {
      blockNodes = [];
    } else {
      if (!(0, _index.isStatement)(node)) {
        if ((0, _index.isFunction)(parent)) {
          node = (0, _index2.returnStatement)(node);
        } else {
          node = (0, _index2.expressionStatement)(node);
        }
      }
      blockNodes = [node];
    }
    return (0, _index2.blockStatement)(blockNodes);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBlock;
  var _index = require_generated();
  var _index2 = require_generated2();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS((exports) => {
  var ensureBlock = function(node, key = "body") {
    const result = (0, _toBlock.default)(node[key], node);
    node[key] = result;
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ensureBlock;
  var _toBlock = require_toBlock();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS((exports) => {
  var toIdentifier = function(input) {
    input = input + "";
    let name = "";
    for (const c of input) {
      name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) {
      name = `_${name}`;
    }
    return name || "_";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toIdentifier;
  var _isValidIdentifier = require_isValidIdentifier();
  var _helperValidatorIdentifier = require_lib3();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS((exports) => {
  var toBindingIdentifierName = function(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments")
      name = "_" + name;
    return name;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBindingIdentifierName;
  var _toIdentifier = require_toIdentifier();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS((exports) => {
  var toComputedKey = function(node, key = node.key || node.property) {
    if (!node.computed && (0, _index.isIdentifier)(key))
      key = (0, _index2.stringLiteral)(key.name);
    return key;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toComputedKey;
  var _index = require_generated();
  var _index2 = require_generated2();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS((exports) => {
  var toExpression = function(node) {
    if ((0, _index.isExpressionStatement)(node)) {
      node = node.expression;
    }
    if ((0, _index.isExpression)(node)) {
      return node;
    }
    if ((0, _index.isClass)(node)) {
      node.type = "ClassExpression";
    } else if ((0, _index.isFunction)(node)) {
      node.type = "FunctionExpression";
    }
    if (!(0, _index.isExpression)(node)) {
      throw new Error(`cannot turn ${node.type} to an expression`);
    }
    return node;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated();
  var _default = exports.default = toExpression;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS((exports) => {
  var traverseFast = function(node, enter, opts) {
    if (!node)
      return;
    const keys = _index.VISITOR_KEYS[node.type];
    if (!keys)
      return;
    opts = opts || {};
    enter(node, opts);
    for (const key of keys) {
      const subNode = node[key];
      if (Array.isArray(subNode)) {
        for (const node2 of subNode) {
          traverseFast(node2, enter, opts);
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = traverseFast;
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS((exports) => {
  var removeProperties = function(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map) {
      if (node[key] != null)
        node[key] = undefined;
    }
    for (const key of Object.keys(node)) {
      if (key[0] === "_" && node[key] != null)
        node[key] = undefined;
    }
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols) {
      node[sym] = null;
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removeProperties;
  var _index = require_constants();
  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS((exports) => {
  var removePropertiesDeep = function(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = removePropertiesDeep;
  var _traverseFast = require_traverseFast();
  var _removeProperties = require_removeProperties();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS((exports) => {
  var toKeyAlias = function(node, key = node.key) {
    let alias;
    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if ((0, _index.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _index.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    }
    if (node.computed) {
      alias = `[${alias}]`;
    }
    if (node.static) {
      alias = `static:${alias}`;
    }
    return alias;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toKeyAlias;
  var _index = require_generated();
  var _cloneNode = require_cloneNode();
  var _removePropertiesDeep = require_removePropertiesDeep();
  toKeyAlias.uid = 0;
  toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS((exports) => {
  var toStatement = function(node, ignore) {
    if ((0, _index.isStatement)(node)) {
      return node;
    }
    let mustHaveId = false;
    let newType;
    if ((0, _index.isClass)(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _index.isFunction)(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _index.isAssignmentExpression)(node)) {
      return (0, _index2.expressionStatement)(node);
    }
    if (mustHaveId && !node.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node.type} to a statement`);
      }
    }
    node.type = newType;
    return node;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = require_generated();
  var _index2 = require_generated2();
  var _default = exports.default = toStatement;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS((exports) => {
  var isRegExp = function(value) {
    return objectToString(value) === "[object RegExp]";
  };
  var isPlainObject = function(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  };
  var valueToNode = function(value) {
    if (value === undefined) {
      return (0, _index.identifier)("undefined");
    }
    if (value === true || value === false) {
      return (0, _index.booleanLiteral)(value);
    }
    if (value === null) {
      return (0, _index.nullLiteral)();
    }
    if (typeof value === "string") {
      return (0, _index.stringLiteral)(value);
    }
    if (typeof value === "number") {
      let result;
      if (Number.isFinite(value)) {
        result = (0, _index.numericLiteral)(Math.abs(value));
      } else {
        let numerator;
        if (Number.isNaN(value)) {
          numerator = (0, _index.numericLiteral)(0);
        } else {
          numerator = (0, _index.numericLiteral)(1);
        }
        result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
      }
      if (value < 0 || Object.is(value, -0)) {
        result = (0, _index.unaryExpression)("-", result);
      }
      return result;
    }
    if (isRegExp(value)) {
      const pattern = value.source;
      const flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return (0, _index.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) {
      return (0, _index.arrayExpression)(value.map(valueToNode));
    }
    if (isPlainObject(value)) {
      const props = [];
      for (const key of Object.keys(value)) {
        let nodeKey;
        if ((0, _isValidIdentifier.default)(key)) {
          nodeKey = (0, _index.identifier)(key);
        } else {
          nodeKey = (0, _index.stringLiteral)(key);
        }
        props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key])));
      }
      return (0, _index.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _isValidIdentifier = require_isValidIdentifier();
  var _index = require_generated2();
  var _default = exports.default = valueToNode;
  var objectToString = Function.call.bind(Object.prototype.toString);
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS((exports) => {
  var appendToMemberExpression = function(member, append, computed = false) {
    member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = appendToMemberExpression;
  var _index = require_generated2();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits2 = __commonJS((exports) => {
  var inherits = function(child, parent) {
    if (!child || !parent)
      return child;
    for (const key of _index.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }
    for (const key of Object.keys(parent)) {
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    for (const key of _index.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }
    (0, _inheritsComments.default)(child, parent);
    return child;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = inherits;
  var _index = require_constants();
  var _inheritsComments = require_inheritsComments();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS((exports) => {
  var prependToMemberExpression = function(member, prepend) {
    if ((0, _index2.isSuper)(member.object)) {
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    }
    member.object = (0, _index.memberExpression)(prepend, member.object);
    return member;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prependToMemberExpression;
  var _index = require_generated2();
  var _index2 = require_lib5();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS((exports) => {
  var getBindingIdentifiers = function(node, duplicates, outerOnly, newBindingsOnly) {
    const search = [].concat(node);
    const ids = Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id)
        continue;
      if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id))) {
        continue;
      }
      const keys = getBindingIdentifiers.keys[id.type];
      if ((0, _index.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
        if ((0, _index.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if ((0, _index.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }
        if ((0, _index.isFunctionExpression)(id)) {
          continue;
        }
      }
      if (keys) {
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          const nodes = id[key];
          if (nodes) {
            Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
          }
        }
      }
    }
    return ids;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getBindingIdentifiers;
  var _index = require_generated();
  getBindingIdentifiers.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS((exports) => {
  var getOuterBindingIdentifiers = function(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _default = exports.default = getOuterBindingIdentifiers;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS((exports) => {
  var traverse = function(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }
    const {
      enter,
      exit
    } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
  };
  var traverseSimpleImpl = function(node, enter, exit, state, ancestors) {
    const keys = _index.VISITOR_KEYS[node.type];
    if (!keys)
      return;
    if (enter)
      enter(node, ancestors, state);
    for (const key of keys) {
      const subNode = node[key];
      if (Array.isArray(subNode)) {
        for (let i = 0;i < subNode.length; i++) {
          const child = subNode[i];
          if (!child)
            continue;
          ancestors.push({
            node,
            key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node,
          key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
    if (exit)
      exit(node, ancestors, state);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = traverse;
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS((exports) => {
  var isBinding = function(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) {
      for (let i = 0;i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0)
            return true;
        } else {
          if (val === node)
            return true;
        }
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBinding;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS((exports) => {
  var isLet = function(node) {
    return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLet;
  var _index = require_generated();
  var _index2 = require_constants();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS((exports) => {
  var isBlockScoped = function(node) {
    return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBlockScoped;
  var _index = require_generated();
  var _isLet = require_isLet();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS((exports) => {
  var isImmutable = function(node) {
    if ((0, _isType.default)(node.type, "Immutable"))
      return true;
    if ((0, _index.isIdentifier)(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isImmutable;
  var _isType = require_isType();
  var _index = require_generated();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS((exports) => {
  var isNodesEquivalent = function(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _index.VISITOR_KEYS[a.type];
    for (const field of fields) {
      const val_a = a[field];
      const val_b = b[field];
      if (typeof val_a !== typeof val_b) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (let i = 0;i < val_a.length; i++) {
          if (!isNodesEquivalent(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (const key of Object.keys(val_a)) {
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent(val_a, val_b)) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNodesEquivalent;
  var _index = require_definitions();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS((exports) => {
  var isReferenced = function(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }
        return parent.object === node;
      case "JSXMemberExpression":
        return parent.object === node;
      case "VariableDeclarator":
        return parent.init === node;
      case "ArrowFunctionExpression":
        return parent.body === node;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;
      case "AssignmentExpression":
        return parent.right === node;
      case "AssignmentPattern":
        return parent.right === node;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node;
      case "TSEnumMember":
        return parent.id !== node;
      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isReferenced;
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS((exports) => {
  var isScope = function(node, parent) {
    if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return false;
    }
    if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return true;
    }
    return (0, _index.isScopable)(node);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isScope;
  var _index = require_generated();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS((exports) => {
  var isSpecifierDefault = function(specifier) {
    return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSpecifierDefault;
  var _index = require_generated();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS((exports) => {
  var isValidES3Identifier = function(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isValidES3Identifier;
  var _isValidIdentifier = require_isValidIdentifier();
  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS((exports) => {
  var isVar = function(node) {
    return (0, _index.isVariableDeclaration)(node, {
      kind: "var"
    }) && !node[_index2.BLOCK_SCOPED_SYMBOL];
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isVar;
  var _index = require_generated();
  var _index2 = require_constants();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS((exports) => {
  var gatherSequenceExpressions = function(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes) {
      if (!(0, _index.isEmptyStatement)(node)) {
        ensureLastUndefined = false;
      }
      if ((0, _index.isExpression)(node)) {
        exprs.push(node);
      } else if ((0, _index.isExpressionStatement)(node)) {
        exprs.push(node.expression);
      } else if ((0, _index.isVariableDeclaration)(node)) {
        if (node.kind !== "var")
          return;
        for (const declar of node.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);
          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node.kind,
              id: (0, _cloneNode.default)(bindings[key])
            });
          }
          if (declar.init) {
            exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
          }
        }
        ensureLastUndefined = true;
      } else if ((0, _index.isIfStatement)(node)) {
        const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
        const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
        if (!consequent || !alternate)
          return;
        exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
      } else if ((0, _index.isBlockStatement)(node)) {
        const body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body)
          return;
        exprs.push(body);
      } else if ((0, _index.isEmptyStatement)(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _index2.sequenceExpression)(exprs);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = gatherSequenceExpressions;
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _index = require_generated();
  var _index2 = require_generated2();
  var _cloneNode = require_cloneNode();
});

// node_modules/.pnpm/@babel+types@7.23.9/node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS((exports) => {
  var toSequenceExpression = function(nodes, scope) {
    if (!(nodes != null && nodes.length))
      return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result)
      return;
    for (const declar of declars) {
      scope.push(declar);
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toSequenceExpression;
  var _gatherSequenceExpressions = require_gatherSequenceExpressions();
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/with@7.0.2/node_modules/@babel/types/lib/index.js
var require_lib5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true,
    __internal__deprecationWarning: true
  };
  Object.defineProperty(exports, "__internal__deprecationWarning", {
    enumerable: true,
    get: function() {
      return _deprecationWarning.default;
    }
  });
  Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function() {
      return _addComment.default;
    }
  });
  Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function() {
      return _addComments.default;
    }
  });
  Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function() {
      return _appendToMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function() {
      return _assertNode.default;
    }
  });
  Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function() {
      return _buildMatchMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function() {
      return _clone.default;
    }
  });
  Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function() {
      return _cloneDeep.default;
    }
  });
  Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function() {
      return _cloneDeepWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function() {
      return _cloneNode.default;
    }
  });
  Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function() {
      return _cloneWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function() {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function() {
      return _createTSUnionType.default;
    }
  });
  Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function() {
      return _createTypeAnnotationBasedOnTypeof.default;
    }
  });
  Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function() {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function() {
      return _ensureBlock.default;
    }
  });
  Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function() {
      return _getBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function() {
      return _getOuterBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function() {
      return _inheritInnerComments.default;
    }
  });
  Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function() {
      return _inheritLeadingComments.default;
    }
  });
  Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function() {
      return _inheritTrailingComments.default;
    }
  });
  Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function() {
      return _inherits.default;
    }
  });
  Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function() {
      return _inheritsComments.default;
    }
  });
  Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function() {
      return _is.default;
    }
  });
  Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function() {
      return _isBinding.default;
    }
  });
  Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function() {
      return _isBlockScoped.default;
    }
  });
  Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function() {
      return _isImmutable.default;
    }
  });
  Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function() {
      return _isLet.default;
    }
  });
  Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function() {
      return _isNode.default;
    }
  });
  Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function() {
      return _isNodesEquivalent.default;
    }
  });
  Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function() {
      return _isPlaceholderType.default;
    }
  });
  Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function() {
      return _isReferenced.default;
    }
  });
  Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function() {
      return _isScope.default;
    }
  });
  Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function() {
      return _isSpecifierDefault.default;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
      return _isType.default;
    }
  });
  Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function() {
      return _isValidES3Identifier.default;
    }
  });
  Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function() {
      return _isValidIdentifier.default;
    }
  });
  Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function() {
      return _isVar.default;
    }
  });
  Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function() {
      return _matchesPattern.default;
    }
  });
  Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function() {
      return _prependToMemberExpression.default;
    }
  });
  exports.react = undefined;
  Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function() {
      return _removeComments.default;
    }
  });
  Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function() {
      return _removeProperties.default;
    }
  });
  Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function() {
      return _removePropertiesDeep.default;
    }
  });
  Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function() {
      return _removeTypeDuplicates.default;
    }
  });
  Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function() {
      return _shallowEqual.default;
    }
  });
  Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function() {
      return _toBindingIdentifierName.default;
    }
  });
  Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function() {
      return _toBlock.default;
    }
  });
  Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function() {
      return _toComputedKey.default;
    }
  });
  Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function() {
      return _toExpression.default;
    }
  });
  Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function() {
      return _toIdentifier.default;
    }
  });
  Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function() {
      return _toKeyAlias.default;
    }
  });
  Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function() {
      return _toStatement.default;
    }
  });
  Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function() {
      return _traverse.default;
    }
  });
  Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function() {
      return _traverseFast.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function() {
      return _valueToNode.default;
    }
  });
  var _isReactComponent = require_isReactComponent();
  var _isCompatTag = require_isCompatTag();
  var _buildChildren = require_buildChildren();
  var _assertNode = require_assertNode();
  var _index = require_generated3();
  Object.keys(_index).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index[key];
      }
    });
  });
  var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
  var _createFlowUnionType = require_createFlowUnionType();
  var _createTSUnionType = require_createTSUnionType();
  var _index2 = require_generated2();
  Object.keys(_index2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index2[key];
      }
    });
  });
  var _uppercase = require_uppercase();
  Object.keys(_uppercase).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _uppercase[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _uppercase[key];
      }
    });
  });
  var _productions = require_productions();
  Object.keys(_productions).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _productions[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _productions[key];
      }
    });
  });
  var _cloneNode = require_cloneNode();
  var _clone = require_clone2();
  var _cloneDeep = require_cloneDeep();
  var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
  var _cloneWithoutLoc = require_cloneWithoutLoc();
  var _addComment = require_addComment();
  var _addComments = require_addComments();
  var _inheritInnerComments = require_inheritInnerComments();
  var _inheritLeadingComments = require_inheritLeadingComments();
  var _inheritsComments = require_inheritsComments();
  var _inheritTrailingComments = require_inheritTrailingComments();
  var _removeComments = require_removeComments();
  var _index3 = require_generated4();
  Object.keys(_index3).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index3[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index3[key];
      }
    });
  });
  var _index4 = require_constants();
  Object.keys(_index4).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index4[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index4[key];
      }
    });
  });
  var _ensureBlock = require_ensureBlock();
  var _toBindingIdentifierName = require_toBindingIdentifierName();
  var _toBlock = require_toBlock();
  var _toComputedKey = require_toComputedKey();
  var _toExpression = require_toExpression();
  var _toIdentifier = require_toIdentifier();
  var _toKeyAlias = require_toKeyAlias();
  var _toStatement = require_toStatement();
  var _valueToNode = require_valueToNode();
  var _index5 = require_definitions();
  Object.keys(_index5).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index5[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index5[key];
      }
    });
  });
  var _appendToMemberExpression = require_appendToMemberExpression();
  var _inherits = require_inherits2();
  var _prependToMemberExpression = require_prependToMemberExpression();
  var _removeProperties = require_removeProperties();
  var _removePropertiesDeep = require_removePropertiesDeep();
  var _removeTypeDuplicates = require_removeTypeDuplicates();
  var _getBindingIdentifiers = require_getBindingIdentifiers();
  var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
  var _traverse = require_traverse();
  Object.keys(_traverse).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _traverse[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _traverse[key];
      }
    });
  });
  var _traverseFast = require_traverseFast();
  var _shallowEqual = require_shallowEqual();
  var _is = require_is();
  var _isBinding = require_isBinding();
  var _isBlockScoped = require_isBlockScoped();
  var _isImmutable = require_isImmutable();
  var _isLet = require_isLet();
  var _isNode = require_isNode();
  var _isNodesEquivalent = require_isNodesEquivalent();
  var _isPlaceholderType = require_isPlaceholderType();
  var _isReferenced = require_isReferenced();
  var _isScope = require_isScope();
  var _isSpecifierDefault = require_isSpecifierDefault();
  var _isType = require_isType();
  var _isValidES3Identifier = require_isValidES3Identifier();
  var _isValidIdentifier = require_isValidIdentifier();
  var _isVar = require_isVar();
  var _matchesPattern = require_matchesPattern();
  var _validate = require_validate();
  var _buildMatchMemberExpression = require_buildMatchMemberExpression();
  var _index6 = require_generated();
  Object.keys(_index6).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index6[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index6[key];
      }
    });
  });
  var _deprecationWarning = require_deprecationWarning();
  var react = exports.react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
  };
  {
    exports.toSequenceExpression = require_toSequenceExpression().default;
  }
});

// node_modules/.pnpm/constantinople@4.0.1/node_modules/constantinople/lib/binaryOperation.js
var require_binaryOperation = __commonJS((exports) => {
  var binaryOperation = function(operator, left, right) {
    switch (operator) {
      case "+":
        return left + right;
      case "-":
        return left - right;
      case "/":
        return left / right;
      case "%":
        return left % right;
      case "*":
        return left * right;
      case "**":
        return Math.pow(left, right);
      case "&":
        return left & right;
      case "|":
        return left | right;
      case ">>":
        return left >> right;
      case ">>>":
        return left >>> right;
      case "<<":
        return left << right;
      case "^":
        return left ^ right;
      case "==":
        return left == right;
      case "===":
        return left === right;
      case "!=":
        return left != right;
      case "!==":
        return left !== right;
      case "in":
        return left in right;
      case "instanceof":
        return left instanceof right;
      case ">":
        return left > right;
      case "<":
        return left < right;
      case ">=":
        return left >= right;
      case "<=":
        return left <= right;
    }
  };
  exports.__esModule = true;
  exports.default = binaryOperation;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-code-gen@3.0.2/node_modules/constantinople/lib/index.js
var require_lib6 = __commonJS((exports, module) => {
  var expressionToConstant = function(expression, options) {
    if (options === undefined) {
      options = {};
    }
    var constant = true;
    function toConstant2(expression2) {
      if (!constant)
        return;
      if (b.isArrayExpression(expression2)) {
        var result_1 = [];
        for (var i = 0;constant && i < expression2.elements.length; i++) {
          var element = expression2.elements[i];
          if (b.isSpreadElement(element)) {
            var spread = toConstant2(element.argument);
            if (!(isSpreadable(spread) && constant)) {
              constant = false;
            } else {
              result_1.push.apply(result_1, spread);
            }
          } else if (b.isExpression(element)) {
            result_1.push(toConstant2(element));
          } else {
            constant = false;
          }
        }
        return result_1;
      }
      if (b.isBinaryExpression(expression2)) {
        var left = toConstant2(expression2.left);
        var right = toConstant2(expression2.right);
        return constant && binaryOperation_1["default"](expression2.operator, left, right);
      }
      if (b.isBooleanLiteral(expression2)) {
        return expression2.value;
      }
      if (b.isCallExpression(expression2)) {
        var args = [];
        for (var i = 0;constant && i < expression2.arguments.length; i++) {
          var arg = expression2.arguments[i];
          if (b.isSpreadElement(arg)) {
            var spread = toConstant2(arg.argument);
            if (!(isSpreadable(spread) && constant)) {
              constant = false;
            } else {
              args.push.apply(args, spread);
            }
          } else if (b.isExpression(arg)) {
            args.push(toConstant2(arg));
          } else {
            constant = false;
          }
        }
        if (!constant)
          return;
        if (b.isMemberExpression(expression2.callee)) {
          var object = toConstant2(expression2.callee.object);
          if (!object || !constant) {
            constant = false;
            return;
          }
          var member = expression2.callee.computed ? toConstant2(expression2.callee.property) : b.isIdentifier(expression2.callee.property) ? expression2.callee.property.name : undefined;
          if (member === undefined && !expression2.callee.computed) {
            constant = false;
          }
          if (!constant)
            return;
          if (canCallMethod(object, "" + member)) {
            return object[member].apply(object, args);
          }
        } else {
          if (!b.isExpression(expression2.callee)) {
            constant = false;
            return;
          }
          var callee = toConstant2(expression2.callee);
          if (!constant)
            return;
          return callee.apply(null, args);
        }
      }
      if (b.isConditionalExpression(expression2)) {
        var test = toConstant2(expression2.test);
        return test ? toConstant2(expression2.consequent) : toConstant2(expression2.alternate);
      }
      if (b.isIdentifier(expression2)) {
        if (options.constants && {}.hasOwnProperty.call(options.constants, expression2.name)) {
          return options.constants[expression2.name];
        }
      }
      if (b.isLogicalExpression(expression2)) {
        var left = toConstant2(expression2.left);
        var right = toConstant2(expression2.right);
        if (constant && expression2.operator === "&&") {
          return left && right;
        }
        if (constant && expression2.operator === "||") {
          return left || right;
        }
      }
      if (b.isMemberExpression(expression2)) {
        var object = toConstant2(expression2.object);
        if (!object || !constant) {
          constant = false;
          return;
        }
        var member = expression2.computed ? toConstant2(expression2.property) : b.isIdentifier(expression2.property) ? expression2.property.name : undefined;
        if (member === undefined && !expression2.computed) {
          constant = false;
        }
        if (!constant)
          return;
        if ({}.hasOwnProperty.call(object, "" + member) && member[0] !== "_") {
          return object[member];
        }
      }
      if (b.isNullLiteral(expression2)) {
        return null;
      }
      if (b.isNumericLiteral(expression2)) {
        return expression2.value;
      }
      if (b.isObjectExpression(expression2)) {
        var result_2 = {};
        for (var i = 0;constant && i < expression2.properties.length; i++) {
          var property = expression2.properties[i];
          if (b.isObjectProperty(property)) {
            if (property.shorthand) {
              constant = false;
              return;
            }
            var key = property.computed ? toConstant2(property.key) : b.isIdentifier(property.key) ? property.key.name : b.isStringLiteral(property.key) ? property.key.value : undefined;
            if (!key || key[0] === "_") {
              constant = false;
            }
            if (!constant)
              return;
            if (b.isExpression(property.value)) {
              var value = toConstant2(property.value);
              if (!constant)
                return;
              result_2[key] = value;
            } else {
              constant = false;
            }
          } else if (b.isObjectMethod(property)) {
            constant = false;
          } else if (b.isSpreadProperty(property)) {
            var argument = toConstant2(property.argument);
            if (!argument)
              constant = false;
            if (!constant)
              return;
            Object.assign(result_2, argument);
          }
        }
        return result_2;
      }
      if (b.isParenthesizedExpression(expression2)) {
        return toConstant2(expression2.expression);
      }
      if (b.isRegExpLiteral(expression2)) {
        return new RegExp(expression2.pattern, expression2.flags);
      }
      if (b.isSequenceExpression(expression2)) {
        for (var i = 0;i < expression2.expressions.length - 1 && constant; i++) {
          toConstant2(expression2.expressions[i]);
        }
        return toConstant2(expression2.expressions[expression2.expressions.length - 1]);
      }
      if (b.isStringLiteral(expression2)) {
        return expression2.value;
      }
      if (b.isTemplateLiteral(expression2)) {
        var result_3 = "";
        for (var i = 0;i < expression2.quasis.length; i++) {
          var quasi = expression2.quasis[i];
          result_3 += quasi.value.cooked;
          if (i < expression2.expressions.length) {
            result_3 += "" + toConstant2(expression2.expressions[i]);
          }
        }
        return result_3;
      }
      if (b.isUnaryExpression(expression2)) {
        var argument = toConstant2(expression2.argument);
        if (!constant) {
          return;
        }
        switch (expression2.operator) {
          case "-":
            return -argument;
          case "+":
            return +argument;
          case "!":
            return !argument;
          case "~":
            return ~argument;
          case "typeof":
            return typeof argument;
          case "void":
            return;
        }
      }
      constant = false;
    }
    var result = toConstant2(expression);
    return constant ? { constant: true, result } : { constant: false };
  };
  var isSpreadable = function(value) {
    return typeof value === "string" || Array.isArray(value) || typeof Set !== "undefined" && value instanceof Set || typeof Map !== "undefined" && value instanceof Map;
  };
  var shallowEqual = function(a, b2) {
    if (a === b2)
      return true;
    if (a && b2 && typeof a === "object" && typeof b2 === "object") {
      for (var key in a) {
        if (a[key] !== b2[key]) {
          return false;
        }
      }
      for (var key in b2) {
        if (a[key] !== b2[key]) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  var canCallMethod = function(object, member) {
    switch (typeof object) {
      case "boolean":
        switch (member) {
          case "toString":
            return true;
          default:
            return false;
        }
      case "number":
        switch (member) {
          case "toExponential":
          case "toFixed":
          case "toPrecision":
          case "toString":
            return true;
          default:
            return false;
        }
      case "string":
        switch (member) {
          case "charAt":
          case "charCodeAt":
          case "codePointAt":
          case "concat":
          case "endsWith":
          case "includes":
          case "indexOf":
          case "lastIndexOf":
          case "match":
          case "normalize":
          case "padEnd":
          case "padStart":
          case "repeat":
          case "replace":
          case "search":
          case "slice":
          case "split":
          case "startsWith":
          case "substr":
          case "substring":
          case "toLowerCase":
          case "toUpperCase":
          case "trim":
            return true;
          default:
            return false;
        }
      default:
        if (object instanceof RegExp) {
          switch (member) {
            case "test":
            case "exec":
              return true;
            default:
              return false;
          }
        }
        return {}.hasOwnProperty.call(object, member) && member[0] !== "_";
    }
  };
  var isConstant = function(src, constants, options) {
    if (constants === undefined) {
      constants = EMPTY_OBJECT;
    }
    if (options === undefined) {
      options = EMPTY_OBJECT;
    }
    if (lastSrc === src && shallowEqual(lastConstants, constants) && shallowEqual(lastOptions, options)) {
      return lastWasConstant;
    }
    lastSrc = src;
    lastConstants = constants;
    var ast;
    try {
      ast = parser_1.parseExpression(src, options);
    } catch (ex) {
      return lastWasConstant = false;
    }
    var _a = expressionToConstant(ast, { constants }), result = _a.result, constant = _a.constant;
    lastResult = result;
    return lastWasConstant = constant;
  };
  var toConstant = function(src, constants, options) {
    if (constants === undefined) {
      constants = EMPTY_OBJECT;
    }
    if (options === undefined) {
      options = EMPTY_OBJECT;
    }
    if (!isConstant(src, constants, options)) {
      throw new Error(JSON.stringify(src) + " is not constant.");
    }
    return lastResult;
  };
  exports.__esModule = true;
  var parser_1 = require_lib2();
  var b = require_lib5();
  var binaryOperation_1 = require_binaryOperation();
  exports.expressionToConstant = expressionToConstant;
  var EMPTY_OBJECT = {};
  var lastSrc = "";
  var lastConstants = EMPTY_OBJECT;
  var lastOptions = EMPTY_OBJECT;
  var lastResult = null;
  var lastWasConstant = false;
  exports.isConstant = isConstant;
  exports.toConstant = toConstant;
  exports.default = isConstant;
  module.exports = isConstant;
  module.exports["default"] = isConstant;
  module.exports.expressionToConstant = expressionToConstant;
  module.exports.isConstant = isConstant;
  module.exports.toConstant = toConstant;
});

// node_modules/.pnpm/pug-filters@4.0.0/node_modules/pug-filters/lib/handle-filters.js
var require_handle_filters = __commonJS((exports, module) => {
  var handleFilters = function(ast, filters, options, filterAliases) {
    options = options || {};
    walk(ast, function(node) {
      var dir = node.filename ? dirname(node.filename) : null;
      if (node.type === "Filter") {
        handleNestedFilters(node, filters, options, filterAliases);
        var text = getBodyAsText(node);
        var attrs = getAttributes(node, options);
        attrs.filename = node.filename;
        node.type = "Text";
        node.val = filterWithFallback(node, text, attrs);
      } else if (node.type === "RawInclude" && node.filters.length) {
        var firstFilter = node.filters.pop();
        var attrs = getAttributes(firstFilter, options);
        var filename = attrs.filename = node.file.fullPath;
        node.type = "Text";
        node.val = filterFileWithFallback(firstFilter, filename, node.file, attrs);
        node.filters.slice().reverse().forEach(function(filter) {
          var attrs2 = getAttributes(filter, options);
          attrs2.filename = filename;
          node.val = filterWithFallback(filter, node.val, attrs2);
        });
        node.filters = undefined;
        node.file = undefined;
      }
      function filterWithFallback(filter, text2, attrs2, funcName) {
        try {
          var filterName = getFilterName(filter);
          if (filters && filters[filterName]) {
            return filters[filterName](text2, attrs2);
          } else {
            return runFilter(filterName, text2, attrs2, dir, funcName);
          }
        } catch (ex) {
          if (ex.code === "UNKNOWN_FILTER") {
            throw error(ex.code, ex.message, filter);
          }
          throw ex;
        }
      }
      function filterFileWithFallback(filter, filename2, file, attrs2) {
        var filterName = getFilterName(filter);
        if (filters && filters[filterName]) {
          if (filters[filterName].renderBuffer) {
            return filters[filterName].renderBuffer(file.raw, attrs2);
          } else {
            return filters[filterName](file.str, attrs2);
          }
        } else {
          return filterWithFallback(filter, filename2, attrs2, "renderFile");
        }
      }
    }, { includeDependencies: true });
    function getFilterName(filter) {
      var filterName = filter.name;
      if (filterAliases && filterAliases[filterName]) {
        filterName = filterAliases[filterName];
        if (filterAliases[filterName]) {
          throw error("FILTER_ALISE_CHAIN", 'The filter "' + filter.name + '" is an alias for "' + filterName + '", which is an alias for "' + filterAliases[filterName] + '".  Pug does not support chains of filter aliases.', filter);
        }
      }
      return filterName;
    }
    return ast;
  };
  var handleNestedFilters = function(node, filters, options, filterAliases) {
    if (node.block.nodes[0] && node.block.nodes[0].type === "Filter") {
      node.block.nodes[0] = handleFilters(node.block, filters, options, filterAliases).nodes[0];
    }
  };
  var getBodyAsText = function(node) {
    return node.block.nodes.map(function(node2) {
      return node2.val;
    }).join("");
  };
  var getAttributes = function(node, options) {
    var attrs = {};
    node.attrs.forEach(function(attr) {
      try {
        attrs[attr.name] = attr.val === true ? true : constantinople.toConstant(attr.val);
      } catch (ex) {
        if (/not constant/.test(ex.message)) {
          throw error("FILTER_OPTION_NOT_CONSTANT", ex.message + " All filters are rendered compile-time so filter options must be constants.", node);
        }
        throw ex;
      }
    });
    var opts = options[node.name] || {};
    Object.keys(opts).forEach(function(opt) {
      if (!attrs.hasOwnProperty(opt)) {
        attrs[opt] = opts[opt];
      }
    });
    return attrs;
  };
  var dirname = __require("path").dirname;
  var constantinople = require_lib6();
  var walk = require_pug_walk();
  var error = require_pug_error();
  var runFilter = require_run_filter();
  module.exports = handleFilters;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-filters/index.js
var require_pug_filters = __commonJS((exports) => {
  exports.runFilter = require_run_filter();
  exports.handleFilters = require_handle_filters();
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-linker/index.js
var require_pug_linker = __commonJS((exports, module) => {
  var error = function() {
    throw require_pug_error().apply(null, arguments);
  };
  var link = function(ast) {
    assert(ast.type === "Block", "The top level element should always be a block");
    var extendsNode = null;
    if (ast.nodes.length) {
      var hasExtends = ast.nodes[0].type === "Extends";
      checkExtendPosition(ast, hasExtends);
      if (hasExtends) {
        extendsNode = ast.nodes.shift();
      }
    }
    ast = applyIncludes(ast);
    ast.declaredBlocks = findDeclaredBlocks(ast);
    if (extendsNode) {
      var mixins = [];
      var expectedBlocks = [];
      ast.nodes.forEach(function addNode(node) {
        if (node.type === "NamedBlock") {
          expectedBlocks.push(node);
        } else if (node.type === "Block") {
          node.nodes.forEach(addNode);
        } else if (node.type === "Mixin" && node.call === false) {
          mixins.push(node);
        } else {
          error("UNEXPECTED_NODES_IN_EXTENDING_ROOT", "Only named blocks and mixins can appear at the top level of an extending template", node);
        }
      });
      var parent = link(extendsNode.file.ast);
      extend(parent.declaredBlocks, ast);
      var foundBlockNames = [];
      walk(parent, function(node) {
        if (node.type === "NamedBlock") {
          foundBlockNames.push(node.name);
        }
      });
      expectedBlocks.forEach(function(expectedBlock) {
        if (foundBlockNames.indexOf(expectedBlock.name) === -1) {
          error("UNEXPECTED_BLOCK", "Unexpected block " + expectedBlock.name, expectedBlock);
        }
      });
      Object.keys(ast.declaredBlocks).forEach(function(name) {
        parent.declaredBlocks[name] = ast.declaredBlocks[name];
      });
      parent.nodes = mixins.concat(parent.nodes);
      parent.hasExtends = true;
      return parent;
    }
    return ast;
  };
  var findDeclaredBlocks = function(ast) {
    var definitions = {};
    walk(ast, function before(node) {
      if (node.type === "NamedBlock" && node.mode === "replace") {
        definitions[node.name] = definitions[node.name] || [];
        definitions[node.name].push(node);
      }
    });
    return definitions;
  };
  var flattenParentBlocks = function(parentBlocks, accumulator) {
    accumulator = accumulator || [];
    parentBlocks.forEach(function(parentBlock) {
      if (parentBlock.parents) {
        flattenParentBlocks(parentBlock.parents, accumulator);
      }
      accumulator.push(parentBlock);
    });
    return accumulator;
  };
  var extend = function(parentBlocks, ast) {
    var stack = {};
    walk(ast, function before(node) {
      if (node.type === "NamedBlock") {
        if (stack[node.name] === node.name) {
          return node.ignore = true;
        }
        stack[node.name] = node.name;
        var parentBlockList = parentBlocks[node.name] ? flattenParentBlocks(parentBlocks[node.name]) : [];
        if (parentBlockList.length) {
          node.parents = parentBlockList;
          parentBlockList.forEach(function(parentBlock) {
            switch (node.mode) {
              case "append":
                parentBlock.nodes = parentBlock.nodes.concat(node.nodes);
                break;
              case "prepend":
                parentBlock.nodes = node.nodes.concat(parentBlock.nodes);
                break;
              case "replace":
                parentBlock.nodes = node.nodes;
                break;
            }
          });
        }
      }
    }, function after(node) {
      if (node.type === "NamedBlock" && !node.ignore) {
        delete stack[node.name];
      }
    });
  };
  var applyIncludes = function(ast, child) {
    return walk(ast, function before(node, replace) {
      if (node.type === "RawInclude") {
        replace({ type: "Text", val: node.file.str.replace(/\r/g, "") });
      }
    }, function after(node, replace) {
      if (node.type === "Include") {
        var childAST = link(node.file.ast);
        if (childAST.hasExtends) {
          childAST = removeBlocks(childAST);
        }
        replace(applyYield(childAST, node.block));
      }
    });
  };
  var removeBlocks = function(ast) {
    return walk(ast, function(node, replace) {
      if (node.type === "NamedBlock") {
        replace({
          type: "Block",
          nodes: node.nodes
        });
      }
    });
  };
  var applyYield = function(ast, block) {
    if (!block || !block.nodes.length)
      return ast;
    var replaced = false;
    ast = walk(ast, null, function(node, replace) {
      if (node.type === "YieldBlock") {
        replaced = true;
        node.type = "Block";
        node.nodes = [block];
      }
    });
    function defaultYieldLocation(node) {
      var res = node;
      for (var i = 0;i < node.nodes.length; i++) {
        if (node.nodes[i].textOnly)
          continue;
        if (node.nodes[i].type === "Block") {
          res = defaultYieldLocation(node.nodes[i]);
        } else if (node.nodes[i].block && node.nodes[i].block.nodes.length) {
          res = defaultYieldLocation(node.nodes[i].block);
        }
      }
      return res;
    }
    if (!replaced) {
      defaultYieldLocation(ast).nodes.push(block);
    }
    return ast;
  };
  var checkExtendPosition = function(ast, hasExtends) {
    var legitExtendsReached = false;
    walk(ast, function(node) {
      if (node.type === "Extends") {
        if (hasExtends && !legitExtendsReached) {
          legitExtendsReached = true;
        } else {
          error("EXTENDS_NOT_FIRST", 'Declaration of template inheritance ("extends") should be the first thing in the file. There can only be one extends statement per file.', node);
        }
      }
    });
  };
  var assert = __require("assert");
  var walk = require_pug_walk();
  module.exports = link;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-code-gen@3.0.2/node_modules/doctypes/index.js
var require_doctypes = __commonJS((exports, module) => {
  module.exports = {
    html: "<!DOCTYPE html>",
    xml: '<?xml version="1.0" encoding="utf-8" ?>',
    transitional: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
    strict: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
    frameset: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
    "1.1": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
    basic: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">',
    mobile: '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">',
    plist: '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
  };
});

// node_modules/.pnpm/pug-runtime@3.0.1/node_modules/pug-runtime/lib/dependencies.js
var require_dependencies = __commonJS((exports, module) => {
  module.exports = {
    has_own_property: [],
    merge: [
      "style"
    ],
    classes_array: [
      "classes",
      "escape"
    ],
    classes_object: [
      "has_own_property"
    ],
    classes: [
      "classes_array",
      "classes_object"
    ],
    style: [
      "has_own_property"
    ],
    attr: [
      "escape"
    ],
    attrs: [
      "attr",
      "classes",
      "has_own_property",
      "style"
    ],
    match_html: [],
    escape: [
      "match_html"
    ],
    rethrow: []
  };
});

// node_modules/.pnpm/pug-runtime@3.0.1/node_modules/pug-runtime/lib/internals.js
var require_internals = __commonJS((exports, module) => {
  module.exports = {
    dependencies: true,
    internals: true,
    has_own_property: true,
    classes_array: true,
    classes_object: true,
    match_html: true
  };
});

// node_modules/.pnpm/pug-runtime@3.0.1/node_modules/pug-runtime/lib/sources.js
var require_sources = __commonJS((exports, module) => {
  module.exports = {
    has_own_property: "var pug_has_own_property=Object.prototype.hasOwnProperty;",
    merge: "function pug_merge(e,r){if(1===arguments.length){for(var t=e[0],g=1;g<e.length;g++)t=pug_merge(t,e[g]);return t}for(var l in r)if(\"class\"===l){var n=e[l]||[];e[l]=(Array.isArray(n)?n:[n]).concat(r[l]||[])}else if(\"style\"===l){var n=pug_style(e[l]);n=n&&\";\"!==n[n.length-1]?n+\";\":n;var a=pug_style(r[l]);a=a&&\";\"!==a[a.length-1]?a+\";\":a,e[l]=n+a}else e[l]=r[l];return e}",
    classes_array: "function pug_classes_array(r,a){for(var s,e=\"\",u=\"\",c=Array.isArray(a),g=0;g<r.length;g++)(s=pug_classes(r[g]))&&(c&&a[g]&&(s=pug_escape(s)),e=e+u+s,u=\" \");return e}",
    classes_object: "function pug_classes_object(r){var a=\"\",n=\"\";for(var o in r)o&&r[o]&&pug_has_own_property.call(r,o)&&(a=a+n+o,n=\" \");return a}",
    classes: "function pug_classes(s,r){return Array.isArray(s)?pug_classes_array(s,r):s&&\"object\"==typeof s?pug_classes_object(s):s||\"\"}",
    style: "function pug_style(r){if(!r)return\"\";if(\"object\"==typeof r){var t=\"\";for(var e in r)pug_has_own_property.call(r,e)&&(t=t+e+\":\"+r[e]+\";\");return t}return r+\"\"}",
    attr: "function pug_attr(t,e,n,r){if(!1===e||null==e||!e&&(\"class\"===t||\"style\"===t))return\"\";if(!0===e)return\" \"+(r?t:t+'=\"'+t+'\"');var f=typeof e;return\"object\"!==f&&\"function\"!==f||\"function\"!=typeof e.toJSON||(e=e.toJSON()),\"string\"==typeof e||(e=JSON.stringify(e),n||-1===e.indexOf('\"'))?(n&&(e=pug_escape(e)),\" \"+t+'=\"'+e+'\"'):\" \"+t+\"='\"+e.replace(/'/g,\"&#39;\")+\"'\"}",
    attrs: "function pug_attrs(t,r){var a=\"\";for(var s in t)if(pug_has_own_property.call(t,s)){var u=t[s];if(\"class\"===s){u=pug_classes(u),a=pug_attr(s,u,!1,r)+a;continue}\"style\"===s&&(u=pug_style(u)),a+=pug_attr(s,u,!1,r)}return a}",
    match_html: "var pug_match_html=/[\"&<>]/;",
    escape: "function pug_escape(e){var a=\"\"+e,t=pug_match_html.exec(a);if(!t)return e;var r,c,n,s=\"\";for(r=t.index,c=0;r<a.length;r++){switch(a.charCodeAt(r)){case 34:n=\"&quot;\";break;case 38:n=\"&amp;\";break;case 60:n=\"&lt;\";break;case 62:n=\"&gt;\";break;default:continue}c!==r&&(s+=a.substring(c,r)),c=r+1,s+=n}return c!==r?s+a.substring(c,r):s}",
    rethrow: "function pug_rethrow(e,n,r,t){if(!(e instanceof Error))throw e;if(!(\"undefined\"==typeof window&&n||t))throw e.message+=\" on line \"+r,e;var o,a,i,s;try{t=t||require(\"fs\").readFileSync(n,{encoding:\"utf8\"}),o=3,a=t.split(\"\\n\"),i=Math.max(r-o,0),s=Math.min(a.length,r+o)}catch(t){return e.message+=\" - could not read from \"+n+\" (\"+t.message+\")\",void pug_rethrow(e,null,r)}o=a.slice(i,s).map(function(e,n){var t=n+i+1;return(t==r?\"  > \":\"    \")+t+\"| \"+e}).join(\"\\n\"),e.path=n;try{e.message=(n||\"Pug\")+\":\"+r+\"\\n\"+o+\"\\n\\n\"+e.message}catch(e){}throw e}"
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-code-gen@3.0.2/node_modules/pug-runtime/build.js
var require_build = __commonJS((exports, module) => {
  var build = function(functions) {
    var fns = [];
    functions = functions.filter(function(fn) {
      return !internals[fn];
    });
    for (var i = 0;i < functions.length; i++) {
      if (fns.indexOf(functions[i]) === -1) {
        fns.push(functions[i]);
        functions.push.apply(functions, dependencies[functions[i]]);
      }
    }
    return fns.sort().map(function(name) {
      return sources[name];
    }).join("\n");
  };
  var fs = __require("fs");
  var dependencies = require_dependencies();
  var internals = require_internals();
  var sources = require_sources();
  module.exports = build;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-runtime/index.js
var require_pug_runtime = __commonJS((exports) => {
  var pug_merge = function(a, b) {
    if (arguments.length === 1) {
      var attrs = a[0];
      for (var i = 1;i < a.length; i++) {
        attrs = pug_merge(attrs, a[i]);
      }
      return attrs;
    }
    for (var key in b) {
      if (key === "class") {
        var valA = a[key] || [];
        a[key] = (Array.isArray(valA) ? valA : [valA]).concat(b[key] || []);
      } else if (key === "style") {
        var valA = pug_style(a[key]);
        valA = valA && valA[valA.length - 1] !== ";" ? valA + ";" : valA;
        var valB = pug_style(b[key]);
        valB = valB && valB[valB.length - 1] !== ";" ? valB + ";" : valB;
        a[key] = valA + valB;
      } else {
        a[key] = b[key];
      }
    }
    return a;
  };
  var pug_classes_array = function(val, escaping) {
    var classString = "", className, padding = "", escapeEnabled = Array.isArray(escaping);
    for (var i = 0;i < val.length; i++) {
      className = pug_classes(val[i]);
      if (!className)
        continue;
      escapeEnabled && escaping[i] && (className = pug_escape(className));
      classString = classString + padding + className;
      padding = " ";
    }
    return classString;
  };
  var pug_classes_object = function(val) {
    var classString = "", padding = "";
    for (var key in val) {
      if (key && val[key] && pug_has_own_property.call(val, key)) {
        classString = classString + padding + key;
        padding = " ";
      }
    }
    return classString;
  };
  var pug_classes = function(val, escaping) {
    if (Array.isArray(val)) {
      return pug_classes_array(val, escaping);
    } else if (val && typeof val === "object") {
      return pug_classes_object(val);
    } else {
      return val || "";
    }
  };
  var pug_style = function(val) {
    if (!val)
      return "";
    if (typeof val === "object") {
      var out = "";
      for (var style in val) {
        if (pug_has_own_property.call(val, style)) {
          out = out + style + ":" + val[style] + ";";
        }
      }
      return out;
    } else {
      return val + "";
    }
  };
  var pug_attr = function(key, val, escaped, terse) {
    if (val === false || val == null || !val && (key === "class" || key === "style")) {
      return "";
    }
    if (val === true) {
      return " " + (terse ? key : key + '="' + key + '"');
    }
    var type = typeof val;
    if ((type === "object" || type === "function") && typeof val.toJSON === "function") {
      val = val.toJSON();
    }
    if (typeof val !== "string") {
      val = JSON.stringify(val);
      if (!escaped && val.indexOf('"') !== -1) {
        return " " + key + "='" + val.replace(/'/g, "&#39;") + "'";
      }
    }
    if (escaped)
      val = pug_escape(val);
    return " " + key + '="' + val + '"';
  };
  var pug_attrs = function(obj, terse) {
    var attrs = "";
    for (var key in obj) {
      if (pug_has_own_property.call(obj, key)) {
        var val = obj[key];
        if (key === "class") {
          val = pug_classes(val);
          attrs = pug_attr(key, val, false, terse) + attrs;
          continue;
        }
        if (key === "style") {
          val = pug_style(val);
        }
        attrs += pug_attr(key, val, false, terse);
      }
    }
    return attrs;
  };
  var pug_escape = function(_html) {
    var html = "" + _html;
    var regexResult = pug_match_html.exec(html);
    if (!regexResult)
      return _html;
    var result = "";
    var i, lastIndex, escape;
    for (i = regexResult.index, lastIndex = 0;i < html.length; i++) {
      switch (html.charCodeAt(i)) {
        case 34:
          escape = "&quot;";
          break;
        case 38:
          escape = "&amp;";
          break;
        case 60:
          escape = "&lt;";
          break;
        case 62:
          escape = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== i)
        result += html.substring(lastIndex, i);
      lastIndex = i + 1;
      result += escape;
    }
    if (lastIndex !== i)
      return result + html.substring(lastIndex, i);
    else
      return result;
  };
  var pug_rethrow = function(err, filename, lineno, str) {
    if (!(err instanceof Error))
      throw err;
    if ((typeof window != "undefined" || !filename) && !str) {
      err.message += " on line " + lineno;
      throw err;
    }
    var context, lines, start, end;
    try {
      str = str || __require("fs").readFileSync(filename, { encoding: "utf8" });
      context = 3;
      lines = str.split("\n");
      start = Math.max(lineno - context, 0);
      end = Math.min(lines.length, lineno + context);
    } catch (ex) {
      err.message += " - could not read from " + filename + " (" + ex.message + ")";
      pug_rethrow(err, null, lineno);
      return;
    }
    context = lines.slice(start, end).map(function(line, i) {
      var curr = i + start + 1;
      return (curr == lineno ? "  > " : "    ") + curr + "| " + line;
    }).join("\n");
    err.path = filename;
    try {
      err.message = (filename || "Pug") + ":" + lineno + "\n" + context + "\n\n" + err.message;
    } catch (e) {
    }
    throw err;
  };
  var pug_has_own_property = Object.prototype.hasOwnProperty;
  exports.merge = pug_merge;
  exports.classes = pug_classes;
  exports.style = pug_style;
  exports.attr = pug_attr;
  exports.attrs = pug_attrs;
  var pug_match_html = /["&<>]/;
  exports.escape = pug_escape;
  exports.rethrow = pug_rethrow;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-code-gen@3.0.2/node_modules/js-stringify/index.js
var require_js_stringify = __commonJS((exports, module) => {
  var stringify = function(obj) {
    if (obj instanceof Date) {
      return "new Date(" + stringify(obj.toISOString()) + ")";
    }
    if (obj === undefined) {
      return "undefined";
    }
    return JSON.stringify(obj).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/</g, "\\u003C").replace(/>/g, "\\u003E").replace(/\//g, "\\u002F");
  };
  module.exports = stringify;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-code-gen@3.0.2/node_modules/pug-attrs/index.js
var require_pug_attrs = __commonJS((exports, module) => {
  var isConstant = function(src) {
    return constantinople(src, { pug: runtime, pug_interp: undefined });
  };
  var toConstant = function(src) {
    return constantinople.toConstant(src, { pug: runtime, pug_interp: undefined });
  };
  var compileAttrs = function(attrs, options) {
    assert(Array.isArray(attrs), "Attrs should be an array");
    assert(attrs.every(function(attr) {
      return attr && typeof attr === "object" && typeof attr.name === "string" && (typeof attr.val === "string" || typeof attr.val === "boolean") && typeof attr.mustEscape === "boolean";
    }), "All attributes should be supplied as an object of the form {name, val, mustEscape}");
    assert(options && typeof options === "object", "Options should be an object");
    assert(typeof options.terse === "boolean", "Options.terse should be a boolean");
    assert(typeof options.runtime === "function", "Options.runtime should be a function that takes a runtime function name and returns the source code that will evaluate to that function at runtime");
    assert(options.format === "html" || options.format === "object", 'Options.format should be "html" or "object"');
    var buf = [];
    var classes = [];
    var classEscaping = [];
    function addAttribute(key, val, mustEscape, buf2) {
      if (isConstant(val)) {
        if (options.format === "html") {
          var str = stringify(runtime.attr(key, toConstant(val), mustEscape, options.terse));
          var last = buf2[buf2.length - 1];
          if (last && last[last.length - 1] === str[0]) {
            buf2[buf2.length - 1] = last.substr(0, last.length - 1) + str.substr(1);
          } else {
            buf2.push(str);
          }
        } else {
          val = toConstant(val);
          if (mustEscape) {
            val = runtime.escape(val);
          }
          buf2.push(stringify(key) + ": " + stringify(val));
        }
      } else {
        if (options.format === "html") {
          buf2.push(options.runtime("attr") + '("' + key + '", ' + val + ", " + stringify(mustEscape) + ", " + stringify(options.terse) + ")");
        } else {
          if (mustEscape) {
            val = options.runtime("escape") + "(" + val + ")";
          }
          buf2.push(stringify(key) + ": " + val);
        }
      }
    }
    attrs.forEach(function(attr) {
      var key = attr.name;
      var val = attr.val;
      var mustEscape = attr.mustEscape;
      if (key === "class") {
        classes.push(val);
        classEscaping.push(mustEscape);
      } else {
        if (key === "style") {
          if (isConstant(val)) {
            val = stringify(runtime.style(toConstant(val)));
          } else {
            val = options.runtime("style") + "(" + val + ")";
          }
        }
        addAttribute(key, val, mustEscape, buf);
      }
    });
    var classesBuf = [];
    if (classes.length) {
      if (classes.every(isConstant)) {
        addAttribute("class", stringify(runtime.classes(classes.map(toConstant), classEscaping)), false, classesBuf);
      } else {
        classes = classes.map(function(cls, i) {
          if (isConstant(cls)) {
            cls = stringify(classEscaping[i] ? runtime.escape(toConstant(cls)) : toConstant(cls));
            classEscaping[i] = false;
          }
          return cls;
        });
        addAttribute("class", options.runtime("classes") + "([" + classes.join(",") + "], " + stringify(classEscaping) + ")", false, classesBuf);
      }
    }
    buf = classesBuf.concat(buf);
    if (options.format === "html")
      return buf.length ? buf.join("+") : '""';
    else
      return "{" + buf.join(",") + "}";
  };
  var assert = __require("assert");
  var constantinople = require_lib6();
  var runtime = require_pug_runtime();
  var stringify = require_js_stringify();
  module.exports = compileAttrs;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-code-gen@3.0.2/node_modules/void-elements/index.js
var require_void_elements = __commonJS((exports, module) => {
  module.exports = {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
});

// node_modules/.pnpm/babel-walk@3.0.0-canary-5/node_modules/babel-walk/lib/explode.js
var require_explode = __commonJS((exports) => {
  var explode = function(input) {
    const results = {};
    for (const key in input) {
      const aliases = FLIPPED_ALIAS_KEYS[key];
      if (aliases) {
        for (const concreteKey of aliases) {
          if (concreteKey in results) {
            if (typeof input[key] === "function") {
              results[concreteKey].enter.push(input[key]);
            } else {
              if (input[key].enter)
                results[concreteKey].enter.push(input[key].enter);
              if (input[key].exit)
                results[concreteKey].exit.push(input[key].exit);
            }
          } else {
            if (typeof input[key] === "function") {
              results[concreteKey] = {
                enter: [input[key]],
                exit: []
              };
            } else {
              results[concreteKey] = {
                enter: input[key].enter ? [input[key].enter] : [],
                exit: input[key].exit ? [input[key].exit] : []
              };
            }
          }
        }
      } else if (TYPES.has(key)) {
        if (key in results) {
          if (typeof input[key] === "function") {
            results[key].enter.push(input[key]);
          } else {
            if (input[key].enter)
              results[key].enter.push(input[key].enter);
            if (input[key].exit)
              results[key].exit.push(input[key].exit);
          }
        } else {
          if (typeof input[key] === "function") {
            results[key] = {
              enter: [input[key]],
              exit: []
            };
          } else {
            results[key] = {
              enter: input[key].enter ? [input[key].enter] : [],
              exit: input[key].exit ? [input[key].exit] : []
            };
          }
        }
      }
    }
    return results;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = __importStar(require_lib5());
  if (!(Array.isArray(t.TYPES) && t.TYPES.every((t2) => typeof t2 === "string"))) {
    throw new Error("@babel/types TYPES does not match the expected type.");
  }
  var FLIPPED_ALIAS_KEYS = t.FLIPPED_ALIAS_KEYS;
  var TYPES = new Set(t.TYPES);
  if (!(FLIPPED_ALIAS_KEYS && typeof FLIPPED_ALIAS_KEYS === "object" && Object.keys(FLIPPED_ALIAS_KEYS).every((key) => Array.isArray(FLIPPED_ALIAS_KEYS[key]) && FLIPPED_ALIAS_KEYS[key].every((v) => typeof v === "string")))) {
    throw new Error("@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.");
  }
  exports.default = explode;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/with@7.0.2/node_modules/babel-walk/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var simple = function(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state) => {
      (function recurse(node2) {
        if (!node2)
          return;
        const visitor = vis[node2.type];
        if (visitor === null || visitor === undefined ? undefined : visitor.enter) {
          for (const v of visitor.enter) {
            v(node2, state);
          }
        }
        for (const key of VISITOR_KEYS[node2.type] || []) {
          const subNode = node2[key];
          if (Array.isArray(subNode)) {
            for (const subSubNode of subNode) {
              recurse(subSubNode);
            }
          } else {
            recurse(subNode);
          }
        }
        if (visitor === null || visitor === undefined ? undefined : visitor.exit) {
          for (const v of visitor.exit) {
            v(node2, state);
          }
        }
      })(node);
    };
  };
  var ancestor = function(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state) => {
      const ancestors = [];
      (function recurse(node2) {
        if (!node2)
          return;
        const visitor = vis[node2.type];
        const isNew = node2 !== ancestors[ancestors.length - 1];
        if (isNew)
          ancestors.push(node2);
        if (visitor === null || visitor === undefined ? undefined : visitor.enter) {
          for (const v of visitor.enter) {
            v(node2, state, ancestors);
          }
        }
        for (const key of VISITOR_KEYS[node2.type] || []) {
          const subNode = node2[key];
          if (Array.isArray(subNode)) {
            for (const subSubNode of subNode) {
              recurse(subSubNode);
            }
          } else {
            recurse(subNode);
          }
        }
        if (visitor === null || visitor === undefined ? undefined : visitor.exit) {
          for (const v of visitor.exit) {
            v(node2, state, ancestors);
          }
        }
        if (isNew)
          ancestors.pop();
      })(node);
    };
  };
  var recursive = function(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state) => {
      (function recurse(node2) {
        if (!node2)
          return;
        const visitor = vis[node2.type];
        if (visitor === null || visitor === undefined ? undefined : visitor.enter) {
          for (const v of visitor.enter) {
            v(node2, state, recurse);
          }
        } else {
          for (const key of VISITOR_KEYS[node2.type] || []) {
            const subNode = node2[key];
            if (Array.isArray(subNode)) {
              for (const subSubNode of subNode) {
                recurse(subSubNode);
              }
            } else {
              recurse(subNode);
            }
          }
        }
      })(node);
    };
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recursive = exports.ancestor = exports.simple = undefined;
  var t = __importStar(require_lib5());
  var explode_1 = __importDefault(require_explode());
  var VISITOR_KEYS = t.VISITOR_KEYS;
  if (!(VISITOR_KEYS && typeof VISITOR_KEYS === "object" && Object.keys(VISITOR_KEYS).every((key) => Array.isArray(VISITOR_KEYS[key]) && VISITOR_KEYS[key].every((v) => typeof v === "string")))) {
    throw new Error("@babel/types VISITOR_KEYS does not match the expected type.");
  }
  exports.simple = simple;
  exports.ancestor = ancestor;
  exports.recursive = recursive;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/with@7.0.2/node_modules/assert-never/index.js
var require_assert_never = __commonJS((exports) => {
  var assertNever = function(value, noThrow) {
    if (noThrow) {
      return value;
    }
    throw new Error("Unhandled discriminated union member: " + JSON.stringify(value));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertNever = assertNever;
  exports.default = assertNever;
});

// node_modules/.pnpm/with@7.0.2/node_modules/with/lib/reference.js
var require_reference = __commonJS((exports) => {
  var isReferenced = function(node, parent) {
    switch (parent.type) {
      case "ObjectProperty":
        return parent.value === node || parent.computed;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "AssignmentExpression":
        return true;
    }
    return t.isReferenced(node, parent);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var t = __importStar(require_lib5());
  exports.default = isReferenced;
});

// node_modules/.pnpm/with@7.0.2/node_modules/with/lib/globals.js
var require_globals = __commonJS((exports) => {
  var declareFunction = function(node) {
    for (const param of node.params) {
      declarePattern(param, node);
    }
    const id = node.id;
    if (id) {
      setLocal(node, id.name);
    }
  };
  var declarePattern = function(node, parent) {
    switch (node.type) {
      case "Identifier":
        setLocal(parent, node.name);
        break;
      case "ObjectPattern":
        for (const prop of node.properties) {
          switch (prop.type) {
            case "RestElement":
              declarePattern(prop.argument, parent);
              break;
            case "ObjectProperty":
              declarePattern(prop.value, parent);
              break;
            default:
              assert_never_1.default(prop);
              break;
          }
        }
        break;
      case "ArrayPattern":
        for (const element of node.elements) {
          if (element)
            declarePattern(element, parent);
        }
        break;
      case "RestElement":
        declarePattern(node.argument, parent);
        break;
      case "AssignmentPattern":
        declarePattern(node.left, parent);
        break;
      default:
        throw new Error("Unrecognized pattern type: " + node.type);
    }
  };
  var declareModuleSpecifier = function(node, _state, parents) {
    for (let i = parents.length - 2;i >= 0; i--) {
      if (isScope(parents[i])) {
        setLocal(parents[i], node.local.name);
        return;
      }
    }
  };
  var findGlobals = function(ast) {
    const globals = [];
    if (!t.isNode(ast)) {
      throw new TypeError("Source must be a Babylon AST");
    }
    firstPass(ast, undefined);
    secondPass(ast, { globals });
    const groupedGlobals = new Map;
    for (const node of globals) {
      const name = node.type === "ThisExpression" ? "this" : node.name;
      const existing = groupedGlobals.get(name);
      if (existing) {
        existing.push(node);
      } else {
        groupedGlobals.set(name, [node]);
      }
    }
    return [...groupedGlobals].map(([name, nodes]) => ({ name, nodes })).sort((a, b) => a.name < b.name ? -1 : 1);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var assert_never_1 = __importDefault(require_assert_never());
  var babel_walk_1 = require_lib7();
  var t = __importStar(require_lib5());
  var reference_1 = __importDefault(require_reference());
  var isScope = (node) => t.isFunctionParent(node) || t.isProgram(node);
  var isBlockScope = (node) => t.isBlockStatement(node) || isScope(node);
  var declaresArguments = (node) => t.isFunction(node) && !t.isArrowFunctionExpression(node);
  var declaresThis = declaresArguments;
  var LOCALS_SYMBOL = Symbol("locals");
  var getLocals = (node) => node[LOCALS_SYMBOL];
  var declareLocals = (node) => node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set;
  var setLocal = (node, name) => declareLocals(node).add(name);
  var firstPass = babel_walk_1.ancestor({
    VariableDeclaration(node, _state, parents) {
      for (let i = parents.length - 2;i >= 0; i--) {
        if (node.kind === "var" ? t.isFunctionParent(parents[i]) : isBlockScope(parents[i])) {
          for (const declaration of node.declarations) {
            declarePattern(declaration.id, parents[i]);
          }
          return;
        }
      }
    },
    FunctionDeclaration(node, _state, parents) {
      if (node.id) {
        for (let i = parents.length - 2;i >= 0; i--) {
          if (isScope(parents[i])) {
            setLocal(parents[i], node.id.name);
            return;
          }
        }
      }
    },
    Function: declareFunction,
    ClassDeclaration(node, _state, parents) {
      for (let i = parents.length - 2;i >= 0; i--) {
        if (isScope(parents[i])) {
          setLocal(parents[i], node.id.name);
          return;
        }
      }
    },
    TryStatement(node) {
      if (node.handler === null)
        return;
      if (node.handler.param === null)
        return;
      declarePattern(node.handler.param, node.handler);
    },
    ImportDefaultSpecifier: declareModuleSpecifier,
    ImportSpecifier: declareModuleSpecifier,
    ImportNamespaceSpecifier: declareModuleSpecifier
  });
  var secondPass = babel_walk_1.ancestor({
    Identifier(node, state, parents) {
      var _a;
      const name = node.name;
      if (name === "undefined")
        return;
      const lastParent = parents[parents.length - 2];
      if (lastParent) {
        if (!reference_1.default(node, lastParent))
          return;
        for (const parent of parents) {
          if (name === "arguments" && declaresArguments(parent)) {
            return;
          }
          if ((_a = getLocals(parent)) === null || _a === undefined ? undefined : _a.has(name)) {
            return;
          }
        }
      }
      state.globals.push(node);
    },
    ThisExpression(node, state, parents) {
      for (const parent of parents) {
        if (declaresThis(parent)) {
          return;
        }
      }
      state.globals.push(node);
    }
  });
  exports.default = findGlobals;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug-code-gen@3.0.2/node_modules/with/lib/index.js
var require_lib8 = __commonJS((exports, module) => {
  var addWith = function(obj, src, exclude = []) {
    obj = obj + "";
    src = src + "";
    let ast;
    try {
      ast = parser_1.parse(src, parseOptions);
    } catch (e) {
      throw Object.assign(new Error("Error parsing body of the with expression"), {
        component: "src",
        babylonError: e
      });
    }
    let objAst;
    try {
      objAst = parser_1.parse(obj, parseOptions);
    } catch (e) {
      throw Object.assign(new Error("Error parsing object part of the with expression"), {
        component: "obj",
        babylonError: e
      });
    }
    const excludeSet = new Set([
      "undefined",
      "this",
      ...exclude,
      ...globals_1.default(objAst).map((g) => g.name)
    ]);
    const vars = new Set(globals_1.default(ast).map((global) => global.name).filter((v) => !excludeSet.has(v)));
    if (vars.size === 0)
      return src;
    let declareLocal = "";
    let local = "locals_for_with";
    let result = "result_of_with";
    if (t.isValidIdentifier(obj)) {
      local = obj;
    } else {
      while (vars.has(local) || excludeSet.has(local)) {
        local += "_";
      }
      declareLocal = `var ${local} = (${obj});`;
    }
    while (vars.has(result) || excludeSet.has(result)) {
      result += "_";
    }
    const args = [
      "this",
      ...Array.from(vars).map((v) => `${JSON.stringify(v)} in ${local} ?
        ${local}.${v} :
        typeof ${v} !== 'undefined' ? ${v} : undefined`)
    ];
    const unwrapped = unwrapReturns(ast, src, result);
    return `;
    ${declareLocal}
    ${unwrapped.before}
    (function (${Array.from(vars).join(", ")}) {
      ${unwrapped.body}
    }.call(${args.join(", ")}));
    ${unwrapped.after};`;
  };
  var unwrapReturns = function(ast, src, result) {
    const charArray = src.split("");
    const state = {
      hasReturn: false,
      source(node) {
        return src.slice(node.start, node.end);
      },
      replace(node, str) {
        charArray.fill("", node.start, node.end);
        charArray[node.start] = str;
      }
    };
    unwrapReturnsVisitors(ast, state);
    return {
      before: state.hasReturn ? `var ${result} = ` : "",
      body: charArray.join(""),
      after: state.hasReturn ? `;if (${result}) return ${result}.value` : ""
    };
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var parser_1 = require_lib2();
  var babel_walk_1 = require_lib7();
  var t = __importStar(require_lib5());
  var globals_1 = __importDefault(require_globals());
  var parseOptions = {
    allowReturnOutsideFunction: true,
    allowImportExportEverywhere: true
  };
  exports.default = addWith;
  var unwrapReturnsVisitors = babel_walk_1.recursive({
    Function(_node, _state, _c) {
    },
    ReturnStatement(node, state) {
      state.hasReturn = true;
      let value = "";
      if (node.argument) {
        value = `value: (${state.source(node.argument)})`;
      }
      state.replace(node, `return {${value}};`);
    }
  });
  module.exports = addWith;
  module.exports.default = addWith;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-code-gen/index.js
var require_pug_code_gen = __commonJS((exports, module) => {
  var generateCode = function(ast, options) {
    return new Compiler(ast, options).compile();
  };
  var isConstant = function(src) {
    return constantinople(src, { pug: runtime, pug_interp: undefined });
  };
  var toConstant = function(src) {
    return constantinople.toConstant(src, { pug: runtime, pug_interp: undefined });
  };
  var Compiler = function(node, options) {
    this.options = options = options || {};
    this.node = node;
    this.bufferedConcatenationCount = 0;
    this.hasCompiledDoctype = false;
    this.hasCompiledTag = false;
    this.pp = options.pretty || false;
    if (this.pp && typeof this.pp !== "string") {
      this.pp = "  ";
    }
    if (this.pp && !/^\s+$/.test(this.pp)) {
      throw new Error("The pretty parameter should either be a boolean or whitespace only string");
    }
    this.debug = options.compileDebug !== false;
    this.indents = 0;
    this.parentIndents = 0;
    this.terse = false;
    this.mixins = {};
    this.dynamicMixins = false;
    this.eachCount = 0;
    if (options.doctype)
      this.setDoctype(options.doctype);
    this.runtimeFunctionsUsed = [];
    this.inlineRuntimeFunctions = options.inlineRuntimeFunctions || false;
    if (this.debug && this.inlineRuntimeFunctions) {
      this.runtimeFunctionsUsed.push("rethrow");
    }
  };
  var tagCanInline = function(tag) {
    function isInline(node) {
      if (node.type === "Block")
        return node.nodes.every(isInline);
      if (node.type === "YieldBlock")
        return true;
      return node.type === "Text" && !/\n/.test(node.val) || node.isInline;
    }
    return tag.block.nodes.every(isInline);
  };
  var doctypes = require_doctypes();
  var makeError = require_pug_error();
  var buildRuntime = require_build();
  var runtime = require_pug_runtime();
  var compileAttrs = require_pug_attrs();
  var selfClosing = require_void_elements();
  var constantinople = require_lib6();
  var stringify = require_js_stringify();
  var addWith = require_lib8();
  var WHITE_SPACE_SENSITIVE_TAGS = {
    pre: true,
    textarea: true
  };
  var INTERNAL_VARIABLES = [
    "pug",
    "pug_mixins",
    "pug_interp",
    "pug_debug_filename",
    "pug_debug_line",
    "pug_debug_sources",
    "pug_html"
  ];
  module.exports = generateCode;
  module.exports.CodeGenerator = Compiler;
  Compiler.prototype = {
    runtime: function(name) {
      if (this.inlineRuntimeFunctions) {
        this.runtimeFunctionsUsed.push(name);
        return "pug_" + name;
      } else {
        return "pug." + name;
      }
    },
    error: function(message, code, node) {
      var err = makeError(code, message, {
        line: node.line,
        column: node.column,
        filename: node.filename
      });
      throw err;
    },
    compile: function() {
      this.buf = [];
      if (this.pp)
        this.buf.push("var pug_indent = [];");
      this.lastBufferedIdx = -1;
      this.visit(this.node);
      if (!this.dynamicMixins) {
        var mixinNames = Object.keys(this.mixins);
        for (var i = 0;i < mixinNames.length; i++) {
          var mixin = this.mixins[mixinNames[i]];
          if (!mixin.used) {
            for (var x = 0;x < mixin.instances.length; x++) {
              for (var y = mixin.instances[x].start;y < mixin.instances[x].end; y++) {
                this.buf[y] = "";
              }
            }
          }
        }
      }
      var js = this.buf.join("\n");
      var globals = this.options.globals ? this.options.globals.concat(INTERNAL_VARIABLES) : INTERNAL_VARIABLES;
      if (this.options.self) {
        js = "var self = locals || {};" + js;
      } else {
        js = addWith("locals || {}", js, globals.concat(this.runtimeFunctionsUsed.map(function(name) {
          return "pug_" + name;
        })));
      }
      if (this.debug) {
        if (this.options.includeSources) {
          js = "var pug_debug_sources = " + stringify(this.options.includeSources) + ";\n" + js;
        }
        js = "var pug_debug_filename, pug_debug_line;try {" + js + "} catch (err) {" + (this.inlineRuntimeFunctions ? "pug_rethrow" : "pug.rethrow") + "(err, pug_debug_filename, pug_debug_line" + (this.options.includeSources ? ", pug_debug_sources[pug_debug_filename]" : "") + ");}";
      }
      return buildRuntime(this.runtimeFunctionsUsed) + "function " + (this.options.templateName || "template") + '(locals) {var pug_html = "", pug_mixins = {}, pug_interp;' + js + ";return pug_html;}";
    },
    setDoctype: function(name) {
      this.doctype = doctypes[name.toLowerCase()] || "<!DOCTYPE " + name + ">";
      this.terse = this.doctype.toLowerCase() == "<!doctype html>";
      this.xml = this.doctype.indexOf("<?xml") == 0;
    },
    buffer: function(str) {
      var self2 = this;
      str = stringify(str);
      str = str.substr(1, str.length - 2);
      if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
        if (this.lastBufferedType === "code") {
          this.lastBuffered += ' + "';
          this.bufferedConcatenationCount++;
        }
        this.lastBufferedType = "text";
        this.lastBuffered += str;
        this.buf[this.lastBufferedIdx - 1] = "pug_html = pug_html + " + this.bufferStartChar + this.lastBuffered + '";';
      } else {
        this.bufferedConcatenationCount = 0;
        this.buf.push('pug_html = pug_html + "' + str + '";');
        this.lastBufferedType = "text";
        this.bufferStartChar = '"';
        this.lastBuffered = str;
        this.lastBufferedIdx = this.buf.length;
      }
    },
    bufferExpression: function(src) {
      if (isConstant(src)) {
        return this.buffer(toConstant(src) + "");
      }
      if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
        this.bufferedConcatenationCount++;
        if (this.lastBufferedType === "text")
          this.lastBuffered += '"';
        this.lastBufferedType = "code";
        this.lastBuffered += " + (" + src + ")";
        this.buf[this.lastBufferedIdx - 1] = "pug_html = pug_html + (" + this.bufferStartChar + this.lastBuffered + ");";
      } else {
        this.bufferedConcatenationCount = 0;
        this.buf.push("pug_html = pug_html + (" + src + ");");
        this.lastBufferedType = "code";
        this.bufferStartChar = "";
        this.lastBuffered = "(" + src + ")";
        this.lastBufferedIdx = this.buf.length;
      }
    },
    prettyIndent: function(offset, newline) {
      offset = offset || 0;
      newline = newline ? "\n" : "";
      this.buffer(newline + Array(this.indents + offset).join(this.pp));
      if (this.parentIndents)
        this.buf.push('pug_html = pug_html + pug_indent.join("");');
    },
    visit: function(node, parent) {
      var debug = this.debug;
      if (!node) {
        var msg;
        if (parent) {
          msg = "A child of " + parent.type + " (" + (parent.filename || "Pug") + ":" + parent.line + ")";
        } else {
          msg = "A top-level node";
        }
        msg += " is " + node + ", expected a Pug AST Node.";
        throw new TypeError(msg);
      }
      if (debug && node.debug !== false && node.type !== "Block") {
        if (node.line) {
          var js = ";pug_debug_line = " + node.line;
          if (node.filename)
            js += ";pug_debug_filename = " + stringify(node.filename);
          this.buf.push(js + ";");
        }
      }
      if (!this["visit" + node.type]) {
        var msg;
        if (parent) {
          msg = "A child of " + parent.type;
        } else {
          msg = "A top-level node";
        }
        msg += " (" + (node.filename || "Pug") + ":" + node.line + ") is of type " + node.type + ", which is not supported by pug-code-gen.";
        switch (node.type) {
          case "Filter":
            msg += " Please use pug-filters to preprocess this AST.";
            break;
          case "Extends":
          case "Include":
          case "NamedBlock":
          case "FileReference":
            msg += " Please use pug-linker to preprocess this AST.";
            break;
        }
        throw new TypeError(msg);
      }
      this.visitNode(node);
    },
    visitNode: function(node) {
      return this["visit" + node.type](node);
    },
    visitCase: function(node) {
      this.buf.push("switch (" + node.expr + "){");
      this.visit(node.block, node);
      this.buf.push("}");
    },
    visitWhen: function(node) {
      if (node.expr == "default") {
        this.buf.push("default:");
      } else {
        this.buf.push("case " + node.expr + ":");
      }
      if (node.block) {
        this.visit(node.block, node);
        this.buf.push("  break;");
      }
    },
    visitLiteral: function(node) {
      this.buffer(node.str);
    },
    visitNamedBlock: function(block) {
      return this.visitBlock(block);
    },
    visitBlock: function(block) {
      var escapePrettyMode = this.escapePrettyMode;
      var pp = this.pp;
      if (pp && block.nodes.length > 1 && !escapePrettyMode && block.nodes[0].type === "Text" && block.nodes[1].type === "Text") {
        this.prettyIndent(1, true);
      }
      for (var i = 0;i < block.nodes.length; ++i) {
        if (pp && i > 0 && !escapePrettyMode && block.nodes[i].type === "Text" && block.nodes[i - 1].type === "Text" && /\n$/.test(block.nodes[i - 1].val)) {
          this.prettyIndent(1, false);
        }
        this.visit(block.nodes[i], block);
      }
    },
    visitMixinBlock: function(block) {
      if (this.pp)
        this.buf.push("pug_indent.push(" + stringify(Array(this.indents + 1).join(this.pp)) + ");");
      this.buf.push("block && block();");
      if (this.pp)
        this.buf.push("pug_indent.pop();");
    },
    visitDoctype: function(doctype) {
      if (doctype && (doctype.val || !this.doctype)) {
        this.setDoctype(doctype.val || "html");
      }
      if (this.doctype)
        this.buffer(this.doctype);
      this.hasCompiledDoctype = true;
    },
    visitMixin: function(mixin) {
      var name = "pug_mixins[";
      var args = mixin.args || "";
      var block = mixin.block;
      var attrs = mixin.attrs;
      var attrsBlocks = this.attributeBlocks(mixin.attributeBlocks);
      var pp = this.pp;
      var dynamic = mixin.name[0] === "#";
      var key = mixin.name;
      if (dynamic)
        this.dynamicMixins = true;
      name += (dynamic ? mixin.name.substr(2, mixin.name.length - 3) : '"' + mixin.name + '"') + "]";
      this.mixins[key] = this.mixins[key] || { used: false, instances: [] };
      if (mixin.call) {
        this.mixins[key].used = true;
        if (pp)
          this.buf.push("pug_indent.push(" + stringify(Array(this.indents + 1).join(pp)) + ");");
        if (block || attrs.length || attrsBlocks.length) {
          this.buf.push(name + ".call({");
          if (block) {
            this.buf.push("block: function(){");
            this.parentIndents++;
            var _indents = this.indents;
            this.indents = 0;
            this.visit(mixin.block, mixin);
            this.indents = _indents;
            this.parentIndents--;
            if (attrs.length || attrsBlocks.length) {
              this.buf.push("},");
            } else {
              this.buf.push("}");
            }
          }
          if (attrsBlocks.length) {
            if (attrs.length) {
              var val = this.attrs(attrs);
              attrsBlocks.unshift(val);
            }
            if (attrsBlocks.length > 1) {
              this.buf.push("attributes: " + this.runtime("merge") + "([" + attrsBlocks.join(",") + "])");
            } else {
              this.buf.push("attributes: " + attrsBlocks[0]);
            }
          } else if (attrs.length) {
            var val = this.attrs(attrs);
            this.buf.push("attributes: " + val);
          }
          if (args) {
            this.buf.push("}, " + args + ");");
          } else {
            this.buf.push("});");
          }
        } else {
          this.buf.push(name + "(" + args + ");");
        }
        if (pp)
          this.buf.push("pug_indent.pop();");
      } else {
        var mixin_start = this.buf.length;
        args = args ? args.split(",") : [];
        var rest;
        if (args.length && /^\.\.\./.test(args[args.length - 1].trim())) {
          rest = args.pop().trim().replace(/^\.\.\./, "");
        }
        this.buf.push(name + " = pug_interp = function(" + args.join(",") + "){");
        this.buf.push("var block = (this && this.block), attributes = (this && this.attributes) || {};");
        if (rest) {
          this.buf.push("var " + rest + " = [];");
          this.buf.push("for (pug_interp = " + args.length + "; pug_interp < arguments.length; pug_interp++) {");
          this.buf.push("  " + rest + ".push(arguments[pug_interp]);");
          this.buf.push("}");
        }
        this.parentIndents++;
        this.visit(block, mixin);
        this.parentIndents--;
        this.buf.push("};");
        var mixin_end = this.buf.length;
        this.mixins[key].instances.push({ start: mixin_start, end: mixin_end });
      }
    },
    visitTag: function(tag, interpolated) {
      this.indents++;
      var name = tag.name, pp = this.pp, self2 = this;
      function bufferName() {
        if (interpolated)
          self2.bufferExpression(tag.expr);
        else
          self2.buffer(name);
      }
      if (WHITE_SPACE_SENSITIVE_TAGS[tag.name] === true)
        this.escapePrettyMode = true;
      if (!this.hasCompiledTag) {
        if (!this.hasCompiledDoctype && name == "html") {
          this.visitDoctype();
        }
        this.hasCompiledTag = true;
      }
      if (pp && !tag.isInline)
        this.prettyIndent(0, true);
      if (tag.selfClosing || !this.xml && selfClosing[tag.name]) {
        this.buffer("<");
        bufferName();
        this.visitAttributes(tag.attrs, this.attributeBlocks(tag.attributeBlocks));
        if (this.terse && !tag.selfClosing) {
          this.buffer(">");
        } else {
          this.buffer("/>");
        }
        if (tag.code || tag.block && !(tag.block.type === "Block" && tag.block.nodes.length === 0) && tag.block.nodes.some(function(tag2) {
          return tag2.type !== "Text" || !/^\s*$/.test(tag2.val);
        })) {
          this.error(name + " is a self closing element: <" + name + "/> but contains nested content.", "SELF_CLOSING_CONTENT", tag);
        }
      } else {
        this.buffer("<");
        bufferName();
        this.visitAttributes(tag.attrs, this.attributeBlocks(tag.attributeBlocks));
        this.buffer(">");
        if (tag.code)
          this.visitCode(tag.code);
        this.visit(tag.block, tag);
        if (pp && !tag.isInline && WHITE_SPACE_SENSITIVE_TAGS[tag.name] !== true && !tagCanInline(tag))
          this.prettyIndent(0, true);
        this.buffer("</");
        bufferName();
        this.buffer(">");
      }
      if (WHITE_SPACE_SENSITIVE_TAGS[tag.name] === true)
        this.escapePrettyMode = false;
      this.indents--;
    },
    visitInterpolatedTag: function(tag) {
      return this.visitTag(tag, true);
    },
    visitText: function(text) {
      this.buffer(text.val);
    },
    visitComment: function(comment) {
      if (!comment.buffer)
        return;
      if (this.pp)
        this.prettyIndent(1, true);
      this.buffer("<!--" + comment.val + "-->");
    },
    visitYieldBlock: function(block) {
    },
    visitBlockComment: function(comment) {
      if (!comment.buffer)
        return;
      if (this.pp)
        this.prettyIndent(1, true);
      this.buffer("<!--" + (comment.val || ""));
      this.visit(comment.block, comment);
      if (this.pp)
        this.prettyIndent(1, true);
      this.buffer("-->");
    },
    visitCode: function(code) {
      if (code.buffer) {
        var val = code.val.trim();
        val = "null == (pug_interp = " + val + ') ? "" : pug_interp';
        if (code.mustEscape !== false)
          val = this.runtime("escape") + "(" + val + ")";
        this.bufferExpression(val);
      } else {
        this.buf.push(code.val);
      }
      if (code.block) {
        if (!code.buffer)
          this.buf.push("{");
        this.visit(code.block, code);
        if (!code.buffer)
          this.buf.push("}");
      }
    },
    visitConditional: function(cond) {
      var test = cond.test;
      this.buf.push("if (" + test + ") {");
      this.visit(cond.consequent, cond);
      this.buf.push("}");
      if (cond.alternate) {
        if (cond.alternate.type === "Conditional") {
          this.buf.push("else");
          this.visitConditional(cond.alternate);
        } else {
          this.buf.push("else {");
          this.visit(cond.alternate, cond);
          this.buf.push("}");
        }
      }
    },
    visitWhile: function(loop) {
      var test = loop.test;
      this.buf.push("while (" + test + ") {");
      this.visit(loop.block, loop);
      this.buf.push("}");
    },
    visitEach: function(each) {
      var indexVarName = each.key || "pug_index" + this.eachCount;
      this.eachCount++;
      this.buf.push("// iterate " + each.obj + "\n;(function(){\n  var $$obj = " + each.obj + ";\n  if ('number' == typeof $$obj.length) {");
      if (each.alternate) {
        this.buf.push("    if ($$obj.length) {");
      }
      this.buf.push("      for (var " + indexVarName + " = 0, $$l = $$obj.length; " + indexVarName + " < $$l; " + indexVarName + "++) {\n        var " + each.val + " = $$obj[" + indexVarName + "];");
      this.visit(each.block, each);
      this.buf.push("      }");
      if (each.alternate) {
        this.buf.push("    } else {");
        this.visit(each.alternate, each);
        this.buf.push("    }");
      }
      this.buf.push("  } else {\n    var $$l = 0;\n    for (var " + indexVarName + " in $$obj) {\n      $$l++;\n      var " + each.val + " = $$obj[" + indexVarName + "];");
      this.visit(each.block, each);
      this.buf.push("    }");
      if (each.alternate) {
        this.buf.push("    if ($$l === 0) {");
        this.visit(each.alternate, each);
        this.buf.push("    }");
      }
      this.buf.push("  }\n}).call(this);\n");
    },
    visitEachOf: function(each) {
      this.buf.push("// iterate " + each.obj + "\nfor (const " + each.val + " of " + each.obj + ") {\n");
      this.visit(each.block, each);
      this.buf.push("}\n");
    },
    visitAttributes: function(attrs, attributeBlocks) {
      if (attributeBlocks.length) {
        if (attrs.length) {
          var val = this.attrs(attrs);
          attributeBlocks.unshift(val);
        }
        if (attributeBlocks.length > 1) {
          this.bufferExpression(this.runtime("attrs") + "(" + this.runtime("merge") + "([" + attributeBlocks.join(",") + "]), " + stringify(this.terse) + ")");
        } else {
          this.bufferExpression(this.runtime("attrs") + "(" + attributeBlocks[0] + ", " + stringify(this.terse) + ")");
        }
      } else if (attrs.length) {
        this.attrs(attrs, true);
      }
    },
    attrs: function(attrs, buffer) {
      var res = compileAttrs(attrs, {
        terse: this.terse,
        format: buffer ? "html" : "object",
        runtime: this.runtime.bind(this)
      });
      if (buffer) {
        this.bufferExpression(res);
      }
      return res;
    },
    attributeBlocks: function(attributeBlocks) {
      return attributeBlocks && attributeBlocks.slice().map(function(attrBlock) {
        return attrBlock.val;
      });
    }
  };
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/.pnpm/pug@3.0.2/node_modules/pug-runtime/wrap.js
var require_wrap = __commonJS((exports, module) => {
  var wrap = function(template, templateName) {
    templateName = templateName || "template";
    return Function("pug", template + "\nreturn " + templateName + ";")(runtime);
  };
  var runtime = require_pug_runtime();
  module.exports = wrap;
});

// /Users/kodi/s/kakao/kakao.app/lib/node_modules/pug/lib/index.js
var require_lib9 = __commonJS((exports) => {
  var applyPlugins = function(value, options, plugins, name) {
    return plugins.reduce(function(value2, plugin) {
      return plugin[name] ? plugin[name](value2, options) : value2;
    }, value);
  };
  var findReplacementFunc = function(plugins, name) {
    var eligiblePlugins = plugins.filter(function(plugin) {
      return plugin[name];
    });
    if (eligiblePlugins.length > 1) {
      throw new Error("Two or more plugins all implement " + name + " method.");
    } else if (eligiblePlugins.length) {
      return eligiblePlugins[0][name].bind(eligiblePlugins[0]);
    }
    return null;
  };
  var compileBody = function(str, options) {
    var debug_sources = {};
    debug_sources[options.filename] = str;
    var dependencies = [];
    var plugins = options.plugins || [];
    var ast = load.string(str, {
      filename: options.filename,
      basedir: options.basedir,
      lex: function(str2, options2) {
        var lexOptions = {};
        Object.keys(options2).forEach(function(key) {
          lexOptions[key] = options2[key];
        });
        lexOptions.plugins = plugins.filter(function(plugin) {
          return !!plugin.lex;
        }).map(function(plugin) {
          return plugin.lex;
        });
        var contents = applyPlugins(str2, { filename: options2.filename }, plugins, "preLex");
        return applyPlugins(lex(contents, lexOptions), options2, plugins, "postLex");
      },
      parse: function(tokens, options2) {
        tokens = tokens.map(function(token) {
          if (token.type === "path" && path.extname(token.val) === "") {
            return {
              type: "path",
              loc: token.loc,
              val: token.val + ".pug"
            };
          }
          return token;
        });
        tokens = stripComments(tokens, options2);
        tokens = applyPlugins(tokens, options2, plugins, "preParse");
        var parseOptions = {};
        Object.keys(options2).forEach(function(key) {
          parseOptions[key] = options2[key];
        });
        parseOptions.plugins = plugins.filter(function(plugin) {
          return !!plugin.parse;
        }).map(function(plugin) {
          return plugin.parse;
        });
        return applyPlugins(applyPlugins(parse(tokens, parseOptions), options2, plugins, "postParse"), options2, plugins, "preLoad");
      },
      resolve: function(filename, source, loadOptions) {
        var replacementFunc = findReplacementFunc(plugins, "resolve");
        if (replacementFunc) {
          return replacementFunc(filename, source, options);
        }
        return load.resolve(filename, source, loadOptions);
      },
      read: function(filename, loadOptions) {
        dependencies.push(filename);
        var contents;
        var replacementFunc = findReplacementFunc(plugins, "read");
        if (replacementFunc) {
          contents = replacementFunc(filename, options);
        } else {
          contents = load.read(filename, loadOptions);
        }
        debug_sources[filename] = Buffer.isBuffer(contents) ? contents.toString("utf8") : contents;
        return contents;
      }
    });
    ast = applyPlugins(ast, options, plugins, "postLoad");
    ast = applyPlugins(ast, options, plugins, "preFilters");
    var filtersSet = {};
    Object.keys(exports.filters).forEach(function(key) {
      filtersSet[key] = exports.filters[key];
    });
    if (options.filters) {
      Object.keys(options.filters).forEach(function(key) {
        filtersSet[key] = options.filters[key];
      });
    }
    ast = filters.handleFilters(ast, filtersSet, options.filterOptions, options.filterAliases);
    ast = applyPlugins(ast, options, plugins, "postFilters");
    ast = applyPlugins(ast, options, plugins, "preLink");
    ast = link(ast);
    ast = applyPlugins(ast, options, plugins, "postLink");
    ast = applyPlugins(ast, options, plugins, "preCodeGen");
    var js = (findReplacementFunc(plugins, "generateCode") || generateCode)(ast, {
      pretty: options.pretty,
      compileDebug: options.compileDebug,
      doctype: options.doctype,
      inlineRuntimeFunctions: options.inlineRuntimeFunctions,
      globals: options.globals,
      self: options.self,
      includeSources: options.includeSources ? debug_sources : false,
      templateName: options.templateName
    });
    js = applyPlugins(js, options, plugins, "postCodeGen");
    if (options.debug) {
      console.error(`
Compiled Function:

\x1B[90m%s\x1B[0m`, js.replace(/^/gm, "  "));
    }
    return { body: js, dependencies };
  };
  var handleTemplateCache = function(options, str) {
    var key = options.filename;
    if (options.cache && exports.cache[key]) {
      return exports.cache[key];
    } else {
      if (str === undefined)
        str = fs.readFileSync(options.filename, "utf8");
      var templ = exports.compile(str, options);
      if (options.cache)
        exports.cache[key] = templ;
      return templ;
    }
  };
  /*!
   * Pug
   * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   */
  var fs = __require("fs");
  var path = __require("path");
  var lex = require_pug_lexer();
  var stripComments = require_pug_strip_comments();
  var parse = require_pug_parser();
  var load = require_pug_load();
  var filters = require_pug_filters();
  var link = require_pug_linker();
  var generateCode = require_pug_code_gen();
  var runtime = require_pug_runtime();
  var runtimeWrap = require_wrap();
  exports.name = "Pug";
  exports.runtime = runtime;
  exports.cache = {};
  exports.filters = {};
  exports.compile = function(str, options) {
    var options = options || {};
    str = String(str);
    var parsed = compileBody(str, {
      compileDebug: options.compileDebug !== false,
      filename: options.filename,
      basedir: options.basedir,
      pretty: options.pretty,
      doctype: options.doctype,
      inlineRuntimeFunctions: options.inlineRuntimeFunctions,
      globals: options.globals,
      self: options.self,
      includeSources: options.compileDebug === true,
      debug: options.debug,
      templateName: "template",
      filters: options.filters,
      filterOptions: options.filterOptions,
      filterAliases: options.filterAliases,
      plugins: options.plugins
    });
    var res = options.inlineRuntimeFunctions ? new Function("", parsed.body + ";return template;")() : runtimeWrap(parsed.body);
    res.dependencies = parsed.dependencies;
    return res;
  };
  exports.compileClientWithDependenciesTracked = function(str, options) {
    var options = options || {};
    str = String(str);
    var parsed = compileBody(str, {
      compileDebug: options.compileDebug,
      filename: options.filename,
      basedir: options.basedir,
      pretty: options.pretty,
      doctype: options.doctype,
      inlineRuntimeFunctions: options.inlineRuntimeFunctions !== false,
      globals: options.globals,
      self: options.self,
      includeSources: options.compileDebug,
      debug: options.debug,
      templateName: options.name || "template",
      filters: options.filters,
      filterOptions: options.filterOptions,
      filterAliases: options.filterAliases,
      plugins: options.plugins
    });
    var body = parsed.body;
    if (options.module) {
      if (options.inlineRuntimeFunctions === false) {
        body = 'var pug = require("pug-runtime");' + body;
      }
      body += " module.exports = " + (options.name || "template") + ";";
    }
    return { body, dependencies: parsed.dependencies };
  };
  exports.compileClient = function(str, options) {
    return exports.compileClientWithDependenciesTracked(str, options).body;
  };
  exports.compileFile = function(path2, options) {
    options = options || {};
    options.filename = path2;
    return handleTemplateCache(options);
  };
  exports.render = function(str, options, fn) {
    if (typeof options == "function") {
      fn = options, options = undefined;
    }
    if (typeof fn === "function") {
      var res;
      try {
        res = exports.render(str, options);
      } catch (ex) {
        return fn(ex);
      }
      return fn(null, res);
    }
    options = options || {};
    if (options.cache && !options.filename) {
      throw new Error('the "filename" option is required for caching');
    }
    return handleTemplateCache(options, str)(options);
  };
  exports.renderFile = function(path2, options, fn) {
    if (typeof options == "function") {
      fn = options, options = undefined;
    }
    if (typeof fn === "function") {
      var res;
      try {
        res = exports.renderFile(path2, options);
      } catch (ex) {
        return fn(ex);
      }
      return fn(null, res);
    }
    options = options || {};
    options.filename = path2;
    return handleTemplateCache(options)(options);
  };
  exports.compileFileClient = function(path2, options) {
    var key = path2 + ":client";
    options = options || {};
    options.filename = path2;
    if (options.cache && exports.cache[key]) {
      return exports.cache[key];
    }
    var str = fs.readFileSync(options.filename, "utf8");
    var out = exports.compileClient(str, options);
    if (options.cache)
      exports.cache[key] = out;
    return out;
  };
  exports.__express = function(path2, options, fn) {
    if (options.compileDebug == undefined && false) {
    }
    exports.renderFile(path2, options, fn);
  };
});

// index.js
var stylus = require_stylus2();
var pug = require_lib9();
var $stylus = (s) => {
  return stylus.render(s);
};
var $pug = (s) => {
  return pug.render(s, { pretty: true });
};
export {
  $stylus as stylus,
  $pug as pug
};
