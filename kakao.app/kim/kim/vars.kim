###
    ███   ███   ███████   ████████    ███████
    ███   ███  ███   ███  ███   ███  ███     
     ███ ███   █████████  ███████    ███████ 
       ███     ███   ███  ███   ███       ███
        █      ███   ███  ███   ███  ███████ 

    inserts var keywords for first assignment 
    operations in scope
###

use pars

class Scoper
    
    vars   : seq[Table[string,bool]]
    lang   : string

    @: ◇string lang -> @lang = lang
    $: ➜string -> $@vars

    exp    : ◇Node body ◇int i ◇Node e ->
    scope  : ◇Node body ➜Node ->
    branch : ◇Node body -> discard @scope(body)
    
    # 00000000  000   000  00000000   
    # 000        000 000   000   000  
    # 0000000     00000    00000000   
    # 000        000 000   000        
    # 00000000  000   000  000        
        
    exp: ◇Node body ◇int i ◇Node e ->
        
        ⮐  if e == nil
        add = ◇string name -> @vars[^1][name] = true
            
        insert = ◇string name ◇Node expr ->
            for map in @vars
                ⮐  if map.hasKey name
                
            body.expressions[i] = Node(token:Token(tok:◂let str:"var" line:expr.token.line) kind:●let, let_expr:expr)
            add name
        
        switch e.kind 
            ●operation
                if e.operand_right.kind == ●func
                    if @lang == "lua" and e.operand_right.func_signature
                        @vars.push initTable[string,bool]()
                        for a in e.operand_right.func_signature.sig_args.list_values
                            switch a.kind
                                ●arg     ➜ add(a.arg_name.token.str)
                                ●literal ➜ add(a.token.str)
                                         ➜ discard
                        body = e.operand_right.func_body
                        for i e in body.expressions
                            @exp body i e 
                        @vars.pops()
                    else
                        @branch e.operand_right.func_body
                elif e.token.tok == ◂assign
                    lhs = e.operand_left
                    switch lhs.kind
                        ●literal
                            insert lhs.token.str e
                        ●list
                            for lv in lhs.list_values
                                if lv.kind != ●literal
                                    ⮐  
                            insert lhs.token.str e
                            for item in lhs.list_values
                                add item.token.str
                        ➜ discard
                    # else
                    #     log "vars lhs #{lhs}"
            ●var
                insert e.var_name.token.str e
            ●let
                if e.let_expr.kind == ●operation and e.let_expr.token.tok == ◂assign
                    add e.let_expr.operand_left.token.str
                elif e.let_expr.kind == ●var
                    add e.let_expr.var_name.token.str
                else
                    log "unhandled let type #{e} #{e.let_expr}"
            ●if
                for condThen in e.condThens
                    @branch condThen.then_branch
                @branch e.else_branch
            ●for
                @branch e.for_body
            ●while
                @branch e.while_body
            ●switch
                for switchCase in e.switch_cases
                    @branch switchCase.case_then
                @branch e.switch_default
            ●testSuite
            ●testSection
                @branch e.test_block
            ●semicolon
                @branch e
            ●func
                @branch e.func_body
            ●return
                @exp body i e.return_value
                
            ➜ discard
                        
    #  0000000   0000000   0000000   00000000   00000000  
    # 000       000       000   000  000   000  000       
    # 0000000   000       000   000  00000000   0000000   
    #      000  000       000   000  000        000       
    # 0000000    0000000   0000000   000        00000000  
        
    scope: ◇Node body ➜Node ->
        
        if body == nil or body.kind notin {●block ●semicolon} or body.expressions.len == 0
            ⮐  body
    
        @vars.push initTable[string,bool]()
    
        for i e in body.expressions
            @exp body i e 
    
        @vars.pops()
        body
    
variables* = ◇Node body ◇string lang ➜Node ->

    @Scoper(lang).scope body 
