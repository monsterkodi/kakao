
###
00     00   0000000   00000000    0000000   0000000  00000000 
000   000  000   000  000   000  000       000       000   000
000000000  000000000  00000000   0000000   000       0000000  
000 0 000  000   000  000             000  000       000   000
000   000  000   000  000        0000000    0000000  000   000
###

use ../util ◆ prof syntax color util
use ..      ◆ theme 
use         ◆ cells

{floor, pow} = Math

function mapscr

    @: screen @state ->
        
        @cells = new cells screen
        
        screen.t.on 'preResize' @onPreResize
       
    init: x y w h -> @cells.init x y w h
        
    # 00000000   00000000   0000000  000  0000000  00000000  
    # 000   000  000       000       000     000   000       
    # 0000000    0000000   0000000   000    000    0000000   
    # 000   000  000            000  000   000     000       
    # 000   000  00000000  0000000   000  0000000  00000000  
    
    onPreResize: => 
        
        @cells.screen.t.write "\x1b_Gq=1,a=d,d=A\x1b\\"
                
    onResize: ->
        
        t = @cells.screen.t
        
        ⮐ if empty t.pixels
        
        clearTimeout @reallocId
        @reallocId = setTimeout @reallocBuffer 10
        
    # 0000000    000   000  00000000  00000000  00000000  00000000   
    # 000   000  000   000  000       000       000       000   000  
    # 0000000    000   000  000000    000000    0000000   0000000    
    # 000   000  000   000  000       000       000       000   000  
    # 0000000     0000000   000       000       00000000  000   000  
    
    reallocBuffer: =>
        
        prof.start 'mapscr'
        
        t = @cells.screen.t
        
        [w h] = [@cells.cols * t.cellsz[0] @cells.rows * t.cellsz[1]]
        
        data = Buffer.alloc w*h*3
        prof.time 'mapscr' 'alloc'
        
        for y in 0...min(h @state.s.lines.length*4)
            li = parseInt y/4
            line = @state.s.lines[li]
            for x in 0...min(w line.length*2)
                if x == 0
                    data[(y*w+x)*3+0] = 55 
                    data[(y*w+x)*3+1] = 55 
                    data[(y*w+x)*3+2] = 55 
                    
                xi = parseInt x/2                
                ch = line[xi]
                
                if valid ch and ch != ' '
                
                    clss = @state.syntax.getClass xi li
                    
                    if 'header' in clss
                        if 'triple' in clss
                            rgb = [27 207 14]
                        else
                            rgb = [9 140 0]
                    else
                        f = 0.7
                        rgb = color.rgb @state.syntax.getColor(xi li)
                        rgb = rgb.map (v) -> clamp(0 255 parseInt(f*v))
                    
                    [r g b] = rgb
                    
                    data[(y*w+x)*3+0] = r
                    data[(y*w+x)*3+1] = g
                    data[(y*w+x)*3+2] = b
                
        prof.time 'mapscr' 'fill'        
        
        # q=1  don't send OK q=2 don't send OK and failure
        # i=n  image id 
        # p=n  placement id
        # f=24 3 bytes per pixel
        # s=n  width v=n  height
        # m=1  image chunk not larger than 4096 bytes
        # m=0  last chunk of image
        # a=p  placement action
                
        if data.length > 4096 # and 'kitty' in process.env.TERM
            base64 = data[0...4096].toString 'base64'
            t.write "\x1b_Gq=1,i=666,p=777,f=24,s=#{w},v=#{h},m=1;#{base64}\x1b\\"
            chunks = Math.ceil data.length / 4096
            for i in 1...chunks
                base64 = data[i*4096...Math.min((i+1)*4096, data.length)].toString 'base64'
                t.write "\x1b_Gq=1,m=#{(i == chunks - 1) ? 0 : 1};#{base64}\x1b\\"
        else
            base64 = data.toString 'base64'
            t.write "\x1b_Gq=1,i=666,p=777,f=24,s=#{w},v=#{h};#{base64}\x1b\\"
            
        prof.end 'mapscr' 'send'
        
        @draw()
                        
    # 0000000    00000000    0000000   000   000  
    # 000   000  000   000  000   000  000 0 000  
    # 000   000  0000000    000000000  000000000  
    # 000   000  000   000  000   000  000   000  
    # 0000000    000   000  000   000  00     00  
    
    draw: ->

        t = @cells.screen.t
        
        ⮐ if empty t.pixels
        
        t.setCursor @cells.x @cells.y
        t.write "\x1b_Gq=1,a=p,i=666,p=777\x1b\\"
        @
        
    #  0000000   0000000  00000000    0000000   000      000      000000000   0000000   
    # 000       000       000   000  000   000  000      000         000     000   000  
    # 0000000   000       0000000    000   000  000      000         000     000   000  
    #      000  000       000   000  000   000  000      000         000     000   000  
    # 0000000    0000000  000   000   0000000   0000000  0000000     000      0000000   
    
    scrollTo: row =>
        
        view = @state.s.view.asMutable()
        
        view[1] = parseInt floor(row * (@state.s.lines.length - @cells.rows + 1)  / (@cells.rows-1))
        
        maxY = @state.s.lines.length - @cells.rows
        
        view[1] = min maxY view[1] if maxY > 0
        view[1] = max 0 view[1]
        
        @state.setView view
        
        true

    scrollToPixel: pixel =>
        
        rof = pixel[1]/@cells.screen.t.cellsz[1]
        
        lf pixel rof
        
        view = @state.s.view.asMutable()
        
        view[1] = parseInt floor(rof * (@state.s.lines.length - @cells.rows + 1)  / (@cells.rows-1))
        
        maxY = @state.s.lines.length - @cells.rows
        
        view[1] = min maxY view[1] if maxY > 0
        view[1] = max 0 view[1]
        
        @state.setView view
        
        true
        
    rowAtPixelY: py =>
        
        parseInt py/@cells.screen.t.cellsz[1]
        
    # 00     00   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000       000       
    # 000000000  000   000  000   000  0000000   0000000   
    # 000 0 000  000   000  000   000       000  000       
    # 000   000   0000000    0000000   0000000   00000000  
    
    onMouse: type sx sy event =>
        
        [col row] = @cells.posForScreen sx sy
        
        switch type
            
            'press'
            
                if @cells.isInsideScreen sx sy
                    @doDrag = true
                    ⮐ @scrollToPixel event.pixel
                    
            'drag'
            
                if @doDrag
                    ⮐ @scrollToPixel event.pixel
                
            'release'
            
                if @doDrag
                    delete @doDrag 
                    @hover = @cells.isInsideScreen sx sy
                    ⮐ true
            
            'move'
            
                @hover = @cells.isInsideScreen sx sy
                    
        false
        
export mapscr
