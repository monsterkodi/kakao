###
00     00   0000000   000000000  00000000   000  000   000
000   000  000   000     000     000   000  000   000 000 
000000000  000000000     000     0000000    000    00000  
000 0 000  000   000     000     000   000  000   000 000 
000   000  000   000     000     000   000  000  000   000
###

use ../kxk ▪ fade randRange randInt randIntRange

function matrix

    @: ->

        @PLANT             = 0
        @EGG               = 1
        @CRITTER           = 2
        @TUBE              = 3
        @NUM_TYPES         = 4
        
        @ws = 40
                
        @eggFadeTime       = 6.0
        @critMoveTime      = 4.0 
        @critDieTime       = 2.3
        
        @numLeaves         = 7
        @critterMaxAge     = 3000
        @critterEggTime    = 500
        @eggMaxAge         = 50
        @leafMaxAge        = 100
        @critterEatTime    = 90
        @critterStarveTime = 50
        
        @start()
        
    #  0000000  000000000   0000000   00000000   000000000  
    # 000          000     000   000  000   000     000     
    # 0000000      000     000000000  0000000       000     
    #      000     000     000   000  000   000     000     
    # 0000000      000     000   000  000   000     000     
    
    start: =>
        
        @grid  = []
        @types = []
        
        for t in 0...@NUM_TYPES
            @types.push []
            
        @eggs     = @types[@EGG]
        @critters = @types[@CRITTER]
        @plants   = @types[@PLANT]
        @tubes    = @types[@TUBE]
        
        for x in 0...@ws
            column = []
            for y in 0...@ws
                column.push null
            @grid.push column
            
        @addEgg @ws/2 @ws/2
        
        for x in 0..@ws/3
            for y in 0..@ws/3
                @addPlant x*3 y*3
        
    #  0000000   0000000    000   000   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000   000  0000  000  000       000       
    # 000000000  000   000   000 000   000000000  000 0 000  000       0000000   
    # 000   000  000   000     000     000   000  000  0000  000       000       
    # 000   000  0000000        0      000   000  000   000   0000000  00000000  
    
    advance: sec =>
        
        for e in @eggs
            
            e.age += sec
            
            if e.age > @eggMaxAge and e.age-sec <= @eggMaxAge
                @addCritter e.x, e.y
                
            if e.age > @eggMaxAge+@eggFadeTime
                @delAt [e.x, e.y]
                
        for c in @critters
            
            c.age += sec
            c.eat -= sec
                        
            if c.age > @critterMaxAge or c.eat < -@critterStarveTime
                c.df ?= 0
                c.df += sec / @critDieTime
                if c.df > 1
                    @delAt [c.x, c.y]
                continue
                
            if c.eat < 0
                if l = @neighborLeaf c
                    c.eat = @critterEatTime
                    l.age = 0
                continue
            
            if Math.floor(c.age / @critterEggTime) > c.eggs
                if n = @emptyNeighbor c
                    @addEgg n.x, n.y
                    c.eggs++

            if c.sf > 0
                c.sf -= sec / @critMoveTime
                c.sf  = max 0 c.sf
                c.tx = fade c.x, c.sx, c.sf
                c.ty = fade c.y, c.sy, c.sf
                continue
                          
            if randInt(3) == 0 or c.age < 1
                c.sx = c.x
                c.sy = c.y
                c.sf = 0.5
                continue
                
            n = @randomOffset c
            if @isInWorld(n) and @isEmpty n
                c.sx = c.x
                c.sy = c.y
                c.sf = 1
                @grid[c.x][c.y] = null
                c.x = n[0]
                c.y = n[1]
                @grid[c.x][c.y] = c
                
        for p in @plants
                        
            for l in p.leaves
                
                l.age += sec
                
    #  0000000   0000000    0000000      
    # 000   000  000   000  000   000    
    # 000000000  000   000  000   000    
    # 000   000  000   000  000   000    
    # 000   000  0000000    0000000      
    
    addObject: x y o =>
        
        @delAt [x, y]
    
        o.x = parseInt x
        o.y = parseInt y
        
        @grid[o.x][o.y] = o
        @types[o.type].push o
                
    addEgg:     x y     => @addObject x, y, type:@EGG,     age:0
    addCritter: x y     => @addObject x, y, type:@CRITTER, age:0, sx:0, sy:0, sf:0, eggs:0, eat:@critterEatTime
    addTube:    x y idx => @addObject x, y, type:@TUBE,    idx:idx
    addPlant:   x y     => 
    
        leaves = [] 
        for l in 0...@numLeaves
            leaves.push age:l*@leafMaxAge/@numLeaves
        
        @addObject x, y, type:@PLANT, leaves:leaves

    # 0000000    00000000  000      
    # 000   000  000       000      
    # 000   000  0000000   000      
    # 000   000  000       000      
    # 0000000    00000000  0000000  
    
    delAt: p =>
        
        if o = @objectAt p
            @types[o.type].splice @types[o.type].indexOf(o), 1
            @grid[o.x][o.y] = null

    # 00000000    0000000    0000000    
    # 000   000  000   000  000         
    # 00000000   000   000  0000000     
    # 000        000   000       000    
    # 000         0000000   0000000     
    
    objectAt:  p => if @isInWorld p ➜ ⮐ @grid[p[0]][p[1]]
    isInWorld: p => p[0] >= 0 and p[1] >= 0 and p[0] < @ws and p[1] < @ws
    isEmpty:   p => not @objectAt p
                
    buildingAt: p =>
        
        if o = @objectAt p
            ⮐ o.type in [@PLANT]
        false
        
    emptyNeighbor: o =>
        
        en = []
        
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                c = [o.x+x, o.y+y]
                continue if not @isInWorld c
                if @isEmpty c
                    en.push x:c[0], y:c[1]
                    
        if en.length
            ⮐ en[randInt(en.length)]
        null
    
    validNeighbors: o =>
        
        vn = []
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                c = [o.x+x, o.y+y]
                if @isInWorld c
                    vn.push c
        vn
        
    neighbors: o =>
        
        n = [] 
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                n.push [o.x+x, o.y+y]
        n
        
    objectOfTypeAt: type p =>
        
        if o = @objectAt p
            ⮐ null if o.type != type
        o
        
    plantAt: p => @objectOfTypeAt @PLANT, p
    tubeAt:  p => @objectOfTypeAt @TUBE, p
                
    leafToEatAt: p =>
        
        if pl = @plantAt p
            for l in pl.leaves
                if l.age > @leafMaxAge
                    ⮐ l
        null
                        
    neighborLeaf: o =>
        
        nl = []
        for vn in @neighbors o
            if l = @leafToEatAt vn
                nl.push l
                    
        if nl.length
            ⮐ nl[randInt(nl.length)]
        null
        
    randomOffset: c =>
        
        o = [[-1 1], [0, 1], [1, 1], [-1 0], [1 0], [-1 -1], [0, -1], [1, -1]][randInt 8]
        [c.x+o[0], c.y+o[1]]

    randomOffsetCross: c =>
        
        o = [[0, 1], [-1 0], [1 0], [0, -1]][randInt 4]
        [c.x+o[0], c.y+o[1]]
            
export matrix
