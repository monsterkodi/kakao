###
 0000000  000   000   0000000   000   0000000  00000000   0000000
000       000   000  000   000  000  000       000       000
000       000000000  000   000  000  000       0000000   0000000
000       000   000  000   000  000  000       000            000
 0000000  000   000   0000000   000   0000000  00000000  0000000
###

use ../../kxk ▪ kstr kseg slash krzl post
use ../util   ◆ color theme util
use ../edit   ◆ editor 

function choices extends editor

    @: screen name features=[] ->

        super screen name ['scrllr'].concat(features)
        
        @items = []
        @focusable = true
        @frontRoundOffset = -1
        @hoverIndex = -1
        @fuzzied = @items
        @filterText = ''
        
    set: @items @key ->
        
        @items ?= []
        @fuzzied = @items
        @filterText = ''
        
        lines = @key ? @items.map(@extract) : @items
        
        @state.loadLines lines
        
    # 0000000    00000000    0000000   000   000  
    # 000   000  000   000  000   000  000 0 000  
    # 000   000  0000000    000000000  000000000  
    # 000   000  000   000  000   000  000   000  
    # 0000000    000   000  000   000  00     00  
    
    drawCursors: ->
        
    drawSelections: lines ->
        
        ⮐ if empty @state.s.selections
        
        bg = theme.choices_current
        
        if not @cells.screen.t.hasFocus
            bg = color.darken bg
        
        selection = @state.s.selections[0]
                
        for li in selection[1]..selection[3]
            
            y = li-@state.s.view[1]
            
            break if y >= @cells.rows
            
            if li == selection[1]
                xs = selection[0]
            else
                xs = 0
                
            if li == selection[3]
                xe = selection[2]
            else
                xe = kseg.width lines[li]
            
            xs = max 0 xs+@frontRoundOffset
            
            for x in xs...xe
                @cells.set_bg x-@state.s.view[0] y bg

            @cells.set_unsafe -@state.s.view[0]+@frontRoundOffset y '' bg theme.choices_bg
            @cells.set x-@state.s.view[0] y '' bg theme.choices_bg

    numChoices:  -> @items.length
    numFiltered: -> @fuzzied.length

    current:     -> @fuzzied[@state.mainCursor()[1]]
    choiceAtRow: row -> @fuzzied[row]
    
    hasNext:    -> @state.mainCursor()[1] < @numFiltered()-1
    hasPrev:    -> @state.mainCursor()[1] > 0
    
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    select: row -> 
        
        ⮐ if row < 0 or row >= @state.s.lines.length
    
        @state.setSelections [util.rangeOfLine(@state.allLines() row)]
        @emit 'select' @choiceAtRow(row)
        
    selectFirst: -> @select 0
    
    moveSelection: dir ->
        
        switch dir
            'down' ➜ @selectNext()
            'up'   ➜ @selectPrev() 
        
    selectNext: -> 
        
        if @hasNext()
            @state.selectNextLine() 
            @emitSelectionChange()
        
    selectPrev: -> 
        
        if @hasPrev()
            @state.selectPrevLine()
            @emitSelectionChange()
            
    emitSelectionChange: ->
            
        @grabFocus() if @focusable
        @frontCursor() 
        @emit 'select' @choiceAtRow(@state.allSelections()[0][1])
        
    frontCursor: -> 
        
        @state.setMainCursor 0 @state.allSelections()[0][1]
    
    # 000   000  00000000  000   0000000   000   000  000000000  
    # 000 0 000  000       000  000        000   000     000     
    # 000000000  0000000   000  000  0000  000000000     000     
    # 000   000  000       000  000   000  000   000     000     
    # 00     00  00000000  000   0000000   000   000     000     
    
    extract: item => @key and item is obj ? item[@key] : kseg.str(item)        
    
    weight: item text =>

        itemText = @extract item
        p = slash.parse itemText
        
        matchOrLevenshtein = t -> 
            idx = t.indexOf text
            if idx < 0
                idx = t.length + kstr.levensthein(t text)
            idx

        w  = @items.indexOf(item)               # try to keep order of original items
        w += 10 * matchOrLevenshtein(p.name)    # high focus on file name
        w += 5  * matchOrLevenshtein(p.dir)     # lesser focus on dir
        w += valid p.ext ? (0.1 * matchOrLevenshtein(p.ext)) : 4 # low weight for extensions
                                                                 # has the side-effect of moving directories down
        w

    # 00000000  000  000      000000000  00000000  00000000   
    # 000       000  000         000     000       000   000  
    # 000000    000  000         000     0000000   0000000    
    # 000       000  000         000     000       000   000  
    # 000       000  0000000     000     00000000  000   000  
    
    filter: text =>
        
        # lf 'choices.filter' text @items

        ⮐ if empty @items

        ⮐ if text == @filterText
        
        ⮐ @set(@items @key) if empty text
            
        @filterText = text
            
        fuzz = new krzl values:@items extract:@extract
        
        @fuzzied = fuzz.filter text

        @fuzzied.sort (a b) => @weight(a text) - @weight(b text)
        
        lines = @fuzzied.map @extract

        lines = [''] if empty lines
        
        # lf 'choices.filter lines' lines

        @state.loadLines lines

    # 00     00   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000       000       
    # 000000000  000   000  000   000  0000000   0000000   
    # 000 0 000  000   000  000   000       000  000       
    # 000   000   0000000    0000000   0000000   00000000  
    
    hoverChoiceAtIndex: index => 
    
        ⮐ if @hoverIndex == index
        
        @hoverIndex = index
        @select @hoverIndex
        @frontCursor()
        post.emit 'pointer' 'pointer'
        
    unhover: =>
    
        @hoverIndex = -1
        @state.clearHighlights()
        post.emit 'pointer' 'default'
        
    clickChoiceAtIndex: index =>
        
        @hoverIndex = -1  
        @emit 'action' 'click' @fuzzied[index]
        
    onMouse: event =>
    
        [col row] = @cells.posForEvent event
        
        if @cells.isInsideEvent(event) and @state.isValidLineIndex(row) and kseg.width(@state.s.lines[row]) >= col
            
            switch event.type
                
                'press'   ➜ ⮐ @clickChoiceAtIndex row + @state.s.view[1] 
                'move'    ➜ ⮐ @hoverChoiceAtIndex row + @state.s.view[1]
                'release' ➜ ⮐ @hoverChoiceAtIndex row + @state.s.view[1]
                
            ⮐ true
        else
            @unhover()
    
        super event

    # 000   000  00000000  000   000  
    # 000  000   000        000 000   
    # 0000000    0000000     00000    
    # 000  000   000          000     
    # 000   000  00000000     000     
    
    onKey: key event =>
        
        ⮐ if not @hasFocus()
            
        switch event.combo
            'right'  
            'left' 
            'delete'
            'space'  
            'return' ➜ @emit 'action' event.combo @current() 
            'up' 
            'down'   ➜ @moveSelection event.combo
            
        # not calling super here effectively disables all text-editing
        true
         
global.choices_class = choices # hack to prevent import recursion
export choices
