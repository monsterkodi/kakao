###
 0000000  000   000   0000000   000   0000000  00000000   0000000
000       000   000  000   000  000  000       000       000
000       000000000  000   000  000  000       0000000   0000000
000       000   000  000   000  000  000       000            000
 0000000  000   000   0000000   000   0000000  00000000  0000000
###

use ../../kxk ▪ kstr kseg slash krzl post
use ../util   ◆ theme util
use ../edit   ◆ editor 

function choices extends editor

    @: screen name features=[] ->

        super screen name ['scrllr'].concat(features)
        
        @items = []
        @hoverIndex = -1
        @fuzzied = @items
        @filterText = ''
        
    set: @items @key ->
        
        @items ?= []
        @fuzzied = @items
        @filterText = ''
        
        lines = @key ? @items.map(@extract) : @items
        
        @state.loadLines lines

    numChoices:  -> @items.length
    numFiltered: -> @fuzzied.length

    current:     -> @fuzzied[@state.mainCursor()[1]]
    choiceAtRow: row -> @fuzzied[row]
    
    hasNext:    -> @state.mainCursor()[1] < @numFiltered()-1
    hasPrev:    -> @state.mainCursor()[1] > 0
    
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    select: row -> 
        
        ⮐ if row < 0 or row >= @state.s.lines.length
    
        @state.setSelections [util.rangeOfLine(@state.allLines() row)]
        @emit 'select' @choiceAtRow(row)
    
    moveSelection: dir ->
        
        switch dir
            'down' ➜ @selectNext()
            'up'   ➜ @selectPrev() 
        
    selectNext: -> 
        
        if @hasNext()
            @state.selectNextLine() 
            @emitSelectionChange()
        
    selectPrev: -> 
        
        if @hasPrev()
            @state.selectPrevLine()
            @emitSelectionChange()
            
    emitSelectionChange: ->
            
        @grabFocus()
        @frontCursor() 
        @emit 'select' @choiceAtRow(@state.allSelections()[0][1])
        
    frontCursor: -> 
        
        @state.setMainCursor 0 @state.mainCursor()[1]
    
    # 000   000  00000000  000   0000000   000   000  000000000  
    # 000 0 000  000       000  000        000   000     000     
    # 000000000  0000000   000  000  0000  000000000     000     
    # 000   000  000       000  000   000  000   000     000     
    # 00     00  00000000  000   0000000   000   000     000     
    
    extract: item => @key and item is obj ? item[@key] : kseg.str(item)        
    
    weight: item text =>

        itemText = @extract item
        p = slash.parse itemText
        
        matchOrLevenshtein = t -> 
            idx = t.indexOf text
            if idx < 0
                idx = t.length + kstr.levensthein(t text)
            idx

        w  = @items.indexOf(item)               # try to keep order of original items
        w += 10 * matchOrLevenshtein(p.name)    # high focus on file name
        w += 5  * matchOrLevenshtein(p.dir)     # lesser focus on dir
        w += valid p.ext ? (0.1 * matchOrLevenshtein(p.ext)) : 4 # low weight for extensions
                                                                 # has the side-effect of moving directories down
        w

    # 00000000  000  000      000000000  00000000  00000000   
    # 000       000  000         000     000       000   000  
    # 000000    000  000         000     0000000   0000000    
    # 000       000  000         000     000       000   000  
    # 000       000  0000000     000     00000000  000   000  
    
    filter: text =>
        
        # lf 'choices.filter' text @items

        ⮐ if empty @items

        ⮐ if text == @filterText
        
        ⮐ @set(@items @key) if empty text
            
        @filterText = text
            
        fuzz = new krzl values:@items extract:@extract
        
        @fuzzied = fuzz.filter text

        @fuzzied.sort (a b) => @weight(a text) - @weight(b text)
        
        lines = @fuzzied.map @extract

        lines = [''] if empty lines
        
        # lf 'choices.filter lines' lines

        @state.loadLines lines

    # 00     00   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000       000       
    # 000000000  000   000  000   000  0000000   0000000   
    # 000 0 000  000   000  000   000       000  000       
    # 000   000   0000000    0000000   0000000   00000000  
    
    hoverChoiceAtRow: row => 
    
        ⮐ if @hoverIndex == row
        
        @hoverIndex = row
        @select @hoverIndex
        post.emit 'pointer' 'pointer'
        
    unhover: =>
    
        @hoverIndex = -1
        @state.clearHighlights()
        post.emit 'pointer' 'default'
        
    clickChoiceAtRow: row =>
        
        @hoverIndex = -1  
        @emit 'action' 'click' @choiceAtRow(row)
        
    onMouse: event =>
    
        [col row] = @cells.posForEvent event
        
        if @cells.isInsideEvent event
            
            switch event.type
                
                'press'   ➜ ⮐ @clickChoiceAtRow row 
                'move'    ➜ ⮐ @hoverChoiceAtRow row
                'release' ➜ ⮐ @hoverChoiceAtRow row
                
            lf "mouse #{@name} #{col} #{row} #{event.type}" 
            
            ⮐ true
        else
            @unhover()
    
        super event

    # 000   000  00000000  000   000  
    # 000  000   000        000 000   
    # 0000000    0000000     00000    
    # 000  000   000          000     
    # 000   000  00000000     000     
    
    onKey: key event =>
        
        ⮐ if not @hasFocus()
            
        switch event.combo
            'right'  
            'left' 
            'delete'
            'space'  
            'return' ➜ @emit 'action' event.combo @current() 
            'up' 
            'down'   ➜ @moveSelection event.combo
            
        # not calling super here effectively disables all text-editing
        true
                        
export choices
