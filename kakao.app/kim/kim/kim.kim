# ███   ███  ███  ██     ██
# ███  ███   ███  ███   ███
# ███████    ███  █████████
# ███  ███   ███  ███ █ ███
# ███   ███  ███  ███   ███

use std ▪ os osproc parseopt random streams asyncdispatch asyncfile posix
use kommon rndr greet

params    ◇ seq[string]
files     ◇ seq[string]
optParser = initOptParser()
outdir    = ""
tests     = false
verbose   = false

testFiles = walkDir(getAppFilename().splitFile()[0] / ".." / "nim" / "test").toSeq().map(◇tuple r ➜string -> r.path)
    
randomize()

verb = ◇string msg -> 
    if verbose ➜ log msg 

#  ███████   ████████  █████████         ███████   ████████   █████████
# ███        ███          ███           ███   ███  ███   ███     ███   
# ███  ████  ███████      ███           ███   ███  ████████      ███   
# ███   ███  ███          ███           ███   ███  ███           ███   
#  ███████   ████████     ███            ███████   ███           ███   

for kind key val in optParser.getopt()
    switch kind
        cmdArgument
            params.add key
            files.add(key)
        cmdLongOption cmdShortOption
            params.add '-' & key
            switch key
                "test" "t"
                    tests = true
                "verbose" "v"
                    verbose = true
                "outdir" "o"
                    outdir = val
                "help" "h"
                    log "usage: " getAppFilename().extractFilename() " [options] [file.kim ...]"
                    log ""
                    log "      transpiles kim files to nim"
                    log "      watches cwd if no files are given"
                    log ""
                    log "options:"
                    log "  -o --outdir:DIR  output directory"
                    log "     --test        run tests"
                    log "  -v --verbose     verbose output"
                    quit(1)
                ➜ 
                    log "unknown option!: " key
                    quit(1)
        cmdEnd
            discard
                        
# ████████   ████████   ███████  █████████   ███████   ████████   █████████
# ███   ███  ███       ███          ███     ███   ███  ███   ███     ███   
# ███████    ███████   ███████      ███     █████████  ███████       ███   
# ███   ███  ███            ███     ███     ███   ███  ███   ███     ███   
# ███   ███  ████████  ███████      ███     ███   ███  ███   ███     ███   
            
when defined(posix)

    use posix
    
    restart = ->
        let args = allocCStringArray(@[getAppFilename()] & params)
        discard execv(getAppFilename().cstring() args)
        quit(1) # only reaches here if execve fails
    
# ███       ███████    ███████   ████████  ███  ███      ████████
# ███      ███   ███  ███        ███       ███  ███      ███     
# ███      ███   ███  ███  ████  ██████    ███  ███      ███████ 
# ███      ███   ███  ███   ███  ███       ███  ███      ███     
# ███████   ███████    ███████   ███       ███  ███████  ████████

logFile = ◇string f prefix="" ->

    let (dir name ext) = f.relativePath(getCurrentDir()).splitFile()
    d = if dir.len ➜ dir & "/" ➜ ""
    icon = if ext == ".kim" ➜ "  " ➜ "  "
    color = if ext == ".kim" ➜ fgGreen ➜ fgMagenta

    styledEcho color prefix styleDim icon resetStyle
               color styleBright d styleBright name resetStyle
        
#  ███████   ███████   ██     ██  ████████   ███  ███      ████████
# ███       ███   ███  ███   ███  ███   ███  ███  ███      ███     
# ███       ███   ███  █████████  ████████   ███  ███      ███████ 
# ███       ███   ███  ███ █ ███  ███        ███  ███      ███     
#  ███████   ███████   ███   ███  ███        ███  ███████  ████████

compile = ◇string file outDir="bin" ➜bool ->

    profileScope 'comp'
    cmd = "nim c --outDir=#{outdir} #{file}"
    # let cmd = &"nim c --outDir={outdir} --stackTrace:on --lineTrace:on {file}"
    let (output exitCode) = execCmdEx(cmd)
        
    if exitCode != 0
        styledEcho fgRed "✘ " $cmd
        log output
        false
    else
        if verbose
            styledEcho fgGreen "✔ " fgWhite cmd
        true
        
# █████████  ████████   ███████  █████████   ███████
#    ███     ███       ███          ███     ███     
#    ███     ███████   ███████      ███     ███████ 
#    ███     ███            ███     ███          ███
#    ███     ████████  ███████      ███     ███████ 

runTests = ➜bool ->

    profileScope 'test'
    fail = false
    
    for f in testFiles
        # let cmd = &"nim r --colors:on {f}"
        let p = startProcess(command = "nim" args = @["r" f] options = {poInteractive poUsePath})
        let startTime = getMonoTime()
        var output = ""
        
        let fd = p.outputHandle
        var flags = fcntl(fd F_GETFL 0)
        discard fcntl(fd F_SETFL flags or O_NONBLOCK)
        
        while true
            let elapsed = (getMonoTime() - startTime).inMilliseconds
            if elapsed >= 5000
                fail = true
                output.add("test killed after #{elapsed} ms!!")
                p.terminate()
                sleep(50)
                if p.running
                    p.kill()
                break
                            
            var line = newString(1024*10)
            let bytesRead = read(fd addr(line[0]) line.len)
            if 
                bytesRead > 0   ➜ output.add(line & "\n")
                bytesRead == 0  ➜ break
                errno == EAGAIN ➜ discard poll(nil 0 50)
                                ➜ break
                
        let exitCode = p.waitForExit()
        if exitCode != 0 or verbose or fail
            styledEcho output.replace("[Suite]"  fg(fgYellow) & "▸\x1b[0m")
                             .replace("[OK]"     fg(fgGreen) & "✔\x1b[0m")
                             .replace("[FAILED]" fg(fgRed) & "✘\x1b[0m")
        else
            let okCount = output.count "[OK]"
            styledEcho output.replace("[Suite]"  fg(fgYellow) & "▸\x1b[0m")
                             .replace(peg"'[OK]' .+" "#{ansiStyleCode(styleDim)} ✔ #{okCount}\x1b[0m")
            
        if exitCode != 0
            styledEcho fgRed "✘ " $f
            fail = true
    # log ""
    not fail

if files.len

    # profileStart 'translate'
    transpiled = rndr.files(files)
    # profileStop 'translate'
    quit transpiled.len - files.len

if tests

    discard runTests()
    quit 0
    
#  ███████  █████████   ███████    ███████   ████████
# ███          ███     ███   ███  ███        ███     
# ███████      ███     █████████  ███  ████  ███████ 
#      ███     ███     ███   ███  ███   ███  ███     
# ███████      ███     ███   ███   ███████   ████████

stage = ◇seq[string] kimFiles ◇string src ◇string dst ➜bool ->

    profileStart dst & " "
    for f in kimFiles 
        copyFileWithPermissions(f, f.replace("/kim/kim/" "/kim/#{dst}/kim/"))
    
    for f in kimFiles 
        let (output exitCode) = execCmdEx("#{src}/bin/kim " & f.replace("/kim/kim/" "/kim/#{dst}/kim/"))
        if exitCode != 0
            log output
            logFile f "✘ "
            ⮐  false
        # else
        #     log output[0..^2].replace(getCurrentDir(), ".")
    profileStop dst & " "
        
    if compile("#{dst}/nim/kim.nim" "#{dst}/bin")
        profileStart "test"
        let (output exitCode) = execCmdEx("#{dst}/bin/kim --test")
        profileStop "test"
        if exitCode == 0
            ⮐  true
        else
            log output
    log "✘ #{dst}"
    false
 
# ███   ███   ███████   █████████   ███████  ███   ███
# ███ █ ███  ███   ███     ███     ███       ███   ███
# █████████  █████████     ███     ███       █████████
# ███   ███  ███   ███     ███     ███       ███   ███
# ██     ██  ███   ███     ███      ███████  ███   ███

watch = ◇seq[string] paths ->

    proc hook() {.noconv.} = 
        styledEcho ""
        styledEcho fgGreen farewells[rand(farewells.high)]
        quit 0
        
    setControlCHook hook
    
    modTimes ◇ Table[string, times.Time]
    
    styledEcho ""
    styledEcho fgGreen greetings[rand(greetings.high)]
    styledEcho ""
    
    for p in paths
        let (dir name ext) = p.splitFile()
        styledEcho fgBlue styleDim "● " resetStyle
            styleBright fgBlue dir " " resetStyle 
            styleBright fgYellow name styleDim ext resetStyle
    
    firstLoop = true
    
    while true
    
        var toTranspile ◇ seq[string]
        var kimFiles    ◇ seq[string]
        
        for path in paths
        
            if not dirExists(path)
            
                continue
                
            for f in walkDirRec(path)
            
                let (_ _ ext) = f.splitFile()
                
                if ext == ".kim" ➜ kimFiles.add(f) ➜ continue
                
                let modTime = getFileInfo(f).lastWriteTime
                
                if not modTimes.hasKey(f)
                    modTimes[f] = modTime
                    continue
                  
                if modTimes[f] == modTime
                    continue
        
                modTimes[f] = modTime
                if ext == ".kim"
                    toTranspile.add f
                
        if firstLoop                                    
            firstLoop = false
            if verbose
                for f in kimFiles ➜ logFile f
                
        if toTranspile
            log "\x1bc"
            for f in toTranspile
                logFile f "▸ "
                
            if stage(kimFiles "." "k1m")
                if stage(kimFiles "k1m" "k2m")
                    log "-> deploy"
                    for f in kimFiles 
                        let srcNim = f.replace("/kim/kim/" "/kim/k2m/nim/").replace(".kim" ".nim")
                        let tgtNim = f.replace("/kim/kim/" "/kim/nim/").replace(".kim" ".nim")
                        copyFileWithPermissions(srcNim, tgtNim)
                    if compile("k2m/nim/kim.nim" "bin")
                        restart()
        sleep 200
        
watch @[getCurrentDir() & "/kim"]
                 