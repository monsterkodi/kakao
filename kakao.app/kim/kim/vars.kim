###
    ███   ███   ███████   ████████    ███████
    ███   ███  ███   ███  ███   ███  ███     
     ███ ███   █████████  ███████    ███████ 
       ███     ███   ███  ███   ███       ███
        █      ███   ███  ███   ███  ███████ 

    inserts var keywords for firs assignment 
    operations in scope
###

use pars

class Scoper*
    
    vars* : seq[Table[string,bool]]

    $*: ➜string -> $@vars

    exp    : ◇Node body ◇int i ◇Node e ->
    scope  : ◇Node body ➜Node ->
    branch : ◇Node body -> discard @scope(body)
    
    # 00000000  000   000  00000000   
    # 000        000 000   000   000  
    # 0000000     00000    00000000   
    # 000        000 000   000        
    # 00000000  000   000  000        
        
    exp: ◇Node body ◇int i ◇Node e ->
        
        ⮐  if e == nil
        
        add = ◇string name -> @vars[^1][name] = true
            
        insert = ◇string name ◇Node expr ->
            
            for map in @vars
                ⮐  if map.hasKey name
                
            body.expressions[i] = Node(token:Token(tok:◂let str:"var" line:expr.token.line) kind:●let, let_expr:expr)
            add name
        
        switch e.kind 
            ●operation
                if e.operand_right.kind == ●func
                    @branch e.operand_right.func_body
                elif e.token.tok == ◂assign
                    lhs = e.operand_left
                    switch lhs.kind
                        ●literal
                            insert lhs.token.str e
                        ●list
                            insert lhs.token.str e
                            for item in lhs.list_values
                                add item.token.str
                        ➜ discard
                    # else
                    #     log "vars lhs #{lhs}"
            ●var
                insert e.var_name.token.str e
            ●let
                if e.let_expr.kind == ●operation and e.let_expr.token.tok == ◂assign
                    add e.let_expr.operand_left.token.str
                elif e.let_expr.kind == ●var
                    add e.let_expr.var_name.token.str
                else
                    log "unhandled let type #{e} #{e.let_expr}"
            ●if
                for condThen in e.condThens
                    @branch condThen.then_branch
                @branch e.else_branch
            ●for
                @branch e.for_body
            ●while
                @branch e.while_body
            ●switch
                for switchCase in e.switch_cases
                    @branch switchCase.case_then
                @branch e.switch_default
                
            ➜ discard
                        
    #  0000000   0000000   0000000   00000000   00000000  
    # 000       000       000   000  000   000  000       
    # 0000000   000       000   000  00000000   0000000   
    #      000  000       000   000  000        000       
    # 0000000    0000000   0000000   000        00000000  
        
    scope: ◇Node body ➜Node ->
        
        if body == nil or body.kind != ●block or body.expressions.len == 0
            ⮐  body
    
        @vars.push initTable[string,bool]()
    
        for i e in body.expressions
            @exp body i e 
    
        @vars.pops()
        body
    
variables* = ◇Node body ➜Node ->

    Scoper().scope body
