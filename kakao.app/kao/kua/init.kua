
# ███  ███   ███  ███  █████████
# ███  ████  ███  ███     ███   
# ███  ███ █ ███  ███     ███   
# ███  ███  ████  ███     ███   
# ███  ███   ███  ███     ███   

use uv utils process hooks math os

initFunc = (main ...) ->

    _G.process = process.globalProcess()
    
    math.randomseed(os.time())
    
    pretty = require "pretty-print"
    
    args = {...}
    
    runMain = ->
        thread = coroutine.create(main)
        utils.assertResume(thread, unpack(args))
        uv.run()
        
    errMain = err ->
        pcall( -> hooks:emit('process.uncaughtException', err))
        return debug.traceback(err)
    
    (success, err) = xpcall(runMain, errMain)
    
    if success
        hooks:emit('process.exit')
        uv.run()
    else
        _G.process.exitCode = -1
        pretty.stderr:write("Uncaught exception:\n" & err & "\n")
    
    isFileHandle = handle name fd ->
        ⮐  _G.process[name].handle == handle and uv.guess_handle(fd) == 'file'
    
    isStdioFileHandle = handle ->
        ⮐  isFileHandle(handle, 'stdin', 0) or isFileHandle(handle, 'stdout', 1) or isFileHandle(handle, 'stderr', 2)
    
    closeHandle = handle ->
        if handle
            close = -> if not handle:is_closing() ➜ handle:close()

            if handle.shutdown and not isStdioFileHandle(handle)
                handle:shutdown close
            else
                close()
    
    uv.walk closeHandle
    uv.run()
    
    ⮐  _G.process.exitCode

⮐  initFunc
