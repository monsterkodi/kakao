###
     ███████  █████████   ███████   █████████  ████████  
    ███          ███     ███   ███     ███     ███       
    ███████      ███     █████████     ███     ███████   
         ███     ███     ███   ███     ███     ███       
    ███████      ███     ███   ███     ███     ████████  

    handles basic text editing for the editor
    wraps text and editor state like cursors and selections 
        in an immutable to simplify undo
    delegates almost all text manipulation to pure functions
        in tool▸belt to simplify testing
###

# use child_process os
# use ../../kxk ▪ immutable kstr kseg events absMin
# use ../util   ◆ syntax
# use ./act     ◆ del insert select join indent multi main
# use ./tool    ◆ belt
# use           ◆ keys mode
use util.syntax

class state extends events

    @: cells name ->
    
        @cells = cells
        @name  = name & '.state'

        @allowedModes = {}

        # for act in [del insert select join indent multi main]
        #     for k v in pairs act
        #         @[k] = v.bind @
        # @handleKey = keys.bind @

        @syntax   = syntax @name & '.syntax'
        @hasFocus = false

        @clearSingle()
        
    $: -> @name

    toggleMode: name -> mode.toggle(@ name) if @allowedModes[name]
    startMode:  name -> mode.start(@ name) if @allowedModes[name]
    stopMode:   name -> mode.stop(@ name) if @allowedModes[name]
        
    owner: -> 
        
        if kstr.endsWith @name '.state'
            string.sub @name 1 -6
        else
            @name
        
    clearHistory: ->
    
        @h = [@s] # undo states (history)
        @r = []   # redo states

    #  0000000  00000000  000000000
    # 000       000          000
    # 0000000   0000000      000
    #      000  000          000
    # 0000000   00000000     000

    set: item arg ->

        # @s = @s.set item arg
        @s[item] = arg
        @swapState()
        @

    setSelections: selections -> @set 'selections' belt.mergeLineRanges(@s.lines selections)
    setHighlights: highlights -> @set 'highlights' belt.normalizeSpans(highlights)

    #  0000000  000   000  00000000    0000000   0000000   00000000    0000000
    # 000       000   000  000   000  000       000   000  000   000  000
    # 000       000   000  0000000    0000000   000   000  0000000    0000000
    # 000       000   000  000   000       000  000   000  000   000       000
    #  0000000   0000000   000   000  0000000    0000000   000   000  0000000

    setCursors: cursors opt ->
        
        opt ?= {}
        opt.mc ?= @mainCursor()
        
        main = opt.main

        if main is arr ➜ main = belt.indexOfPosInPositions main cursors
        if main is num and main < 0 ➜ main = cursors.length+main

        mainCursor = @mainCursor()
        if main
            mainCursor = cursors[clamp(0, cursors.length-1, main)]
            # mainCursor = copy cursors[clamp 0 cursors.length-1 main]
        
        cursors = belt.normalizePositions cursors @s.lines.length-1
        
        @s = @s.set 'cursors' cursors

        main = -1
        for cur,idx in cursors
            if cur eql mainCursor
                main = idx
                break

        if main < 0 ➜ main = @s.main 
        main = clamp 0 @s.cursors.length-1 main

        @s = @s.set 'main' main
        
        @adjustViewForMainCursor opt
        
        @swapState()
        
        mode.cursorsSet @
        @emit 'cursorsSet'
        @
            
    textOfSelectionOrWordAtCursor: -> 
        
        if @s.selections.length
            ⮐  @textOfSelection()
        else
            ⮐  @wordAtCursor()

    # 000      000  000   000  00000000   0000000
    # 000      000  0000  000  000       000
    # 000      000  000 0 000  0000000   0000000
    # 000      000  000  0000  000            000
    # 0000000  000  000   000  00000000  0000000

    setLines: lines ->
        
        if empty lines ➜ lines = ['']
        
        @setSegls kseg.segls(lines)
        
    setSegls: segls ->
    
        @segls = segls
        
        if empty @segls ➜ @segls = [[]]
        
        @syntax∙setSegls @segls
                    
        @changeLinesSegls()
        
        @r = []
        
        @maxLineWidth = belt.widthOfLines @s.lines
        
        @pushState()
        
    loadLines: lines -> 
    
        if valid(lines) and not (lines[1] is "string")
            error "#{@name}.loadLines - first line not a string?" lines
        
        @loadSegls kseg.segls(lines)
    
    loadSegls: segls ->
    
        @clearEmpty()
        @setSegls segls

    clearSingle: -> @clearSegls [[]]
    clearEmpty:  -> @clearSegls [  ]
    clearSegls: segls ->
    
        @segls = segls
    
        # @s = immutable {
        @s = {
            lines:       @segls
            selections:  []
            highlights:  []
            cursors:     [[0 0]]
            main:        0
            view:        [0 0]
            }
            
        @syntax∙clear()
        
        @h = []
        @r = []
        
    addLine: line ext ->

        segl = kseg line
        @syntax.addSegl segl ext
        @segls ?= []
        @segls.push segl

        @changeLinesSegls()
        
    appendLines: lines ext ->

        segls = kseg.segls lines
        @syntax.appendSegls segls ext
        @segls ?= []
        @segls = @segls.concat segls

        @changeLinesSegls()
        
    #  ███████  ███   ███   ███████   ███   ███   ███████   ████████        ███      ███  ███   ███  ████████   ███████
    # ███       ███   ███  ███   ███  ████  ███  ███        ███             ███      ███  ████  ███  ███       ███     
    # ███       █████████  █████████  ███ █ ███  ███  ████  ███████         ███      ███  ███ █ ███  ███████   ███████ 
    # ███       ███   ███  ███   ███  ███  ████  ███   ███  ███             ███      ███  ███  ████  ███            ███
    #  ███████  ███   ███  ███   ███  ███   ███   ███████   ████████        ███████  ███  ███   ███  ████████  ███████ 

    changeLinesSegls: ->
    
         #oldLines = @s.lines
         #
         # @s = @s.set 'lines' @segls
         @s.lines = @segls
         #
         #if oldLines != @s.lines
         #    diff = belt.diffLines oldLines @s.lines            
         #    @emit 'lines.changed' diff

    linesInView: -> @s.lines∙slice(@s.view[1] @s.view[1]+@cells.rows)

    clearLines: ->

        @setSegls [[]]
        @setMainCursor 0 0

    isValidLineIndex:   li -> 0 <= li < @s.lines.length
    isInvalidLineIndex: li -> not @isValidLineIndex li

    # 000   000  000   000  0000000     0000000
    # 000   000  0000  000  000   000  000   000
    # 000   000  000 0 000  000   000  000   000
    # 000   000  000  0000  000   000  000   000
    #  0000000   000   000  0000000     0000000

    undo: ->

        ⮐  if @h.length <= 1
        @r.push @h.pop()
        @s = @h[-1]
        @syntax.setSegls @s.lines

    redo: ->

        ⮐  if empty @r
        @h.push @r.pop()
        @s = @h[-1]
        @syntax.setSegls @s.lines

    begin: -> @beginIndex = @h.length

    ende: ->

        if valid @beginIndex

            @h.splice @beginIndex @h.length-@beginIndex-1
            @beginIndex = nil
            # delete @beginIndex
        @

    pushState: -> 
        @h∙push @s  
        @
        
    swapState: -> 
    
        @h∙pop()  
        @pushState()

    isDirty: -> @h.length > 1
    hasRedo: -> @r.length > 0

    gutterWidth: -> math.max 4 2 + math.ceil(math.log10(@s.lines.length+1))

    #  0000000  000   000  000000000
    # 000       000   000     000
    # 000       000   000     000
    # 000       000   000     000
    #  0000000   0000000      000

    cut: ->

        @copy {deselect:false}
        if empty @s.selections
            @selectCursorLines()
        @deleteSelection()

    #  0000000   0000000   00000000   000   000
    # 000       000   000  000   000   000 000
    # 000       000   000  00000000     00000
    # 000       000   000  000           000
    #  0000000   0000000   000           000

    copy: opt ->
    
        opt ?= {}

        switch os.platform()

            'darwin'

                prcs = child_process.spawn 'pbcopy'
                prcs.stdin.write @textOfSelectionOrCursorLines()
                prcs.stdin.close()

            'linux'

                prcs = child_process.spawn("xsel", {"-i", "--clipboard"})
                prcs.stdin.write @textOfSelectionOrCursorLines()
                prcs.stdin.close()

            'win32'

                prcs = child_process.spawn "#{slash.cwd()}/../../bin/utf8clip.exe"
                prcs.stdin.write @textOfSelectionOrCursorLines()
                prcs.stdin.close()
                
        @deselect() if opt.deselect != false

    # 00000000    0000000    0000000  000000000  00000000
    # 000   000  000   000  000          000     000
    # 00000000   000000000  0000000      000     0000000
    # 000        000   000       000     000     000
    # 000        000   000  0000000      000     00000000

    paste: ->

        switch os.platform()

            'darwin'

                @insert child_process.execSync('pbpaste').toString("utf8")

            'linux'

                text = child_process.execSync('xsel -o --clipboard')

                log 'paste\n' noon(text.toString("utf8"))

                @insert text.toString("utf8")

            'win32'

                @insert child_process.execSync("#{slash.cwd()}/../../bin/utf8clip.exe").toString("utf8")

    #  0000000   0000000  00000000    0000000   000      000          000   000  000  00000000  000   000  
    # 000       000       000   000  000   000  000      000          000   000  000  000       000 0 000  
    # 0000000   000       0000000    000   000  000      000           000 000   000  0000000   000000000  
    #      000  000       000   000  000   000  000      000             000     000  000       000   000  
    # 0000000    0000000  000   000   0000000   0000000  0000000          0      000  00000000  00     00  

    scrollView: dir steps=1 ->

        sx = 1 
        sy = 1

        switch dir
            'left'  ➜ sx = -1
            'right' ➜ sx =  1
            'up'    ➜ sy = -steps
            'down'  ➜ sy =  steps

        view = @s.view #.asMutable()

        view[1] += sx
        view[2] += sy

        view[2] = clamp 1 math.max(1 @s.lines.length-@cells.rows) view[2]

        maxOffsetX = math.max 1 @maxLineWidth-@cells.cols+2
        maxOffsetX = math.max maxOffsetX @mainCursor()[1]-@cells.cols+2
        view[1] = clamp 1 maxOffsetX view[1]
        
        ⮐  if view == @s.view

        @setView view

    #  0000000   0000000          000  000   000   0000000  000000000       000   000  000  00000000  000   000  
    # 000   000  000   000        000  000   000  000          000          000   000  000  000       000 0 000  
    # 000000000  000   000        000  000   000  0000000      000           000 000   000  0000000   000000000  
    # 000   000  000   000  000   000  000   000       000     000             000     000  000       000   000  
    # 000   000  0000000     0000000    0000000   0000000      000              0      000  00000000  00     00  
    
    adjustViewForMainCursor: opt ->
        
        opt ?= {}
        
        ⮐  if @cells.cols <= 0 or @cells.rows <= 0
        
        ⮐  if opt.adjust == false

        (x y) = @mainCursor()

        view = @s.view #.asMutable()
        
        topBotDelta = 7
        topDelta = 7
        botDelta = max topDelta math.floor(@cells.rows/2)
        
        if opt.adjust == 'topDelta'

            view[2] = y - topDelta
            
        elif opt.adjust == 'topBotDeltaGrow' and opt.mc
        
            dtt = y-view[2]
            dtb = y-(view[2]+@cells.rows)
            if dtt < 0 
                view[2] = y - topDelta
            elif dtb > 0
                view[2] = y - (@cells.rows-botDelta)
            else
                dir = y - opt.mc[2]
                if dtt < topDelta and dir < 0  or -dtb < botDelta and dir > 0
                    view[2] += dir
        else        
            if opt.adjust != 'topBotDelta'
                topBotDelta = 0
    
            if y >= view[2] + @cells.rows - 1 - topBotDelta
                view[2] = y - @cells.rows + 1 + topBotDelta
            elif y < view[2] + topBotDelta
                view[2] = y - topBotDelta

        if view[2] > 1 and @s.lines.length <= @cells.rows
            view[2] = 1

        if not @skipAdjustViewForMainCursor
            view[1] = math.max 1 x - @cells.cols + 2 # adding one for wide graphemes
        
        ⮐  if view == @s.view
        
        @setView view

    initView: ->

        # view = @s.view.asMutable()
        view = @s.view
        
        view[2] = clamp 1 math.max(1 @s.lines.len-@cells.rows) view[2]
        view[1] = math.max 1 view[1] or 1

        @setView view

    setView: view ->
        
        ⮐  if @s.view == view
        @set 'view' view
        @emit 'view.changed' @s.view
        @

    rangeForVisibleLines: ->

        [@s.view[1] @s.view[2] @s.view[1]+@cells.cols-1 @s.view[2]+@cells.rows-1]

    setMain: m -> 
    
        mc = @mainCursor()
        # @s = @s.set 'main' clamp(1 @s.cursors.length m)
        @s.main = clamp(1 @s.cursors.length m)
        @adjustViewForMainCursor {adjust:'topBotDeltaGrow' mc:mc}
        
    mainCursor: -> 
        #.asMutable()
        @s.cursors[@s.main] 
    
    #  ███████  ████████  █████████
    # ███       ███          ███   
    # ███████   ███████      ███   
    #      ███  ███          ███   
    # ███████   ████████     ███   

    setMainCursor: x y ->
        
        (x y) = belt.pos x y
        
        y = clamp 1 @s.lines.length y
        x = math.max 1 x
                        
        @setCursors [[x y]]
        
    # ██     ██   ███████   ███   ███  ████████
    # ███   ███  ███   ███  ███   ███  ███     
    # █████████  ███   ███   ███ ███   ███████ 
    # ███ █ ███  ███   ███     ███     ███     
    # ███   ███   ███████       █      ████████

    moveMainCursorInDirection: dir opt={} ->
        
        mc = belt.positionInDirection @mainCursor() dir
        
        if opt.keep
            @addCursor mc
        else
            @moveMainCursor mc
                        
    moveMainCursor: x y ->
                
        (x y) = belt.pos x y
        
        y = clamp 1 @s.lines.length y
        x = max 1 x
        
        mainCursor = @mainCursor()
        
        ⮐  if mainCursor == [x y]

        cursors = @allCursors()

        cursors∙splice belt.indexOfPosInPositions(mainCursor cursors) 1
        
        main = belt.indexOfPosInPositions [x y] cursors
        if main < 1
            cursors∙push [x y]
            main = cursors.len
        
        @setCursors cursors {main:main}
                
    # ████████   ███████    ███    
    # ███       ███   ███   ███    
    # ███████   ███   ███   ███    
    # ███       ███   ███   ███    
    # ████████   ███████    ███████

    singleCursorAtEndOfLine: ->
        
        rng = belt.lineRangeAtPos @s.lines @mainCursor()
        mc  = belt.endOfRange rng
        
        @deselect()
        @setCursors [mc]
        
    # ███  ███   ███  ███████            ███████     ███████   ███      
    # ███  ████  ███  ███   ███          ███   ███  ███   ███  ███      
    # ███  ███ █ ███  ███   ███          ███████    ███   ███  ███      
    # ███  ███  ████  ███   ███          ███   ███  ███   ███  ███      
    # ███  ███   ███  ███████    ██████  ███████     ███████   ███████  

    singleCursorAtIndentOrStartOfLine: ->
        
        lines = @s.lines
        mc    = @mainCursor()
        
        rng   = belt.lineRangeAtPos  lines mc
        ind   = belt.lineIndentAtPos lines mc
        
        if ind < mc[1]
            mc[1] = ind
        else
            mc  = belt.startOfRange rng
        
        @deselect()
        @setCursors [mc]

    # ████████    ███████    ███████   ████████
    # ███   ███  ███   ███  ███        ███     
    # ████████   █████████  ███  ████  ███████ 
    # ███        ███   ███  ███   ███  ███     
    # ███        ███   ███   ███████   ████████

    singleCursorPage: dir ->

        mc = @mainCursor()
        
        switch dir
            'up'   ➜  mc[2] -= @cells.rows
            'down' ➜  mc[2] += @cells.rows

        @deselect()
        @setCursors [mc]
                                    
    wordAtCursor:      -> belt.wordAtPos      @s.lines @mainCursor()
    chunkBeforeCursor: -> belt.chunkBeforePos @s.lines @mainCursor()
    chunkAfterCursor:  -> belt.chunkAfterPos  @s.lines @mainCursor()
        
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    setMainCursorAndSelect: x y ->
        
        @setSelections belt.extendLineRangesFromPositionToPosition @s.lines @allSelections() @mainCursor() [x y]
        @setCursors [[x y]] {adjust:'topBotDelta'}

⮐  state
