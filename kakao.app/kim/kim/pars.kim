# ████████    ███████   ████████    ███████
# ███   ███  ███   ███  ███   ███  ███     
# ████████   █████████  ███████    ███████ 
# ███        ███   ███  ███   ███       ███
# ███        ███   ███  ███   ███  ███████ 

use node

export node

{.experimental: "codeReordering".}

type RHS = proc(p: Parser): Node
type LHS = proc(p: Parser, left: Node): Node

EOF = tkn(◂eof)
    
type Pratt = object
    rhs         : RHS
    lhs         : LHS
    precedence  : int
         
class Parser*

    tokens*     : seq[Token]
    pratts*     : seq[Pratt]
    blocks*     : seq[Node]
    pos*        : int
    explicit    : int
    listless    : int
    inlinecall  : int
    returning   : bool
    typeless    : bool
    failed      : bool
    text        : string # used in `$` for debugging. should be removed eventually 

    current: ➜Token ->
    
        if @pos < @tokens.len
            ⮐  @tokens[@pos]
            
        tkn(◂eof)
    
    tok: ➜tok -> @current.tok

    peek: ahead=1 ➜Token ->
    
        if @pos + ahead < @tokens.len
            @tokens[@pos + ahead]
        else
            EOF

    # ████████   ████████   ███  ███   ███  █████████  
    # ███   ███  ███   ███  ███  ████  ███     ███     
    # ████████   ███████    ███  ███ █ ███     ███     
    # ███        ███   ███  ███  ███  ████     ███     
    # ███        ███   ███  ███  ███   ███     ███     

    $: ➜string ->
    
        s = ""
        if @tok != ◂eof
            s = "▪▪▪ #{@current} #{@pos}"
            l = @text.split("\n")[@current.line]
            s &= "\n#{@current.line}: #{l}"
        else
            s = @text
        s

    error: ◇string msg token=EOF ➜Node ->
    
        styledEcho fgRed, styleDim, "△ ", resetStyle, fgYellow, msg
        if token.tok != ◂eof
            line = @text.split("\n")[token.line]
            styledEcho fgWhite, styleDim, "#{token.line}", resetStyle, fgGreen, $line
        elif @tok != ◂eof
            line = @text.split("\n")[@current.line]
            styledEcho fgWhite, styleDim, "#{@current.line}", resetStyle, fgGreen, $line
        @failed = true    
        nil
    
    #  ███████   ███████   ███   ███   ███████  ███   ███  ██     ██  ████████
    # ███       ███   ███  ████  ███  ███       ███   ███  ███   ███  ███     
    # ███       ███   ███  ███ █ ███  ███████   ███   ███  █████████  ███████ 
    # ███       ███   ███  ███  ████       ███  ███   ███  ███ █ ███  ███     
    #  ███████   ███████   ███   ███  ███████    ███████   ███   ███  ████████
    
    consume: ➜Token ->
    
        t = @current
        if @pos < @tokens.len
            @pos += 1
        t
    
    swallow: ->
    
        discard @consume()
    
    swallow: ◇tok tok ->
    
        if @tok == tok
            @swallow()
            
    swallowError: ◇tok tok ◇string err ->
    
        if @tok != tok
            discard @error("Expected #{tok} to swallow, but found #{@tok} instead")
            discard @error(err)
            ⮐  
        @swallow()
                
    swallowSameIndent: ◇int indent ➜bool ->
    
        if @tok == ◂indent and @current.str.len == indent
            @swallow()
            ⮐  true
        false
    
    atIndent: ➜bool ->  
    
        @current.col == 0 or @peek(-1).tok == ◂indent
            
    atEnd: ➜bool ->  
    
        @pos >= @tokens.len
    
    isDedent: ◇int indent ➜bool ->  
    
        if @tok == ◂indent
            @current.str.len < indent
        else
            @current.col < indent
            
    isNextLineIndented: ◇Token token ➜bool -> 
    
        n = 0
        while @peek(n).tok != ◂indent
            n += 1
            if @peek(n).tok == ◂eof
                ⮐  false
            
        idt = if token.tok == ◂indent ➜ token.str.len ➜ token.col
        ⮐  @peek(n).str.len > idt
    
    isTokAhead: ◇tok tokAhead ➜bool ->
    
        n = 0
        c = @current
        line = c.line
        
        # log "isTokAhead #{tokAhead} #{line}"
        
        while c.tok != ◂eof
            if c.line > line
                ⮐  false
            if c.tok == tokAhead
                ⮐  true
            n += 1
            c = @peek n
        false    

    firstLineToken: ➜Token ->
    
        line = @current.line
        tpos = @tokens.len
        while tpos > 0
            if @tokens[tpos-1].line < line
                break
            tpos -= 1
        @tokens[tpos]
        
    lineIndent: ◇int line ➜int ->
    
        tpos = @tokens.len
        while tpos > 0
            if @tokens[tpos-1].line < line
                break
            tpos -= 1
    
        if @tokens[tpos].tok == ◂indent
            @tokens[tpos].str.len
        else
            @tokens[tpos].col
    
    isThenlessIf: ◇Token token ➜bool ->
    
        if @isNextLineIndented(token)
            ⮐  false
    
        not @isTokAhead ◂then
        
    getPrecedence: ◇Token token ➜int ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].precedence
        0
        
    rightHandSide: ◇Token token ➜RHS ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].rhs
    
    leftHandSide: ◇Token token ➜LHS ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].lhs
    
    expression: precedenceRight=0 ➜Node ->
    
    expression: ◇Token tokenRight ➜Node ->
    
        @expression @getPrecedence(tokenRight)
    
    value: ➜Node ->
    
        @expression(-2)

    # ███████    ███       ███████    ███████  ███   ███
    # ███   ███  ███      ███   ███  ███       ███  ███ 
    # ███████    ███      ███   ███  ███       ███████  
    # ███   ███  ███      ███   ███  ███       ███  ███ 
    # ███████    ███████   ███████    ███████  ███   ███
    
    parseBlock: ◇Node bn=nil ➜Node ->
    
        token        ◇ Token
        block_indent ◇ int
        
        while @tok == ◂indent
            token = @consume() 
            block_indent = @current.col
        
        bn = bn
        if bn == nil
            bn = nod(●block, token, [])
            
        expr = @expression()
        
        while expr != nil
        
            if expr.kind == ●func and bn.expressions.len
                prevExpr = bn.expressions[^1]
                if prevExpr.token.line == expr.token.line and prevExpr.token.tok == ◂assign
                    prevExpr = bn.expressions.pop()
                    if prevExpr.operand_right.kind == ●operation
                        argtoken = prevExpr.operand_right.operand_left.token
                        argtoken.tok = ◂val_type
                        argnode = nod(●arg argtoken nil prevExpr.operand_right.operand_left prevExpr.operand_right.operand_right)
                        expr.func_signature.sig_args.list_values.unshift(argnode)
                    else
                        expr.func_signature.sig_args.list_values.unshift(prevExpr.operand_right)
                    prevExpr.operand_right = expr
                    expr = prevExpr
                    
            bn.expressions.add expr
            if @tok == ◂indent
                ind = @current.str.len
                if ind < block_indent
                    break
                elif ind > block_indent
                    @blocks.add bn
                    expr = @parseBlock()
                    bn = @blocks.pop()
                    continue
                else
                    @swallow()
                    
            if @atEnd() or @current.col < block_indent
                break
                
            expr = @expression()
        bn
    
    expressionOrIndentedBlock: ◇Token token ◇int col ➜Node ->
    
        if @tok == ◂indent
            if @current.str.len > col
                ⮐  @parseBlock()
        else
            ⮐  @expression(token)
            
    #  ███████   ███████   ███      ███       ███████   ████████    ███████    ███████
    # ███       ███   ███  ███      ███      ███   ███  ███   ███  ███        ███     
    # ███       █████████  ███      ███      █████████  ███████    ███  ████  ███████ 
    # ███       ███   ███  ███      ███      ███   ███  ███   ███  ███   ███       ███
    #  ███████  ███   ███  ███████  ███████  ███   ███  ███   ███   ███████   ███████ 
    
    swallowIndent: ◇int col ➜bool ->
    
        @swallow ◂comma
        if @tok == ◂indent
            if @current.str.len > col
                @swallow()
            else
                ⮐  true
        false
        
    parseCallArgs: ◇int col ➜seq[Node] ->
    
        @explicit += 1
        @listless += 1
        list ◇ seq[Node]
        line = @current.line
        expr = @expression()
        while expr != nil
            list.add expr
            if @inlinecall and @tok == ◂indent
                break
            if @swallowIndent(col)
                break
            # if @tok in {◂comment_start, ◂then, ◂paren_close}
            if @tok in {◂comment_start, ◂then}
                break
            expr = @expression()
        @listless -= 1
        @explicit -= 1
        list
        
    # █████████  ███   ███  ████████   ████████
    #    ███      ███ ███   ███   ███  ███     
    #    ███       █████    ████████   ███████ 
    #    ███        ███     ███        ███     
    #    ███        ███     ███        ████████
    
    parseType: ➜Node ->
        
        token = @consume()
        token.tok = ◂type
        
        if @tok == ◂square_open
            opened = 0
            while @tok notin {◂eof}
                t = @consume()
                token.str &= t.str
                if t.tok == ◂square_open
                    opened += 1
                elif t.tok == ◂square_close
                    opened -= 1
                    if opened == 0
                        break
        
        nod(●type token)
        
    parseVar: ➜Node ->
    
        token     = @current()
        var_name  = @value()
        var_value ◇ Node
        var_type  ◇ Node
        
        if @tok == ◂assign
            @swallow()
            var_value = @thenBlock()
        elif @tok in {◂val_type, ◂var_type}
            token = @consume()
            var_type = @parseType()
            if @tok == ◂assign
                @swallow()
                var_value = @expression()
        
        nod(●var token var_name var_type var_value)
        
    parseModule: ➜Node ->
    
        line = @current.line
        s = ""
        while @current.str notin ["▪" "◆"]
            e = @current.col + @current.str.len
            s &= @consume().str
            if @atEnd() or @current.line != line
                break 
            if @current.col > e and @current.str notin ["▪" "◆"] 
                s &= " "
            
        Node(token:Token(str:s))    

    # ███      ███   ███████  █████████
    # ███      ███  ███          ███   
    # ███      ███  ███████      ███   
    # ███      ███       ███     ███   
    # ███████  ███  ███████      ███   
    
    parseParenList: ➜seq[Node] ->
    
        token = @consume() # (
        args  ◇ seq[Node]
        
        @explicit += 1
        while @tok != ◂paren_close and @tok != ◂eof
            args.add @expression()
            @swallow ◂comma
        @swallowError(◂paren_close, "Missing closing parenthesis")
        @explicit -= 1
        if args.len == 1 and args[0].kind == ●list
            ⮐  args[0].list_values
        args
        
    parseDelimitedList: ◇tok open ◇tok close ➜seq[Node] ->
    
        token = @consume()
        args  ◇ seq[Node]
        
        @explicit += 1
        while true
            discard @swallowIndent(-1)
            if @tok != close and @tok != ◂eof
                args.add @expression()
            else
                break
        @swallowError(close, "Missing closing bracket")
        @explicit -= 1
        
        if args.len == 1 and args[0].kind == ●list
            ⮐  args[0].list_values
        args
        
    parseNames: ➜seq[Node] -> 
    
        list ◇ seq[Node]
        line = @current.line
        @explicit += 1
        expr = @rSymbol()
        while expr != nil
            list.add expr        
            if @current.line != line
                break
            @swallow ◂comma
            expr = @rSymbol()
        @explicit -= 1
        list
    
    parseNamesUntil: ◇tok stop ➜Node -> 
    
        token = @current
                                    
        list_values ◇ seq[Node]
        @explicit += 1
        while @tok != stop
            if @tok == ◂eof
                ⮐  @error("Missing 'in' for 'for' loop (eof detected)!", token)
            if @current.line != token.line
                ⮐  @error("Missing 'in' for 'for' loop (linebreak detected)!", token)
            list_values.add @rSymbol()
            @swallow ◂comma
        @explicit -= 1
        if list_values.len == 1
            list_values[0]
        else
            nod(●list token list_values)
    
    # █████████  ███   ███  ████████  ███   ███
    #    ███     ███   ███  ███       ████  ███
    #    ███     █████████  ███████   ███ █ ███
    #    ███     ███   ███  ███       ███  ████
    #    ███     ███   ███  ████████  ███   ███
    
    thenBlock: ➜Node ->
    
        if @tok == ◂then
            @swallow ◂then
            
        if @tok == ◂indent
            @parseBlock()
        else
            @expression()
            
    thenIndented: ◇Token token ➜Node ->
    
        if @tok == ◂then
            @swallow ◂then
            
        if @tok == ◂indent
            if @isNextLineIndented(token)
                ⮐  @parseBlock()
            ⮐  nil
        else
            ⮐  @expression()
            
    #  ███████   ███████   ███      ███    
    # ███       ███   ███  ███      ███    
    # ███       █████████  ███      ███    
    # ███       ███   ███  ███      ███    
    #  ███████  ███   ███  ███████  ███████
    
    lCall: ◇Node callee ➜Node ->
    
        token = @consume() # (
        args = @parseCallArgs(callee.token.col)
        @swallowError(◂paren_close, "Missing closing paren for call arguments")    
        Node(token:token, kind:●call, callee:callee, callargs:args)
    
# ███  ██     ██  ████████   ███      ███   ███████  ███  █████████
# ███  ███   ███  ███   ███  ███      ███  ███       ███     ███   
# ███  █████████  ████████   ███      ███  ███       ███     ███   
# ███  ███ █ ███  ███        ███      ███  ███       ███     ███   
# ███  ███   ███  ███        ███████  ███   ███████  ███     ███   

isImplicitCallPossible = ◇Parser p ➜bool ->

    ⮐  false if p.explicit

    currt = p.peek(0)
    
    optoks = { 
        ◂indent, ◂eof,
        ◂then, ◂else, ◂elif, ◂test, ◂val_type, ◂var_type, ◂colon,
        ◂plus, ◂minus, ◂divide, ◂multiply, ◂and, ◂or, ◂ampersand, ◂is, ◂in, ◂notin, ◂not,
        ◂equal, ◂not_equal, ◂greater_equal, ◂less_equal, ◂greater, ◂less, ◂match, ◂comment_start,
        ◂assign, ◂divide_assign, ◂multiply_assign, ◂plus_assign, ◂minus_assign, ◂ampersand_assign }
        
    ⮐  false if currt.tok in optoks  
    
    prevt = p.peek(-1)
    
    ⮐  false if currt.col <= prevt.col+ksegWidth(prevt.str)
    ⮐  false if p.isTokAhead(◂func)
    true
    
rSymbol = ◇Parser p ➜Node ->

    token = p.consume()
    
    if token.str in ["peg", "re", "r"] and p.tok == ◂string_start and token.col + token.str.len == p.current.col
        n = p.rString()
        n.string_prefix = nod ●literal token
        ⮐  n

    if p.isImplicitCallPossible()
        let args = p.parseCallArgs(token.col)
        ⮐  Node(token:token, kind:●call, callee:nod(●literal token), callargs:args)

    nod ●literal token
        
# ███  ████████                             ███  ████████                               ███  ████████  
# ███  ███                                  ███  ███                                    ███  ███       
# ███  ██████                               ███  ██████                                 ███  ██████    
# ███  ███                                  ███  ███                                    ███  ███       
# ███  ███                                  ███  ███                                    ███  ███       

inline = ◇Parser p ➜Node ->

    p.inlinecall += 1
    e = p.expression()
    p.inlinecall -= 1
    e

rIf = ◇Parser p ➜Node ->

    token     = p.consume() # if or when
    condThens ◇ seq[Node]
    ifIndent  = token.col
    condIndt  = ifIndent
    
    if p.tok == ◂indent
        condIndt = p.current.str.len
        if condIndt <= ifIndent
            ⮐  p.error "Expected indentation after 'if' without condition"
        p.swallow ◂indent # block indentation
    
    condition = p.inline() # initial condition
    then_branch = p.thenBlock()
    
    condThens.add nod(●condThen condition.token condition then_branch)
    
    outdent = false
    
    while p.tok in {◂elif, ◂indent}
    
        if p.tok == ◂indent            
            if p.current.str.len < ifIndent
                outdent = true
                break
            if ifIndent < condIndt 
                if p.current.str.len < condIndt
                    break
            if p.peek(1).tok != ◂elif and p.current.str.len == ifIndent
                break
            p.swallow ◂indent
            if p.tok == ◂comment_start
                p.swallow()
                p.swallow ◂comment
            if p.tok == ◂indent
                continue
                
        p.swallow(◂elif)
        if p.tok in {◂then, ◂else}
            break # then without condition -> else
        
        condition = p.inline()
        p.swallow ◂comment
        then_branch = p.thenBlock()
        
        condThens.add nod(●condThen condition.token condition then_branch)
        
    else_branch ◇ Node

    if not outdent    
        p.swallow(◂indent)
        
        if p.tok in {◂else, ◂then}
            p.swallow() # else or then without condition
            else_branch = p.thenBlock()
    
    Node(token:token, kind:●if, cond_thens:condThens, else_branch:else_branch)

# █████████   ███████   ███  ███         ███  ████████
#    ███     ███   ███  ███  ███         ███  ███     
#    ███     █████████  ███  ███         ███  ██████  
#    ███     ███   ███  ███  ███         ███  ███     
#    ███     ███   ███  ███  ███████     ███  ███     

lTailIf = ◇Parser p ◇Node left ➜Node ->

    ⮐  if p.returning
    ⮐  if left.token.line != p.current.line
        
    token = p.consume()
    condition = p.expression()
    condThen = nod ●condThen condition.token condition left

    Node(token:token, kind:●if, cond_thens: @[condThen])
        
# ████████   ███████   ████████ 
# ███       ███   ███  ███   ███
# ██████    ███   ███  ███████  
# ███       ███   ███  ███   ███
# ███        ███████   ███   ███

rFor = ◇Parser p ➜Node ->

    token = p.consume()
    for_value = p.parseNamesUntil ◂in
    p.swallowError(◂in, "Expected 'in' after for value")
    for_range = p.expression()
    for_body  = p.thenBlock()

    nod ●for token for_value for_range for_body

rWhile = ◇Parser p ➜Node ->

    nod ●while p.consume() p.expression() p.thenBlock()

#  ███████  ███   ███  ███  █████████   ███████  ███   ███
# ███       ███ █ ███  ███     ███     ███       ███   ███
# ███████   █████████  ███     ███     ███       █████████
#      ███  ███   ███  ███     ███     ███       ███   ███
# ███████   ██     ██  ███     ███      ███████  ███   ███

switchCase = ◇Parser p ◇int baseIndent ➜Node ->

    case_when ◇ seq[Node]
    token     = p.current
    first     = p.firstLineToken()
    
    while true
    
        if p.tok == ◂indent
            if case_when.len == 0 and p.peek(1).tok == ◂then
                p.swallow()
                ⮐  # indent followed by a ➜ is else
            if not p.swallowSameIndent baseIndent
                break

        ⮐  if p.tok in {◂else, ◂eof} or p.isDedent(baseIndent)

        break if p.tok == ◂then
    
        p.explicit += 1
        case_when.add p.value()
        p.explicit -= 1
        p.swallow ◂comma
    
    ⮐  if p.isDedent baseIndent

    case_then = p.thenIndented first
                
    if case_then == nil
        ⮐  p.error("Expected case body after match(es)", token)
    
    Node(token:token, kind:●switchCase, case_when:case_when, case_then:case_then)

rSwitch = ◇Parser p ➜Node ->

    token = p.consume()
    switch_value = p.expression()
    
    if switch_value == nil
        ⮐  p.error("Expected value after switch keyword", token)
    
    baseIndent = p.current.str.len 
    
    p.swallowError(◂indent, "Expected indentation after switch statement")
    
    switch_cases ◇ seq[Node]
    
    while true 

        switch_case = p.switchCase(baseIndent)
        if switch_case
            switch_cases.add switch_case
        else
            break
    
    switch_default ◇ Node
    
    if p.tok in {◂else, ◂then}
        p.swallow()
        switch_default = p.thenBlock()
        if switch_default == nil
            ⮐  p.error("Expected default value", token)
    
    Node(token:token, kind:●switch, switch_value:switch_value, switch_cases:switch_cases, switch_default:switch_default)
                
lArrayAccess = ◇Parser p ◇Node array_owner ➜Node ->

    token = p.current()
    array_indices = p.parseDelimitedList(◂square_open, ◂square_close)
    array_index = 
        switch array_indices.len
            0 ➜ nil
            1 ➜ array_indices[0]
              ➜ nod ●list token array_indices
        
    nod ●arrayAccess token array_owner array_index

lPropertyAccess = ◇Parser p ◇Node owner ➜Node ->

    token = p.consume()
    property = p.rLiteral()
    
    n = nod ●propertyAccess token owner property
    
    if p.isImplicitCallPossible()
        ⮐  Node(token:token, kind:●call, callee:n, callargs:p.parseCallArgs(token.col))
    n

rLiteral    = ◇Parser p ➜Node -> nod(●literal   p.consume())
rKeyword    = ◇Parser p ➜Node -> nod(●keyword   p.consume())
rImport     = ◇Parser p ➜Node -> nod(●import    p.consume())
rProc       = ◇Parser p ➜Node -> nod(●proc      p.consume())
rTypeDef    = ◇Parser p ➜Node -> nod(●typeDef   p.consume())
rMacro      = ◇Parser p ➜Node -> nod(●macro     p.consume())
rTemplate   = ◇Parser p ➜Node -> nod(●template  p.consume())
rConverter  = ◇Parser p ➜Node -> nod(●converter p.consume())
rLet        = ◇Parser p ➜Node -> nod(●let       p.consume() p.parseVar())
rReturnType = ◇Parser p ➜Node -> nod(●signature p.consume() nil p.parseType())
rQuote      = ◇Parser p ➜Node -> nod(●quote     p.consume() p.thenBlock())
    
#  ███████  █████████  ████████   ███  ███   ███   ███████ 
# ███          ███     ███   ███  ███  ████  ███  ███      
# ███████      ███     ███████    ███  ███ █ ███  ███  ████
#      ███     ███     ███   ███  ███  ███  ████  ███   ███
# ███████      ███     ███   ███  ███  ███   ███   ███████ 

rString = ◇Parser p ➜Node ->

    token = p.consume() # string start

    if p.tok == ◂string_end
        p.swallow()
        Node(token:token, kind:●string, string_content:nod(●literal tkn(◂string)))
    else
        string_content ◇ Node 
        if p.tok != ◂stripol_start
            string_content = nod ●literal p.consume()
        else
            string_content = nod ●literal tkn(◂string "" p.current.line p.current.col)
            
        string_stripols ◇ seq[Node]
        while p.tok notin {◂string_end, ◂eof}
        
            p.swallowError(◂stripol_start, "Expected string interpolation start")
            
            stripol = Node(token:p.current, kind:●stripol)
            
            stripol_xprssns ◇ seq[Node]
            while p.tok notin {◂stripol_end, ◂eof}
                xpr = p.expression()
                stripol_xprssns.add xpr
                
            stripol.stripol_xprssns = stripol_xprssns
            
            p.swallowError(◂stripol_end, "Expected string interpolation end")
            if p.tok notin {◂stripol_start, ◂string_end, ◂eof}
                stripol.stripol_content = nod ●literal p.consume()
            elif p.tok == ◂stripol_start
                stripol.stripol_content = nod ●literal tkn(◂string p.current.line p.current.col)
            
            string_stripols.add stripol
            
        p.swallowError(◂string_end, "Expected closing string delimiter")
        Node(token:token, kind:●string, string_content:string_content, string_stripols:string_stripols)

rUse = ◇Parser p ➜Node ->

    token = p.consume()
    p.explicit += 1
    use_module = p.parseModule()
    if not p.atEnd() and p.current.line == token.line
        use_kind = p.rSymbol()
        use_items  = p.parseNames()
        p.explicit -= 1
        Node(token:token, kind:●use, use_module:use_module, use_kind:use_kind, use_items:use_items) 
    else
        p.explicit -= 1
        Node(token:token, kind:●use, use_module:use_module) 
        
rComment = ◇Parser p ➜Node ->

    n = nod ●comment p.consume() Node(token:p.consume())
    p.swallow ◂comment_end
    n
    
lReturnType = ◇Parser p ◇Node left ➜Node ->

    ⮐  if not p.isTokAhead(◂func)

    if left.kind in {●list, ●arg, ●operation}
        if left.kind == ●operation 
            if left.token.tok == ◂assign
                sig = p.rReturnType()
                argtoken = tkn(◂val_type "" left.token.line left.token.col)
                argNode  = nod ●arg argtoken nil left.operand_left left.operand_right
                sig.sig_args = nod ●list left.token @[argNode]
                ⮐  sig
        elif left.kind == ●list
            sig = p.rReturnType()
            sig.sig_args = left
            ⮐  sig
        elif left.kind == ●arg
            sig = p.rReturnType()
            sig.sig_args = nod ●list left.token @[left]
            ⮐  sig
                    
rArg = ◇Parser p ➜Node ->

    token = p.consume() # ◆ or ◇
    
    if p.typeless
        nameToken = p.consume()
        nameToken.tok = ◂name
        nameToken.str = token.str & nameToken.str
        nameToken.col = token.col
        ⮐  nod ●literal nameToken

    arg_type  = p.parseType()
    arg_name  = p.value()
    arg_value ◇ Node
    
    if p.tok == ◂assign
        t = p.consume() # =
        arg_value = p.expression() 
    
    nod ●arg token arg_type arg_name arg_value

lVar = ◇Parser p ◇Node left ➜Node ->

    ⮐  if left.token.tok != ◂name
        
    token     = p.consume() # ◆ or ◇
    var_type  = p.parseType()
    var_value ◇ Node
    
    if p.tok == ◂assign
        t = p.consume() # =
        var_value = p.expression() 
    nod ●var token left var_type var_value

lSymbolList = ◇Parser p ◇Node left ➜Node ->

    ⮐  if p.listless

    switch left.kind 
        ●list
            list_values = left.list_values
            # todo: check if all list items are symbols?
            list_values.add p.rSymbol()
            ⮐  nod ●list left.token list_values
        ●literal
            if left.token.tok != ◂name
                ⮐  
            list_values ◇ seq[Node]
            list_values.add left
            list_values.add p.rSymbol()
            ⮐  nod ●list left.token list_values
        ➜ 
            discard

lArgList = ◇Parser p ◇Node left ➜Node ->
    
    switch left.kind 
        ●list
            var list_values = left.list_values
            list_values.add p.rArg()
            ⮐  nod ●list left.token list_values
        ●arg
            list_values ◇ seq[Node]
            list_values.add left
            list_values.add p.rArg()
            ⮐  nod ●list left.token list_values
        ●literal
            if left.token.tok == ◂name
                ⮐  p.lVar left
        ➜ 
            discard

# ████████  ███   ███  ███   ███   ███████
# ███       ███   ███  ████  ███  ███     
# ██████    ███   ███  ███ █ ███  ███     
# ███       ███   ███  ███  ████  ███     
# ███        ███████   ███   ███   ███████

lFunc = ◇Parser p ◇Node left ➜Node ->

    ⮐  if left.kind notin {●signature, ●list, ●arg, ●operation}
        
    func_signature ◇ Node
    
    if left.kind == ●operation
    
        # log "lfunc op #{left}"
        
        ⮐  if left.token.tok != ◂assign
            
        ⮐  if left.operand_left.token.tok != ◂name
            
        if left.operand_left.token.col == 0 
            left = left
            argtoken = tkn(◂val_type left.operand_right.token.line left.operand_right.token.col)
            left.operand_right = p.lFunc(nod(●arg argtoken nil left.operand_right nil))
            ⮐  left
            
        vartoken = tkn(◂val_type left.operand_left.token.line left.operand_left.token.col)
        varNode  = nod ●arg vartoken nil left.operand_left left.operand_right
        sig_args = nod ●list vartoken @[varNode]
        func_signature = nod ●signature left.token sig_args nil
        
    elif left.kind == ●list
    
        # log "lfunc list"
        
        sig_args = left
        for i,a in sig_args.list_values
            if a.kind == ●operation and a.token.tok == ◂assign
                argtoken = tkn(◂val_type a.operand_left.token.line a.operand_left.token.col)
                sig_args.list_values[i] = nod ●arg argtoken nil a.operand_left a.operand_right
            elif a.kind == ●literal and a.token.tok == ◂name
                argtoken = tkn(◂val_type a.token.line a.token.col)
                sig_args.list_values[i] = nod ●arg argtoken nil a nil
        func_signature = nod ●signature left.token sig_args nil
        
    elif left.kind == ●arg
    
        # log "lfunc arg"
        
        sig_args = nod ●list left.token @[left]
        func_signature = nod ●signature left.token sig_args nil
        
    elif left.kind == ●signature
        func_signature = left
    
    firstToken = p.firstLineToken()
    token = p.consume()
    
    func_mod ◇Node
    if p.tok == ◂mod
        func_mod = p.rLiteral()
    
    func_body = p.thenIndented firstToken
    
    nod ●func token func_signature func_mod func_body

rFunc = ◇Parser p ➜Node ->

    firstToken = p.firstLineToken()
    token = p.consume()
    
    func_mod ◇ Node
    if p.tok == ◂mod
        func_mod = p.rLiteral()
    
    func_body = p.thenIndented firstToken
    
    nod ●func token nil nil func_body

parseSignature = ◇Parser p ➜Node ->

    sig_args = nod ●list p.current() @[]
    sig_type ◇ Node
    
    parens = false
    if p.tok == ◂paren_open
        p.swallow()
        parens = true
    
    while true
        
        token    = p.current()
        arg_type ◇ Node = nil
        
        if p.tok in {◂var_type, ◂val_type}
        
            p.swallow() # ◆ or ◇
            arg_type  = p.parseType()
                        
        if p.tok != ◂name
            break
                
        arg_name  = p.value()
        arg_value ◇ Node

        if p.tok == ◂assign
            p.swallow() # =
            p.listless += 1
            p.explicit += 1
            arg_value = p.expression()
            p.explicit -= 1
            p.listless -= 1
            
        p.swallow ◂comma
        
        sig_args.list_values.add nod(●arg token arg_type arg_name arg_value)
    
    if parens 
        ⮐  if p.tok != ◂paren_close
        p.swallow()

    if p.tok == ◂then
        p.swallow()
        sig_type = p.parseType()

    if p.tok != ◂func
        ⮐  
        
    nod ●signature sig_args.token sig_args sig_type

funcOrExpression = ◇Parser p ◇Token token ➜Node ->

    col = p.lineIndent token.line

    if p.isTokAhead ◂func
        startPos = p.pos
        func_signature ◇ Node
        if p.tok != ◂func
            func_signature = p.parseSignature()
        if p.tok == ◂func
            ftoken = p.consume()
            func_mod = if p.tok == ◂mod ➜ p.rLiteral() ➜ nil
            func_body = p.expressionOrIndentedBlock(tkn(◂null), col)
            ⮐  nod ●func ftoken func_signature func_mod func_body
        else
            p.pos = startPos
    
    p.expressionOrIndentedBlock(token, col)

rReturn = ◇Parser p ➜Node ->

    token = p.consume()
    
    if p.tok == ◂if and p.isThenlessIf(token)
        nod ●return token nil
    else
        p.returning = true

        right ◇ Node 
        if p.tok != ◂indent or p.isNextLineIndented(token)
            right = p.expression(token)
        
        p.returning = false
        nod ●return token right

rDiscard = ◇Parser p ➜Node ->

    token = p.consume()
    if p.isDedent token.col
        nod ●discard token nil
    else
        nod ●discard token p.value()
        
#  ███████   ████████   ████████  ████████    ███████   █████████  ███   ███████   ███   ███
# ███   ███  ███   ███  ███       ███   ███  ███   ███     ███     ███  ███   ███  ████  ███
# ███   ███  ████████   ███████   ███████    █████████     ███     ███  ███   ███  ███ █ ███
# ███   ███  ███        ███       ███   ███  ███   ███     ███     ███  ███   ███  ███  ████
#  ███████   ███        ████████  ███   ███  ███   ███     ███     ███   ███████   ███   ███

lOperation = ◇Parser p ◇Node left ➜Node ->
    token = p.consume()
    right = p.expression(token)
    nod ●operation token left right
    
lNotIn = ◇Parser p ◇Node left ➜Node ->

    if p.peek(1).tok == ◂in
        token = p.consume()
        token.str = "notin"
        token.tok = ◂notin
        p.swallow()
        right = p.expression(token)
        ⮐  nod ●operation token left right

lPostOp = ◇Parser p ◇Node left ➜Node ->

    nod ●postOp p.consume() left

rPreOp = ◇Parser p ➜Node ->

    token = p.consume()
    right = p.expression(token)
    nod ●preOp token right
    
rDollar = ◇Parser p ➜Node ->

    if p.current.str.len > 1
        token = p.consume()
        token.tok = ◂name
        ⮐  nod ●literal token
    if p.peek(1).tok in {◂assign, ◂colon}
        token = p.consume()
        token.tok = ◂name
        ⮐  nod ●literal token
    p.rPreOp()

lAssign = ◇Parser p ◇Node left ➜Node ->

    token = p.consume()
    right = p.funcOrExpression(token)
    nod ●operation token left right

lRange = ◇Parser p ◇Node left ➜Node ->

    token = p.consume()
    right = p.expression(token)
    nod ●range token left right
        
rParenExpr = ◇Parser p ➜Node ->

    nod ●list p.current p.parseParenList()

rCurly = ◇Parser p ➜Node ->

    nod ●curly p.current p.parseDelimitedList(◂bracket_open, ◂bracket_close)

rSquarely = ◇Parser p ➜Node ->

    nod ●squarely p.current p.parseDelimitedList(◂square_open, ◂square_close)

rEnum = ◇Parser p ➜Node ->

    token = p.consume()
    enum_name = p.value()
    enum_body ◇ Node
    if p.isNextLineIndented token
        p.typeless = true
        enum_body = p.parseBlock()
        p.typeless = false
    nod ●enum token enum_name enum_body
    
rClass = ◇Parser p ➜Node ->

    token = p.consume()
    class_name = p.value()
    class_body = p.parseBlock()
    nod ●class token class_name class_body
    
lMember = ◇Parser p ◇Node left ➜Node ->

    token = p.consume()
    right = p.funcOrExpression(token)
    nod ●member token left right
    
lTestCase = ◇Parser p ◇Node left ➜Node ->

    token = p.consume() # ▸
    p.swallow(◂indent) # todo: check if indent is larger than that of the test expression
    right = p.expression()
    nod ●testCase token left right

rTestSuite = ◇Parser p ➜Node ->

    token = p.consume() # ▸
    test_block = p.thenBlock()
    if token.col == 0
        nod ●testSuite token test_block
    else
        nod ●testSection token test_block

# ████████  ███   ███  ████████   ████████   ████████   ███████   ███████  ███   ███████   ███   ███
# ███        ███ ███   ███   ███  ███   ███  ███       ███       ███       ███  ███   ███  ████  ███
# ███████     █████    ████████   ███████    ███████   ███████   ███████   ███  ███   ███  ███ █ ███
# ███        ███ ███   ███        ███   ███  ███            ███       ███  ███  ███   ███  ███  ████
# ████████  ███   ███  ███        ███   ███  ████████  ███████   ███████   ███   ███████   ███   ███

###
   ◂R      ◂LR     ◂L      ◂R      ◂L      ◂LR     ◂R 
   │       │       │       │       │       │ 
   ◂R➜●    │       │       ◂R➜●    │       │ 
      │    │       │          │    │       │
      ╰───●◂L➜●───●◂L➜●       ╰───●◂L➜●───●◂L➜●
                      │                       │
                      ▾                       ▾
###

expression = ◇Parser this precedenceRight=0 ➜Node ->

    token = this.current
    if token.tok in {◂eof, ◂stripol_end, ◂paren_close}
        ⮐  nil

    rhs = this.rightHandSide(token)
    
    if rhs == nil
        ⮐  this.error(&"Expected expression but found {token.str} {token}", token)
        
    node = this.rhs()
    
    if precedenceRight < -1
        ⮐  node

    while not this.atEnd()
        
        token = this.current
        precedence = this.getPrecedence(token)
        
        if token.tok in {◂assign, ◂test}
            precedence += 1
        
        lhs = this.leftHandSide(token)
        
        if precedenceRight >= precedence
            break
    
        if lhs == nil
            break
            
        lhn = this.lhs(node)
        
        if lhn != nil
            node = lhn
        else
            break 
            
        if this.tok == ◂indent and this.peek(1).tok in {◂dot}
             this.swallow()
             node = this.lPropertyAccess node
    node
            
# ████████   ████████    ███████   █████████  █████████
# ███   ███  ███   ███  ███   ███     ███        ███   
# ████████   ███████    █████████     ███        ███   
# ███        ███   ███  ███   ███     ███        ███   
# ███        ███   ███  ███   ███     ███        ███   

pratt = ◇Parser p ◇tok t ◇LHS lhs ◇RHS rhs ◇int precedence ->

    if p.pratts.len <= t.ord
        p.pratts.setLen(t.ord + 1)
    
    p.pratts[t.ord] = Pratt(lhs:lhs, rhs:rhs, precedence:precedence)

#  ███████  ████████  █████████  ███   ███  ████████ 
# ███       ███          ███     ███   ███  ███   ███
# ███████   ███████      ███     ███   ███  ████████ 
#      ███  ███          ███     ███   ███  ███      
# ███████   ████████     ███      ███████   ███      

setup = ◇Parser p ->

    p.pratt ◂true              nil               rLiteral        0
    p.pratt ◂false             nil               rLiteral        0
    p.pratt ◂mod               nil               rLiteral        0
    p.pratt ◂null              nil               rLiteral        0
    p.pratt ◂number            nil               rLiteral        0
    p.pratt ◂string_start      nil               rString         0
    p.pratt ◂comment_start     nil               rComment        0
    p.pratt ◂name              lSymbolList       rSymbol        13 # higher than assign
    p.pratt ◂import            nil               rImport         0
    p.pratt ◂macro             nil               rMacro          0
    p.pratt ◂template          nil               rTemplate       0
    p.pratt ◂converter         nil               rConverter      0
    p.pratt ◂proc              nil               rProc           0
    p.pratt ◂type              nil               rTypeDef        0
    p.pratt ◂use               nil               rUse            0
    p.pratt ◂let               nil               rLet            0
    p.pratt ◂var               nil               rLet            0
    p.pratt ◂return            nil               rReturn         0
    p.pratt ◂discard           nil               rDiscard        0
    p.pratt ◂quote             nil               rQuote          0
    p.pratt ◂test              lTestCase         rTestSuite      0
    
    p.pratt ◂class             nil               rClass          0
    p.pratt ◂enum              nil               rEnum           0
    p.pratt ◂colon             lMember           nil            10
    
    p.pratt ◂continue          nil               rKeyword        0
    p.pratt ◂break             nil               rKeyword        0
                                                                    
    p.pratt ◂assign            lAssign           nil            10
    p.pratt ◂plus_assign       lAssign           nil            10
    p.pratt ◂minus_assign      lAssign           nil            10
    p.pratt ◂divide_assign     lAssign           nil            10
    p.pratt ◂multiply_assign   lAssign           nil            10
    p.pratt ◂ampersand_assign  lAssign           nil            10

    p.pratt ◂if                lTailIf           rIf            20
    p.pratt ◂when              nil               rIf            20
    p.pratt ◂for               nil               rFor           20
    p.pratt ◂switch            nil               rSwitch        20
    p.pratt ◂while             nil               rWhile         20
    p.pratt ◂func              lFunc             rFunc          20
    
    p.pratt ◂or                lOperation        nil            30
    p.pratt ◂and               lOperation        nil            31
    
    p.pratt ◂is                lOperation        nil            32
    p.pratt ◂in                lOperation        nil            33
    p.pratt ◂notin             lOperation        nil            34
    

    p.pratt ◂equal             lOperation        nil            40
    p.pratt ◂not_equal         lOperation        nil            40
    p.pratt ◂greater_equal     lOperation        nil            40
    p.pratt ◂less_equal        lOperation        nil            40
    p.pratt ◂less              lOperation        nil            40
    p.pratt ◂greater           lOperation        nil            40
    p.pratt ◂match             lOperation        nil            40
    
    p.pratt ◂doubledot         lRange            nil            40
    p.pratt ◂tripledot         lRange            nil            40
    
    p.pratt ◂dollar            nil               rDollar        41
    p.pratt ◂ampersand         lOperation        nil            42
    
    p.pratt ◂plus              lOperation        nil            50
    p.pratt ◂minus             lOperation        rPreOp         50
                                                   
    p.pratt ◂multiply          lOperation        nil            60
    p.pratt ◂divide            lOperation        nil            60

    p.pratt ◂not               lNotIn            rPreOp         70

    p.pratt ◂increment         lPostOp           nil            80
    p.pratt ◂decrement         lPostOp           nil            80

    p.pratt ◂square_open       lArrayAccess      rSquarely      90
    p.pratt ◂paren_open        lCall             rParenExpr     90
    p.pratt ◂bracket_open      nil               rCurly         90
    p.pratt ◂then              lReturnType       rReturnType    99
    p.pratt ◂val_type          lArgList          rArg          100
    p.pratt ◂var_type          lArgList          rArg          100
    p.pratt ◂dot               lPropertyAccess   nil           102
    
#  ███████    ███████  █████████
# ███   ███  ███          ███   
# █████████  ███████      ███   
# ███   ███       ███     ███   
# ███   ███  ███████      ███   

ast* = ◇string text ➜Node ->

    # profileStart 'tknz'
    tokens = tokenize text
    # profileStop 'tknz'
    # log &"ast* {tokens}"
    # profileStart 'pars'
    p = Parser(tokens:tokens, pos:0, text:text)
    p.setup()
    b = p.parseBlock()
    # profileStop 'pars'
    ⮐  nil if p.failed
    b
    
    