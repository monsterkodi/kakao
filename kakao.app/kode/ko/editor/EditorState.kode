###
00000000  0000000    000  000000000   0000000   00000000    0000000  000000000   0000000   000000000  00000000
000       000   000  000     000     000   000  000   000  000          000     000   000     000     000     
0000000   000   000  000     000     000   000  0000000    0000000      000     000000000     000     0000000 
000       000   000  000     000     000   000  000   000       000     000     000   000     000     000     
00000000  0000000    000     000      0000000   000   000  0000000      000     000   000     000     00000000
###

use ../../kxk ▪ kstr immutable

function EditorState
    
    @: (stateOrLines = []) ->
        
        @lineCache = []
        
        if immutable.isImmutable stateOrLines
            @s = stateOrLines
        else if stateOrLines is arr
            @s = @stateForLines stateOrLines
            
    stateForLines: (lineStrings) ->
        
        lineId = 0
        linkId = 0
        lines  = {}
        links  = '-1':[-1 linkId]
        
        for lineString,lineIndex in lineStrings
            
            nextLinkId    = lineIndex<lineStrings.length-1 ? linkId+1 : null
            lines[lineId] = lineString
            links[linkId] = [lineId, nextLinkId]
            
            linkId++
            lineId++
            
        mcy = lineId ? 0 : -1
            
        immutable
            
            lineId:      lineId
            linkId:      linkId
            lines:       lines
            links:       links
            
            numLines:    lineId
            numOriginal: lineId
                    
            cursors:     [[0,mcy]]
            selections:  []
            highlights:  []
            main:        0
            
    next: (link) -> if valid link?[1] ➜ @s.links[link[1]]
            
    # 000000000  00000000    0000000   000   000  00000000  00000000    0000000  00000000  
    #    000     000   000  000   000  000   000  000       000   000  000       000       
    #    000     0000000    000000000   000 000   0000000   0000000    0000000   0000000   
    #    000     000   000  000   000     000     000       000   000       000  000       
    #    000     000   000  000   000      0      00000000  000   000  0000000   00000000  
    
    traverse: (cb) ->
        
        lineIndex = 0
        prev = next = @s.links['-1']
        
        while next = @next prev
            if not cb lineIndex, next[0], prev[1] ➜ return
            prev = next
            lineIndex++
            
    # 000      000  000   000  00000000   0000000  
    # 000      000  0000  000  000       000       
    # 000      000  000 0 000  0000000   0000000   
    # 000      000  000  0000  000            000  
    # 0000000  000  000   000  00000000  0000000   
    
    line: (i) ->
        
        if @lineCache[i] ➜ return @lineCache[i]

        l = null
        li = -1
        @traverse (lineIndex, lineId, linkId) => l = @s.lines[lineId]; li = lineIndex; li < i
        
        if li == i
            @lineCache[i] = kstr.detab l 
            
        @lineCache[i]
        
    lines: ->
        
        l = []
        @traverse (lineIndex, lineId, linkId) => l.push @s.lines[lineId]; true
        l
        
    #  0000000  00000000  00000000  000   000  
    # 000       000       000       000  000   
    # 0000000   0000000   0000000   0000000    
    #      000  000       000       000  000   
    # 0000000   00000000  00000000  000   000  
    
    seek: (i) ->
        
        i = max 0 i
        
        info = {}
        prev = null
        
        @traverse (lineIndex, lineId, linkId) => 
            
            info = {lineIndex, lineId, linkId, prev}
            prev = linkId
            lineIndex < i
            
        info
        
    seekLast: -> @seek Infinity

    # 0000000    00000000  000      00000000  000000000  00000000  
    # 000   000  000       000      000          000     000       
    # 000   000  0000000   000      0000000      000     0000000   
    # 000   000  000       000      000          000     000       
    # 0000000    00000000  0000000  00000000     000     00000000  
    
    deleteLine: (i) ->

        info = @seek i
        
        return @ if info.lineIndex != i
        
        s = @s
        if valid info.prev
            s = s.setIn ['links' info.prev], [s.links[info.prev][0], s.links[info.linkId][1]]
        s = s.setIn ['links' info.linkId]
        s = s.set 'numLines' s.numLines-1
        
        new EditorState s
        
    #  0000000  000   000   0000000   000   000   0000000   00000000  
    # 000       000   000  000   000  0000  000  000        000       
    # 000       000000000  000000000  000 0 000  000  0000  0000000   
    # 000       000   000  000   000  000  0000  000   000  000       
    #  0000000  000   000  000   000  000   000   0000000   00000000  
    
    changeLine: (i, t) ->
        
        info = @seek i
        new EditorState @s.setIn ['lines' info.lineId], t
        
    # 000  000   000   0000000  00000000  00000000   000000000  
    # 000  0000  000  000       000       000   000     000     
    # 000  000 0 000  0000000   0000000   0000000       000     
    # 000  000  0000       000  000       000   000     000     
    # 000  000   000  0000000   00000000  000   000     000     
    
    insertLine: (i, t) ->
        
        info = @seek i
                
        s = @s
        s = s.setIn ['lines' s.lineId], t # new line record
        
        if info.lineIndex >= i
            s = s.setIn ['links' s.linkId], [s.lineId, info.linkId] # link new line to next line
            if valid info.prev # insert ▸ change link of previous line
                s = s.setIn ['links' info.prev], [s.links[info.prev][0], s.linkId]
            else
                s = s.setIn ['links' '-1'], [-1, s.linkId] # prepend ▸ link root to new line
        else 
            s = s.setIn ['links' s.linkId], [s.lineId, null] # # append ▸ link new line to nada
            if valid info # link previously last line to new line
                s = s.setIn ['links' info.linkId], [s.links[info.linkId][0], s.linkId] 
            
        s = s.set 'lineId'   s.lineId+1 
        s = s.set 'linkId'   s.linkId+1 
        s = s.set 'numLines' s.numLines+1
        
        new EditorState s
        
    #  0000000   00000000   00000000   00000000  000   000  0000000    
    # 000   000  000   000  000   000  000       0000  000  000   000  
    # 000000000  00000000   00000000   0000000   000 0 000  000   000  
    # 000   000  000        000        000       000  0000  000   000  
    # 000   000  000        000        00000000  000   000  0000000    
    
    appendLine: (t) -> @insertLine Infinity, t
    
    # read only:
    
    text: (n='\n') -> @lines().join n
    tabline:   (i) -> @lines()[i]
    
    cursors:       -> @s.cursors.asMutable    deep: true
    highlights:    -> @s.highlights.asMutable deep: true
    selections:    -> @s.selections.asMutable deep: true
    main:          -> @s.main

    cursor:    (i) -> @s.cursors[i]?.asMutable    deep: true
    selection: (i) -> @s.selections[i]?.asMutable deep: true
    highlight: (i) -> @s.highlights[i]?.asMutable deep: true

    numLines:      -> @s.numLines 
    numCursors:    -> @s.cursors.length
    numSelections: -> @s.selections.length
    numHighlights: -> @s.highlights.length
    mainCursor:    -> @s.cursors[@s.main].asMutable deep: true

    # modify:
        
    lineState: (s) -> ns = new EditorState(s); ns.lineCache = @lineCache; ns

    setSelections: (s) -> @lineState @s.set 'selections' s
    setHighlights: (h) -> @lineState @s.set 'highlights' h
    setCursors:    (c) -> @lineState @s.set 'cursors'    c
    setMain:       (m) -> @lineState @s.set 'main'       m
    
    addHighlight:  (h) -> m = @s.highlights.asMutable(); m.push h; @lineState @s.set 'highlights' m

export EditorState
