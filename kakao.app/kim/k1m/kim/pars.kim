# ████████    ███████   ████████    ███████
# ███   ███  ███   ███  ███   ███  ███     
# ████████   █████████  ███████    ███████ 
# ███        ███   ███  ███   ███       ███
# ███        ███   ███  ███   ███  ███████ 

use kommon tknz

enum NodeKind*
    
    ●error
    ●block
    ●comment
    ●literal
    ●string
    ●stripol
    ●keyword  
    ●preOp 
    ●operation 
    ●postOp
    ●call
    ●if
    ●condThen
    ●for 
    ●list
    ●curly
    ●squarely
    ●range 
    ●while
    ●switch
    ●switchCase
    ●arg
    ●var        
    ●let        
    ●propertyAccess        
    ●arrayAccess
    ●arrayLike
    ●func
    ●type
    ●signature
    ●return 
    ●discard 
    ●break 
    ●continue          
    ●use 
    ●import
    ●template
    ●converter
    ●macro
    ●proc
    ●typeDef
    ●enum
    ●class
    ●member
    ●testSuite
    ●testSection
    ●testCase
    ●eof
    
# ███   ███   ███████   ███████    ████████
# ████  ███  ███   ███  ███   ███  ███     
# ███ █ ███  ███   ███  ███   ███  ███████ 
# ███  ████  ███   ███  ███   ███  ███     
# ███   ███   ███████   ███████    ████████

type Node* = ref object

    token* : Token
        
    switch kind* : NodeKind
    
        ●block
            
            expressions*    : seq[Node]
            
        ●operation
        
            operand_left*   : Node
            operand_right*  : Node
            
        ●string
        
            string_content*  : Node
            string_stripols* : seq[Node]
            
        ●comment
        
            comment_content* : Node
            
        ●stripol
        
            stripol_xprssns* : seq[Node]
            stripol_content* : Node
    
        ●range
        
            range_start*    : Node
            range_end*      : Node
            
        ●postOp, ●preOp
        
            operand*        : Node 
            
        ●return
        
            return_value*   : Node  
    
        ●discard
        
            discard_value*  : Node  
    
        ●call
        
            callee*         : Node
            call_args*      : seq[Node]
    
        ●propertyAccess
        
            owner*          : Node
            property*       : Node
            
        ●arrayAccess
        
            array_owner*    : Node
            array_index*    : Node
            
        ●if
            # also handles when
            cond_thens*     : seq[Node]
            `else`*         : Node
            
        ●condThen
        
            cond*           : Node
            then*           : Node
            
        ●switch
            
            switch_value*   : Node
            switch_cases*   : seq[Node]
            switch_default* : Node
            
        ●switchCase
        
            case_when*      : seq[Node]
            case_then*      : Node
            
        ●while
        
            while_cond*     : Node
            while_body*     : Node
            
        ●for
        
            for_value*      : Node
            for_range*      : Node
            for_body*       : Node
            
        ●list, ●curly, ●squarely
        
            list_values*    : seq[Node] 

        ●arg
        
            arg_type*       : Node
            arg_name*       : Node
            arg_value*      : Node
            
        ●var
        
            var_name*       : Node
            var_type*       : Node
            var_value*      : Node
            
        ●let
            
            let_expr*       : Node
            
        ●signature
        
            sig_args*       : Node
            sig_type*       : Node
            
        ●func
        
            func_signature* : Node
            func_mod*       : Node
            func_body*      : Node
            
        ●use
        
            use_module*     : Node
            use_kind*       : Node
            use_items*      : seq[Node]
            
        ●class
            
            class_name*     : Node
            class_body*     : Node
            
        ●member
        
            member_key*     : Node
            member_value*   : Node
            
        ●enum
            
            enum_name*      : Node
            enum_body*      : Node
            
        ●testSuite, ●testSection
        
            test_block*     : Node
                        
        ●testCase
            
            test_value*     : Node
            test_expected*  : Node
            
        else
            discard
                
template choose*(cond, a, b: untyped): untyped =

    when typeof(cond) is bool
        if cond 
            a 
        else 
            b
    elif typeof(cond) is ref
        if cond != nil 
            a 
        else 
            b
    else
        {.error: "Condition must be bool or ref type".}

# ████████    ███████   ████████    ███████  ████████  ████████ 
# ███   ███  ███   ███  ███   ███  ███       ███       ███   ███
# ████████   █████████  ███████    ███████   ███████   ███████  
# ███        ███   ███  ███   ███       ███  ███       ███   ███
# ███        ███   ███  ███   ███  ███████   ████████  ███   ███

{.experimental: "codeReordering".}

type RHS = proc(p: Parser): Node
type LHS = proc(p: Parser, left: Node): Node
    
type Pratt = object
        rhs         : RHS
        lhs         : LHS
        precedence  : int
         
type Parser* = ref object
        tokens*     : seq[Token]
        pratts*     : seq[Pratt]
        blocks*     : seq[Node]
        pos*        : int
        explicit    : bool
        listless    : bool
        returning   : bool
        typeless    : bool
        text        : string # used in `$` for debugging. should be removed eventually 
    
proc current(p: Parser): Token =

    if p.pos < p.tokens.len
        ⮐  p.tokens[p.pos]
        
    Token(tok:◂eof, line: -1, col: -1)
    
proc tok(p: Parser) : tok = p.current.tok

proc peek(p: Parser, ahead=1): Token =

    if p.pos + ahead < p.tokens.len
        p.tokens[p.pos + ahead]
    else
        Token(tok:◂eof)

# ████████   ████████   ███  ███   ███  █████████  
# ███   ███  ███   ███  ███  ████  ███     ███     
# ████████   ███████    ███  ███ █ ███     ███     
# ███        ███   ███  ███  ███  ████     ███     
# ███        ███   ███  ███  ███   ███     ███     

proc `$`(p: Parser): string = 

    var s : string
    if p.tok != ◂eof
        s = "▪▪▪ #{p.current} #{p.pos}"
        let l = p.text.split("\n")[p.current.line]
        s &= "\n#{p.current.line}: #{l}"
    else
        s = p.text
    s

proc `$`*(n: Node): string = 

    if n == nil
        ⮐  "NIL"
        
    var s = "#{n.token.tok}"
    
    switch n.kind
        ●block
            s = "▪["
            for e in n.expressions
                if e != nil
                    s &= "#{e}"
                else
                    s &= "NIL"
            s &= "]"
        ●operation
            s = "(#{n.operand_left} #{s} #{n.operand_right})"
        ●range
            s = "(#{n.range_start} #{s} #{n.range_end})"
        ●string
            var ips = ""
            for i,s in n.string_stripols
                if i == 0
                    ips &= "\#{"
                ips &= $s.stripol_xprssns
                if 0 < i and i < n.string_stripols.len-1
                    ips &= " "
                if i == n.string_stripols.len-1
                    ips &= "}"
            s = "◂string#{ips}"
        ●preOp
            s = "(#{s} #{n.operand})"
        ●postOp
            s = "(#{n.operand} #{s})"
        ●return
            let e = choose(n.return_value, " #{n.return_value}", "")
            s = "(#{s}#{e})"
        ●call
            s = "(#{n.callee} ◂call #{n.callargs})"
        ●propertyAccess
            s = "(#{n.owner} #{s} #{n.property})"
        ●if
            let e = choose(n.else, " #{n.else}", "")
            s = "(#{s} #{n.cond_thens}#{e})"
        ●condThen
            s = "(#{n.cond} #{n.then})"
        ●switch
            let e = choose(n.switch_default, " #{n.switch_default}", "")
            s = "(#{s} #{n.switch_value} #{n.switch_cases}#{e})"
        ●switchCase
            s = "(#{n.case_when} #{n.case_then})"
        ●for
            let b = choose(n.for_body, " #{n.for_body}", "")
            s = "(#{s} #{n.for_value} in #{n.for_range}#{b})"
        ●list
            s = "#{n.list_values}"
            s = "◂" & s[1..^1]
        ●curly
            s = "#{n.list_values}"
            s = "{" & s[2..^2] & "}"
        ●squarely
            s = "#{n.list_values}"
            s = "[" & s[1..^1] & "]]"
        ●while
            let b = choose(n.while_body, " #{n.while_body}", "")
            s = "(#{s} #{n.while_cond}#{b})"
        ●func
            let sig = choose(n.func_signature, "#{n.func_signature} ", "")
            let mdf = choose(n.func_mod, " #{n.func_mod.token.str} ", "")
            let bdy = choose(n.func_body, " #{n.func_body}", "")
            s = "(#{sig}#{s}#{mdf}#{bdy})"
        ●signature
            let a = choose(n.sig_args, "#{n.sig_args}", "")
            let t = choose(n.sig_type, " ➜ #{n.sig_type}", "")
            s = "#{a}#{t}"
        ●arrayAccess
            let i = choose(n.array_index, "#{n.array_index}", "")
            s = "(#{n.array_owner}[#{i}])"
        ●arg
            let t = choose(n.arg_type, "#{n.arg_type}", "")
            let v = choose(n.arg_value, " (= #{n.arg_value})", "")
            s = "(#{s}#{t} #{n.arg_name}#{v})"
        ●var
            let t = choose(n.var_type, " #{s}#{n.var_type}", "")
            let v = choose(n.var_value, " (= #{n.var_value})", "")
            s = "(#{n.var_name}#{t}#{v})"
        ●let
            s = "(#{s} #{n.let_expr})"
        ●type
            s = "type(#{n.token.str})"
        ●use
            let k = choose(n.use_kind, " #{n.use_kind.token.str}", "")
            let i = choose(n.use_items.len>0, " #{n.use_items}", "")
            s = "(#{s} #{n.use_module}#{k}#{i})"
        ●enum    
            let b = choose(n.enum_body, " #{n.enum_body}", "")
            s = "(#{s} #{n.enum_name}#{b})"
        ●class    
            let b = choose(n.class_body, " #{n.class_body}", "")
            s = "(#{s} #{n.class_name}#{b})"
        ●member
            s = "(#{n.member_key} #{s} #{n.member_value})"
        ●testSuite
            let b = choose(n.test_block, " #{n.test_block}", "")
            s = "(#{s} suite#{b})"
        ●testSection
            let b = choose(n.test_block, " #{n.test_block}", "")
            s = "(#{s} section#{b})"
        ●testCase
            s = "(#{n.test_value} #{s} #{n.test_expected})"
        else
            discard
    s

proc formatValue*(result:var string, n:Node,   specifier: string) = result.add $n
proc formatValue*(result:var string, p:Parser, specifier: string) = result.add $p
proc error(p: Parser, msg: string, token=Token(tok:◂eof)) : Node =

    styledEcho fgRed, styleDim, "△ ", resetStyle, fgYellow, msg
    if token.tok != ◂eof
        let line = p.text.split("\n")[token.line]
        styledEcho fgWhite, styleDim, "#{token.line}", resetStyle, fgGreen, "#{line}"
    elif p.tok != ◂eof
        let line = p.text.split("\n")[p.current.line]
        styledEcho fgWhite, styleDim, "#{p.current.line}", resetStyle, fgGreen, "#{line}"
        
    nil
    
#  ███████   ███████   ███   ███   ███████  ███   ███  ██     ██  ████████
# ███       ███   ███  ████  ███  ███       ███   ███  ███   ███  ███     
# ███       ███   ███  ███ █ ███  ███████   ███   ███  █████████  ███████ 
# ███       ███   ███  ███  ████       ███  ███   ███  ███ █ ███  ███     
#  ███████   ███████   ███   ███  ███████    ███████   ███   ███  ████████

proc consume(p: Parser): Token =

    let t = p.current
    if p.pos < p.tokens.len
        p.pos += 1
    t

proc swallow(p: Parser) =

    discard p.consume()

proc swallow(p: Parser, tok: tok) =

    if p.tok == tok
        p.swallow()
        
proc swallowError(p: Parser, tok: tok, err: string) = 

    if p.tok != tok
        discard p.error("Expected #{tok} to swallow, but found #{p.tok} instead")
        discard p.error(err)
        ⮐  
    p.swallow()
            
proc swallowSameIndent(p: Parser, indent:int): bool = 

    if p.tok == ◂indent and p.current.str.len == indent
        p.swallow()
        ⮐  true
    false
    
proc atIndent(p: Parser) : bool =

    p.current.col == 0 or p.peek(-1).tok == ◂indent
        
proc atEnd(p:Parser): bool = p.pos >= p.tokens.len

proc isDedent(p: Parser, indent:int): bool =

    if p.tok == ◂indent
        p.current.str.len < indent
    else
        p.current.col < indent
        
proc isNextLineIndented(p: Parser, token:Token): bool =

    var n = 0
    while p.peek(n).tok != ◂indent
        n += 1
        if p.peek(n).tok == ◂eof
            ⮐  false
        
    ⮐  p.peek(n).str.len > token.col
    
proc isTokAhead(p: Parser, tokAhead:tok) : bool =

    var n = 0
    var c = p.current
    let line = c.line
    while c.tok != ◂eof
        if c.line > line
            ⮐  false
        if c.tok == tokAhead
            ⮐  true
        n += 1
        c = p.peek n
    false    

proc isThenlessIf(p:Parser, token:Token) : bool =

    if p.isNextLineIndented token
        ⮐  false

    not p.isTokAhead ◂then
    
proc getPrecedence(p: Parser, token: Token): int =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].precedence
    0
    
proc rightHandSide(p: Parser, token: Token): RHS =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].rhs

proc leftHandSide(p: Parser, token: Token): LHS =

    if token.tok.ord < p.pratts.len
        ⮐  p.pratts[token.tok.ord].lhs

proc expression(p: Parser, precedenceRight = 0): Node
    
proc expression(p: Parser, tokenRight:Token ): Node =

    expression(p, p.getPrecedence(tokenRight))

proc value(p: Parser) : Node = p.expression(-2)

# ███████    ███       ███████    ███████  ███   ███
# ███   ███  ███      ███   ███  ███       ███  ███ 
# ███████    ███      ███   ███  ███       ███████  
# ███   ███  ███      ███   ███  ███       ███  ███ 
# ███████    ███████   ███████    ███████  ███   ███

proc parseBlock(p:Parser, bn:Node=nil): Node =

    var token: Token
    var block_indent : int
    while p.tok == ◂indent
        token = p.consume() 
        block_indent = p.current.col
    
    var bn = bn
    if bn == nil
        bn = Node(token:token, kind:●block, expressions: @[])
        
    var expr : Node = p.expression()
    
    while expr != nil
    
        if expr.kind == ●func and bn.expressions.len
            var prevExpr = bn.expressions[^1]
            if prevExpr.token.line == expr.token.line and prevExpr.token.tok == ◂assign
                prevExpr = bn.expressions.pop()
                if prevExpr.operand_right.kind == ●operation
                    var argtoken = prevExpr.operand_right.operand_left.token
                    argtoken.tok = ◂val_type
                    let argnode = Node(token:argtoken, kind:●arg, arg_name:prevExpr.operand_right.operand_left, arg_value:prevExpr.operand_right.operand_right)
                    expr.func_signature.sig_args.list_values.unshift(argnode)
                else
                    expr.func_signature.sig_args.list_values.unshift(prevExpr.operand_right)
                prevExpr.operand_right = expr
                expr = prevExpr
                
        bn.expressions.add expr
        if p.tok == ◂indent
            let ind = p.current.str.len
            if ind < block_indent
                break
            elif ind > block_indent
                p.blocks.add bn
                expr = p.parseBlock()
                bn = p.blocks.pop()
                continue
            else
                p.swallow()
                
        if p.current.col < block_indent
            break
            
        expr = p.expression()
    bn

proc expressionOrIndentedBlock(p: Parser, token:Token, col:int): Node =

    if p.tok == ◂indent
        if p.current.str.len > col
            ⮐  p.parseBlock()
    else
        ⮐  p.expression(token)
            
#  ███████   ███████   ███      ███       ███████   ████████    ███████    ███████
# ███       ███   ███  ███      ███      ███   ███  ███   ███  ███        ███     
# ███       █████████  ███      ███      █████████  ███████    ███  ████  ███████ 
# ███       ███   ███  ███      ███      ███   ███  ███   ███  ███   ███       ███
#  ███████  ███   ███  ███████  ███████  ███   ███  ███   ███   ███████   ███████ 

proc swallowIndent(p:Parser, col:int) : bool = 

    p.swallow ◂comma
    if p.tok == ◂indent
        if p.current.str.len > col
            p.swallow()
        else
            ⮐  true
    false
    
proc parseCallArgs(p:Parser, col:int) : seq[Node] = 

    p.explicit = true
    p.listless = true
    var list : seq[Node]
    let line = p.current.line
    var expr : Node = p.expression()
    while expr != nil
        list.add expr
        if p.swallowIndent(col)
            break
        if p.tok in {◂comment_start, ◂then}
            break
        expr = p.expression()
    p.listless = false
    p.explicit = false
    list
    
# █████████  ███   ███  ████████   ████████
#    ███      ███ ███   ███   ███  ███     
#    ███       █████    ████████   ███████ 
#    ███        ███     ███        ███     
#    ███        ███     ███        ████████

proc parseType(p: Parser): Node =
    
    var token = p.consume()
    token.tok = ◂type
    
    if p.tok == ◂square_open
        var opened = 0
        while p.tok not in {◂eof}
            let t = p.consume()
            token.str &= t.str
            if t.tok == ◂square_open
                opened += 1
            elif t.tok == ◂square_close
                opened -= 1
                if opened == 0
                    break
    
    Node(token:token, kind:●type)
    
proc parseVar(p: Parser): Node = 

    var token = p.current()
    let var_name = p.value()
    var var_value : Node
    var var_type  : Node
    
    if p.tok == ◂assign
        p.swallow()
        var_value = p.expression()
    elif p.tok in {◂val_type, ◂var_type}
        token = p.consume()
        var_type = p.parseType()
        if p.tok == ◂assign
            p.swallow()
            var_value = p.expression()
    
    Node(token:token, kind: ●var, var_name:var_name, var_type:var_type, var_value:var_value)
    
proc parseModule(p:Parser) : Node = 

    let line = p.current.line
    var s = ""
    while p.current.str not in @["▪", "◆"]
        let e = p.current.col + p.current.str.len
        s &= p.consume().str
        if p.atEnd() or p.current.line != line
            break 
        if p.current.col > e and p.current.str not in @["▪", "◆"] 
            s &= " "
        
    Node(token:Token(str:s))    

# ███      ███   ███████  █████████
# ███      ███  ███          ███   
# ███      ███  ███████      ███   
# ███      ███       ███     ███   
# ███████  ███  ███████      ███   

proc parseParenList(p: Parser): seq[Node] =

    let token = p.consume() # (
    
    var args : seq[Node]
    p.explicit = true
    while p.tok != ◂paren_close and p.tok != ◂eof
        args.add p.expression()
        p.swallow ◂comma
    p.swallowError(◂paren_close, "Missing closing parenthesis")
    p.explicit = false
    if args.len == 1 and args[0].kind == ●list
        ⮐  args[0].list_values
    args
    
proc parseDelimitedList(p: Parser, open:tok, close:tok): seq[Node] =

    let token = p.consume()
    var args : seq[Node]
    
    p.explicit = true
    while true
        discard p.swallowIndent(-1)
        if p.tok != close and p.tok != ◂eof
            args.add p.expression()
        else
            break
    p.swallowError(close, "Missing closing bracket")
    p.explicit = false
    
    if args.len == 1 and args[0].kind == ●list
        ⮐  args[0].list_values
    args
    
proc parseNames(p:Parser) : seq[Node] = 

    var list : seq[Node]
    let line = p.current.line
    p.explicit = true
    var expr : Node = p.rSymbol()
    while expr != nil
        list.add expr        
        if p.current.line != line
            break
        p.swallow ◂comma
        expr = p.rSymbol()
    p.explicit = false
    list

proc parseNamesUntil(p: Parser, stop: tok) : Node =

    let token = p.current
                                
    var list_values: seq[Node]
    p.explicit = true
    while p.tok != stop
        if p.tok == ◂eof
            ⮐  p.error("Missing 'in' for 'for' loop (edetected)!", token)
        if p.current.line != token.line
            ⮐  p.error("Missing 'in' for 'for' loop (linebreak detected)!", token)
        list_values.add p.rSymbol()
        p.swallow ◂comma
    p.explicit = false
    if list_values.len == 1
        list_values[0]
    else
        Node(token:token, kind:●list, list_values:list_values)
    
# █████████  ███   ███  ████████  ███   ███
#    ███     ███   ███  ███       ████  ███
#    ███     █████████  ███████   ███ █ ███
#    ███     ███   ███  ███       ███  ████
#    ███     ███   ███  ████████  ███   ███

proc then(p: Parser) : Node = 

    if p.tok == ◂then
        p.swallow ◂then
        
    if p.tok == ◂indent
        p.parseBlock()
    else
        p.expression()
    
#  ███████   ███████   ███      ███    
# ███       ███   ███  ███      ███    
# ███       █████████  ███      ███    
# ███       ███   ███  ███      ███    
#  ███████  ███   ███  ███████  ███████

proc lCall(p: Parser, callee: Node): Node =

    let token = p.consume() # (
    let args = p.parseCallArgs(callee.token.col)
    p.swallowError(◂paren_close, "Missing closing paren for call arguments")    
    Node(token:token, kind:●call, callee:callee, callargs:args)
    
# ███  ██     ██  ████████   ███      ███   ███████  ███  █████████
# ███  ███   ███  ███   ███  ███      ███  ███       ███     ███   
# ███  █████████  ████████   ███      ███  ███       ███     ███   
# ███  ███ █ ███  ███        ███      ███  ███       ███     ███   
# ███  ███   ███  ███        ███████  ███   ███████  ███     ███   

proc isImplicitCallPossible(p: Parser, token: Token) : bool =     

    let currt = p.peek(0)

    if not p.explicit and currt.tok not in {◂indent} and not p.isTokAhead(◂func)
        if currt.col > token.col+token.str.len
            const optoks= { ◂then, ◂else, ◂elif, ◂test,
                            ◂val_type, ◂var_type, ◂colon,
                            ◂plus, ◂minus, ◂divide, ◂multiply, ◂and, ◂or, ◂ampersand, ◂is, ◂in, ◂not in,
                            ◂equal, ◂not_equal, ◂greater_equal, ◂less_equal, ◂greater, ◂less,
                            ◂assign, ◂divide_assign, ◂multiply_assign, ◂plus_assign, ◂minus_assign, ◂ampersand_assign}
            if currt.tok not in optoks
                ⮐  true
    false
    
proc rSymbol(p: Parser): Node =

    let token = p.consume()

    if p.isImplicitCallPossible token
        let args = p.parseCallArgs(token.col)
        ⮐  Node(token:token, kind:●call, callee:Node(token:token, kind:●literal), callargs:args)

    Node(token:token, kind:●literal)
        
# ███  ████████                             ███  ████████                               ███  ████████  
# ███  ███                                  ███  ███                                    ███  ███       
# ███  ██████                               ███  ██████                                 ███  ██████    
# ███  ███                                  ███  ███                                    ███  ███       
# ███  ███                                  ███  ███                                    ███  ███       

proc rIf(p: Parser): Node =

    let token = p.consume() # if or when
    var condThens: seq[Node]

    let ifIndent = token.col
    var condIndt = ifIndent
    
    if p.tok == ◂indent
        condIndt = p.current.str.len
        if condIndt <= ifIndent
            ⮐  p.error "Expected indentation after 'if' without condition"
        p.swallow ◂indent # block indentation
    
    var cond = p.expression() # initial condition
            
    var then = p.then()
    
    condThens.add(Node(token:cond.token, kind:●condThen, cond:cond, then:then))
    
    var outdent = false
    
    while p.tok in {◂elif, ◂indent}
    
        if p.tok == ◂indent            
            if p.current.str.len < ifIndent
                outdent = true
                break
            if ifIndent < condIndt 
                if p.current.str.len < condIndt
                    break
            if p.peek(1).tok != ◂elif and p.current.str.len == ifIndent
                break
            p.swallow ◂indent
            if p.tok == ◂comment_start
                p.swallow()
                p.swallow ◂comment
            if p.tok == ◂indent
                continue
                
        p.swallow(◂elif)
        if p.tok in {◂then, ◂else}
            break # then without condition -> else
        
        cond = p.expression()
        
        then = p.then()
        
        condThens.add(Node(token:cond.token, kind:●condThen, cond:cond, then:then))
        
    var elseBranch: Node

    if not outdent    
        p.swallow(◂indent)
        
        if p.tok in {◂else, ◂then}
            p.swallow() # else or then without condition
            elseBranch = p.then()
    
    Node(token:token, kind:●if, cond_thens:condThens,`else`:elseBranch)

# █████████   ███████   ███  ███         ███  ████████
#    ███     ███   ███  ███  ███         ███  ███     
#    ███     █████████  ███  ███         ███  ██████  
#    ███     ███   ███  ███  ███         ███  ███     
#    ███     ███   ███  ███  ███████     ███  ███     

proc lTailIf(p: Parser, left: Node) : Node =

    if p.returning
        ⮐ 
        
    if left.token.line != p.current.line
        ⮐  
        
    # log "TAILIF {left} {left.token.line} {p.current.line} {p.explicit}"
    let token = p.consume()
    var cond  = p.expression()
    let condThen = Node(token:cond.token, kind:●condThen, cond:cond, then:left)

    Node(token:token, kind:●if, cond_thens: @[condThen])
        
# ████████   ███████   ████████ 
# ███       ███   ███  ███   ███
# ██████    ███   ███  ███████  
# ███       ███   ███  ███   ███
# ███        ███████   ███   ███

proc rFor(p: Parser): Node = 

    let token = p.consume()
    let for_value = p.parseNamesUntil ◂in
    p.swallowError(◂in, "Expected 'in' after for value")
    let for_range = p.expression()
    let for_body  = p.then()

    Node(token:token, kind:●for, for_value:for_value, for_range:for_range, for_body:for_body)

proc rWhile(p: Parser): Node =

    Node(token:p.consume(), kind:●while, while_cond:p.expression(), while_body:p.then())

#  ███████  ███   ███  ███  █████████   ███████  ███   ███
# ███       ███ █ ███  ███     ███     ███       ███   ███
# ███████   █████████  ███     ███     ███       █████████
#      ███  ███   ███  ███     ███     ███       ███   ███
# ███████   ██     ██  ███     ███      ███████  ███   ███

proc switchCase(p: Parser, baseIndent: int): Node =

    var case_when: seq[Node]
    let token = p.current
    
    p.explicit = true
    while p.tok not in {◂else, ◂then, ◂indent, ◂eof}
        case_when.add p.value()
        p.swallow ◂comma
    p.explicit = false
    
    let case_then = p.then()
                
    if case_then == nil
        ⮐  p.error("Expected case body after match(es)", token)
    
    Node(token:token, kind:●switchCase, case_when:case_when, case_then:case_then)

proc rSwitch(p: Parser): auto =

    let token = p.consume()
    let switch_value = p.expression()
    
    if switch_value == nil
        ⮐  p.error("Expected value after switch keyword", token)
    
    let baseIndent = p.current.str.len 
    
    p.swallowError(◂indent, "Expected indentation after switch statement")
    
    var switch_cases: seq[Node]
    
    while p.tok not in {◂else, ◂then, ◂eof}
        if p.isDedent baseIndent
            break
        if p.tok == ◂indent and p.peek(1).tok == ◂then
            p.swallow() # indent followed by a ➜ is else
            break
        if p.swallowSameIndent baseIndent
            continue

        let switch_case = p.switchCase(baseIndent)
        if switch_case == nil
            ⮐  p.error("Failed to parse switch case", token)
        else
            switch_cases.add switch_case
    
    var switch_default: Node
    
    if p.tok in {◂else, ◂then}
        p.swallow()
        switch_default = 
            if p.tok == ◂indent and p.current.str.len > baseIndent
                p.swallow()
                p.expression()
            else
                p.expression()
        
        if switch_default == nil
            ⮐  p.error("Expected default value", token)
    
    Node(token:token, kind:●switch, switch_value:switch_value, switch_cases:switch_cases, switch_default:switch_default)
                
proc lArrayAccess(p: Parser, array_owner: Node): Node =

    let token = p.current()
    let array_indices = p.parseDelimitedList(◂square_open, ◂square_close)
    var array_index = 
        switch array_indices.len
            0
                nil
            1
                array_indices[0]
            else
                Node(token:token, kind:●list, list_values:array_indices)
        
    Node(token:token, kind:●arrayAccess, array_owner:array_owner, array_index:array_index)

proc rLiteral(p: Parser): Node =

    Node(token:p.consume(), kind: ●literal)
    
proc lPropertyAccess(p: Parser, owner: Node): Node =

    let token = p.consume()
    let property = p.rLiteral()
    
    let n = Node(token:token, kind:●propertyAccess, owner:owner, property:property)
    
    if p.isImplicitCallPossible property.token
        ⮐  Node(token:token, kind:●call, callee:n, callargs:p.parseCallArgs(token.col))
    n

proc rKeyword(p: Parser): Node =

    Node(token:p.consume(), kind: ●keyword)
    
proc rImport    (p: Parser): Node = Node(token:p.consume(), kind: ●import)
proc rProc      (p: Parser): Node = Node(token:p.consume(), kind: ●proc)
proc rTypeDef   (p: Parser): Node = Node(token:p.consume(), kind: ●typeDef)
proc rMacro     (p: Parser): Node = Node(token:p.consume(), kind: ●macro)
proc rTemplate  (p: Parser): Node = Node(token:p.consume(), kind: ●template)
proc rConverter (p: Parser): Node = Node(token:p.consume(), kind: ●converter)
        
proc rLet(p: Parser): Node =

    Node(token:p.consume(), kind: ●let, let_expr:p.parseVar())
    
#  ███████  █████████  ████████   ███  ███   ███   ███████ 
# ███          ███     ███   ███  ███  ████  ███  ███      
# ███████      ███     ███████    ███  ███ █ ███  ███  ████
#      ███     ███     ███   ███  ███  ███  ████  ███   ███
# ███████      ███     ███   ███  ███  ███   ███   ███████ 

proc rString(p: Parser): Node =

    let token = p.consume() # string start

    if p.tok == ◂string_end
        p.swallow()
        Node(token:token, kind:●string, string_content:Node(token:Token(str:"", tok:◂string), kind:●literal))
    else
        var string_content : Node 
        if p.tok != ◂stripol_start
            string_content = Node(token:p.consume(), kind:●literal)
        else
            string_content = Node(token:Token(str:"", tok:◂string, line:p.current.line, col:p.current.col), kind:●literal)
            
        var string_stripols : seq[Node]
        while p.tok not in {◂string_end, ◂eof}
        
            p.swallowError(◂stripol_start, "Expected string interpolation start")
            
            var stripol = Node(token:p.current, kind:●stripol)
            
            var stripol_xprssns : seq[Node]
            while p.tok not in {◂stripol_end, ◂eof}
                let xpr = p.expression()
                stripol_xprssns.add xpr
                
            stripol.stripol_xprssns = stripol_xprssns
            
            p.swallowError(◂stripol_end, "Expected string interpolation end")
            if p.tok not in {◂stripol_start, ◂string_end, ◂eof}
                stripol.stripol_content = Node(token:p.consume(), kind:●literal)
            elif p.tok == ◂stripol_start
                stripol.stripol_content = Node(token:Token(str:"", tok:◂string, line:p.current.line, col:p.current.col), kind:●literal)
            
            string_stripols.add stripol
            
        p.swallowError(◂string_end, "Expected closing string delimiter")
        Node(token:token, kind:●string, string_content:string_content, string_stripols:string_stripols)

proc rUse(p: Parser): Node =

    let token = p.consume()
    let use_module = p.parseModule()
    if not p.atEnd() and p.current.line == token.line
        let use_kind = p.rSymbol()
        let use_items  = p.parseNames()
        Node(token:token, kind:●use, use_module:use_module, use_kind:use_kind, use_items:use_items) 
    else
        Node(token:token, kind:●use, use_module:use_module) 
        
proc rComment(p: Parser): Node = 

    let n = Node(token:p.consume(), kind:●comment, comment_content:Node(token:p.consume()))
    p.swallow ◂comment_end
    n
    
proc rReturnType(p: Parser): Node =

    Node(token:p.consume(), kind:●signature, sig_type:p.parseType())

proc lReturnType(p: Parser, left: Node): Node =

    if not p.isTokAhead(◂func)
        ⮐  

    if left.kind in {●list, ●arg, ●operation}
        if left.kind == ●operation 
            if left.token.tok == ◂assign
                var sig = p.rReturnType()
                let argtoken = Token(tok:◂val_type, line:left.token.line, col:left.token.col)
                let argNode  = Node(token:argtoken, kind:●arg, arg_name:left.operand_left, arg_value:left.operand_right)
                sig.sig_args = Node(token:left.token, kind:●list, list_values: @[argNode])
                ⮐  sig
        elif left.kind == ●list
            var sig = p.rReturnType()
            sig.sig_args = left
            ⮐  sig
        elif left.kind == ●arg
            var sig = p.rReturnType()
            sig.sig_args = Node(token:left.token, kind:●list, list_values: @[left])
            ⮐  sig
                    
proc rArg(p: Parser) : Node =

    let token = p.consume() # ◆ or ◇
    
    if p.typeless
        var nameToken = p.consume()
        nameToken.tok = ◂name
        nameToken.str = token.str & nameToken.str
        nameToken.col = token.col
        ⮐  Node(token:nameToken, kind:●literal)

    let arg_type = p.parseType()
    let arg_name = p.value()
    var arg_value : Node
    
    if p.tok == ◂assign
        let t = p.consume() # =
        arg_value = p.expression() 
    
    Node(token:token, kind:●arg, arg_type:arg_type, arg_name:arg_name, arg_value:arg_value)

proc lVar(p: Parser, left: Node) : Node =

    if left.token.tok != ◂name
        ⮐  
    let token    = p.consume() # ◆ or ◇
    let var_type = p.parseType()
    var var_value : Node
    
    if p.tok == ◂assign
        let t = p.consume() # =
        var_value = p.expression() 
    Node(token:token, kind:●var, var_name:left, var_type:var_type, var_value:var_value)

proc lSymbolList(p: Parser, left: Node) : Node =

    if p.listless
        ⮐  

    switch left.kind 
        ●list
            var list_values = left.list_values
            # todo: check if all list items are symbols?
            list_values.add p.rSymbol()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        ●literal
            if left.token.tok != ◂name
                ⮐  
            var list_values : seq[Node]
            list_values.add left
            list_values.add p.rSymbol()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        else
            discard

proc lArgList(p: Parser, left: Node) : Node =
    
    switch left.kind 
        ●list
            var list_values = left.list_values
            list_values.add p.rArg()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        ●arg
            var list_values : seq[Node]
            list_values.add left
            list_values.add p.rArg()
            ⮐  Node(token:left.token, kind:●list, list_values:list_values)
        ●literal
            if left.token.tok == ◂name
                ⮐  p.lVar left
        else
            discard

# ████████  ███   ███  ███   ███   ███████
# ███       ███   ███  ████  ███  ███     
# ██████    ███   ███  ███ █ ███  ███     
# ███       ███   ███  ███  ████  ███     
# ███        ███████   ███   ███   ███████

proc lFunc(p: Parser, left: Node): Node =

    if left.kind not in {●signature, ●list, ●arg, ●operation}
        ⮐ 
        
    var func_signature = left
    
    # log "lFunc LEFT {left}"
    
    if left.kind == ●operation
        if left.token.tok != ◂assign
            ⮐  
        if left.operand_left.token.tok != ◂name
            ⮐  
        if left.operand_left.token.col == 0 
            var left = left
            let argtoken = Token(tok:◂val_type, line:left.operand_right.token.line,col:left.operand_right.token.col)
            left.operand_right = p.lFunc(Node(token:argtoken, kind:●arg, arg_name:left.operand_right))
            ⮐  left
            
        let vartoken = Token(tok:◂val_type, line:left.operand_left.token.line,col:left.operand_left.token.col)
        let varNode = Node(token:vartoken, kind:●arg, arg_name:left.operand_left, arg_value:left.operand_right)
        let sig_args = Node(token:vartoken, kind:●list, list_values: @[varNode])
        func_signature = Node(token:left.token, kind:●signature, sig_args:sig_args)
        
    elif left.kind == ●list
        var sig_args = left
        for i,a in sig_args.list_values
            if a.kind == ●operation and a.token.tok == ◂assign
                let argtoken = Token(tok:◂val_type, line:a.operand_left.token.line,col:a.operand_left.token.col)
                sig_args.list_values[i] = Node(token:argtoken, kind:●arg, arg_name:a.operand_left, arg_value:a.operand_right)
            elif a.kind == ●literal and a.token.tok == ◂name
                let argtoken = Token(tok:◂val_type, line:a.token.line,col:a.token.col)
                sig_args.list_values[i] = Node(token:argtoken, kind:●arg, arg_name:a)
        func_signature = Node(token:left.token, kind:●signature, sig_args:sig_args)
    elif left.kind == ●arg
        let sig_args = Node(token:left.token, kind:●list, list_values: @[left])
        func_signature = Node(token:left.token, kind:●signature, sig_args:sig_args)
    
    let token = p.consume() # ->
    
    var func_mod : Node
    if p.tok == ◂mod
        func_mod = p.rLiteral
    
    let func_body = p.then()
    
    Node(token:token, kind:●func, func_signature:func_signature, func_mod:func_mod, func_body:func_body)

proc rFunc(p: Parser): Node =

    let token = p.consume() # ->
    
    var func_mod : Node
    if p.tok == ◂mod
        func_mod = p.rLiteral
    
    let func_body = p.then()
    
    Node(token:token, kind:●func, func_body:func_body)

proc rReturn(p: Parser): Node =

    let token = p.consume()
    
    if p.tok == ◂if and p.isThenlessIf(token)
        Node(token:token, kind:●return)
    else
        p.returning = true

        var right : Node 
        if p.tok != ◂indent or p.isNextLineIndented(token)
            right = p.expression(token)
        
        p.returning = false
        Node(token:token, kind:●return, return_value:right)

proc rDiscard(p: Parser): Node =

    let token = p.consume()
    if p.isDedent token.col
        Node(token:token, kind:●discard)
    else
        let right = p.value()
        Node(token:token, kind:●discard, discard_value:right)

#  ███████   ████████   ████████  ████████    ███████   █████████  ███   ███████   ███   ███
# ███   ███  ███   ███  ███       ███   ███  ███   ███     ███     ███  ███   ███  ████  ███
# ███   ███  ████████   ███████   ███████    █████████     ███     ███  ███   ███  ███ █ ███
# ███   ███  ███        ███       ███   ███  ███   ███     ███     ███  ███   ███  ███  ████
#  ███████   ███        ████████  ███   ███  ███   ███     ███     ███   ███████   ███   ███

proc lOperation(p: Parser, left: Node): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind: ●operation, operand_left: left, operand_right:right)

proc lPostOp(p: Parser, left: Node): Node =

    Node(token:p.consume(), kind: ●postOp, operand:left)

proc rPreOp(p: Parser): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind:●preOp, operand:right)

proc lAssign(p: Parser, left: Node): Node =

    let token = p.consume()
    let right = p.expressionOrIndentedBlock(token, left.token.col)

    Node(token:token, kind: ●operation, operand_left: left, operand_right: right)

proc lRange(p: Parser, left: Node): Node =

    let token = p.consume()
    let right = p.expression(token)
    Node(token:token, kind: ●range, range_start: left, range_end: right)
        
proc rParenExpr(p: Parser): Node =

    Node(token:p.current, kind:●list, list_values:p.parseParenList())

proc rCurly(p: Parser): Node =

    Node(token:p.current, kind:●curly, list_values:p.parseDelimitedList(◂bracket_open, ◂bracket_close))

proc rSquarely(p: Parser): Node =

    Node(token:p.current, kind:●squarely, list_values:p.parseDelimitedList(◂square_open, ◂square_close))

proc rEnum(p: Parser) : Node = 

    let token = p.consume()
    let enum_name = p.value()
    var enum_body : Node
    if p.isNextLineIndented token
        p.typeless = true
        enum_body = p.parseBlock()
        p.typeless = false
    Node(token:token, kind:●enum, enum_name:enum_name, enum_body:enum_body)
    
proc rClass(p: Parser) : Node = 

    let token = p.consume()
    let class_name = p.value()
    let class_body = p.parseBlock()
    Node(token:token, kind:●class, class_name:class_name, class_body:class_body)
    
proc lMember(p: Parser, left: Node) : Node =

    let token = p.consume()
    Node(token:token, kind:●member, member_key:left, member_value:p.expression())
    
proc lTestCase(p: Parser, left: Node): Node =

    let token = p.consume() # ▸
    p.swallow(◂indent) # todo: check if indent is larger than that the test expression
    let right = p.expression()
    Node(token:token, kind: ●testCase, test_value:left, test_expected:right)

proc rTestSuite(p: Parser): Node =

    let token = p.consume() # ▸
    let test_block = p.then()
    if token.col == 0
        Node(token:token, kind:●testSuite, test_block:test_block)
    else
        Node(token:token, kind:●testSection, test_block:test_block)

# ████████  ███   ███  ████████   ████████   ████████   ███████   ███████  ███   ███████   ███   ███
# ███        ███ ███   ███   ███  ███   ███  ███       ███       ███       ███  ███   ███  ████  ███
# ███████     █████    ████████   ███████    ███████   ███████   ███████   ███  ███   ███  ███ █ ███
# ███        ███ ███   ███        ███   ███  ███            ███       ███  ███  ███   ███  ███  ████
# ████████  ███   ███  ███        ███   ███  ████████  ███████   ███████   ███   ███████   ███   ███

###
   ◂R      ◂LR     ◂L      ◂R      ◂L      ◂LR     ◂R 
   │       │       │       │       │       │ 
   ◂R➜●    │       │       ◂R➜●    │       │ 
      │    │       │          │    │       │
      ╰───●◂L➜●───●◂L➜●       ╰───●◂L➜●───●◂L➜●
                      │                       │
                      ▾                       ▾
###

proc expression(p: Parser, precedenceRight = 0): Node =

    let token = p.current
    if token.tok in {◂eof, ◂stripol_end, ◂paren_close}
        ⮐  nil
    
    let rhs = p.rightHandSide(token)
    
    if rhs == nil
    
        ⮐  p.error("Expected expression but found {token.str} {token}", token)
        
    var node: Node = rhs(p)

    if precedenceRight < -1
        ⮐  node

    while true
        
        let token = p.current
        var precedence = p.getPrecedence(token)
        
        if token.tok in {◂assign, ◂test}
            precedence += 1
        
        let lhs = p.leftHandSide(token)
        
        if precedenceRight >= precedence
            break
    
        if lhs == nil
            break
            
        let lhn = p.lhs(node)
        if lhn != nil
            node = lhn
        else
            break 
            
        if p.tok == ◂indent and p.peek(1).tok in {◂dot}
             p.swallow()
             node = p.lPropertyAccess node
    node
            
# ████████   ████████    ███████   █████████  █████████
# ███   ███  ███   ███  ███   ███     ███        ███   
# ████████   ███████    █████████     ███        ███   
# ███        ███   ███  ███   ███     ███        ███   
# ███        ███   ███  ███   ███     ███        ███   

proc pratt(p: Parser, t:tok, lhs:LHS, rhs:RHS, precedence:int) = 

    if p.pratts.len <= t.ord
        p.pratts.setLen(t.ord + 1)
    
    p.pratts[t.ord] = Pratt(lhs:lhs, rhs:rhs, precedence:precedence)

#  ███████  ████████  █████████  ███   ███  ████████ 
# ███       ███          ███     ███   ███  ███   ███
# ███████   ███████      ███     ███   ███  ████████ 
#      ███  ███          ███     ███   ███  ███      
# ███████   ████████     ███      ███████   ███      

proc setup(p: Parser) =

    p.pratt ◂true,              nil,               rLiteral,        0
    p.pratt ◂false,             nil,               rLiteral,        0
    p.pratt ◂mod,               nil,               rLiteral,        0
    p.pratt ◂null,              nil,               rLiteral,        0
    p.pratt ◂number,            nil,               rLiteral,        0
    p.pratt ◂string_start,      nil,               rString,         0
    p.pratt ◂comment_start,     nil,               rComment,        0
    p.pratt ◂name,              lSymbolList,       rSymbol,        13 # higher than assign
    p.pratt ◂import,            nil,               rImport,         0
    p.pratt ◂macro,             nil,               rMacro,          0
    p.pratt ◂template,          nil,               rTemplate,       0
    p.pratt ◂converter,         nil,               rConverter,      0
    p.pratt ◂proc,              nil,               rProc,           0
    p.pratt ◂type,              nil,               rTypeDef,        0
    p.pratt ◂use,               nil,               rUse,            0
    p.pratt ◂let,               nil,               rLet,            0
    p.pratt ◂var,               nil,               rLet,            0
    p.pratt ◂return,            nil,               rReturn,         0
    p.pratt ◂discard,           nil,               rDiscard,        0
    p.pratt ◂test,              lTestCase,         rTestSuite,      0
    
    p.pratt ◂class,             nil,               rClass,          0
    p.pratt ◂enum,              nil,               rEnum,           0
    p.pratt ◂colon,             lMember,           nil,            10
    
    p.pratt ◂continue,          nil,               rKeyword,        0
    p.pratt ◂break,             nil,               rKeyword,        0
                                                                    
    p.pratt ◂assign,            lAssign,           nil,            10
    p.pratt ◂plus_assign,       lAssign,           nil,            10
    p.pratt ◂minus_assign,      lAssign,           nil,            10
    p.pratt ◂divide_assign,     lAssign,           nil,            10
    p.pratt ◂multiply_assign,   lAssign,           nil,            10
    p.pratt ◂ampersand_assign,  lAssign,           nil,            10

    p.pratt ◂if,                lTailIf,           rIf,            20
    p.pratt ◂when,              nil,               rIf,            20
    p.pratt ◂for,               nil,               rFor,           20
    p.pratt ◂switch,            nil,               rSwitch,        20
    p.pratt ◂while,             nil,               rWhile,         20
    p.pratt ◂func,              lFunc,             rFunc,          20
    
    p.pratt ◂is,                lOperation,        nil,            28
    p.pratt ◂in,                lOperation,        nil,            29
    p.pratt ◂or,                lOperation,        nil,            30
    p.pratt ◂and,               lOperation,        nil,            31

    p.pratt ◂equal,             lOperation,        nil,            40
    p.pratt ◂not_equal,         lOperation,        nil,            40
    p.pratt ◂greater_equal,     lOperation,        nil,            40
    p.pratt ◂less_equal,        lOperation,        nil,            40
    p.pratt ◂less,              lOperation,        nil,            40
    p.pratt ◂greater,           lOperation,        nil,            40
    
    p.pratt ◂doubledot,         lRange,            nil,            40
    p.pratt ◂tripledot,         lRange,            nil,            40
    p.pratt ◂ampersand,         lOperation,        nil,            40
                                                   
    p.pratt ◂plus,              lOperation,        nil,            50
    p.pratt ◂minus,             lOperation,        rPreOp,         50
                                                   
    p.pratt ◂multiply,          lOperation,        nil,            60
    p.pratt ◂divide,            lOperation,        nil,            60

    p.pratt ◂not,               nil,               rPreOp,         70

    p.pratt ◂increment,         lPostOp,           nil,            80
    p.pratt ◂decrement,         lPostOp,           nil,            80

    p.pratt ◂square_open,       lArrayAccess,      rSquarely,      90
    p.pratt ◂paren_open,        lCall,             rParenExpr,     90
    p.pratt ◂bracket_open,      nil,               rCurly,         90
    p.pratt ◂then,              lReturnType,       rReturnType,    99
    p.pratt ◂val_type,          lArgList,          rArg,          100
    p.pratt ◂var_type,          lArgList,          rArg,          100
    p.pratt ◂dot,               lPropertyAccess,   nil,           102
    
#  ███████    ███████  █████████
# ███   ███  ███          ███   
# █████████  ███████      ███   
# ███   ███       ███     ███   
# ███   ███  ███████      ███   

proc ast*(text:string) : Node =

    let tokens = tokenize text
    # log "ast* {tokens}"
    var p = Parser(tokens:tokens, pos:0, text:text)
    p.setup()
    p.parseBlock()
    