###
     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  
    ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà       
    ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   
    ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà            ‚ñà‚ñà‚ñà  
     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   

    an editor that can't edit ;)
    
    displays selections with nice rounded edges and is used almost 
    everywhere by now: 
        context menu dirtree funtree quicky browse finder searcher...
    
    takes list of items as input and extracts text to display from them    
    supports filtering of the items
###

# use ../../../kxk    ‚ñ™ kstr kseg slash krzl post
# use ../../theme     ‚óÜ color theme 
# use ../../edit/tool ‚óÜ belt
# use ../../edit      ‚óÜ editor

use edit.editor

class choices extends editor

    @: screen name features=[] ->

        editor.init @, screen, name, features
        
        @setColor 'bg'    theme.editor.bg
        @setColor 'hover' theme.hover
        
        @pointerType = 'pointer'
        @roundedSelections = true
        @frontRoundOffset = 0
        @hoverIndex = -1
        @hoverForSubmenu = false
        
        @items = []
        @fuzzied = @items
        @filterText = ''
        
    setColor: key color ->
    
        editor.setColor @ key color
    
        if key == 'bg'
            @setColor        'empty' @color.bg
            if @gutter
                @gutter‚àôsetColor 'bg'    @color.bg
            if @scroll
                @scroll‚àôsetColor 'bg'    @color.bg

    extract: item -> 
    
        if @key 
            item[@key]
        else
            kseg.str item
        
    clear: -> @set []
    
    clearEmpty: ->
    
        @items = []
        @fuzzied = @items
        @state‚àôclearEmpty()
        
    #  0000000  00000000  000000000  
    # 000       000          000     
    # 0000000   0000000      000     
    #      000  000          000     
    # 0000000   00000000     000     
    
    set: items key ->
        
        @key = key
        @items = items
        @items ?= []
        @fuzzied = @items
        @filterText = ''
        
        lines = @items
        if @key ‚ûú lines = @items‚àômap((i)->@extract(i))
        log "#{@name} set lines" lines
        @state‚àôloadLines lines
        @
        
    add: item ->
    
        @items‚àôpush item
        @state‚àôaddLine item.line item.ext
        
    append: items ext key='line'->
    
        @items = @items.concat items
        @fuzzied = @items # ùúèùñçùöíùñò ùöíùñò ‚üí…º‚äö‚à©ùöê! ùöíùúèœµ‚´ôùñò ùñòùñç‚äöùìä‚üÖùíπ ùîüœµ …ºœµœùùìäùìèùìèùöíœµùíπ ùöí‚à©ùñòùúèœµùïíùíπ
        @state‚àôappendLines(items‚àômap((i) -> ‚Æê  i[key]), ext)
                
    # 0000000    00000000    0000000   000   000  
    # 000   000  000   000  000   000  000 0 000  
    # 000   000  0000000    000000000  000000000  
    # 000   000  000   000  000   000  000   000  
    # 0000000    000   000  000   000  00     00  
    
    drawCursors: ->
        
    drawSelections: ->
        
        ‚Æê  if empty @state.s.selections
        
        if not @roundedSelections
            ‚Æê  editor.drawSelections @
        
        # fg = if @hasFocus() ‚ûú @color.hover.bg ‚ûú @color.hover.blur
        # fg = @color.hover
        fg = [255 255 0]
        
        # if not @cells.screen.t.hasFocus
        #     fg = color.darken fg
        
        sel = @state.s.selections[1]
                
        li = sel[2]
        y  = li-@state.s.view[2]+1
        
        ‚Æê  if y > @cells.rows
        
        # xs = max sel[1] kseg.headCount(@state.s.lines[li] ' ')
        xs = max sel[1] @state.s.lines[li]‚àôindent()+1
        if xs == 1
            xs += @frontRoundOffset 

        @cells‚àôset_ch_fg 1 y 'ÓÇ∂' fg
        
        for x in xs..sel[3]
            @cells‚àôset_bg x-@state.s.view[1]+1 y fg
            # @cells‚àôadjustContrastForHighlight x-@state.s.view[1] y fg
            
        @cells‚àôset_ch_fg sel[3]+2-@state.s.view[1] y 'ÓÇ¥' fg

    numChoices:  -> @items.len
    numFiltered: -> @fuzzied.len

    currentIndex: -> @state‚àômainCursor()[2]
    current: opt ->
    
        opt ?= {}
        cc = @fuzzied[@currentIndex()]
        if cc is "string"
            if opt.trim == 'front'
                cc = kstr.ltrim cc
            else if opt.trim != false 
                cc = kstr.trim cc
        cc
        
    choiceAtRow: row -> @fuzzied[row]
    
    # 000   000  00000000  000   000  000000000        00000000   00000000   00000000  000   000  
    # 0000  000  000        000 000      000           000   000  000   000  000       000   000  
    # 000 0 000  0000000     00000       000           00000000   0000000    0000000    000 000   
    # 000  0000  000        000 000      000           000        000   000  000          000     
    # 000   000  00000000  000   000     000           000        000   000  00000000      0      

    hasNext: -> @nextRow()
    hasPrev: -> @prevRow()

    nextRow: ->
        
        y = @state‚àômainCursor()[2]
        while y < @state.s.lines.len
            y += 1
            if kseg.trim(@state.s.lines[y]).len >= 1
                ‚Æê  y 
        
    prevRow: ->

        y = @state‚àômainCursor()[2]
        while y > 1
            y -= 1
            if kseg.trim(@state.s.lines[y]).len >= 1
                ‚Æê  y 
            
    pageUpRow: ->
    
        y = @state‚àômainCursor()[2] - @cells.rows + 1
        y = max y 1 
        
        while y > 1 and empty kseg.trim(@state.s.lines[y])
            y -= 1
            
        if empty kseg.trim(@state.s.lines[y]) and y < @state.s.lines.len
            y += 1
        y
    
    pageDownRow: ->
    
        y = @state‚àômainCursor()[2] + @cells.rows - 1
        y = min y @state.s.lines.len
        
        while y < @state.s.lines.len and empty kseg.trim(@state.s.lines[y])
            y += 1
            
        if empty kseg.trim(@state.s.lines[y]) and y > 1
            y -= 1
        y
        
    #  0000000  00000000  000      00000000   0000000  000000000  
    # 000       000       000      000       000          000     
    # 0000000   0000000   000      0000000   000          000     
    #      000  000       000      000       000          000     
    # 0000000   00000000  0000000  00000000   0000000     000     
    
    select: row -> 
    
        ‚Æê  if not row
        ‚Æê  if not row is "number"
        ‚Æê  if row < 1 or row > @state.s.lines.len
    
        @state‚àôsetSelections [belt.rangeOfLine(@state.s.lines row)]
        @state‚àôsetMainCursor 1 row
        
        @grabFocus() if @focusable

        @emit 'select' @choiceAtRow(row)
        
    selectFirst: -> @select 1
    
    moveSelection: dir ->
        
        switch dir
            'pagedown' ‚ûú @selectPageDown()
            'pageup'   ‚ûú @selectPageUp()
            'down'     ‚ûú @selectNext()
            'up'       ‚ûú @selectPrev() 
        @
        
    selectPageUp:   -> @select @pageUpRow()
    selectPageDown: -> @select @pageDownRow()
    selectNext: -> @select @nextRow()
    selectPrev: -> 
        row = @prevRow()
        if empty row
            @emitAction 'boundary' @current()
        else
            @select row
                    
    # 000   000  00000000  000   0000000   000   000  000000000  
    # 000 0 000  000       000  000        000   000     000     
    # 000000000  0000000   000  000  0000  000000000     000     
    # 000   000  000       000  000   000  000   000     000     
    # 00     00  00000000  000   0000000   000   000     000     
        
    weight: item text ->

        itemText = @extract item
        p = slash.parse itemText
        
        matchOrLevenshtein = t -> 
            idx = t.indexOf text
            if idx < 0
                idx = t.length + kstr.levensthein(t text)
            idx

        w  = @items.indexOf(item)               # try to keep order of original items
        w += 10 * matchOrLevenshtein(p.name)    # high focus on file name
        w += 5  * matchOrLevenshtein(p.dir)     # lesser focus on dir
        # w += valid p.ext ? (0.1 * matchOrLevenshtein(p.ext)) : 4 # low weight for extensions
        if valid(p.ext)
            w += 0.1 * matchOrLevenshtein(p.ext)
        else
            w += 4
        w

    # 00000000  000  000      000000000  00000000  00000000   
    # 000       000  000         000     000       000   000  
    # 000000    000  000         000     0000000   0000000    
    # 000       000  000         000     000       000   000  
    # 000       000  0000000     000     00000000  000   000  
    
    filter: text ->
        
        ‚Æê  if empty @items
           
        ‚Æê  if text == @filterText
           
        ‚Æê  @set(@items @key) if empty text
        log "FILTER"    
        @filterText = text
            
        fuzz = krzl {values:@items extract:@extract}
        
        @fuzzied = fuzz.filter text

        @fuzzied.sort((a b) -> @weight(a text) - @weight(b text))
        
        lines = @fuzzied.map @extract

        if empty lines
            lines = [''] 
        
        @state.loadLines lines

    # ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 
    # ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà
    # ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  
    # ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà
    # ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà

    hoverChoiceAtIndex: index event -> 
    
        ‚Æê  true if @hoverIndex == index
        
        @hoverIndex = index
        @state‚àôsetMainCursor 0 index
        @select @hoverIndex
        post.emit 'pointer' 'pointer'
        @emitAction 'hover' @current() event
        {redraw:true}
        
    unhover: ->
        
        @hoverIndex = -1
        @state.deselect()
        post.emit 'pointer' 'default'
        {redraw:true}

    # 00     00   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000       000       
    # 000000000  000   000  000   000  0000000   0000000   
    # 000 0 000  000   000  000   000       000  000       
    # 000   000   0000000    0000000   0000000   00000000  
    
    dragChoiceAtIndex: index event ->
        
        @hoverChoiceAtIndex index event
        @emitAction 'drag' @fuzzied[index] event
        {redraw:true}
        
    clickChoiceAtIndex: index event ->
        
        @hoverIndex = -1  
        @emitAction 'click' @fuzzied[index] event
        {redraw:true}
        
    doubleClickChoiceAtIndex: index event ->
        
        @hoverIndex = -1  
        @emitAction 'doubleclick' @fuzzied[index] event
        {redraw:true}
        
    onMouse: event ->
        
        if editor.onMouse @ event ‚ûú ‚Æê  true
        
        if @mapscr and @mapscr.onMouse event ‚ûú ‚Æê  true
        
        if @hover
        
            (col row) = @eventPos event
            
            if @state.isValidLineIndex(row)
                
                if @hoverForSubmenu and event.type == 'move' and col > kseg.width(@state.s.lines[row])
                    dx = abs event.delta[0]
                    dy = abs event.delta[1]
                    ‚Æê  if dx*2 >= dy
                
                switch event.type
                    
                    'move'  
                            ‚Æê  @hoverChoiceAtIndex row + @state.s.view[1] event
                            
                    'press' 
                    
                        if event.count == 2
                            ‚Æê  @doubleClickChoiceAtIndex row + @state.s.view[1] event
                        else
                            @dragStart = [col row]
                            ‚Æê  @clickChoiceAtIndex row + @state.s.view[1] event
                            
                    'drag'
                            if @dragStart
                                ‚Æê  @dragChoiceAtIndex row + @state.s.view[1] event
                                
                    'release'
                            delete @dragStart
        @hover
        
    #  0000000    0000000  000000000  000   0000000   000   000  
    # 000   000  000          000     000  000   000  0000  000  
    # 000000000  000          000     000  000   000  000 0 000  
    # 000   000  000          000     000  000   000  000  0000  
    # 000   000   0000000     000     000   0000000   000   000  
    
    emitAction: action choice event ->
        
        # log "emitAction" action, choice, event
        @emit 'action' action choice event
                    
    # 000   000  00000000  000   000  
    # 000  000   000        000 000   
    # 0000000    0000000     00000    
    # 000  000   000          000     
    # 000   000  00000000     000     
    
    onKey: key event ->
    
        # log "#{@name} onKey #{key} combo #{event.combo}"
        
        switch event.combo        
            'up' 
            'down'   
            'pageup'   
            'pagedown'   
                @moveSelection event.combo
                ‚Æê  true
                
            'ctrl+alt+up'   ‚ûú @moveSelection 'pageup'   ; ‚Æê  true 
            'ctrl+alt+down' ‚ûú @moveSelection 'pagedown' ; ‚Æê  true 
        
        ‚Æê  if not @hasFocus()
            
        switch event.combo
        
            'esc'
            'left' 
            'right'  
            'space'  
            'delete'
            'return' ‚ûú @emitAction event.combo @current() event
            
        @emitAction event.combo @current() event
                        
        # not calling super here effectively disables all text-editing
        true
         
# _G.choices_class = choices # hack to prevent import recursion
‚Æê  choices
