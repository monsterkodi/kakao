# ████████    ███████   ████████    ███████
# ███   ███  ███   ███  ███   ███  ███     
# ████████   █████████  ███████    ███████ 
# ███        ███   ███  ███   ███       ███
# ███        ███   ███  ███   ███  ███████ 

use node
export node

{.experimental: "codeReordering".}

type RHS = proc(p: Parser): Node
type LHS = proc(p: Parser, left: Node): Node

EOF = tkn(◂eof)
    
struct Pratt
    rhs         : RHS
    lhs         : LHS
    precedence  : int
         
class Parser

    tokens      : seq[Token]
    pratts      : seq[Pratt]
    blocks      : seq[Node]
    pos         : int
    explicit    : int
    listless    : int
    inlinecall  : int
    rangeless   : bool
    returning   : bool
    typeless    : bool
    failed      : bool
    lang        : string
    text        : string # used in `$` for debugging. should be removed eventually 

    current: ➜Token ->
    
        if @pos < @tokens.len
            ⮐  @tokens[@pos]
        EOF
    
    tok: ➜tok -> @current.tok

    peek: ahead=1 ➜Token ->
    
        if @pos + ahead < @tokens.len
            @tokens[@pos + ahead]
        else
            EOF

    # ████████   ████████   ███  ███   ███  █████████  
    # ███   ███  ███   ███  ███  ████  ███     ███     
    # ████████   ███████    ███  ███ █ ███     ███     
    # ███        ███   ███  ███  ███  ████     ███     
    # ███        ███   ███  ███  ███   ███     ███     

    $: ➜string ->
    
        s = ""
        if @tok != ◂eof
            s = "▪▪▪ #{@current} #{@pos}"
            l = @text.split("\n")[@current.line]
            s &= "\n#{@current.line}: #{l}"
        else
            s = @text
        s

    error: ◇string msg token=EOF ➜Node ->
    
        if token.tok != ◂eof
            styledEcho styleDim fgRed "△ " fgWhite $(token.line+1) ": " resetStyle fgYellow msg
            line = @text.split("\n")[token.line]
            styledEcho fgRed, styleDim, "╰" & ('─'.repeat(token.col-1)) & "╮"
            styledEcho fgGreen, $line
            echo ""
        elif @tok != ◂eof
            styledEcho fgRed, styleDim, "△ ", resetStyle, fgYellow, msg
            line = @text.split("\n")[@current.line]
            styledEcho fgWhite, styleDim, "#{@current.line}", resetStyle, fgGreen, $line
        else
            styledEcho fgRed, styleDim, "△ ", resetStyle, fgYellow, msg
        @failed = true    
        nil
    
    #  ███████   ███████   ███   ███   ███████  ███   ███  ██     ██  ████████
    # ███       ███   ███  ████  ███  ███       ███   ███  ███   ███  ███     
    # ███       ███   ███  ███ █ ███  ███████   ███   ███  █████████  ███████ 
    # ███       ███   ███  ███  ████       ███  ███   ███  ███ █ ███  ███     
    #  ███████   ███████   ███   ███  ███████    ███████   ███   ███  ████████
    
    consume: ➜Token ->
    
        t = @current
        if @pos < @tokens.len
            @pos += 1
        t
    
    swallow: ->
    
        discard @consume()
    
    swallow: ◇tok tok ->
    
        if @tok == tok
            @swallow()

    swallowComment: ->
    
        if @tok == ◂comment_start
            @swallow()
            @swallow ◂comment
            
    swallowError: ◇tok tok ◇string err ◇Token token ->
    
        if @tok != tok
            discard @error("Expected #{tok} but found #{@tok}" token)
            discard @error(err token)
            ⮐  
        @swallow()
                
    swallowSameIndent: ◇int indent ➜bool ->
    
        if @tok == ◂indent and @current.str.len == indent
            @swallow()
            ⮐  true
        false
    
    atIndent: ➜bool ->  
    
        @current.col == 0 or @peek(-1).tok == ◂indent
            
    atEnd: ➜bool ->  
    
        @pos >= @tokens.len
    
    isDedent: ◇int indent ➜bool ->  
    
        if @tok == ◂indent
            @current.str.len < indent
        else
            @current.col < indent
            
    isNextLineIndented: ◇Token token ➜bool -> 
    
        n = 0
        while @peek(n).tok != ◂indent
            n += 1
            if @peek(n).tok == ◂eof
                ⮐  false
            
        idt = if token.tok == ◂indent ➜ token.str.len ➜ token.col
        ⮐  @peek(n).str.len > idt
    
    isTokAhead: ◇tok tokAhead ➜bool ->
    
        n = 0
        c = @current
        line = c.line
        
        # log "isTokAhead #{tokAhead} #{line}"
        
        while c.tok != ◂eof
            if c.line > line
                ⮐  false
            if c.tok == tokAhead
                ⮐  true
            n += 1
            c = @peek n
        false
        
    isConnectedLeft: n=0 ➜bool ->
    
        lt = @peek(n-1)
        ct = @peek(n)
        
        lt != EOF and ct != EOF and lt.tok != ◂indent and lt.line == ct.line and lt.col+ksegWidth(lt.str) == ct.col

    isConnectedRight: n=0 ➜bool ->
    
        ct = @peek(n)
        rt = @peek(n+1)
        rt != EOF and ct != EOF and rt.tok != ◂indent and rt.line == ct.line and ct.col+ksegWidth(ct.str) == rt.col
        
    isConnectedLeftAndRight: n=0 ➜bool ->
    
        @isConnectedLeft(n) and @isConnectedRight(n)

    firstLineToken: ➜Token ->
    
        line = @current.line
        tpos = @tokens.len
        while tpos > 0
            if @tokens[tpos-1].line < line
                break
            tpos -= 1
        @tokens[tpos]
        
    lineIndent: ◇int line ➜int ->
    
        tpos = @tokens.len
        while tpos > 0
            if @tokens[tpos-1].line < line
                break
            tpos -= 1
    
        if @tokens[tpos].tok == ◂indent
            @tokens[tpos].str.len
        else
            @tokens[tpos].col
    
    isThenlessIf: ◇Token token ➜bool ->
    
        if @isNextLineIndented(token)
            ⮐  false
    
        not @isTokAhead ◂then
        
    getPrecedence: ◇Token token ➜int ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].precedence
        0
        
    rightHandSide: ◇Token token ➜RHS ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].rhs
    
    leftHandSide: ◇Token token ➜LHS ->
    
        if token.tok.ord < @pratts.len
            ⮐  @pratts[token.tok.ord].lhs
    
    expression: precedenceRight=0 ➜Node ->
    
    expression: ◇Token tokenRight ➜Node ->
    
        @expression @getPrecedence(tokenRight)
    
    value: ➜Node ->
    
        @expression(-2)

    # ███████    ███       ███████    ███████  ███   ███
    # ███   ███  ███      ███   ███  ███       ███  ███ 
    # ███████    ███      ███   ███  ███       ███████  
    # ███   ███  ███      ███   ███  ███       ███  ███ 
    # ███████    ███████   ███████    ███████  ███   ███
    
    parseBlock: ◇Node bn=nil ➜Node ->
    
        token        ◇ Token
        block_indent ◇ int
        
        while @tok == ◂indent
            token = @consume() 
            block_indent = @current.col
        
        bn = bn
        if bn == nil
            bn = nod(●block, token, [])
            
        expr = @expression()
        
        while expr != nil
        
            if expr.kind == ●func and bn.expressions.len
                prevExpr = bn.expressions[^1]
                if prevExpr.token.line == expr.token.line and prevExpr.token.tok == ◂assign
                    prevExpr = bn.expressions.pop()
                    if prevExpr.operand_right.kind == ●operation
                        argtoken = prevExpr.operand_right.operand_left.token
                        argtoken.tok = ◂val_type
                        argnode = nod ●arg argtoken nil prevExpr.operand_right.operand_left prevExpr.operand_right.operand_right
                        expr.func_signature.sig_args.list_values.unshift argnode
                    else
                        expr.func_signature.sig_args.list_values.unshift prevExpr.operand_right
                    prevExpr.operand_right = expr
                    expr = prevExpr
                    
            bn.expressions.add expr
            if @tok == ◂indent
                ind = @current.str.len
                if ind < block_indent
                    break
                elif ind > block_indent
                    @blocks.add bn
                    expr = @parseBlock()
                    bn = @blocks.pop()
                    continue
                else
                    @swallow()
                    
            if @atEnd() or @current.col < block_indent
                break
                
            expr = @expression()
        bn
    
    expressionOrIndentedBlock: ◇Token token ◇int col ➜Node ->
    
        if @tok == ◂indent
            if @current.str.len > col
                ⮐  @parseBlock()
        else
            ⮐  @expression(token)
            
    #  ███████   ███████   ███      ███       ███████   ████████    ███████    ███████
    # ███       ███   ███  ███      ███      ███   ███  ███   ███  ███        ███     
    # ███       █████████  ███      ███      █████████  ███████    ███  ████  ███████ 
    # ███       ███   ███  ███      ███      ███   ███  ███   ███  ███   ███       ███
    #  ███████  ███   ███  ███████  ███████  ███   ███  ███   ███   ███████   ███████ 
    
    swallowIndent: ◇int col ➜bool ->
    
        @swallow ◂comma
        if @tok == ◂indent
            if @current.str.len > col
                @swallow()
            else
                ⮐  true
        false
        
    parseCallArgs: ◇int col ➜seq[Node] ->
    
        @explicit += 1
        @listless += 1
        list ◇ seq[Node]
        line = @current.line
        expr = @expression()
        while expr != nil
            list.add expr
            if @inlinecall and @tok == ◂indent
                break
            if @swallowIndent col
                break
            if @tok in {◂comment_start ◂then ◂test ◂semicolon}
                break
            expr = @expression()
        @listless -= 1
        @explicit -= 1
        list
        
    # █████████  ███   ███  ████████   ████████
    #    ███      ███ ███   ███   ███  ███     
    #    ███       █████    ████████   ███████ 
    #    ███        ███     ███        ███     
    #    ███        ███     ███        ████████
    
    parseType: ➜Node ->
        
        token = @consume()
        token.tok = ◂type
        
        if token.str == "ref"
            token.str &= " "
            t = @consume()
            token.str &= t.str
        
        if @tok == ◂square_open
            opened = 0
            while @tok != ◂eof
                t = @consume()
                token.str &= t.str
                if t.tok == ◂square_open
                    opened += 1
                elif t.tok == ◂square_close
                    opened -= 1
                    if opened == 0
                        break
        
        nod(●type token)
        
    parseVar: ➜Node ->
    
        token     = @current()
        var_name  = @value()
        var_value ◇ Node
        var_type  ◇ Node
        
        if @tok == ◂assign
            @swallow()
            var_value = @thenBlock()
        elif @tok in {◂val_type ◂var_type}
            token = @consume()
            var_type = @parseType()
            if @tok == ◂assign
                @swallow()
                var_value = @expression()
        
        nod(●var token var_name var_type var_value)
        
    parseModule: ➜Node ->
    
        line = @current.line
        s = ""
        while @current.str notin ["▪" "◆"]
            e = @current.col + @current.str.len
            s &= @consume().str
            if @atEnd() or @current.line != line
                break 
            if @current.col > e and @current.str notin ["▪" "◆"] 
                s &= " "
            
        Node(token:Token(str:s))    

    # ███      ███   ███████  █████████
    # ███      ███  ███          ███   
    # ███      ███  ███████      ███   
    # ███      ███       ███     ███   
    # ███████  ███  ███████      ███   
    
    parseParenList: ➜seq[Node] ->
    
        token = @consume() # (
        args  ◇ seq[Node]
        
        @explicit += 1
        while @tok != ◂paren_close and @tok != ◂eof
            exp = @expression()
            if exp
                args.add exp
            else
                break
            @swallow ◂comma
            
        @swallowError ◂paren_close "Missing closing )" token
        @explicit -= 1
        
        if args.len == 1 and args[0].kind == ●list
            ⮐  args[0].list_values
        args
        
    parseDelimitedList: ◇tok open ◇tok close ➜seq[Node] ->
    
        token = @consume()
        args  ◇ seq[Node]
        
        @explicit += 1
        while true
            discard @swallowIndent(-1)
            if @tok != close and @tok != ◂eof
                exp = @expression()
                if exp
                    args.add exp
                else
                    break
            else
                break
                
        @swallowError close "Missing closing #{close}" token
        @explicit -= 1
        
        if args.len == 1 and args[0].kind == ●list
            ⮐  args[0].list_values
        args
        
    parseNames: ➜seq[Node] -> 
    
        list ◇ seq[Node]
        line = @current.line
        @explicit += 1
        expr = @rSymbol()
        while expr != nil
            list.add expr        
            if @current.line != line
                break
            @swallow ◂comma
            expr = @rSymbol()
        @explicit -= 1
        list
    
    parseNamesUntil: ◇set[tok] stop ➜Node -> 
    
        token = @current
                                    
        list_values ◇ seq[Node]
        @explicit += 1
        while @tok notin stop
            log "TOK " @tok, " " @current.str
            if @tok == ◂eof
                ⮐  @error "'for' without 'in' or 'of' (eof detected)!" token
            if @current.line != token.line
                ⮐  @error "'for' without 'in' or 'of' (linebreak detected)!" token
            list_values.add @rSymbol()
            @swallow ◂comma
        @explicit -= 1
        if list_values.len == 1
            list_values[0]
        else
            nod ●list token list_values

    parseList: ◇Token token ➜Node -> 
    
        list_values ◇ seq[Node]
        while @tok not in {◂eof ◂semicolon ◂indent ◂comment_start}
            exp = @expression(token)
            if exp
                list_values.add exp
                @swallow ◂comma
            else
                ⮐  @error "list expression expected" token
        nod ●list token list_values
        
    parseExprOrList: ◇Token token ➜Node ->
    
        l = @parseList token
        if l.list_values.len == 1
            ⮐  l.list_values[0]
        l
    
    # █████████  ███   ███  ████████  ███   ███
    #    ███     ███   ███  ███       ████  ███
    #    ███     █████████  ███████   ███ █ ███
    #    ███     ███   ███  ███       ███  ████
    #    ███     ███   ███  ████████  ███   ███
    
    thenBlock: ➜Node ->
    
        if @tok == ◂then
            @swallow ◂then
            
        if @tok == ◂indent
            @parseBlock()
        else
            @expression()
            
    thenExpressions: ➜Node ->

        token = @current()
        expressions ◇ seq[Node]
        while @tok not in {◂eof ◂indent ◂paren_close}
            exp = @expression()
            if exp
                expressions.add exp
                @swallow ◂semicolon
            else
                ⮐  @error "then expression expected" token

        if expressions.len == 0
            nil
        elif expressions.len == 1
            expressions[0]
        else
            nod ●semicolon token expressions
            
    thenIndented: ◇Token token ➜Node ->

        thenToken ◇ Token
        if @tok == ◂then
            thenToken = @consume()
            
        if @tok == ◂indent
            if @isNextLineIndented token
                ⮐  @parseBlock()
            ⮐  nil
        elif thenToken.tok == ◂then
            ⮐  @thenExpressions()

    funcBody: ◇Token token ➜Node ->

        if @tok == ◂indent
            if @isNextLineIndented token
                ⮐  @parseBlock()
            ⮐  nil
        else
            ⮐  @thenExpressions()
            
    #  ███████   ███████   ███      ███    
    # ███       ███   ███  ███      ███    
    # ███       █████████  ███      ███    
    # ███       ███   ███  ███      ███    
    #  ███████  ███   ███  ███████  ███████
    
    lCall: ◇Node callee ➜Node ->
    
        ⮐  if callee.token.line != @current.line
        ⮐  if callee.kind in {●string ●operation ●preOp ●postOp}
        # ⮐  if callee.token.tok in {◂string ◂number ◂assign ◂colon ◂comma ◂paren_open ◂bracket_open}
        token = @consume() # (
        args = @parseCallArgs callee.token.col
        @swallowError ◂paren_close "Missing closing paren for call arguments" token
        Node token:token kind:●call callee:callee callargs:args
    
    # ███  ██     ██  ████████   ███      ███   ███████  ███  █████████
    # ███  ███   ███  ███   ███  ███      ███  ███       ███     ███   
    # ███  █████████  ████████   ███      ███  ███       ███     ███   
    # ███  ███ █ ███  ███        ███      ███  ███       ███     ███   
    # ███  ███   ███  ███        ███████  ███   ███████  ███     ███   
    
    isImplicitCallPossible: ➜bool ->
    
        ⮐  false if @explicit
    
        currt = @peek(0)
                    
        ⮐  false if currt.tok in noCallToks and (currt.tok != ◂minus or not @isConnectedRight())
        
        prevt = @peek(-1)
        
        ⮐  false if currt.col <= prevt.col+ksegWidth(prevt.str)
        ⮐  false if @returning and @isTokAhead ◂if
        ⮐  false if @isTokAhead ◂func
        true
        
    rSymbol: ➜Node ->
    
        token = @consume()
        
        if token.str in ["peg" "re" "r"] and @tok == ◂string_start and token.col + token.str.len == @current.col
            n = @rString()
            n.string_prefix = nod ●literal token
            ⮐  n
    
        if @isImplicitCallPossible()
            args = this.parseCallArgs token.col
            ⮐  Node token:token kind:●call callee:nod(●literal token) callargs:args
    
        nod ●literal token
            
    # ███  ████████                             ███  ████████                               ███  ████████  
    # ███  ███                                  ███  ███                                    ███  ███       
    # ███  ██████                               ███  ██████                                 ███  ██████    
    # ███  ███                                  ███  ███                                    ███  ███       
    # ███  ███                                  ███  ███                                    ███  ███       
    
    inline: ➜Node ->
    
        @inlinecall += 1
        e = @expression()
        @inlinecall -= 1
        @swallowComment()
        e
    
    rIf: ➜Node ->
    
        token     = @consume() # if or when
        condThens ◇ seq[Node]
        ifIndent  = token.col
        condIndt  = ifIndent
        
        if @tok == ◂indent
            condIndt = @current.str.len
            if condIndt <= ifIndent
                ⮐  @error "Expected indentation after 'if' without condition"
            @swallow ◂indent # block indentation
        
        condition = @inline() # initial condition        
        then_branch = @thenBlock()
        
        condThens.add nod(●condThen condition.token condition then_branch)
        
        outdent = false
        
        while @tok in {◂elif ◂indent}
        
            if @tok == ◂indent
                if @current.str.len < ifIndent
                    outdent = true
                    break
                if ifIndent < condIndt 
                    if @current.str.len < condIndt
                        break
                if @peek(1).tok != ◂elif and @current.str.len == ifIndent
                    break
                @swallow ◂indent
                @swallowComment()
                if @tok == ◂indent
                    continue

            @swallow ◂elif
            @swallowComment()
            if @tok in {◂then ◂else}
                break # then without condition -> else
            
            condition   = @inline()
            then_branch = @thenBlock()
            
            condThens.add nod(●condThen condition.token condition then_branch)
            
        else_branch ◇ Node
    
        if not outdent    
            @swallow(◂indent)
            
            if @tok in {◂else ◂then}
                @swallow() # else or then without condition
                @swallowComment()
                else_branch = @thenBlock()
                
        Node token:token kind:●if cond_thens:condThens else_branch:else_branch
    
    # █████████   ███████   ███  ███         ███  ████████
    #    ███     ███   ███  ███  ███         ███  ███     
    #    ███     █████████  ███  ███         ███  ██████  
    #    ███     ███   ███  ███  ███         ███  ███     
    #    ███     ███   ███  ███  ███████     ███  ███     
    
    lTailIf: ◇Node left ➜Node ->
    
        ⮐  if @returning
        ⮐  if left.token.line != @current.line
            
        token = @consume()
        condition = @expression()
        condThen = nod ●condThen condition.token condition left
    
        Node token:token kind:●if cond_thens:[condThen]
            
    # ████████   ███████   ████████ 
    # ███       ███   ███  ███   ███
    # ██████    ███   ███  ███████  
    # ███       ███   ███  ███   ███
    # ███        ███████   ███   ███
    
    rFor: ➜Node ->
    
        token = @consume()
        for_value ◇ Node
        if @tok == ◂paren_open
            for_value = @rParenExpr()
        else
            for_value = @parseNamesUntil {◂in ◂of}
        if @tok notin {◂in ◂of}
            ⮐  @error "Expected 'in' or 'of' after for value" token
        for_inof  = nod ●literal @consume()
        for_range = @expression()
        for_body  = @thenBlock()
    
        Node token:token kind:●for for_value:for_value for_inof:for_inof for_range:for_range for_body:for_body
    
    rWhile: ➜Node ->
    
        nod ●while @consume() @expression() @thenBlock()
    
    #  ███████  ███   ███  ███  █████████   ███████  ███   ███
    # ███       ███ █ ███  ███     ███     ███       ███   ███
    # ███████   █████████  ███     ███     ███       █████████
    #      ███  ███   ███  ███     ███     ███       ███   ███
    # ███████   ██     ██  ███     ███      ███████  ███   ███
    
    switchCase: ◇int baseIndent ➜Node ->
    
        case_when ◇ seq[Node]
        token     = @current
        first     = @firstLineToken()
        
        while true
        
            if @tok == ◂indent
                if case_when.len == 0 and @peek(1).tok == ◂then
                    @swallow()
                    ⮐  # indent followed by a ➜ is else
                if not @swallowSameIndent baseIndent
                    break
    
            ⮐  if @tok in {◂else ◂eof} or @isDedent(baseIndent)
    
            break if @tok == ◂then

            @explicit += 1
            val = @value()
            if val == nil
                ⮐  @error "Expected value to switch on" token
            case_when.add val
            @explicit -= 1
            @swallow ◂comma
        
        ⮐  if @isDedent baseIndent
    
        case_then = @thenIndented first
                    
        if case_then == nil
            ⮐  @error "Expected case body after match(es)" token
        
        Node token:token kind:●switchCase case_when:case_when case_then:case_then
    
    rSwitch: ➜Node ->
    
        token = @consume()
        switch_value = @expression()
        
        if switch_value == nil
            ⮐  @error("Expected value after switch keyword", token)
        
        baseIndent = @current.str.len 
        
        @swallowError ◂indent "Expected indentation after switch statement" token
        
        switch_cases ◇ seq[Node]
        
        while true 
    
            switch_case = @switchCase baseIndent
            if switch_case
                switch_cases.add switch_case
            else
                break
        
        switch_default ◇ Node
        
        if @tok in {◂else ◂then}
            @swallow()
            switch_default = @thenBlock()
            if switch_default == nil
                ⮐  @error "Expected default value" token
                
        if switch_cases.len == 0
            ⮐  @error("Missing switch cases", token)
            
        Node token:token kind:●switch switch_value:switch_value switch_cases:switch_cases switch_default:switch_default
                    
    lArrayAccess: ◇Node array_owner ➜Node ->

        ⮐  if not @isConnectedLeft()

        token = @current()
        array_indices = @parseDelimitedList ◂square_open ◂square_close
        array_index = 
            switch array_indices.len
                0 ➜ nil
                1 ➜ array_indices[0]
                  ➜ nod ●list token array_indices
            
        nod ●arrayAccess token array_owner array_index
    
    lPropertyAccess: ◇Node owner ➜Node ->
    
        token = @consume()
        property = @rLiteral()
        
        n = nod ●propertyAccess token owner property
        
        if @isImplicitCallPossible()
            ⮐  Node token:token kind:●call callee:n callargs:@parseCallArgs(token.col)
        n
    
    rLiteral   : ➜Node -> nod(●literal   @consume())
    rKeyword   : ➜Node -> nod(●keyword   @consume())
    rLet       : ➜Node -> nod(●let       @consume() @parseVar())
    rReturnType: ➜Node -> nod(●signature @consume() nil @parseType())
    rQuote     : ➜Node -> nod(●quote     @consume() @thenBlock())
    
    lSemiColon: ◇Node left ➜Node ->
        ⮐  if @explicit and @listless # left is probably an implicit call arg
        # log "semicolon #{left} #{@explicit} #{@listless}"
        if @peek(1).tok notin {◂indent ◂eof}
            token = @consume()
            right = @expression(token)
            if right.kind == ●semicolon
                right.expressions.unshift left
                ⮐  right
            ⮐  nod ●semicolon token [left right]
    
    #  ███████  █████████  ████████   ███  ███   ███   ███████ 
    # ███          ███     ███   ███  ███  ████  ███  ███      
    # ███████      ███     ███████    ███  ███ █ ███  ███  ████
    #      ███     ███     ███   ███  ███  ███  ████  ███   ███
    # ███████      ███     ███   ███  ███  ███   ███   ███████ 
    
    rString: ➜Node ->
    
        token = @consume() # string start
    
        if @tok == ◂string_end
            @swallow()
            Node token:token kind:●string string_content:nod(●literal tkn(◂string))
        else
            string_content ◇ Node 
            if @tok != ◂stripol_start
                string_content = nod ●literal @consume()
            else
                string_content = nod ●literal tkn(◂string "" @current.line @current.col)
                
            string_stripols ◇ seq[Node]
            while @tok notin {◂string_end ◂eof}
            
                @swallowError ◂stripol_start "Expected string interpolation start" token
                
                stripol = nod ●stripol @current
                
                stripol_xprssns ◇ seq[Node]
                while @tok notin {◂stripol_end ◂eof}
                    xpr = @expression()
                    if not xpr ➜ ⮐  @error "Expected string interpolation" token
                    stripol_xprssns.add xpr
                    
                stripol.stripol_xprssns = stripol_xprssns
                
                @swallowError ◂stripol_end "Expected string interpolation end" token
                if @tok notin {◂stripol_start ◂string_end ◂eof}
                    stripol.stripol_content = nod ●literal @consume()
                elif @tok == ◂stripol_start
                    stripol.stripol_content = nod ●literal tkn(◂string @current.line @current.col)
                
                string_stripols.add stripol
                
            @swallowError ◂string_end "Expected closing string delimiter" token
            Node token:token kind:●string string_content:string_content string_stripols:string_stripols
    
    rUse: ➜Node ->
    
        token = @consume()
        @explicit += 1
        use_module = @parseModule()
        if not @atEnd() and @current.line == token.line
            use_kind = @rSymbol()
            use_items  = @parseNames()
            @explicit -= 1
            Node token:token kind:●use use_module:use_module use_kind:use_kind use_items:use_items
        else
            @explicit -= 1
            Node token:token kind:●use use_module:use_module
            
    rComment: ➜Node ->
    
        n = nod ●comment @consume() Node(token:@consume())
        @swallow ◂comment_end
        n
        
    lReturnType: ◇Node left ➜Node ->
    
        ⮐  if not @isTokAhead(◂func) and not @isTokAhead(◂method)
    
        if left.kind in {●list ●arg ●operation}
            if left.kind == ●operation 
                if left.token.tok == ◂assign
                    sig = @rReturnType()
                    argtoken = tkn(◂val_type "" left.token.line left.token.col)
                    argNode  = nod ●arg argtoken nil left.operand_left left.operand_right
                    sig.sig_args = nod ●list left.token [argNode]
                    ⮐  sig
            elif left.kind == ●list
                sig = @rReturnType()
                sig.sig_args = left
                ⮐  sig
            elif left.kind == ●arg
                sig = @rReturnType()
                sig.sig_args = nod ●list left.token [left]
                ⮐  sig
                        
    rColor: ➜Node ->
    
        token = @consume() # ◌
        token.str = ""
        color_value = nod ●literal token
        lt = @peek(-1)
        while @tok notin {◂comma ◂eof ◂indent} and @isConnectedLeft()
            t = @consume()
            color_value.token.str &= t.str
        nod ●color token color_value
                        
    rArg: ➜Node ->
    
        token = @consume() # ◆ or ◇
        
        if @typeless
            nameToken = @consume()
            nameToken.tok = ◂name
            nameToken.str = token.str & nameToken.str
            nameToken.col = token.col
            ⮐  nod ●literal nameToken
    
        arg_type  = @parseType()
        arg_name  = @value()
        arg_value ◇ Node
        
        if @tok == ◂assign
            t = @consume() # =
            arg_value = @expression() 
        
        nod ●arg token arg_type arg_name arg_value
    
    lVar: ◇Node left ➜Node ->
    
        ⮐  if left.token.tok != ◂name
            
        token     = @consume() # ◆ or ◇
        var_type  = @parseType()
        var_value ◇ Node
        
        if @tok == ◂assign
            t = @consume() # =
            var_value = @expression() 
        nod ●var token left var_type var_value
    
    lSymbolList: ◇Node left ➜Node ->
    
        ⮐  if @listless
    
        switch left.kind 
            ●list
                list_values = left.list_values
                # todo: check if all list items are symbols?
                list_values.add @rSymbol()
                ⮐  nod ●list left.token list_values
            ●literal
                if left.token.tok != ◂name
                    ⮐  
                list_values ◇ seq[Node]
                list_values.add left
                list_values.add @rSymbol()
                ⮐  nod ●list left.token list_values
            ➜ 
                discard
    
    lArgList: ◇Node left ➜Node ->
        
        switch left.kind 
            ●list
                list_values = left.list_values
                list_values.add @rArg()
                ⮐  nod ●list left.token list_values
            ●arg
                list_values ◇ seq[Node]
                list_values.add left
                list_values.add @rArg()
                ⮐  nod ●list left.token list_values
            ●literal
                if left.token.tok == ◂name
                    ⮐  @lVar left
            ➜ 
                discard

    # ████████  ███   ███  ███   ███   ███████
    # ███       ███   ███  ████  ███  ███     
    # ██████    ███   ███  ███ █ ███  ███     
    # ███       ███   ███  ███  ████  ███     
    # ███        ███████   ███   ███   ███████
    
    lFunc: ◇Node left ➜Node ->
    
        ⮐  if left.kind notin {●signature ●list ●arg ●operation ●range ●member}

        func_signature ◇ Node
        
        if left.kind == ●operation
        
            # log "lfunc op #{left}"
            
            ⮐  if left.token.tok != ◂assign
                
            ⮐  if left.operand_left.token.tok != ◂name
                
            if left.operand_left.token.col == 0 
                left = left
                argtoken = tkn ◂val_type left.operand_right.token.line left.operand_right.token.col
                left.operand_right = @lFunc nod(●arg argtoken nil left.operand_right nil)
                ⮐  left
                
            vartoken = tkn ◂val_type left.operand_left.token.line left.operand_left.token.col
            varNode  = nod ●arg vartoken nil left.operand_left left.operand_right
            sig_args = nod ●list vartoken [varNode]
            func_signature = nod ●signature left.token sig_args nil
            
        elif left.kind == ●member
        
            left = left
            argtoken = tkn ◂val_type left.member_value.token.line left.member_value.token.col
            left.member_value = @lFunc nod(●arg argtoken nil left.member_value nil)
            ⮐  left
            
        elif left.kind == ●list
        
            # log "lfunc list"
            
            sig_args = left
            for i a in sig_args.list_values
                if a.kind == ●operation and a.token.tok == ◂assign
                    argtoken = tkn ◂val_type a.operand_left.token.line a.operand_left.token.col
                    sig_args.list_values[i] = nod ●arg argtoken nil a.operand_left a.operand_right
                elif a.kind == ●literal and a.token.tok == ◂name
                    argtoken = tkn ◂val_type a.token.line a.token.col
                    sig_args.list_values[i] = nod ●arg argtoken nil a nil
            func_signature = nod ●signature left.token sig_args nil
            
        elif left.kind == ●arg
        
            # log "lfunc arg"
            
            sig_args = nod ●list left.token [left]
            func_signature = nod ●signature left.token sig_args nil
            
        elif left.kind == ●range
        
            # log "left range #{left}"
            sig_args = nod ●list left.token [left]
            func_signature = nod ●signature left.token sig_args nil
            
        elif left.kind == ●signature
        
            func_signature = left
            
        else
        
            log "unhandled left #{left.kind}"
        
        firstToken = @firstLineToken()
        token = @consume()
        
        func_mod ◇Node
        if @tok == ◂mod
            func_mod = @rLiteral()
        
        func_body = @funcBody firstToken
        
        nod ●func token func_signature func_mod func_body
    
    rFunc: ➜Node ->

        firstToken = @firstLineToken()
        token = @consume()
        
        func_mod ◇ Node
        if @tok == ◂mod
            func_mod = @rLiteral()

        func_body = @funcBody firstToken
        
        nod ●func token nil nil func_body
    
    parseSignature: ➜Node ->
    
        sig_args = nod ●list @current() []
        sig_type ◇ Node
        
        parens = false
        if @tok == ◂paren_open
            @swallow()
            parens = true
        
        while true
            
            token    = @current()
            arg_type ◇ Node = nil
            
            if @tok in {◂var_type ◂val_type}
            
                @swallow() # ◆ or ◇
                arg_type  = @parseType()
                            
            if @tok != ◂name
                break
                    
            arg_name  = @value()
            arg_value ◇ Node
    
            if @tok == ◂assign
                @swallow() # =
                @listless += 1
                @explicit += 1
                arg_value = @expression()
                @explicit -= 1
                @listless -= 1
                
            @swallow ◂comma
            
            sig_args.list_values.add nod(●arg token arg_type arg_name arg_value)
        
        if parens 
            ⮐  if @tok != ◂paren_close
            @swallow()
    
        if @tok == ◂then
            @swallow()
            sig_type = @parseType()
    
        if @tok notin {◂func ◂method}
            ⮐  
            
        nod ●signature sig_args.token sig_args sig_type
    
    funcOrExpression: ◇Token token ➜Node ->
    
        col = @lineIndent token.line
    
        if @isTokAhead(◂func) or @isTokAhead(◂method) 
            startPos = @pos
            func_signature ◇ Node
            if @tok notin {◂func ◂method}
                func_signature = @parseSignature()
            if @tok in {◂func ◂method}
                ftoken = @consume()
                func_mod = if @tok == ◂mod ➜ @rLiteral() ➜ nil
                func_body = @funcBody tkn(◂null token.line col)
                ⮐  nod ●func ftoken func_signature func_mod func_body
            else
                @pos = startPos
        
        @expressionOrIndentedBlock token col
    
    rReturn: ➜Node ->
    
        token = @consume()
        
        if @tok == ◂if and @isThenlessIf token
            nod ●return token nil
        else
            @returning = true
    
            right ◇ Node 
            if @tok != ◂indent or @isNextLineIndented token
                right = @expression token
            
            @returning = false
            nod ●return token right
    
    rDiscard: ➜Node ->
    
        token = @consume()
        if @isDedent token.col
            nod ●discard token nil
        else
            nod ●discard token @value()
        
    #  ███████   ████████   ████████  ████████    ███████   █████████  ███   ███████   ███   ███
    # ███   ███  ███   ███  ███       ███   ███  ███   ███     ███     ███  ███   ███  ████  ███
    # ███   ███  ████████   ███████   ███████    █████████     ███     ███  ███   ███  ███ █ ███
    # ███   ███  ███        ███       ███   ███  ███   ███     ███     ███  ███   ███  ███  ████
    #  ███████   ███        ████████  ███   ███  ███   ███     ███     ███   ███████   ███   ███
    
    lOperation: ◇Node left ➜Node ->
    
        token = @consume()
        right = @expression token
        nod ●operation token left right

    lMinus: ◇Node left ➜Node ->
    
        if not @isConnectedLeft() and @isConnectedRight() or left.token.line < @current.line
            ⮐ 
        else
            token = @consume()
            right = @expression token
            nod ●operation token left right
        
    lNotIn: ◇Node left ➜Node ->
    
        if @peek(1).tok == ◂in
            token = @consume()
            token.str = "notin"
            token.tok = ◂notin
            @swallow()
            right = @expression token
            ⮐  nod ●operation token left right
    
    lPostOp: ◇Node left ➜Node ->
    
        nod ●postOp @consume() left
    
    rPreOp: ➜Node ->
    
        token = @consume()
        right = @expression token
        nod ●preOp token right

    rLog: ➜Node ->
    
        token = @consume()
        right ◇ Node
        if @tok == ◂paren_open
            right = @rParenExpr()
        else
            right = @parseExprOrList token
        nod ●preOp token right
        
    rAssert: ➜Node ->
    
        token = @consume()
        args  = @parseCallArgs token.col
        Node token:token kind:●call callee:nod(●literal token) callargs:args
        
    rDollar: ➜Node ->
    
        if @current.str.len > 1
            token = @consume()
            token.tok = ◂name
            ⮐  nod ●literal token
        if @peek(1).tok in {◂assign ◂colon}
            token = @consume()
            token.tok = ◂name
            ⮐  nod ●literal token
        @rPreOp()
    
    lAssign: ◇Node left ➜Node ->
    
        token = @consume()
        right = @funcOrExpression token
        nod ●operation token left right
    
    lRange: ◇Node left ➜Node ->
    
        ⮐  if @isTokAhead ◂func
        token = @consume()
        right = @expression token
        nod ●range token left right
        
    rRange: ◇Node ➜Node ->

        token = @consume()
        right ◇ Node
        if @tok notin {◂paren_close ◂indent ◂then} and not @isTokAhead ◂func
            right = @expression token
        nod ●range token nil right
            
    rParenExpr: ➜Node ->
    
        nod ●list @current @parseParenList()
    
    rCurly: ➜Node ->
    
        nod ●curly @current @parseDelimitedList(◂bracket_open ◂bracket_close)
    
    rSquarely: ➜Node ->
    
        nod ●squarely @current @parseDelimitedList(◂square_open ◂square_close)
    
    rEnum: ➜Node ->
    
        token = @consume()
        enum_name = @value()
        enum_body ◇ Node
        if @isNextLineIndented token
            @typeless = true
            enum_body = @parseBlock()
            @typeless = false
        nod ●enum token enum_name enum_body
        
    rClass: ➜Node ->
    
        token = @consume()
        
        if @tok != ◂name
            ⮐  nod ●literal token
        
        @explicit += 1
        name  = @value()
        parent ◇ Node
        if @current.str == "extends"
            @swallow()
            parent = @value()
        @explicit -= 1
        nod ●class token name parent @parseBlock()

    rStruct: ➜Node ->

        token = @consume()
        name  = @value()
        parent ◇ Node
        if @current.str == "extends"
            @swallow()
            parent = @value()
    
        nod ●struct token name parent @parseBlock()
        
    lMember: ◇Node left ➜Node ->
        if @isConnectedLeftAndRight()
            token = @consume()
            token.col = left.token.col
            right = @value()
            if not right
                ⮐  @error "Expected member value" token
            nod ●member token left right
        else            
            token = @consume()
            token.col = left.token.col
            right = @funcOrExpression token
            if not right
                ⮐  @error "Expected member value" token
            nod ●member token left right
        
    lTestCase: ◇Node left ➜Node ->
        
        ⮐  if @listless
        token = @consume() # ▸
        @swallow ◂indent # todo: check if indent is larger than that of the test expression
        right = @expression()
        nod ●testCase token left right
    
    rTestSuite: ➜Node ->
    
        token = @consume() # ▸
        test_block = @thenBlock()
        if token.col == 0
            nod ●testSuite token test_block
        else
            nod ●testSection token test_block

    # ████████  ███   ███  ████████   ████████   ████████   ███████   ███████  ███   ███████   ███   ███
    # ███        ███ ███   ███   ███  ███   ███  ███       ███       ███       ███  ███   ███  ████  ███
    # ███████     █████    ████████   ███████    ███████   ███████   ███████   ███  ███   ███  ███ █ ███
    # ███        ███ ███   ███        ███   ███  ███            ███       ███  ███  ███   ███  ███  ████
    # ████████  ███   ███  ███        ███   ███  ████████  ███████   ███████   ███   ███████   ███   ███
    
    ###
       ◂R      ◂LR     ◂L      ◂R      ◂L      ◂LR     ◂R 
       │       │       │       │       │       │ 
       ◂R➜●    │       │       ◂R➜●    │       │ 
          │    │       │          │    │       │
          ╰───●◂L➜●───●◂L➜●       ╰───●◂L➜●───●◂L➜●
                          │                       │
                          ▾                       ▾
    ###
    
    expression: precedenceRight=0 ➜Node ->
    
        ⮐  nil if @failed
    
        token = @current
        if token.tok in {◂eof ◂stripol_end ◂paren_close}
            ⮐  nil
    
        rhs = @rightHandSide token
        
        if rhs == nil
            # ⮐  @error "Expected expression but found #{token.str} #{token}" token
            ⮐  @error "Expected expression but found #{token.str}" token
            
        node = @rhs()
        
        if precedenceRight < -1
            ⮐  node
    
        while not @atEnd()
            
            token = @current
            precedence = @getPrecedence token
            
            if token.tok in {◂assign ◂test ◂semicolon}
                precedence += 1
                
            lhs = @leftHandSide token
            
            if precedenceRight >= precedence
                break
        
            if lhs == nil
                break
                
            lhn = @lhs(node)
            
            if lhn != nil
                node = lhn
            else
                break 
                
            if @tok == ◂indent and @peek(1).tok in {◂dot}
                 @swallow()
                 node = @lPropertyAccess node
                                 
        node
                
    # ████████   ████████    ███████   █████████  █████████
    # ███   ███  ███   ███  ███   ███     ███        ███   
    # ████████   ███████    █████████     ███        ███   
    # ███        ███   ███  ███   ███     ███        ███   
    # ███        ███   ███  ███   ███     ███        ███   
    
    pratt: ◇tok t ◇LHS lhs ◇RHS rhs ◇int precedence ->
    
        if @pratts.len <= t.ord
            @pratts.setLen t.ord + 1
        
        @pratts[t.ord] = Pratt lhs:lhs rhs:rhs precedence:precedence
    
    #  ███████  ████████  █████████  ███   ███  ████████ 
    # ███       ███          ███     ███   ███  ███   ███
    # ███████   ███████      ███     ███   ███  ████████ 
    #      ███  ███          ███     ███   ███  ███      
    # ███████   ████████     ███      ███████   ███      
    
    setup: ->
    
        @pratt ◂semicolon         lSemiColon        nil,            0
        @pratt ◂log               nil               rLog            1
        @pratt ◂assert            nil               rAssert         2
        @pratt ◂true              nil               rLiteral        2
        @pratt ◂false             nil               rLiteral        2
        @pratt ◂mod               nil               rLiteral        2
        @pratt ◂null              nil               rLiteral        2
        @pratt ◂number            nil               rLiteral        2
        @pratt ◂string_start      nil               rString         2
        @pratt ◂comment_start     nil               rComment        2
        @pratt ◂verbatim          nil               rLiteral        2
        @pratt ◂use               nil               rUse            2
        @pratt ◂let               nil               rLet            2
        @pratt ◂var               nil               rLet            2
        @pratt ◂return            nil               rReturn         2
        @pratt ◂discard           nil               rDiscard        2
        @pratt ◂quote             nil               rQuote          2
        @pratt ◂test              lTestCase         rTestSuite      2
        @pratt ◂class             nil               rClass          2
        @pratt ◂struct            nil               rStruct         2
        @pratt ◂enum              nil               rEnum           2
        @pratt ◂continue          nil               rKeyword        2
        @pratt ◂break             nil               rKeyword        2
                                                                        
        @pratt ◂assign            lAssign           nil            10
        @pratt ◂plus_assign       lAssign           nil            10
        @pratt ◂minus_assign      lAssign           nil            10
        @pratt ◂divide_assign     lAssign           nil            10
        @pratt ◂multiply_assign   lAssign           nil            10
        @pratt ◂ampersand_assign  lAssign           nil            10
        @pratt ◂qmark_assign      lAssign           nil            10
    
        @pratt ◂name              lSymbolList       rSymbol        13 # higher than assign
        
        @pratt ◂if                lTailIf           rIf            20
        @pratt ◂when              nil               rIf            20
        @pratt ◂for               nil               rFor           20
        @pratt ◂switch            nil               rSwitch        20
        @pratt ◂while             nil               rWhile         20
        @pratt ◂func              lFunc             rFunc          20
        @pratt ◂method            lFunc             rFunc          20
        
        @pratt ◂or                lOperation        nil            30
        @pratt ◂and               lOperation        nil            31
        
        @pratt ◂is                lOperation        nil            32
        @pratt ◂in                lOperation        nil            33
        @pratt ◂of                lOperation        nil            33
        @pratt ◂notin             lOperation        nil            34
            
        @pratt ◂equal             lOperation        nil            40
        @pratt ◂not_equal         lOperation        nil            40
        @pratt ◂greater_equal     lOperation        nil            40
        @pratt ◂less_equal        lOperation        nil            40
        @pratt ◂less              lOperation        nil            40
        @pratt ◂greater           lOperation        nil            40
        @pratt ◂match             lOperation        nil            40
        
        @pratt ◂doubledot         lRange            nil            40
        @pratt ◂tripledot         lRange            rRange         40
        
        @pratt ◂ampersand         lOperation        nil            42
        @pratt ◂dollar            nil               rDollar        48
        @pratt ◂caret             nil               rPreOp         48
        
        @pratt ◂plus              lOperation        nil            50
        @pratt ◂minus             lMinus            rPreOp         50
                                                       
        @pratt ◂multiply          lOperation        nil            60
        @pratt ◂divide            lOperation        nil            60
        @pratt ◂modulo            lOperation        nil            60
        @pratt ◂bitor             lOperation        nil            60
    
        @pratt ◂not               lNotIn            rPreOp         70
        @pratt ◂tilde             nil               rPreOp         70
        @pratt ◂colon             lMember           nil            71
    
        @pratt ◂increment         lPostOp           nil            80
        @pratt ◂decrement         lPostOp           nil            80
    
        @pratt ◂square_open       lArrayAccess      rSquarely      90
        @pratt ◂paren_open        lCall             rParenExpr     90
        @pratt ◂bracket_open      nil               rCurly         90
        @pratt ◂then              lReturnType       rReturnType    99
        @pratt ◂color             nil               rColor        100
        @pratt ◂val_type          lArgList          rArg          100
        @pratt ◂var_type          lArgList          rArg          100
        @pratt ◂dot               lPropertyAccess   nil           102
    
#  ███████    ███████  █████████
# ███   ███  ███          ███   
# █████████  ███████      ███   
# ███   ███       ███     ███   
# ███   ███  ███████      ███   

ast* = ◇string text ◇string lang ➜Node ->

    # profileStart 'tknz'
    tokens = tokenize text lang
    # profileStop 'tknz'
    # log &"ast* {tokens}"
    # profileStart 'pars'
    p = Parser tokens:tokens pos:0 text:text lang:lang
    p.setup()
    b = p.parseBlock()
    # profileStop 'pars'
    ⮐  nil if p.failed
    b
    
    