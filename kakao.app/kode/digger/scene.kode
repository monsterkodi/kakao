###
 0000000   0000000  00000000  000   000  00000000    
000       000       000       0000  000  000         
0000000   000       0000000   000 0 000  0000000     
     000  000       000       000  0000  000         
0000000    0000000  00000000  000   000  00000000    
###

use ../kxk ▪ deg2rad randInt randRange
use ./lib/gridhelper
use ./lib/noise ▪ simplex3

import * as three from 'three'
import { EffectComposer }   from 'three/addons/postprocessing/EffectComposer.js'
import { RenderPass }       from 'three/addons/postprocessing/RenderPass.js'
import { UnrealBloomPass }  from 'three/addons/postprocessing/UnrealBloomPass.js'
import { OutputPass }       from 'three/addons/postprocessing/OutputPass.js'
import { OrbitControls }    from 'three/addons/controls/OrbitControls.js'
import { MarchingCubes }    from 'three/addons/objects/MarchingCubes.js'

function Scene

    @: @view ->
        
        @scene     = new three.Scene()
        @clock     = new three.Clock()
        @raycaster = new three.Raycaster()
        @mouse     = new three.Vector2 1 1
        @unitX     = new three.Vector3 1 0 0
        @unitY     = new three.Vector3 0 1 0
        @unitZ     = new three.Vector3 0 0 1
        @vec       = new three.Vector3
        @quat      = new three.Quaternion
        @matrix    = new three.Matrix4

        @initRenderer()
        @initCamera()
        @initLights()
        @initMarchingCubes()
        @initHelpers()
        # @initControls()
        @initComposer()
        
        window.addEventListener 'resize' @onWindowResize 
        document.addEventListener 'mousemove' @onMouseMove

    # 00000000   00000000  000   000  0000000    00000000  00000000   00000000  00000000   
    # 000   000  000       0000  000  000   000  000       000   000  000       000   000  
    # 0000000    0000000   000 0 000  000   000  0000000   0000000    0000000   0000000    
    # 000   000  000       000  0000  000   000  000       000   000  000       000   000  
    # 000   000  00000000  000   000  0000000    00000000  000   000  00000000  000   000  
    
    initRenderer: =>
        
        @renderer = new three.WebGLRenderer()

        @renderer.setPixelRatio window.devicePixelRatio
        @renderer.setSize @view.clientWidth @view.clientHeight
        @renderer.shadowMap.enabled = true
        @renderer.shadowMap.type = three.PCFSoftShadowMap
        @renderer.setClearColor new three.Color 0 0 0         
        @renderer.toneMapping = three.ReinhardToneMapping
        @renderer.toneMappingExposure = Math.pow 1 4.0

        @view.appendChild @renderer.domElement
        @renderer.setAnimationLoop @animate 
        
    #  0000000   0000000   00     00  00000000  00000000    0000000   
    # 000       000   000  000   000  000       000   000  000   000  
    # 000       000000000  000000000  0000000   0000000    000000000  
    # 000       000   000  000 0 000  000       000   000  000   000  
    #  0000000  000   000  000   000  00000000  000   000  000   000  
    
    initCamera: =>
        
        @camera = new three.PerspectiveCamera 45 @view.clientWidth / @view.clientHeight 0.1 1000
        @camera.position.set 0 0 150
        @camera.lookAt 0 0 0 
        
    #  0000000   0000000   00     00  00000000    0000000    0000000  00000000  00000000   
    # 000       000   000  000   000  000   000  000   000  000       000       000   000  
    # 000       000   000  000000000  00000000   000   000  0000000   0000000   0000000    
    # 000       000   000  000 0 000  000        000   000       000  000       000   000  
    #  0000000   0000000   000   000  000         0000000   0000000   00000000  000   000  
    
    initComposer: =>
        
        renderScene = new RenderPass @scene @camera
        
        size = new three.Vector2 @view.clientWidth @view.clientHeight
        
        bloomPass  = new UnrealBloomPass size 0.3 0 1.01 # strength radius threshold 
        outputPass = new OutputPass()
                
        @composer = new EffectComposer @renderer
        @composer.setPixelRatio window.devicePixelRatio
        @composer.setSize @view.clientWidth @view.clientHeight
        @composer.addPass renderScene
        @composer.addPass bloomPass
        @composer.addPass outputPass
        
    #  0000000   0000000   000   000  000000000  00000000    0000000   000       0000000  
    # 000       000   000  0000  000     000     000   000  000   000  000      000       
    # 000       000   000  000 0 000     000     0000000    000   000  000      0000000   
    # 000       000   000  000  0000     000     000   000  000   000  000           000  
    #  0000000   0000000   000   000     000     000   000   0000000   0000000  0000000   
    
    initControls: =>
        
        @controls = new OrbitControls @camera @renderer.domElement
        @controls.maxPolarAngle = Math.PI * 0.5
        @controls.minDistance   = 13
        @controls.maxDistance   = 300
        @controls.enableDamping = true
        @controls.minPolarAngle = -Math.PI
        @controls.maxPolarAngle = Math.PI
        @controls.target.set 0 1 0
        
    # 000      000   0000000   000   000  000000000   0000000  
    # 000      000  000        000   000     000     000       
    # 000      000  000  0000  000000000     000     0000000   
    # 000      000  000   000  000   000     000          000  
    # 0000000  000   0000000   000   000     000     0000000   
    
    initLights: =>
        
        @lightIntensityAmbient = 10
        @lightIntensityPlayer  = 10
        @lightIntensityShadow  = 20
        
        @lightAmbient = new three.AmbientLight 0xffffff @lightIntensityAmbient
        @scene.add @lightAmbient
        
        @lightPlayer = new three.PointLight 0xffffff @lightIntensityPlayer 0 0
        @lightPlayer.position.copy @camera.position
        @scene.add @lightPlayer

        @lightShadow = new three.DirectionalLight 0xffffff @lightIntensityShadow 
        @lightShadow.castShadow = true
        @lightShadow.position.set -10 30 30
        @lightShadow.target.position.set 0 0 0
        @lightShadow.shadow.mapSize.width  = 4096
        @lightShadow.shadow.mapSize.height = 4096
        @lightShadow.shadow.camera.near    = 0.5
        @lightShadow.shadow.camera.far     =  400
        @lightShadow.shadow.camera.left    = -50
        @lightShadow.shadow.camera.right   =  50
        @lightShadow.shadow.camera.top     =  50
        @lightShadow.shadow.camera.bottom  = -50
        @scene.add @lightShadow
                        
        if false
            geom = new three.PlaneGeometry 1500 1500
            @shadowFloor = new three.Mesh geom new three.ShadowMaterial color:0x000000 opacity:0.2 depthWrite:false
            @shadowFloor.rotateX deg2rad(-90)
            @shadowFloor.receiveShadow = true
            @scene.add @shadowFloor

    # 00000000   00000000   0000000  000  0000000  00000000  
    # 000   000  000       000       000     000   000       
    # 0000000    0000000   0000000   000    000    0000000   
    # 000   000  000            000  000   000     000       
    # 000   000  00000000  0000000   000  0000000  00000000  
    
    onWindowResize: =>

        @camera.aspect = @view.clientWidth / @view.clientHeight 
        @camera.updateProjectionMatrix()

        @renderer.setSize @view.clientWidth @view.clientHeight 
        @composer.setSize @view.clientWidth @view.clientHeight 

    # 00     00   0000000   000   000   0000000  00000000       00     00   0000000   000   000  00000000  
    # 000   000  000   000  000   000  000       000            000   000  000   000  000   000  000       
    # 000000000  000   000  000   000  0000000   0000000        000000000  000   000   000 000   0000000   
    # 000 0 000  000   000  000   000       000  000            000 0 000  000   000     000     000       
    # 000   000   0000000    0000000   0000000   00000000       000   000   0000000       0      00000000  
    
    onMouseMove: event =>

        event.preventDefault()

        @mouse.x =  (event.clientX / @view.clientWidth) * 2 - 1
        @mouse.y = -((event.clientY-30) / @view.clientHeight) * 2 + 1
        @mouse
        
    # 000   000  00000000  000      00000000   00000000  00000000    0000000  
    # 000   000  000       000      000   000  000       000   000  000       
    # 000000000  0000000   000      00000000   0000000   0000000    0000000   
    # 000   000  000       000      000        000       000   000       000  
    # 000   000  00000000  0000000  000        00000000  000   000  0000000   
    
    initHelpers: =>
        
        @lightShadowHelper = new three.DirectionalLightHelper @lightShadow 5 new three.Color 0xffff00
        @lightShadowHelper.visible = false
        @scene.add @lightShadowHelper
        
        @shadowCameraHelper = new three.CameraHelper @lightShadow.shadow.camera
        @shadowCameraHelper.visible = false
        @scene.add @shadowCameraHelper
        
        @axesHelper = new three.AxesHelper 10
        @axesHelper.visible = false
        @axesHelper.position.set 0 0.1 0
        @axesHelper.material.depthWrite = false
        @axesHelper.material.depthTest = false
        @axesHelper.material.depthFunc = three.NeverDepth
        @scene.add @axesHelper
        
        @gridHelper = new gridhelper()
        @gridHelper.visible = false
        @scene.add @gridHelper
        
    # 00     00   0000000   00000000    0000000  000   000  000  000   000   0000000 
    # 000   000  000   000  000   000  000       000   000  000  0000  000  000      
    # 000000000  000000000  0000000    000       000000000  000  000 0 000  000  0000
    # 000 0 000  000   000  000   000  000       000   000  000  000  0000  000   000
    # 000   000  000   000  000   000   0000000  000   000  000  000   000   0000000 
    
    initMarchingCubes: =>
        
        @resolution = 100
        
        color = new three.Color 1 1 1
        mat = new three.MeshLambertMaterial color:color vertexColors:true flatShading:false dithering:true
        enableUvs = false
        enableColors = true
        maxPolyCount = 1500000
        @mc = new MarchingCubes @resolution mat enableUvs enableColors maxPolyCount
        @mc.scale.set 50 50 50
        @mc.receiveShadow = true
        @mc.castShadow = true
        @scene.add @mc
        
        @initGyroidSphere()
        
    #  0000000   000   000  00000000    0000000   000  0000000    
    # 000         000 000   000   000  000   000  000  000   000  
    # 000  0000    00000    0000000    000   000  000  000   000  
    # 000   000     000     000   000  000   000  000  000   000  
    #  0000000      000     000   000   0000000   000  0000000    
    
    initGyroidSphere: =>
        
        gyroid = x y z -> Math.sin(x)*Math.cos(y)+Math.sin(y)*Math.cos(z)+Math.sin(z)*Math.cos(x)
        
        @mc.reset()
        
        for x in 0...@resolution
            for y in 0...@resolution
                for z in 0...@resolution
                    ss = @resolution/(Math.PI*12)
                    rf = Math.sqrt((x/@resolution-0.5)*(x/@resolution-0.5) + (y/@resolution-0.5)*(y/@resolution-0.5) + (z/@resolution-0.5)*(z/@resolution-0.5))
                    ff = 1-1.41*rf
                    
                    nx = x/ss
                    ny = y/ss
                    nz = z/ss
                    
                    cx = nx-0.5
                    cy = ny-0.5
                    cz = nz-0.5
                    
                    fo = Math.sqrt cx*cx + cz*cz
                    beta = fo*0.01
                    rx = cx*Math.cos(beta)-cz*Math.sin(beta)
                    ry = cy 
                    rz = cx*Math.sin(beta)+cz*Math.cos(beta)
                    
                    nx = rx+0.5
                    ny = ry+0.5
                    nz = rz+0.5
                    
                    @mc.setCell x y z Math.max(0 ff*100*(gyroid(nx ny nz)+1))
                        
                    yn = y/@resolution 

                    b = ff * ff
                    b = b * b * b
                    b = clamp 0 1 b
                    ss = 0.8*@resolution
                    r = 4*Math.max(0 simplex3(x/ss y/ss z/ss)+0.05)
                    r = r * r * b
                    g = r/2
                    @mc.setColor x y z r g Math.max(0 b-r)
            
        @mc.update()

    #  0000000   000   000  000  00     00   0000000   000000000  00000000  
    # 000   000  0000  000  000  000   000  000   000     000     000       
    # 000000000  000 0 000  000  000000000  000000000     000     0000000   
    # 000   000  000  0000  000  000 0 000  000   000     000     000       
    # 000   000  000   000  000  000   000  000   000     000     00000000  
    
    animate: =>

        # @raycaster.setFromCamera @mouse @camera

        # intersection = @raycaster.intersectObject @mesh 
        # if intersection.length > 0    
            # log intersection[0]
            # instanceId = intersection[0].instanceId

        @lightPlayer.position.copy @camera.position
        
        @lightShadow.position.copy @camera.position
        
        @quat.copy @camera.quaternion
        @vec.copy @unitX
        @vec.applyQuaternion @quat
        @vec.multiplyScalar -20
        
        @lightShadow.position.add @vec
        
        @vec.copy @unitY
        @vec.applyQuaternion @quat
        @vec.multiplyScalar 10
        @lightShadow.position.add @vec
        
        @controls?.update @clock.getDelta()
        @composer.render()

export Scene
