###
00     00   0000000   000000000  00000000   000  000   000
000   000  000   000     000     000   000  000   000 000 
000000000  000000000     000     0000000    000    00000  
000 0 000  000   000     000     000   000  000   000 000 
000   000  000   000     000     000   000  000  000   000
###

use ../kxk ▪ fade randRange randInt randIntRange

function matrix

    @: ->

        @PLANT             = 0
        @EGG               = 1
        @CRITTER           = 2
        @TUBE              = 3
        @NUM_TYPES         = 4
        
        @ws = 40
                
        @eggFadeTime       = 6.0
        @eggMoveTime       = 3.0
        @critMoveTime      = 4.0 
        @critDieTime       = 4.0
        
        @numLeaves         = 8
        @setCritterAge     600
        @critterNumEggs    = 3
        @eggMaxAge         = 200
        @leafMaxAge        = 50
        @critterEatPeriod  = 50
        @critterStarveTime = 50
        
        @tweaky.init                                                        
            speed:      min: 1    max:100    step:1      value:@speed,              cb: (@speed) =>
            leaves:     min: 4    max:12     step:1      value:@numLeaves,          cb: (@numLeaves) =>
            leafAge:    min: 1    max:100    step:1      value:@leafMaxAge,         cb: (@leafMaxAge) =>
            eggAge:     min: 10   max:200    step:10     value:@eggMaxAge,          cb: (@eggMaxAge) =>
            critterAge: min: 60   max:600    step:10     value:@critterMaxAge,      cb: @setCritterAge
            eatPeriod:  min: 1    max:100    step:1      value:@critterEatPeriod,   cb: (@critterEatPeriod) =>
            starveTime: min: 1    max:100    step:1      value:@critterStarveTime,  cb: (@critterStarveTime) =>
        
        @start()
        
    setCritterAge: (@critterMaxAge) =>
        
        @critterAdultAge = parseInt @critterMaxAge/3
        
    #  0000000  000000000   0000000   00000000   000000000  
    # 000          000     000   000  000   000     000     
    # 0000000      000     000000000  0000000       000     
    #      000     000     000   000  000   000     000     
    # 0000000      000     000   000  000   000     000     
    
    start: =>
        
        @anims = []
        @grid  = []
        @types = []
        
        for t in 0...@NUM_TYPES
            @types.push []
            
        @eggs     = @types[@EGG]
        @critters = @types[@CRITTER]
        @plants   = @types[@PLANT]
        @tubes    = @types[@TUBE]
        
        for x in 0...@ws
            column = []
            for y in 0...@ws
                column.push null
            @grid.push column
            
        @addEgg @ws/2 @ws/2
        
        for x in 0..@ws/3
            for y in 0..@ws/3
                @addPlant x*3 y*3
        
    #  0000000   0000000    000   000   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000   000  0000  000  000       000       
    # 000000000  000   000   000 000   000000000  000 0 000  000       0000000   
    # 000   000  000   000     000     000   000  000  0000  000       000       
    # 000   000  0000000        0      000   000  000   000   0000000  00000000  
    
    advance: sec =>
        
        for e in @eggs
            
            e.age += sec
            
            if e.age > @eggMaxAge and e.age-sec <= @eggMaxAge
                @addCritter e.x, e.y
                
            if e.age > @eggMaxAge+@eggFadeTime
                @del e
                
        for c in @critters
            
            c.age += sec
            c.eat -= sec
                                    
            if c.age > @critterMaxAge or c.eat < -@critterStarveTime
                c.df ?= 0
                c.df += sec / @critDieTime
                # if c.df > 1
                    # @del c
                continue
                
            if c.eat < 0
                if l = @neighborLeaf c
                    c.eat = @critterEatPeriod
                    l.age = 0
                # continue
                
            continue if c.p
            continue if c.ox or c.oy
            
            if Math.floor((c.age-@critterAdultAge) / @critterEggPeriod(c)) > c.eggs
                if n = @emptyNeighbor c
                    e = @addEgg n.x, n.y
                    @moveObjectFrom e, c, @eggMoveTime
                    @anim c, 'p' 1 0 2
                c.eggs++
                    
            continue if @critterEggFactor(c) > 0.9
                    
            n = @randomOffset c
            if @isInWorld(n) and @isEmpty n
                op = x:c.x, y:c.y
                @grid[c.x][c.y] = null
                c.x = n[0]
                c.y = n[1]
                @grid[c.x][c.y] = c
                @moveObjectFrom c, op, @critMoveTime
                
        for p in @plants
                        
            for l in p.leaves
                
                l.age += sec
                
        @animate sec

    critterEggFactor: c =>
        
        f = 0
        if c.age > @critterAdultAge and c.eggs < @critterNumEggs
            f = (c.age - @critterAdultAge) / @critterEggPeriod(c)
            f -= c.eggs
        f
        
    critterEggPeriod: c =>
        
        (@critterMaxAge - @critterAdultAge) / (@critterNumEggs + 1)
                
    #  0000000   000   000  000  00     00   0000000   000000000  00000000  
    # 000   000  0000  000  000  000   000  000   000     000     000       
    # 000000000  000 0 000  000  000000000  000000000     000     0000000   
    # 000   000  000  0000  000  000 0 000  000   000     000     000       
    # 000   000  000   000  000  000   000  000   000     000     00000000  
    
    animate: sec =>
        
        ⮐ if empty @anims
                
        for ai in @anims.length-1..0
            
            a = @anims[ai]

            d = (sec / a.d) * (a.t - a.s)
            
            a.o[a.m] += d
            
            if (d > 0 and a.o[a.m] > a.t) or (d < 0 and a.o[a.m] < a.t)
                a.o[a.m] = a.t
                @anims.splice ai, 1
                
    moveObjectFrom: o s d=1 =>
        
        @anim o, 'ox' s.x-o.x, 0 d
        @anim o, 'oy' s.y-o.y, 0 d 
        
    anim: o m s t d =>
        
        ⮐ if d <= 0
        ⮐ if s == t
        
        o[m] = s
        
        @anims.push o:o, m:m, s:s, t:t, d:d
                
    #  0000000   0000000    0000000      
    # 000   000  000   000  000   000    
    # 000000000  000   000  000   000    
    # 000   000  000   000  000   000    
    # 000   000  0000000    0000000      
    
    addObject: x y o =>
        
        @delAt [x, y]
    
        o.x = parseInt x
        o.y = parseInt y
        
        @grid[o.x][o.y] = o
        @types[o.type].push o
        o
                
    addEgg:     x y     => @addObject x, y, type:@EGG,     age:0
    addCritter: x y     => @addObject x, y, type:@CRITTER, age:0, sx:0, sy:0, sf:0, eggs:0, eat:@critterEatPeriod
    addTube:    x y idx => @addObject x, y, type:@TUBE,    idx:idx
    addPlant:   x y     => 
    
        leaves = [] 
        for l in 0...@numLeaves
            leaves.push age:l*@leafMaxAge/@numLeaves
        
        @addObject x, y, type:@PLANT, leaves:leaves

    # 0000000    00000000  000      
    # 000   000  000       000      
    # 000   000  0000000   000      
    # 000   000  000       000      
    # 0000000    00000000  0000000  
    
    delAt: p =>
        
        if o = @objectAt p
            @del o
            
    del: o =>
        
        @types[o.type].splice @types[o.type].indexOf(o), 1
        @grid[o.x][o.y] = null
            
    # 00000000    0000000    0000000    
    # 000   000  000   000  000         
    # 00000000   000   000  0000000     
    # 000        000   000       000    
    # 000         0000000   0000000     
    
    objectAt:  p => if @isInWorld p ➜ ⮐ @grid[p[0]][p[1]]
    isInWorld: p => p[0] >= 0 and p[1] >= 0 and p[0] < @ws and p[1] < @ws
    isEmpty:   p => not @objectAt p
                
    buildingAt: p =>
        
        if o = @objectAt p
            ⮐ o.type in [@PLANT]
        false
        
    emptyNeighbor: o =>
        
        en = []
        
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                c = [o.x+x, o.y+y]
                continue if not @isInWorld c
                if @isEmpty c
                    en.push x:c[0], y:c[1]
                    
        if en.length
            ⮐ en[randInt(en.length)]
        null
    
    validNeighbors: o =>
        
        vn = []
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                c = [o.x+x, o.y+y]
                if @isInWorld c
                    vn.push c
        vn
        
    neighbors: o =>
        
        n = [] 
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                n.push [o.x+x, o.y+y]
        n
        
    objectOfTypeAt: type p =>
        
        if o = @objectAt p
            ⮐ null if o.type != type
        o
        
    plantAt: p => @objectOfTypeAt @PLANT, p
    tubeAt:  p => @objectOfTypeAt @TUBE, p
                
    leafToEatAt: p =>
        
        if pl = @plantAt p
            for l in pl.leaves
                if l.age > @leafMaxAge
                    ⮐ l
        null
                        
    neighborLeaf: o =>
        
        nl = []
        for vn in @neighbors o
            if l = @leafToEatAt vn
                nl.push l
                    
        if nl.length
            ⮐ nl[randInt(nl.length)]
        null
        
    randomOffset: c =>
        
        o = [[-1 1], [0, 1], [1, 1], [-1 0], [1 0], [-1 -1], [0, -1], [1, -1]][randInt 8]
        [c.x+o[0], c.y+o[1]]

    randomOffsetCross: c =>
        
        o = [[0, 1], [-1 0], [1 0], [0, -1]][randInt 4]
        [c.x+o[0], c.y+o[1]]
            
export matrix
