# █████████   ███████   ███   ███   ███████
#    ███     ███   ███  ███  ███   ███     
#    ███     ███   ███  ███████    ███████ 
#    ███     ███   ███  ███  ███        ███
#    ███      ███████   ███   ███  ███████ 

use kxk
export kxk

enum tt*
        
    ◂text
    ◂number
    ◂comment
        
struct Tkn*

    t : tt
    s : int
    e : int
    l : int
    c : int
    
    @: ◇tt t s=-1 e=-1 l=-1 c=-1 -> @t=t ; @s=s ; @e=e ; @l=l ; @c=c
        
    $: ➜string -> "tkn(#{@t} #{@s} #{@e} #{@l} #{@c})"
        
    len: ➜int -> @e - @s

tkn* = ◇tt typ ◇int ss         ◇int line ◇int col ➜Tkn -> t = Tkn() ; t.init typ ss ss line col
tkn* = ◇tt typ ◇int ss ◇int se ◇int line ◇int col ➜Tkn -> t = Tkn() ; t.init typ ss se line col

struct Tknz

    lines : seq[seq[Tkn]]
    line  : seq[Tkn]
    token : Tkn
    segi  : int
    segs  : seq[string]
    bol   : int # segi at start of current line
    idx   : int # current line index
    
    col: ➜int -> @segi - @bol
    
    $: ➜string ->
    
        "▸▸▸ #{@lines} #{@token} bol #{@bol} segi #{@segi} #{@segs} ◂◂◂"
                
    # █████████  ███   ███  ███   ███  ███████
    #    ███     ███  ███   ████  ███     ███ 
    #    ███     ███████    ███ █ ███    ███  
    #    ███     ███  ███   ███  ████   ███   
    #    ███     ███   ███  ███   ███  ███████
    
    push: ->
        if @token.len ➜ @line.add @token
        if @line.len  ➜ @lines.add @line
    
    next: ➜ bool ->
    
        ⮐  false if @segi >= @segs.len
        
        switch @segs[@segi] 
        
            "\n"
                @push()
                @line  = []
                @idx  += 1
                @bol   = @segi
                @token = tkn ◂text @segi+1 @idx 0
            " "
                if @token.len
                    @line.add @token
                    @token = tkn ◂text @segi+1 @idx @col+1
                else
                    @token.s += 1
                    @token.e += 1
                    @token.c += 1
            ➜ 
                @token.e += 1
                    
        @segi += 1
        true
    
    tknz: ◇seq[string] segs ➜seq[seq[Tkn]] ->
    
        @segs = segs
        while @next() ➜ discard
        @push()
        ⮐  @lines

toks* = ◇seq[string] segs ➜seq[seq[Tkn]] -> t = Tknz() ; t.tknz segs
toks* =     ◇string  text ➜seq[seq[Tkn]] -> toks kseg(text)
    
nums* = ◇seq[string] segs ◇seq[seq[Tkn]] tkns ➜seq[seq[Tkn]] ->

    for i1 tknl in tkns
        for i2 tkn in tknl
            p = tkn.s
            
            seg = o=0 ➜string  -> if p+o < tkn.e ➜ segs[p+o] ➜ ""
            chr = o=0 ➜char    -> s = seg(o) ; if s.len > 0 ➜ s[0] ➜ ' '
            adv = ◇int n       -> p += n
            adv = ◇set[char] s -> while chr() in s ➜ p += 1
            num =              ->  
                if p == tkn.e
                    (cast[ref seq[seq[Tkn]]](unsafeAddr(tkns)))[i1][i2].t = ◂number
                
            if seg() == "0" 
                if seg(1) == "x"
                    adv 2
                    adv {'0'..'9' 'a'..'f' 'A'..'F'}
                    num()
                    continue
                if seg(1) == "b"
                    adv 2
                    adv {'0' '1'}
                    num()
                    continue
                if seg(1) == "o"
                    adv 2
                    adv {'0'..'7' }
                    num()
                    continue
                    
            adv {'0'..'9'}
            
            continue if p == tkn.s
                
            if seg() == "." and chr(1) in {'0'..'9'}
                adv 1
                adv {'0'..'9'}
                
            if seg() == "e" and chr(1) in {'0'..'9' '+' '-'}
                adv 2
                adv {'0'..'9'}
            
            num()
    tkns
        