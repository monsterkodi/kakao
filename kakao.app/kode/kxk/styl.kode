###
     0000000  000000000  000   000  000    
    000          000      000 000   000    
    0000000      000       00000    000    
         000     000        000     000    
    0000000      000        000     0000000
    
    poor man's stylus :)
###

use ./kstr â–ª unfillet blockFillets

# 00000000   00000000  000   000  0000000    00000000  00000000   
# 000   000  000       0000  000  000   000  000       000   000  
# 0000000    0000000   000 0 000  000   000  0000000   0000000    
# 000   000  000       000  0000  000   000  000       000   000  
# 000   000  00000000  000   000  0000000    00000000  000   000  

vars = {}
funcs = {}

subvars = (fillets) ->
    
    for fillet in fillets
        if value = vars[fillet.match]
            fillet.match = value
        
    fillets
    
calculus = (fillets) ->
    
    for fillet,index in fillets
        if index == 0
            if fillet.match in '+-'
                rhs  = parseFloat fillets[index+1].match
                rhu  = trim fillets[index+1].match[("#{rhs}").length..]
                fillets.splice index, 2, match:fillet.match + rhs + rhu
                return calculus fillets
            if fillet.match[0] == '-'
                if vars[fillet.match[1..]]
                    fillets.splice index, 1, match:'-'+vars[fillet.match[1..]]
                    return calculus fillets
        if fillet.match in '*+-/'
            lhs  = parseFloat fillets[index-1].match
            rhs  = parseFloat fillets[index+1].match
            if lhs is num and rhs is num
                lhu  = trim fillets[index-1].match[("#{lhs}").length..]
                rhu  = trim fillets[index+1].match[("#{rhs}").length..]
                unit = valid lhu ? lhu : rhu
                result = eval "#{lhs} #{fillet.match} #{rhs}"
                result += unit
                fillets.splice index-1, 3, match:result
                return calculus fillets
        
    fillets

render = (block, text, amps=[]) ->
    
    if block.fillet[0]?.match == '//'
        return text
        
    if block.fillet[1]?.match == '='
        varName = block.fillet[0]?.match
        varValue = unfillet calculus subvars block.fillet[2..]
        vars[varName] = varValue
        return text
        
    if block.fillet[1]?.match == '()'
        funcName = block.fillet[0]?.match
        
        if funcs[funcName]
            text += funcs[funcName]
            return text
        
        funcValue = ''
        for cb in block.blocks
            funcValue = render cb, funcValue, amps
        funcs[funcName] = funcValue
        return text
        
    idt = rpad block.indent
        
    if valid block.blocks
        
        childBlocks = block.blocks.filter (cb) ->
            if cb.fillet[0]?.match[0] == '&'
                cb.fillet[0].match = cb.fillet[0].match[1..]
                cb.fillet = block.fillet.concat cb.fillet
                amps.push cb
                false
            else
                true
        
        text += '\n' + idt + unfillet block.fillet
        text += '\n' + idt + '{'
        for b in childBlocks
            text += render b, ''
        text += '\n' + idt + '}\n'
    else
        text += '\n'
        text += idt + block.fillet[0].match + ': ' + unfillet calculus subvars block.fillet[1..]
        text += ';'
    
    while amp = amps.shift()
        
        amp.indent = 0
        
        for block in amp.blocks
            block.indent = 4
        
        text += render amp, ''

    text
    
#  0000000  000000000  000   000  000      
# 000          000      000 000   000      
# 0000000      000       00000    000      
#      000     000        000     000      
# 0000000      000        000     0000000  

styl = (srcText) ->
    
    vars = {}
    funcs = {}
    
    tgtText = ''
    lines   = srcText.split '\n'
    blocks  = blockFillets lines.map (line) -> kstr.fillet line, '-'
    
    for block in blocks
        tgtText = render block, tgtText

    tgtText

export styl
