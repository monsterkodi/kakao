###
000000000  000000000  000   0000000   
   000        000     000  000   000  
   000        000     000  000   000  
   000        000     000  000   000  
   000        000     000   0000000   
###

use ../kxk ◆ events post

function TTIO extends events

    @: ->
        
        # @store()
        
        @hideCursor()
        
        if process.stdin.isTTY ➜ process.stdin.setRawMode true
            
        lf 'ttio ▸' 

        @write '\x1b[?1000h'    # mouse events
        @write '\x1b[?1002h'    # cell motion tracking
        @write '\x1b[?1003h'    # mouse move events
        @write '\x1b[?1004h'    # focus events        
        @write '\x1b[?1006h'    # mouse SGR mode
        @write '\x1b[?1049h'    # alternate screen buffer
        @write '\x1b[?2004h'    # bracketed paste mode
        @write '\x1b[>1s'       # send shift in mouse press events
        @write '\x1b[>1u'       # kitty keyboard protocol
        @write '\x1b[=31;1u'    # 1 disambiguate escape codes
                                # 2 event types
                                # 4 alternate keys
                                # 8 all keys as escape codes
                                # 16 associated text
        
        process.stdout.on 'resize' @onResize
        process.stdin.on  'data'   @onData
        
    write: str => process.stdout.write str
    
    quit: =>
        
        process.stdout.removeListener 'resize' @onResize
        process.stdin.removeListener  'data'   @onData
        
        @clear()
        @write '\x1b[>0s'    # end sending shift in mouse press
        @write '\x1b[<u'     # end kitty keyboard protocol
        @write '\x1b[?1049l' # scrollback screen buffer
        @showCursor()
        lf 'ttio ◂◂◂'
        @restore()
    
    clear: =>
        @write '\x1b[2J' # clear screen
        @write '\x1b[H'  # cursor home

    cols: => process.stdout.columns
    rows: => process.stdout.rows
        
    #  0000000  000   000  00000000    0000000   0000000   00000000   
    # 000       000   000  000   000  000       000   000  000   000  
    # 000       000   000  0000000    0000000   000   000  0000000    
    # 000       000   000  000   000       000  000   000  000   000  
    #  0000000   0000000   000   000  0000000    0000000   000   000  
    
    setCursor: x y => @write "\x1b[#{y+1};#{x+1}H"
    hideCursor: => @write '\x1b[?25l'
    showCursor: show=true => 
        if show
            @write '\x1b[?25h'
        else
            @hideCursor()
            
    store:   => @write '\x1b7'
    restore: => @write '\x1b8'

    onResize: => @emit 'resize' @cols() @rows()
            
    # 000   000  000  000000000  000000000  000   000  
    # 000  000   000     000        000      000 000   
    # 0000000    000     000        000       00000    
    # 000  000   000     000        000        000     
    # 000   000  000     000        000        000     
    #
    # https://sw.kovidgoyal.net/kitty/keyboard-protocol/
    #
    # doesn't work in terminal.app
    
    parseKitty: csi ->
                
        ⮐ if csi[-1] not in 'uABCD'
        
        key = switch csi[-1]
            'A' ➜ 'up'    
            'B' ➜ 'down'  
            'D' ➜ 'left'  
            'C' ➜ 'right'
            
        char = ''
            
        if csi[-1] == 'u'
            code = parseInt csi
            ⮐ if empty code
            lfc 'csi:' csi
            key = switch code
                9       ➜ 'tab'
                27      ➜ 'esc'
                32      ➜ 'space'
                13      ➜ 'return'
                127     ➜ 'delete'
                57441   ➜ 'shift'
                57442   ➜ 'ctrl'
                57443   ➜ 'alt'
                57444   ➜ 'cmd'
                        ➜ String.fromCodePoint code
                        
            char = switch key
                'tab'    ➜ '\t'
                'return' ➜ '\n'
                'space'  ➜ ' '
                         ➜ ''
                    
        mods = []
        type = 'press'
        
        splt = csi[0..-2].split ';'
           
        lc 'csi' csi

        if splt.length > 1
            
            type = 'repeat'  if splt[1].endsWith ':2'
            type = 'release' if splt[1].endsWith ':3'
            
            if splt.length > 2
                code = parseInt splt[2]
                if valid code
                    char = String.fromCodePoint code
            
            mbit = parseInt(splt[1])-1
            if mbit & 0x1 ➜ mods.push 'shift'
            if mbit & 0x4 ➜ mods.push 'ctrl'
            if mbit & 0x2 ➜ mods.push 'alt'
            if mbit & 0x8 ➜ mods.push 'cmd'
                
        if key not in mods
            mods.push key
            
        combo = mods.join '+'
        
        key:    key
        combo:  combo
        type:   type
        char:   char
        
    #  0000000   0000000  000  
    # 000       000       000  
    # 000       0000000   000  
    # 000            000  000  
    #  0000000  0000000   000  
    
    parseCsi: csi =>
        
        switch csi
            'I'     ➜ ⮐ post.emit 'focus'
            'O'     ➜ ⮐ post.emit 'blur'
            'H'     ➜ ⮐ @keyEventForCombo('home')
            'F'     ➜ ⮐ @keyEventForCombo('end')
            '3~'    ➜ ⮐ @keyEventForCombo('entf')
            '5~'    ➜ ⮐ @keyEventForCombo('pageup')
            '6~'    ➜ ⮐ @keyEventForCombo('pagedown')
            'Z'     ➜ ⮐ @keyEventForCombo('shift+z' 'Z')
        
        lf '---- csi' csi
        
    # 00000000   0000000   0000000  
    # 000       000       000       
    # 0000000   0000000   000       
    # 000            000  000       
    # 00000000  0000000    0000000  
    
    parseEsc: esc =>
        
        lf '---- esc' esc
        
        switch esc
        
            'OP' ➜ ⮐ @keyEventForCombo('f1')
            'OQ' ➜ ⮐ @keyEventForCombo('f2')
            'OR' ➜ ⮐ @keyEventForCombo('f3')
            'OS' ➜ ⮐ @keyEventForCombo('f4')
            
        char = esc.toString 'utf8'
        
        if event = @keyEventForChar char
            return event
        
    # 00000000    0000000   000   000  
    # 000   000  000   000  000 0 000  
    # 0000000    000000000  000000000  
    # 000   000  000   000  000   000  
    # 000   000  000   000  00     00  
    
    parseRaw: raw =>
        
        lf '---- raw' '0x'+Number(raw[0]).toString(16) #'a'.charCodeAt(0)
        
        if raw.length == 1
                                
            switch raw[0]
                0x9  ➜ ⮐ @keyEventForCombo('tab')
                0xd  ➜ ⮐ @keyEventForCombo('return' '\n')
                0x1b ➜ ⮐ @keyEventForCombo('esc')
                0x7f ➜ ⮐ @keyEventForCombo('delete')

            if 0x1 <= raw[0] <= 0x1a
                ⮐ @keyEventForCombo("ctrl+#{String.fromCharCode(raw[0]+96)}")
                
            char = raw.toString 'utf8'
            
            if event = @keyEventForChar char
                ⮐ event
                
            if raw[0] > 127 
                raw[0] -= 128
                ⮐ parseEsc raw.toString 'utf8'
                
        lf '---! raw' raw
        
    keyEventForChar: char =>
        
        if char.length
            key = char.toLowerCase()
            return
                key:    key
                type:   'press'
                combo:  key != char ? 'shift' : ''
                char:   char
                
    keyEventForCombo: combo char='' =>
    
        key:    combo.split('+')[-1]
        type:   'press'
        combo:  combo
        char:   char
            
    # 00     00   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000       000       
    # 000000000  000   000  000   000  0000000   0000000   
    # 000 0 000  000   000  000   000       000  000       
    # 000   000   0000000    0000000   0000000   00000000  
    
    parseMouse: csi =>
                
        [code col row] = csi[1..-2].split(';').map (s) -> parseInt s
        x = col-1
        y = row-1
        
        event =
            type:   'release'
            x:      x
            y:      y
        
        mods = []
        mods.push 'shift' if code & 0b00100
        mods.push 'alt'   if code & 0b01000
        mods.push 'ctrl'  if code & 0b10000
        
        event.mods = mods.join '+' if valid mods
        event[m] = m in mods for m in ['shift' 'ctrl' 'alt' 'cmd']
                        
        if csi.endsWith 'M'

            event.type = switch code & 0b11100000
                32  ➜ (code & 0b11 == 3) ? 'move' : 'drag'
                64  ➜ 'wheel'
                0   ➜ 'press'  
                
        if event.type == 'wheel'
            
            event.dir = switch code & 0b11
                0 ➜ 'up'
                1 ➜ 'down'
                2 ➜ 'left'
                3 ➜ 'right'
                
        else if (code & 0b11) != 3
            
            event.button = switch code & 0b11
                0 ➜ 'left'
                1 ➜ 'middle'
                2 ➜ 'right'

        # lf 'mouse----' csi noon(event)                
        event
            
    emitMouseEvent: event =>
        
        if event.type == 'press'
        
            @lastClick ?= 
                x:      event.x
                y:      event.y
                count:  0
                time:   process.hrtime()
            
            if @lastClick.y == event.x and @lastClick.x == event.y
                diff = process.hrtime @lastClick.time
                @lastClick.time = process.hrtime()
                if diff[0] < 1 and diff[1] < 500000000
                    @lastClick.count += 1
                else    
                    @lastClick.count = 1
            else
               @lastClick.y     = event.x
               @lastClick.x     = event.y
               @lastClick.count = 1
               @lastClick.time  = process.hrtime()
               
            event.count = @lastClick.count
        
        # lfc noon event
        @emit 'mouse' event.type event.x event.y event
            
    # 0000000     0000000   000000000   0000000   
    # 000   000  000   000     000     000   000  
    # 000   000  000000000     000     000000000  
    # 000   000  000   000     000     000   000  
    # 0000000    000   000     000     000   000  
    
    onData: data =>

        if data[0] == 0x1b and data[1] == 0x5b
            csi = data[2..].toString 'utf8'
        else if data[0] == 0x1b
            esc = data[1..].toString 'utf8'
        
        #lfc 'data' data[1..] csi esc
            
        if @pasteBuffer?
            
            @pasteBuffer += data.toString 'utf8'
            
            if @pasteBuffer.endsWith '\x1b[201~'
                
                @pasteBuffer = @pasteBuffer[0...-6]
                @emit 'paste' @pasteBuffer
                delete @pasteBuffer
            ⮐ 
        
        if csi
            
            if csi.startsWith '200~' # paste start
                @pasteBuffer = ''
                if csi.endsWith '\x1b[201~'
                    @onData data[6..]
                ⮐
                
            if csi.startsWith('<') and csi[-1] in 'Mm'
                
                if event = @parseMouse csi
                    ⮐ @emitMouseEvent event
                    
                lfc 'unhandled mouse event?' csi
                
            if event = @parseKitty csi
                if event.type == 'release'
                    ⮐ @emit 'release' event.combo event
                else 
                    #lf '▸' noon(event)
                    ⮐ @emit 'key' event.combo event
                    
            if event = @parseCsi csi
                if event.type in ['press' 'repeat']
                    ⮐ @emit 'key' event.combo event
                    
        else if esc
            
            if event = @parseEsc esc
                if event.type in ['press' 'repeat']
                    ⮐ @emit 'key' event.combo event
                
        else # not a csi or esc sequence

            if event = @parseRaw data
                if event.type in ['press' 'repeat']
                    ⮐ @emit 'key' event.combo event
        
            text = data.toString 'utf8'
            
            if text.length > 1
                lfc 'paste?' data[0]==0x1b data[1..] text.length text
                ⮐ @emit 'paste' text
                        
            # lfc 'unhandled?' data data.length data[0] data[1..]
                
export TTIO
