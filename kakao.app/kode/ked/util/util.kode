###
000   000  000000000  000  000    
000   000     000     000  000    
000   000     000     000  000    
000   000     000     000  000    
 0000000      000     000  0000000
###

use ../../kxk ▪ kstr
use ◆ prof

class util
    
    #  0000000  00000000  000      000       0000000  
    # 000       000       000      000      000       
    # 000       0000000   000      000      0000000   
    # 000       000       000      000           000  
    #  0000000  00000000  0000000  0000000  0000000   
    
    @cells: rows cols ->
    
        lines = []
        for l in 0...rows
            cells = []
            for c in 0...cols
                cells.push bg:null fg:null char:' '
            lines.push cells
        lines
    
    # 00000000    0000000    0000000
    # 000   000  000   000  000     
    # 00000000   000   000  0000000 
    # 000        000   000       000
    # 000         0000000   0000000 

    @pos: x y -> (x is arr and empty y) ? x : [x y]
    
    @samePos: a b -> a[0] == b[0] and a[1] == b[1]
    
    @normalizePositions: posl maxY ->
        
        ⮐ [] if empty posl 
        
        posl = posl.map (a) -> [max(0 a[0]) clamp(0 maxY a[1])]
        posl = util.sortPositions posl
        posl = util.removeDuplicatePositions posl
        
    @sortPositions: posl -> posl.sort (a b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]
        
    @removeDuplicatePositions: posl ->
        
        ⮐ posl if posl.length <= 1
        
        for i in posl.length-1..1
            if util.samePos posl[i] posl[i-1]
                posl.splice i 1
        posl
        
    @indexOfPosInPositions: pos posl ->
        
        ⮐ -1 if empty posl
        posl.findIndex (p) -> pos eql p
        
    @lineIndicesForPositions: posl ->
        
        set = new Set()
        for pos in posl
            set.add pos[1]
        Array.from set
        
    @positionInDirection: pos dir ->
        
        [x y] = pos
        
        switch dir
            'up'    ➜ [x y-1]
            'down'  ➜ [x y+1]
            'left'  ➜ [x-1 y]
            'right' ➜ [x+1 y]
            
    @traversePositionsInDirection: posl pos dir ->

        while next = util.neighborPositionInDirection posl pos dir
            pos = next
        pos
        
    @neighborPositionInDirection: posl pos dir ->
        
        nbp = util.positionInDirection pos dir
        if util.positionsContain posl nbp
            posl[util.indexOfPosInPositions nbp posl]

    @positionsContain: posl pos ->
        
        for p in posl
            ⮐ true if p eql pos
        false
        
    @positionsOutsideRange: posl rng ->
        
        posl.filter (p) -> util.isPosOutsideRange(p rng)
                
    # 00000000    0000000   000   000   0000000   00000000  
    # 000   000  000   000  0000  000  000        000       
    # 0000000    000000000  000 0 000  000  0000  0000000   
    # 000   000  000   000  000  0000  000   000  000       
    # 000   000  000   000  000   000   0000000   00000000  
    
    @isPosInsideRange: pos rng ->
        
        ⮐ false if util.isPosBeforeRange pos rng 
        ⮐ false if util.isPosAfterRange  pos rng 
        true
        
    @isPosOutsideRange: pos rng -> not util.isPosInsideRange pos rng

    @isPosBeforeRange: pos rng ->
    
        pos[1] < rng[1] or (pos[1] == rng[1] and pos[0] < rng[0])
    
    @isPosAfterRange: pos rng ->
    
        pos[1] > rng[3] or (pos[1] == rng[3] and pos[0] >= rng[2])
        
    @isPosTouchingRange: pos rng ->
        
        ⮐ true if util.isPosInsideRange pos rng
        ⮐ true if pos eql util.endOfRange rng
        ⮐ true if pos eql util.startOfRange rng
        false

    @rangeContainsPos: rng pos -> util.isPosInsideRange pos rng
    @rangeTouchesPos:  rng pos -> util.isPosTouchingRange pos rng
        
    @rangeForSpan: span -> [span[0] span[1] span[2] span[1]]
    @rangeFromStartToEnd: start end -> [start[0] start[1] end[0] end[1]]
    
    @isEmptyRange: rng -> rng[0] == rng[2] and rng[1] == rng[3]
    @isRangeEmpty: rng -> rng[0] == rng[2] and rng[1] == rng[3]

    @startOfRange: rng -> [rng[0] rng[1]]
    @endOfRange:   rng -> [rng[2] rng[3]]
        
    #  0000000  00000000    0000000   000   000  
    # 000       000   000  000   000  0000  000  
    # 0000000   00000000   000000000  000 0 000  
    #      000  000        000   000  000  0000  
    # 0000000   000        000   000  000   000  
 
    @isSameSpan:  a b -> a eql b
    @isSameRange: a b -> a eql b
    
    @isPosInsideSpan: pos span ->

        ⮐ false if util.isPosBeforeSpan pos span
        ⮐ false if util.isPosAfterSpan pos span
        true
        
    @isPosBeforeSpan: pos span ->
        
        pos[1] < span[1] or (pos[1] == span[1] and pos[0] < span[0])

    @isPosAfterSpan: pos span ->
        
        pos[1] > span[1] or (pos[1] == span[1] and pos[0] >= span[2])
        
    @isPosBeforeOrInsideSpan: pos span ->
        
        util.isPosBeforeSpan(pos span) or util.isPosInsideSpan(pos span)

    @startOfSpan: s -> [s[0] s[1]]
    @endOfSpan:   s -> [s[2] s[1]]
    
    @nextSpanAfterPos: spans pos ->
        
        ⮐ if empty spans
        
        pos = [0 0] if util.isPosAfterSpan pos spans[-1]
        
        ⮐ spans[0] if util.isPosBeforeSpan pos spans[0]
            
        for span,index in spans
            if util.isPosAfterSpan pos span
                if index+1 < spans.length and util.isPosBeforeOrInsideSpan pos spans[index+1]
                    ⮐ spans[index+1]

    @prevSpanBeforePos: spans pos ->
        
        ⮐ if empty spans
        ⮐ spans[-1] if util.isPosBeforeSpan pos spans[0]
        ⮐ spans[-1] if util.isPosInsideSpan pos spans[0]
            
        for index in spans.length-1..0
            span = spans[index]
            if util.isPosAfterSpan pos span
                ⮐ span
                    
    @normalizeSpans: spans ->
        
        ⮐ [] if empty spans
        
        spans = spans.map (a) -> if a[0] > a[2] ➜ [a[2] a[1] a[0]] else a
        spans.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        spans = spans.filter (a) -> a[0] != a[2]
        
    # 00000000    0000000   000   000   0000000   00000000   0000000  
    # 000   000  000   000  0000  000  000        000       000       
    # 0000000    000000000  000 0 000  000  0000  0000000   0000000   
    # 000   000  000   000  000  0000  000   000  000            000  
    # 000   000  000   000  000   000   0000000   00000000  0000000   
    
    @rangesContainLine: rngs lineIndex -> 
        
        for rng in rngs
            ⮐ true if rng[1] <= lineIndex <= rng[3]
        false
        
    @rangesContainSpan: rngs span -> @rangesContainRange rngs util.rangeForSpan(span)
    @rangesContainRange: rngs range -> 
        
        for rng in rngs
            ⮐ true if rng eql range
        false
                
    @normalizeRanges: rngs ->
        
        ⮐ [] if empty rngs or not rngs is arr
        
        rngs = rngs.map (a) -> if a[1] > a[3] ➜ [a[2] a[3] a[0] a[1]] else a
        rngs = rngs.map (a) -> if a[1] == a[3] and a[0] > a[2] ➜ [a[2] a[1] a[0] a[3]] else a
        rngs.sort (a b) -> if a[1] == b[1] ➜ a[0] - b[0] else a[1] - b[1]
        rngs.filter (a) -> a[1] != a[3] or a[0] != a[2] 
        
    @startPositionsOfRanges: rngs -> rngs.map (r) -> util.startOfRange r
    @endPositionsOfRanges:   rngs -> rngs.map (r) -> util.endOfRange r
        
    @removeTrailingEmptyRange: rngs ->
        
        if util.isEmptyRange rngs[-1]
            rngs[0..-2]
        else
            rngs

    ###
    returns a list of ranges for lines split by positions.
    the range up to the first position is included, as well as the
    one from the last position up to the end of text.
    ###        
    @rangesForLinePositions: lines posl ->
        
        ⮐ [] if empty posl
        rngs = [[0 0 posl[0][0] posl[0][1]]]
        for pos,idx in posl
            rngs.push [posl[idx-1][0] posl[idx-1][1] pos[0] pos[1]] if idx > 0            
        rngs.push [posl[-1][0] posl[-1][1] lines[-1].length lines.length-1]
        rngs
        
    @rangeInRangesContainingPos: rngs pos ->
        
        for rng in rngs
            if util.rangeContainsPos rng pos
                ⮐ rng

    @rangeInRangesTouchingPos: rngs pos ->
        
        for rng in rngs
            if util.rangeTouchesPos rng pos
                ⮐ rng   

    @lineIndicesForRangesOrPositions: rngs posl ->

        indices = util.lineIndicesForRanges rngs
        indices = util.lineIndicesForPositions posl if empty indices
        indices
                
    # 00     00  00000000  00000000    0000000   00000000  
    # 000   000  000       000   000  000        000       
    # 000000000  0000000   0000000    000  0000  0000000   
    # 000 0 000  000       000   000  000   000  000       
    # 000   000  00000000  000   000   0000000   00000000  
    
    @mergeLineRanges: lines rngs ->
        
        ⮐ [] if empty rngs or not rngs is arr
        
        rngs = util.normalizeRanges rngs
        
        mrgd = []
        for s,i in rngs
            if empty mrgd or 
                s[1] > tail[3]+1 or 
                s[1] == tail[3] and s[0] > tail[2] or 
                s[1] == tail[3]+1 and (s[0] > 0 or tail[2] < lines[tail[3]].length)
                    mrgd.push s
                    tail = s
            else if s[3] > tail[3] or s[3] == tail[3] and s[2] > tail[2]
                tail[2] = s[2] 
                tail[3] = s[3]

        mrgd

    # 000000000  00000000  000   000  000000000  
    #    000     000        000 000      000     
    #    000     0000000     00000       000     
    #    000     000        000 000      000     
    #    000     00000000  000   000     000     
    
    @linesForText: text -> 
        
        text = text.replace /\x1b/g, '�'
    
        text.split /\r?\n/
    
    @textForLineRange: lines rng ->
        
        ⮐ '' if empty lines or empty rng
        
        l = []
        
        for y in rng[1]..rng[3]
            continue if util.isInvalidLineIndex lines y
            if
                y == rng[1]
                    if 
                        y == rng[3] ➜ l.push lines[y][rng[0]...rng[2]]
                                    ➜ l.push lines[y][rng[0]..]
                y == rng[3] ➜ l.push lines[y][0...rng[2]]
                            ➜ l.push lines[y]
        
        l.join '\n'
        
    @textForLineRanges: lines rngs ->
        
        ⮐ '' if empty lines
        
        text = ''
        for rng in rngs
            text += util.textForLineRange lines rng
            text += '\n'
        text[0...-1]
        
    @lineSpansForText: lines text ->
        
        spans = []
        
        for line,y in lines
            x2 = 0
            while true
                x1 = line.indexOf text x2
                break if x1 < 0
                x2 = x1+text.length
                spans.push [x1 y x2]
        
        spans
        
    @textFromBolToPos: lines pos -> lines[pos[1]][0...pos[0]]
    
    @isOnlyWhitespace: text -> /^\s+$/.test text
    
    @numIndent: str ->
 
        if m = str.match /^\s+/
            ⮐ String(m).length
        0
        
    @splitLineIndent: str ->
        
        i = util.numIndent str
        [str[0...i] str[i..]]
        
    # 000      000  000   000  00000000   0000000  
    # 000      000  0000  000  000       000       
    # 000      000  000 0 000  0000000   0000000   
    # 000      000  000  0000  000            000  
    # 0000000  000  000   000  00000000  0000000   
    
    @lineRangeAtPos: lines pos ->

        [0 pos[1] lines[pos[1]].length pos[1]]

    @lineRangesForPositions: lines posl append=false->
        
        rngs = util.lineIndicesForPositions(posl).map (y) -> [0 y lines[y].length y]
        if valid rngs and append
            rngs[-1][2]  = 0 
            rngs[-1][3] += 1
        rngs        

    @lineIndentAtPos: lines pos -> 

        [x y] = pos

        util.numIndent lines[y]
            
    @lineIndicesForRange: rng ->
        
        indices = []
        
        for li in rng[1]..rng[3]
            if li != rng[3] or rng[2] > 0
                indices.push li
        
        indices
        
    @lineIndicesForRanges: rngs ->
        
        indices = []
        
        for rng in rngs
            indices = indices.concat @lineIndicesForRange(rng)
            
        indices
        
    @numFullLinesInRange: lines rng ->
        
        d = rng[3] - rng[1]
        
        if d == 0 
            ⮐ rng[0] == 0 and rng[2] == lines[rng[1]].length ? 1 : 0
        
        n = 0
        n += 1   if rng[0] == 0 
        n += d-2 if d > 1
        n += 1   if rng[2] == lines[rng[3]].length
        n
        
    @numLinesInRange: rng -> rng[3] - rng[1] + 1
    
    @isEmptyLineAtPos: lines pos -> lines[pos[1]].length <= 0
        
    @lineRangesInRange: lines rng ->
        
        rngs = []
        for ln in 0...util.numLinesInRange(rng)
            rngs.push util.lineRangeAtPos(lines [0 rng[1]+ln])
        rngs
        
    @linesForRange: lines rng ->

        nl = util.numLinesInRange rng 
        
        ⮐ [lines[rng[1]][rng[0]...rng[2]]] if nl == 1
        
        lns = [lines[rng[1]][rng[0]..]]
        lns = lns.concat lines[rng[1]+1...rng[3]] if nl > 2
        lns = lns.concat lines[rng[3]][0...rng[2]] 

    @splitLineRange: lines rng includeEmpty=true -> # split multi-line-range into list of single-line-ranges
        
        nl = util.numLinesInRange rng 
        ⮐ [rng] if nl == 1
        
        split = []
        
        split.push [rng[0] rng[1] lines[rng[1]].length rng[1]]
        
        if nl > 2
            for i in 1..nl-2
                split.push [0 rng[1]+i lines[rng[1]+i].length rng[1]+i]
        
        split.push [0 rng[3] rng[2] rng[3]] if includeEmpty or rng[2] > 0

        split
                            
    @splitLineRanges: lines rngs includeEmpty=true -> # split list of multi-line-ranges into list of single-line-ranges
        
        split = []        
        for rng in rngs
            split = split.concat util.splitLineRange(lines rng includeEmpty)
        split
        
    @isLinesPosInside:  lines pos -> pos[1] < lines.length and 0 <= pos[0] <= lines[pos[1]].length
    @isLinesPosOutside: lines pos -> not util.isLinesPosInside lines pos 
    
    @isValidLineIndex:   lines li -> 0 <= li < lines.length
    @isInvalidLineIndex: lines li -> not util.isValidLineIndex lines li
    
    @isMultiLineRange: lines rng -> rng[1] != rng[3]
        
    @isFullLineRange: lines rng -> (0 <= rng[1] <= rng[3] < lines.length) and (rng[0] == 0) and (rng[2] >= lines[rng[3]].length or rng[2] == 0 and rng[1] < rng[3])
    
    @isSpanLineRange: lines rng -> (0 <= rng[1] == rng[3] < lines.length) and (rng[0] > 0 or rng[2] < lines[rng[1]].length)
        
    @rangeOfLine: lines y -> [0 y lines[y].length y]
    
    @numIndentOfLines: lines ->
        
        for line in lines
            continue if empty trim line
            ⮐ util.numIndent line
        0

    #  0000000  000   000  000   000  000   000  000   000  
    # 000       000   000  000   000  0000  000  000  000   
    # 000       000000000  000   000  000 0 000  0000000    
    # 000       000   000  000   000  000  0000  000  000   
    #  0000000  000   000   0000000   000   000  000   000  
    
    @rangeOfClosestChunkToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if util.isInvalidLineIndex lines y
         
        if r = kstr.rangeOfClosestChunk lines[y] x
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]
        
    # 000   000   0000000   00000000   0000000    
    # 000 0 000  000   000  000   000  000   000  
    # 000000000  000   000  0000000    000   000  
    # 000   000  000   000  000   000  000   000  
    # 00     00   0000000   000   000  0000000    
    
    @rangeOfClosestWordToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if util.isInvalidLineIndex lines y
         
        if r = kstr.rangeOfClosestWord lines[y] x
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]

    @rangeOfWordOrWhitespaceLeftToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if x <= 0 or util.isInvalidLineIndex lines y
        
        if r = kstr.rangeOfClosestWord lines[y][0...x] x
            if r[1] < x
                ⮐ [r[1] y x y]
            if 0 <= r[0] < r[1]
                ⮐ [r[0] y r[1] y]
            
        [0 y x y]   

    @rangeOfWordOrWhitespaceRightToPos: lines pos ->
        
        [x y] = pos
        
        ⮐ if x < 0 or util.isInvalidLineIndex lines y
        
        if r = kstr.rangeOfClosestWord lines[y][x..] 0
            if 0 == r[0] < r[1]
                ⮐ [x y r[1]+x y]
            if r[0] > 0 
                ⮐ [x y r[0]+x y]
            
        [x y lines[y].length y]   
        
    @lineChar: line x -> line[x] if 0 <= x < line.length
        
    @categoryForChar: char -> 
        
        if 
            empty char      ➜ ⮐ 'empty'
            /\s+/.test char ➜ ⮐ 'ws'
            /\w+/.test char ➜ ⮐ 'word'
            
        'punct'
        
    @jumpDelta: line px dx jump ->
        
        if dx > 0
            ci = px
            if nc = cat = util.categoryForChar util.lineChar(line ci)
                ⮐ dx if cat not in jump
                while true
                    ci += dx
                    nc = util.categoryForChar util.lineChar(line ci)
                    break if nc != cat
                    break if ci <= 0
                    ⮐ 1 if nc == 'empty'
            ci - px
        else
            ci = px - 1
            ⮐ 0 if ci < 0
            if ci >= line.length and 'empty' in jump ➜ ⮐ line.length - ci - 1
            cat = util.categoryForChar util.lineChar(line ci)
            ⮐ dx if cat not in jump
            while 0 <= ci < line.length and util.categoryForChar(util.lineChar(line ci)) == cat
                ci += dx
            min dx ci - px + 1

    @numCharsFromPosToWordOrPunctInDirection: lines pos dir opt ->
        
        dx = dir == 'left' ? -1 : 1
        
        if opt?.jump ➜ ⮐ util.jumpDelta(lines[pos[1]] pos[0] dx opt.jump)
            
        ⮐ 0 if pos[0] + dx < 0
        dx
        
    # 0000000    00000000  000      00000000  000000000  00000000  
    # 000   000  000       000      000          000     000       
    # 000   000  0000000   000      0000000      000     0000000   
    # 000   000  000       000      000          000     000       
    # 0000000    00000000  0000000  00000000     000     00000000  
    
    @deleteLineRangesAndAdjustPositions: lines rngs posl ->
        
        lines = copy lines
        posl  = clone posl
        
        for ri in rngs.length-1..0
            rng = rngs[ri]
            
            posl = util.adjustPositionsForDeletedLineRange posl lines rng
            
            if rng[1] == rng[3] # single line range
                if rng[0] == 0 and rng[2] == lines[rng[1]].length
                    lines.splice rng[1] 1
                else
                    lines.splice rng[1] 1 kstr.splice(lines[rng[1]] rng[0] rng[2]-rng[0])
            else # range spans multiple lines
                if rng[2] == lines[rng[3]].length # range ends at end of last line
                    lines.splice rng[3] 1 
                else
                    lines.splice rng[3] 1 lines[rng[3]][rng[2]..]
                    partialLast = true
                    
                if rng[3]-rng[1] >= 2 # more than 2 lines in range
                    lines.splice rng[1]+1 rng[3]-rng[1]-1 # remove middle lines
                    
                if rng[0] == 0 # range starts at start of first line
                    lines.splice rng[1] 1
                else
                    lines.splice rng[1] 1 lines[rng[1]][0...rng[0]]
                    
                    if partialLast
                        lines.splice rng[1] 2 lines[rng[1]] + lines[rng[1]+1]
               
        [lines posl]
        
    @adjustPositionsForDeletedLineRange: posl lines rng ->
        
        for pi in posl.length-1..0
            pos = posl[pi]
            
            if util.isPosTouchingRange pos rng
                pos[0] = rng[0] 
                pos[1] = rng[1]
            else if util.isPosAfterRange pos rng
                if pos[1] == rng[3] # pos in last line of range
                    pos[0] -= rng[2] - rng[0]
                    if rng[1] < rng[3] # multi line range
                        pos[1] -= rng[3] - rng[1]
                else
                    pos[1] -= util.numFullLinesInRange(lines rng)
            else
                break
                    
        util.removeDuplicatePositions posl
        
    @moveCursorsInSameLineBy: cursors cursor delta ->
    
        ci = cursors.indexOf cursor
    
        while true
            
            cursors[ci][0] += delta
            ci++
            
            ⮐ if ci >= cursors.length
            ⮐ if cursors[ci][1] > cursor[1]
            
    #  0000000   0000000    0000000          00000000    0000000   000   000   0000000   00000000   0000000  
    # 000   000  000   000  000   000        000   000  000   000  0000  000  000        000       000       
    # 000000000  000   000  000   000        0000000    000000000  000 0 000  000  0000  0000000   0000000   
    # 000   000  000   000  000   000        000   000  000   000  000  0000  000   000  000            000  
    # 000   000  0000000    0000000          000   000  000   000  000   000   0000000   00000000  0000000   
    
    @addLinesBelowPositionsToRanges: lines posl rngs ->
    
        newp = []
        newr = copy rngs
    
        addLineAtIndex = c i ->
            range = util.rangeOfLine lines i
            range[1] += 1 if util.isEmptyRange range
            newr.push range
            newp.push util.endOfRange(range)
            
        for c in posl
            if not util.rangesContainLine(rngs c[1])
                addLineAtIndex c c[1]
            else
                addLineAtIndex c c[1]+1 if c[1] < lines.length-1
    
        [newp newr]
    
    # 00000000   00000000  00     00   0000000   000   000  00000000     00000000   000   000   0000000    0000000    
    # 000   000  000       000   000  000   000  000   000  000          000   000  0000  000  000        000         
    # 0000000    0000000   000000000  000   000   000 000   0000000      0000000    000 0 000  000  0000  0000000     
    # 000   000  000       000 0 000  000   000     000     000          000   000  000  0000  000   000       000    
    # 000   000  00000000  000   000   0000000       0      00000000     000   000  000   000   0000000   0000000     
    
    @removeLinesAtPositionsFromRanges: lines posl rngs ->
        
        newp = []
        newr = util.splitLineRanges lines rngs
        
        for pos in posl
            if rng = util.rangeInRangesTouchingPos newr pos
                idx = newr.indexOf rng
                if idx > 0
                    newp.push util.endOfRange(newr[idx-1])
                else
                    newp.push util.endOfRange(newr[idx])
                newr.splice idx 1
            else
                newp.push pos
        [newp newr]
        
    # 000  000   000   0000000  00000000  00000000   000000000        000000000  00000000  000   000  000000000  
    # 000  0000  000  000       000       000   000     000              000     000        000 000      000     
    # 000  000 0 000  0000000   0000000   0000000       000              000     0000000     00000       000     
    # 000  000  0000       000  000       000   000     000              000     000        000 000      000     
    # 000  000   000  0000000   00000000  000   000     000              000     00000000  000   000     000     
    
    @insertTextAtPositions: lines text posl ->
                          
        # prof.start 'insert'
        
        if text == '\t'
            pos  = posl[0]
            text = lpad 4-pos[0]%4 ' '
            
        # lf "insert text ▸#{text}◂"
            
        text = kstr.detab text
        
        txtls = util.linesForText text  # the text to insert split into lines
        newls = []                      # list of new lines 
        newpl = []                      # list of new positions
        rngs = util.rangesForLinePositions lines posl # list of ranges for lines split by positions
        
        for rng,idx in rngs
            
            after = util.linesForRange lines rng # all the lines in the current range (after current position)
                        
            if idx > 0                           # start processing ranges after the first position
                
                [x y] = posl[idx-1]              # coordinates of current position 
                
                if valid before ➜ line = before.pop() # pop the last line from before the current position
                else              line = newls.pop()  # or the last of the already generated lines
                    
                if x > line.length ➜ line += lpad x-line.length # fill line at end with spaces if pos is in empty space
                                        
                if txtls.length > 1     # handle multiples lines to insert (including two empty lines when inserting \n)
                    
                    # mod = (idx-1) % txtls.length
                    # txt = txtls[mod]
                    
                    posLineIndent = util.numIndent line
                    
                    indent = 0                                                   # indentation mess, needs cleanup
                    # lf "newls.length #{newls.length}"                          # indentation mess, needs cleanup
                    indent = util.numIndent last(newls) if newls.length          # indentation mess, needs cleanup
                    # lf "current indent #{indent}"                              # indentation mess, needs cleanup
                    if after.length>1 and posl[idx-1][0] > indent                # indentation mess, needs cleanup
                        indent = max indent util.numIndentOfLines(after[1..])    # indentation mess, needs cleanup
                        # lf "forward indent #{indent}"                          # indentation mess, needs cleanup
                                                                                 # indentation mess, needs cleanup
                    txtindent = util.numIndentOfLines txtls                      # indentation mess, needs cleanup
                    indent   -= txtindent                                        # indentation mess, needs cleanup
                    indent    = max 0 indent                                     # indentation mess, needs cleanup
                                                                                 # indentation mess, needs cleanup
                    indentstr = lpad indent                                      # indentation mess, needs cleanup
                                                                                 # indentation mess, needs cleanup
                    # if posl[idx-1][0] > indent                                   # indentation mess, needs cleanup
                        # line = line[txtindent..]                                 # indentation mess, needs cleanup
                    
                    # txt = txtls[idx-1]
#                         
                    # while mod < txtls.length-1 # loop over lines in text to insert
                        # mod++
                        # txt  = txtls[mod]
                        # line = indentstr
                        
                    # before.
                    
                    lf "▪#{line}▪#{txtls[0]}▪" 
                                        
                    before.push line + txtls[0]
                    for line,lidx in txtls[1..]
                        before.push indentstr + line
                    
                    if x > posLineIndent
                        newpl.push [last(before).length newls.length+before.length-1]
                        before.push before.pop()+after.shift()
                    else
                        before.pop() if text == '\n'
                        newpl.push [indent newls.length+before.length]
                        
                    newls = newls.concat before
                            
                else                                # if text is the only line to insert

                    newpl.push [line.length+txtls[0].length newls.length+before.length] # move position to the end of the inserted text
                    line += txtls[0] + after.shift()        # append it and first line after to current line
                    newls = newls.concat before line        # add lines from before and current line to result
                
            before = after 
            
        newls = newls.concat before
            
        # prof.end 'insert'
        
        [newls newpl]      
        
    @rangeForJoiningLine: lines idx -> [lines[idx].length idx 0 idx+1]
        
    @rangesForJoiningLines: lines idxs -> idxs.map (idx) -> util.rangeForJoiningLine lines idx
    
    # 00     00   0000000   000   000  00000000         000      000  000   000  00000000   0000000  
    # 000   000  000   000  000   000  000              000      000  0000  000  000       000       
    # 000000000  000   000   000 000   0000000          000      000  000 0 000  0000000   0000000   
    # 000 0 000  000   000     000     000              000      000  000  0000  000            000  
    # 000   000   0000000       0      00000000         0000000  000  000   000  00000000  0000000   
    
    @moveLineRangesAndPositionsAtIndicesInDirection: lines rngs posl indices dir ->
        
        if empty indices or dir == 'down' and indices[-1] >= lines.length-1 or dir == 'up' and indices[0] <= 0
            ⮐ [lines rngs posl]
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        [rs re] = switch dir
            'down' ➜ [indices.length-1 0]
            'up'   ➜ [0 indices.length-1]
        
        for ii in rs..re
            index = indices[ii]
            
            switch dir 
                'down' ➜ newLines.splice index   2 newLines[index+1] newLines[index] 
                'up'   ➜ newLines.splice index-1 2 newLines[index]   newLines[index-1]
                
            for pos in newPosl
                if pos[1] == index 
                    pos[1] += switch dir                     
                        'down' ➜ 1
                        'up'   ➜ -1

            for rng in newRngs
                if rng[1] == index 
                    d = switch dir                     
                        'down' ➜ 1
                        'up'   ➜ -1
                    rng[1] += d
                    rng[3] += d
        
        [newLines newRngs newPosl]
                  
    #  0000000   0000000   00     00  00     00  00000000  000   000  000000000   0000000  
    # 000       000   000  000   000  000   000  000       0000  000     000     000       
    # 000       000   000  000000000  000000000  0000000   000 0 000     000     0000000   
    # 000       000   000  000 0 000  000 0 000  000       000  0000     000          000  
    #  0000000   0000000   000   000  000   000  00000000  000   000     000     0000000   
    
    @toggleCommentsInLineRangesAtIndices: lines rngs posl indices ->
        
        ⮐ [lines rngs posl] if empty indices
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        comStart = '#'
        minIndent = Infinity
             
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
            if not line.startsWith comStart
                comment = comStart
                minIndent = min indent.length minIndent
            
        comIndent = lpad minIndent if comment
                
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
            if comment
                indent = indent.length > minIndent ? lpad(indent.length-minIndent) : ''
                newLine = comIndent + comment + indent + ' ' + line
            else
                d = line[comStart.length] == ' ' ? 1 : 0
                newLine = indent + line[comStart.length+d..]
            newLines.splice index 1 newLine
        
        [newLines newRngs newPosl]      
        
    # 0000000    00000000  000  000   000  0000000    00000000  000   000  000000000  
    # 000   000  000       000  0000  000  000   000  000       0000  000     000     
    # 000   000  0000000   000  000 0 000  000   000  0000000   000 0 000     000     
    # 000   000  000       000  000  0000  000   000  000       000  0000     000     
    # 0000000    00000000  000  000   000  0000000    00000000  000   000     000     
    
    @deindentLineRangesAndPositionsAtIndices: lines rngs posl indices ->
        
        ⮐ [lines rngs posl] if empty indices  
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
        
            if indent.length
                
                sc = min 4 indent.length
                newLines.splice index 1 indent[sc..] + line
                
                for pos in newPosl
                    if pos[1] == index 
                        pos[0] = max 0 pos[0] - sc
                        
                for rng in newRngs
                    if rng[1] == index 
                        rng[0] = max 0 rng[0] - sc
                        rng[2] = max 0 rng[2] - sc
        
        [newLines newRngs newPosl]

    # 000  000   000  0000000    00000000  000   000  000000000  
    # 000  0000  000  000   000  000       0000  000     000     
    # 000  000 0 000  000   000  0000000   000 0 000     000     
    # 000  000  0000  000   000  000       000  0000     000     
    # 000  000   000  0000000    00000000  000   000     000     
    
    @indentLineRangesAndPositionsAtIndices: lines rngs posl indices ->
        
        ⮐ [lines rngs posl] if empty indices  
        
        newLines = copy lines
        newRngs  = copy rngs
        newPosl  = copy posl
        
        for index in indices
            
            [indent line] = util.splitLineIndent newLines[index]
        
            newLines[index] = lpad(4 ' ') + newLines[index]
            
            for pos in newPosl
                if pos[1] == index 
                    pos[0] += 4
                    
            for rng in newRngs
                if rng[1] == index 
                    rng[0] += 4
                    rng[2] += 4
        
        [newLines newRngs newPosl]
        
    # 00000000  000   000  000000000  00000000  000   000  0000000          00000000   000   000   0000000    0000000  
    # 000        000 000      000     000       0000  000  000   000        000   000  0000  000  000        000       
    # 0000000     00000       000     0000000   000 0 000  000   000        0000000    000 0 000  000  0000  0000000   
    # 000        000 000      000     000       000  0000  000   000        000   000  000  0000  000   000       000  
    # 00000000  000   000     000     00000000  000   000  0000000          000   000  000   000   0000000   0000000   
    
    @extendLineRangesFromPositionToPosition: lines rngs start pos ->

        if empty rngs ➜ ⮐ [util.rangeFromStartToEnd(start pos)]

        newRngs = copy rngs
        
        if rng = util.rangeInRangesTouchingPos newRngs start
            if util.isPosAfterRange pos rng
                rng[2] = pos[0]
                rng[3] = pos[1]
            else if util.isPosBeforeRange pos rng
                rng[0] = pos[0]
                rng[1] = pos[1]
        else
            newRngs.push util.rangeFromStartToEnd(start pos)

        newRngs
    
    @extendLineRangesByMovingPositionsInDirection: lines rngs posl dir ->
        
        newRngs = copy rngs
        newPosl = copy posl
        
        for pos in newPosl
            
            line = lines[pos[1]]
            rng = [pos[0] pos[1] pos[0] pos[1]]
            newRngs.push rng
            
            switch dir
                'left'  
                'right'     ➜ pos[0] += util.numCharsFromPosToWordOrPunctInDirection(lines pos dir)
                'up'        ➜ pos[1] -= 1
                'down'      ➜ pos[1] += 1
                'eol'       ➜ pos[0] = line.length
                'bol'       ➜ pos[0] = 0
                'bof'       ➜ pos[0] = 0; pos[1] = 0
                'eof'       ➜ pos[1] = lines.length-1; pos[0] = lines[lines.length-1].length

                'ind_bol'   ➜ ind = util.numIndent(line); pos[0] = pos[0] > ind ? ind : 0
                'ind_eol'   ➜ ind = util.numIndent(line); pos[0] = pos[0] < ind ? ind : line.length
                
            switch dir
                'left'      ➜ rng[0] = rng[0]-1
                'right'     ➜ rng[2] = rng[2]+1
                'up'        ➜ rng[1] = max 0 rng[1]-1
                'down'      ➜ rng[3] = min lines.length-1 rng[3]+1
                'eol'       ➜ rng[2] = Infinity
                'bol'       ➜ rng[0] = 0
                'bof'       ➜ rng[1] = rng[0] = 0
                'eof'       ➜ rng[3] = lines.length-1; rng[2] = lines[lines.length-1].length

                'ind_bol'   ➜ ind = util.numIndent(line); rng[0] = rng[0] > ind ? ind : 0
                'ind_eol'   ➜ ind = util.numIndent(line); rng[2] = rng[2] < ind ? ind : line.length
                
            rng[0] = clamp 0 lines[rng[1]].length rng[0] if rng[1] < lines.length
            rng[2] = clamp 0 lines[rng[3]].length rng[2] if rng[3] < lines.length
        
        [newRngs newPosl]
        
export util
