
# ███  ███   ███   ███████  ████████   ████████   ███████  █████████
# ███  ████  ███  ███       ███   ███  ███       ███          ███   
# ███  ███ █ ███  ███████   ████████   ███████   ███          ███   
# ███  ███  ████       ███  ███        ███       ███          ███   
# ███  ███   ███  ███████   ███        ████████   ███████     ███   

# Copyright (c) 2022 Enrique García Cota

inspect = {Options = {}, }

inspect.KEY       = setmetatable({}, { __tostring = (() -> ⮐  'inspect.KEY' ) })
inspect.METATABLE = setmetatable({}, { __tostring = (() -> ⮐  'inspect.METATABLE' ) })

rep   = string.rep
match = string.match
char  = string.char
gsub  = string.gsub
fmt   = string.format

rawpairs = t -> ⮐  (next t nil)

smartQuote = str ->
    if match(str, '"') and not match(str, "'")
       ⮐  "'" & str & "'"
    ⮐  '"' & gsub(str, '"', '\\"') & '"'
    
shortEscapes = {"\a":"\\a" "\b":"\\b" "\f":"\\f" "\n":"\\n" "\r":"\\r" "\t":"\\t" "\v":"\\v" "\127":"\\127"}
longEscapes  = {"\127":"\127"}

for i in 0..31
    ch = char(i)
    if not shortEscapes[ch]
        shortEscapes[ch] = "\\" & i
        longEscapes[ch] = fmt("\\%03d" i)

escape = str -> ⮐  (gsub(gsub(gsub(str "\\" "\\\\") "(%c)%f[0-9]" longEscapes) "%c" shortEscapes))

luaKeywords = {
   'and':       true
   'break':     true
   'do':        true
   'else':      true
   'elseif':    true
   'end':       true
   'false':     true
   'for':       true
   'function':  true
   'goto':      true
   'if':        true
   'in':        true
   'local':     true
   'nil':       true
   'not':       true
   'or':        true
   'repeat':    true
   'return':    true
   'then':      true
   'true':      true
   'until':     true
   'while':     true
}

isIdentifier = str ->

    ⮐  type(str) == "string" and str:match("^[_%a][_%a%d]*$") and not luaKeywords[str]

isSequenceKey = k sequenceLength ->

    ⮐  type(k) == "number" and math.floor(k) == k and 1 <= (k) and k <= sequenceLength

typeOrders = { 'number':1   'boolean':2  'string':3 'table':4 'function':5 'userdata':6 'thread':7 }

sortKeys = a b ->

    ta = type(a)
    tb = type(b)
    
    if ta == tb and (ta == 'string' or ta == 'number')
       ⮐  (a) < (b)
    
    dta = typeOrders[ta] or 100
    dtb = typeOrders[tb] or 100
    
    ⮐  dta == dtb and ta < tb or dta < dtb

getKeys = t ->

    seqLen = 1
    while t[seqLen] != nil
        seqLen = seqLen + 1
    seqLen = seqLen - 1
    
    (keys, keysLen) = ({}, 0)
    for k in rawpairs(t)
        if not isSequenceKey(k, seqLen)
            keysLen = keysLen + 1
            keys[keysLen] = k
    table.sort(keys, sortKeys)
    ⮐  (keys, keysLen, seqLen)

countCycles = x cycles ->

    if type(x) == "table"
    
        if cycles[x]
            cycles[x] = cycles[x] + 1
        else
            cycles[x] = 1
            for k v in rawpairs(x)
                countCycles k cycles
                countCycles v cycles
            countCycles getmetatable(x) cycles

puts = buf str ->

    buf.n = buf.n + 1
    buf[buf.n] = str

Inspector = {}

Inspector:getId = v ->

    id = self.ids[v]
    ids = self.ids
    if not id then
        tv = type(v)
        id = (ids[tv] or 0) + 1
        (ids[v] ids[tv]) = (id id)
    ⮐  tostring(id)

Inspector:putValue = v ->

    tabify = -> puts self.buf self.newline & rep(self.indent self.level)

    buf = self.buf
    tv = type(v)
    
    if tv == 'string'
        puts(buf, smartQuote(escape(v)))
    elif tv == 'number' or tv == 'boolean' or tv == 'nil' or tv == 'cdata' or tv == 'ctype' 
        puts(buf, tostring(v))
    elif tv == 'table' and not self.ids[v]
        t = v
        
        if t == inspect.KEY or t == inspect.METATABLE
            puts buf tostring(t)
        elif self.level >= self.depth
            puts buf '{...}'
        else
            self.level = self.level + 1
            
            if self.cycles[t] > 1 
                tabify()
                puts buf fmt('<%d>' self:getId(t))
            
            (keys keysLen seqLen) = getKeys(t)
            
            for i in 1..seqLen + keysLen 
                if i <= seqLen
                    puts buf ' '
                    self:putValue(t[i])
                else
                    tabify()
                    k = keys[i - seqLen]
                    if isIdentifier k
                        puts buf k
                        if k.len < 12
                            puts buf rep(" " 12-k.len)
                    else
                        puts buf "["
                        self:putValue k
                        puts buf "]"
                    puts buf '  '
                    self:putValue t[k]
            
            mt = getmetatable(t)
            if type(mt) == 'table'
                tabify()
                puts buf '<meta> '
                self:putValue(mt)
            
            self.level = self.level - 1
            
            if seqLen > 0
                puts buf ' '
    else
        if tv == "function"
            puts buf "->"
        elif tv == "table"
            puts buf "<" & self:getId(v) & ">"
        else
            puts buf fmt('<%s %d>' tv self:getId(v))

inspect.inspect = root ->
    
    cycles = {}
    countCycles(root, cycles)
    
    inspector = setmetatable({
        buf     : { n = 0 }
        ids     : {}
        cycles  : cycles
        depth   : math.huge
        level   : 0
        newline : '\n'
        indent  : "    "
    } { __index: Inspector })
    
    inspector:putValue root
    
    ⮐  table.concat inspector.buf

setmetatable inspect {
    __call = ((_, root) -> ⮐  inspect.inspect(root))
}

⮐  inspect
