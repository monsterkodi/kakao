# ████████   ███   ███  ███████    ████████ 
# ███   ███  ████  ███  ███   ███  ███   ███
# ███████    ███ █ ███  ███   ███  ███████  
# ███   ███  ███  ████  ███   ███  ███   ███
# ███   ███  ███   ███  ███████    ███   ███

import kommon
import tknz
import pars

type
    Rndr = object
        s               : string
        annotateVarArg  : bool

proc add(r: var Rndr, text: string) = r.s &= text
proc spc(r: var Rndr)               = r.s &= " "
proc tok(r: var Rndr, n: Node)      = r.s &= n.token.str
proc rnd(r: var Rndr, n: Node)

proc rnd(r: var Rndr, nodes: seq[Node]) =

    for i,n in nodes
        r.rnd n
        if i<nodes.len-1
            r.add ", "

proc ▸block(r: var Rndr, n: Node) = 
    var idt : string
    if n.token.tok == ◆indent
        # log &"rndr.block {n} {n.token}"
        idt = n.token.str
        # r.add "\n" & idt
        r.add "\n" & idt
        
    for i,exp in n.expressions
        r.rnd exp
        if i < n.expressions.len-1
            # log &"{n.expressions[i+1].token} > {exp.token}"
            if n.expressions[i+1].token.line > exp.token.line
                r.add "\n" & idt
            else
                r.add " "

proc ▸proc(r: var Rndr, n: Node) = 

    let f = n.operand_right
    
    r.add "proc "
    r.rnd n.operand_left
    r.rnd f.func_signature
    r.add " ="
    if f.func_body != nil
        r.add " "
        r.rnd f.func_body

proc ▸operation(r: var Rndr, n: Node) = 

    if n.token.tok == ◆assign 
        if n.operand_right.token.tok == ◆func
            r.▸proc n
            ⮐  

    if n.token.tok notin {◆assign, ◆ampersand}
        r.add "("
    if n.token.tok == ◆assign and n.operand_left.kind == ●list
        r.add "("
    r.rnd n.operand_left
    if n.token.tok == ◆assign and n.operand_left.kind == ●list
        r.add ")"
    r.spc()
    case n.token.tok
        of ◆and
            r.add 'and'
        of ◆or
            r.add 'or'
        else 
            r.tok n
    r.spc()
    r.rnd n.operand_right
    if n.token.tok notin {◆assign, ◆ampersand}
        r.add ")"
        
proc ▸let(r: var Rndr, n: Node) = 

    r.tok n
    r.add " "
    r.rnd n.let_expr

proc ▸preOp(r: var Rndr, n: Node) = 

    if n.token.tok == ◆not
        r.add "not "
    else
        r.tok n
        
    r.rnd n.operand
    
proc ▸postOp(r: var Rndr, n: Node) = 

    r.rnd n.operand
    r.tok n
    
proc ▸propertyAccess(r: var Rndr, n: Node) = 

    r.rnd n.owner
    r.tok n
    r.rnd n.property

proc ▸arrayAccess(r: var Rndr, n: Node) = 

    r.rnd n.array_owner
    r.add "["
    r.rnd n.array_index
    r.add "]"
    
proc ▸func(r: var Rndr, n: Node) = 

    r.add "proc "
    r.annotateVarArg = true
    r.rnd n.func_signature
    r.annotateVarArg = false
    if n.func_mod != nil
        r.add " "
        r.tok n.func_mod
    r.add " ="
    if n.func_body != nil
        r.add " "
        r.rnd n.func_body

proc ▸signature(r: var Rndr, n:Node) =

    r.add "("
    r.annotateVarArg = true
    r.rnd n.sig_args
    r.annotateVarArg = false
    r.add ")"
    if n.sig_type != nil
        r.add " : "
        r.rnd n.sig_type
            
proc ▸var(r: var Rndr, n: Node) =

    r.rnd n.var_name
    if n.var_type != nil
        r.add " : "
        if n.token.tok == ◆var_type and r.annotateVarArg
            r.add "var "
        r.rnd n.var_type
    if n.var_value != nil
        r.add " = "
        r.rnd n.var_value

proc ▸string(r: var Rndr, n: Node) = 

    var delimiter = n.token.str
    
    if delimiter == "'" and n.string_content.token.str.len > 1
        delimiter = "\""
    
    if n.string_stripols.len > 0
        r.add "&"
        
    r.add delimiter
    r.tok n.string_content
    for stripol in n.string_stripols
        r.add "{"
        r.rnd stripol.stripol_xprssns
        r.add "}"
        if stripol.stripol_content != nil
            r.tok stripol.stripol_content
    
    r.add delimiter
    
proc ▸use(r: var Rndr, n: Node) = 
    
    r.add "import "
    r.tok n.use_module
    if n.use_kind != nil and n.use_kind.token.str == '▪'
        r.add "/["
        r.rnd n.use_items
        r.add "]"
    
proc ▸comment(r: var Rndr, n: Node) = 

    r.tok n
    r.tok n.comment_content
    
proc ▸call(r: var Rndr, n: Node) =

    r.rnd n.callee
    r.add "("
    r.rnd n.call_args
    r.add ")"

proc ▸if(r: var Rndr, n: Node) =

    var idt = ' '.repeat n.token.col
    var line = n.token.line
    
    r.tok n
    r.add " "
    for i,condThen in n.cond_thens
        if i > 0
            if condThen.token.line > line
                r.add "\n" & idt & "elif "
            else
                r.add " elif "
        r.rnd condThen.cond
        r.add ": "
        r.rnd condThen.then
    if n.else != nil   
        if n.else.token.line > line
            r.add "\n" & idt & "else: "
        else
            r.add " else: "
        r.rnd n.else
        
proc ▸for(r: var Rndr, n: Node) =

    r.add "for "
    if n.for_value.kind == ●list
        for i,v in n.for_value.list_values
            r.rnd v
            if i < n.for_value.list_values.len-1
                r.add ", "
    else
        r.rnd n.for_value
    r.add " in "
    r.rnd n.for_range
    r.add ": "
    r.rnd n.for_body
    
proc ▸while(r: var Rndr, n: Node) =

   r.add "while "
   r.rnd n.while_cond
   r.rnd n.while_body
    
proc ▸list(r: var Rndr, n: Node) =

    for i,item in n.list_values
        r.rnd item
        if i < n.list_values.len-1
            r.add ", "

proc ▸curly(r: var Rndr, n: Node) =

    r.add "{"
    for i,item in n.list_values
        r.rnd item
        if i < n.list_values.len-1
            r.add ", "
    r.add "}"

proc ▸squarely(r: var Rndr, n: Node) =

    r.add "@["
    for i,item in n.list_values
        r.rnd item
        if i < n.list_values.len-1
            r.add ", "
    r.add "]"
    
proc ▸range(r: var Rndr, n: Node) = 

    r.add "["
    r.rnd n.range_start
    r.tok n
    r.rnd n.range_end
    r.add "]"
        
proc ▸return(r: var Rndr, n: Node) =

    r.add "return"
    if n.return_value != nil
        r.spc()
        r.rnd n.return_value

proc ▸discard(r: var Rndr, n: Node) =

    r.add "discard"
    if n.discard_value != nil
        r.spc()
        r.rnd n.discard_value
     
proc ▸switch(r: var Rndr, n: Node) =

    var idt = ' '.repeat n.token.col
    
    r.add idt & "case "
    r.rnd(n.switch_value)
    r.add ":"
    
    var cdt = ' '.repeat n.switch_cases[0].token.col
    
    for i,caseNode in n.switch_cases
        r.add "\n" & cdt
        r.add "of "
        for j,whenNode in caseNode.case_when
            if j > 0
                r.add ", "
            r.rnd(whenNode)
        r.add ": "
        r.rnd(caseNode.case_then)
    
    if n.switch_default != nil
        r.add "\n" & cdt
        r.add "else: "
        r.rnd(n.switch_default)

proc ▸testCase(r: var Rndr, n: Node) =

    r.add "check "
    r.rnd n.test_expression
    r.add " == "
    r.rnd n.test_expected

proc ▸testSuite(r: var Rndr, n:Node) =

    if n.kind == ●testSuite
        r.add "suite"
    else
        r.add "test"
    r.add " \"" 
    r.add n.token.str[4..^1] 
    r.add "\": "
    r.rnd n.test_block

proc rnd(r: var Rndr, n: Node) =

    if n == nil
        ⮐  
    
    case n.kind
    
        of ●block
            r.▸block(n)
        of ●if
            r.▸if(n)
        of ●switch
            r.▸switch(n)
        of ●func
            r.▸func(n)
        of ●signature
            r.▸signature(n)
        of ●call
            r.▸call(n)
        of ●operation
            r.▸operation(n)
        of ●postOp
            r.▸postOp(n)
        of ●preOp
            r.▸preOp(n)
        of ●for
            r.▸for(n)
        of ●while
            r.▸while(n)
        of ●list
            r.▸list(n)
        of ●curly
            r.▸curly(n)
        of ●squarely
            r.▸squarely(n)
        of ●range
            r.▸range(n)
        of ●string
            r.▸string(n)
        of ●comment
            r.▸comment(n)
        of ●use
            r.▸use(n)
        of ●propertyAccess
            r.▸propertyAccess(n)
        of ●arrayAccess
            r.▸arrayAccess(n)
        of ●var
            r.▸var(n)
        of ●let
            r.▸let(n)
        of ●return
            r.▸return(n)
        of ●discard
            r.▸discard(n)
        of ●testSuite, ●testSection
            r.▸testSuite(n)
        of ●testCase
            r.▸testCase(n)
        of ●literal, ●type, ●import, ●keyword
            r.tok n
        else
            log &"unhandled {n} {n.kind}"
            r.tok n

proc renderNode*(root: Node): string =

    var r = Rndr()
    r.rnd(root)
    r.s

proc renderCode*(code: string): string =

    let a = ast(code)
    # echo &"ast {a}"
    renderNode(a)
    
proc file*(file: string) : string = 

    var fileOut = file.swapLastPathComponentAndExt("kim", "nim")
    # log &"fileOut {fileOut}"
    let code = file.readFile()
    # echo &"code {code}"
    let trns = renderCode code
    log &"{trns}"
    fileOut
    
proc files*(files: seq[string]): seq[string] = 

    var transpiled: seq[string]
    for f in files
        transpiled.add file f
        
    # echo "render.files done: ", transpiled
    transpiled
        
                            