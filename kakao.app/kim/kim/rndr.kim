# ████████   ███   ███  ███████    ████████ 
# ███   ███  ████  ███  ███   ███  ███   ███
# ███████    ███ █ ███  ███   ███  ███████  
# ███   ███  ███  ████  ███   ███  ███   ███
# ███   ███  ███   ███  ███████    ███   ███

use kommon tknz pars vars

class Rndr
    code            : string
    s               : string
    annotateVarArg  : bool

$* = ◇Rndr r ➜string ->
    s = ""
    s &= "▸"
    s &= r.code
    s &= "◂"
    s

add = ◇Rndr r ◇string text -> r.s &= text
spc = ◇Rndr r              -> r.s &= " "
tok = ◇Rndr r ◇Node n      -> r.s &= n.token.str
rnd = ◇Rndr r ◇Node n      ->
rnd = ◇Rndr r ◇seq[Node] nodes ->

    for i,n in nodes
        r.rnd n
        if i<nodes.len-1
            r.add ", "

▸block = ◇Rndr r ◇Node n -> 

    idt ◇ string
    if n.token.tok == ◂indent
        idt = n.token.str
        r.add "\n" & idt
        
    for i,exp in n.expressions
        r.rnd exp
        if i < n.expressions.len-1
            if n.expressions[i+1].token.line > exp.token.line
                r.add "\n" & idt
            else
                r.add " "

▸proc = ◇Rndr r ◇Node n -> 

    if n == nil or n.operand_left == nil or n.operand_right == nil
        log &"DAFUK? {n} {n.token}"
        ⮐  

    f = n.operand_right
    
    r.add "proc "
    if n.operand_left.token.str[0] == '$'
        r.add "`$`" & n.operand_left.token.str[1..^1]
    else
        r.rnd n.operand_left
    r.rnd f.func_signature
    if f.func_body
        r.add " ="
        r.add " "
        r.rnd f.func_body

▸operation = ◇Rndr r ◇Node n -> 

    if n == nil or n.operand_left == nil or n.operand_right == nil
        log &"DAFUK? {n} {n.token}"
        ⮐  

    if n.token.tok == ◂assign 
        if n.operand_right.token.tok == ◂func
            r.▸proc n
            ⮐  

    if n.token.tok notin {◂assign, ◂ampersand}
        r.add "("
    if n.token.tok == ◂assign and n.operand_left.kind == ●list
        r.add "("
    r.rnd n.operand_left
    if n.token.tok == ◂assign and n.operand_left.kind == ●list
        r.add ")"
    r.spc()
    switch n.token.tok
        ◂and ➜ r.add 'and'
        ◂or  ➜ r.add 'or'
             ➜ r.tok n
    r.spc()
    if n.token.tok == ◂assign and n.operand_right.kind == ●list
        r.add "("
    r.rnd n.operand_right
    if n.token.tok == ◂assign and n.operand_right.kind == ●list
        r.add ")"
    if n.token.tok notin {◂assign, ◂ampersand}
        r.add ")"
        
▸let = ◇Rndr r ◇Node n -> 

    r.tok n
    r.add " "
    r.rnd n.let_expr

▸preOp = ◇Rndr r ◇Node n -> 

    if n.token.tok == ◂not
        r.add "not "
    else
        r.tok n
        
    r.rnd n.operand
    
▸postOp = ◇Rndr r ◇Node n -> 

    r.rnd n.operand
    r.tok n
    
▸propertyAccess = ◇Rndr r ◇Node n -> 

    r.rnd n.owner
    r.tok n
    r.rnd n.property

▸arrayAccess = ◇Rndr r ◇Node n -> 

    r.rnd n.array_owner
    r.add "["
    r.rnd n.array_index
    r.add "]"
    
▸func = ◇Rndr r ◇Node n -> 

    r.add "proc "
    r.annotateVarArg = true
    r.rnd n.func_signature
    r.annotateVarArg = false
    if n.func_mod
        r.add " "
        r.tok n.func_mod
    if n.func_body
        r.add " ="
        r.add " "
        r.rnd n.func_body

▸signature = ◇Rndr r ◇Node n ->

    r.add "("
    r.annotateVarArg = true
    r.rnd n.sig_args
    r.annotateVarArg = false
    r.add ")"
    if n.sig_type
        r.add " : "
        r.rnd n.sig_type
            
▸var = ◇Rndr r ◇Node n ->

    if n.var_name.kind == ●list
        r.add "("
    r.rnd n.var_name
    if n.var_name.kind == ●list
        r.add ")"
    if n.var_type
        r.add " : "
        r.rnd n.var_type
    if n.var_value
        r.add " = "
        r.rnd n.var_value

▸arg = ◇Rndr r ◇Node n ->

    r.rnd n.arg_name
    if n.arg_type
        r.add " : "
        if n.token.tok == ◂var_type and r.annotateVarArg
            r.add "var "
        r.rnd n.arg_type
    if n.arg_value
        r.add " = "
        r.rnd n.arg_value

▸string = ◇Rndr r ◇Node n -> 

    delimiter = n.token.str
    
    if delimiter == "'" and n.string_content.token.str.len > 1
        delimiter = "\""
    
    if n.string_stripols.len > 0
        r.add "&"
    elif n.string_prefix
        r.tok n.string_prefix
        
    r.add delimiter
    
    sct = n.string_content.token.str

    mill = high(int)
    if delimiter == "\"\"\""
        var lines = n.string_content.token.str.split "\n"
        if lines.len > 1
            let ill = indentLen(lines[1..^1])
            mill = min(mill, ill)
                
        for stripol in n.string_stripols
            if stripol.stripol_content
                lines = stripol.stripol_content.token.str.split "\n"
                if lines.len > 1
                    let ill = indentLen(lines[1..^1])
                    mill = min(mill, ill)
        
    demill = ◇Node n -> 
        if mill == 0
            r.tok n
        else
            var lines = n.token.str.split "\n"
            for i in 1..<lines.len
                lines[i] = lines[i][mill..^1]
            r.add lines.join("\n")
        
    demill n.string_content
    for stripol in n.string_stripols
        r.add "{"
        r.rnd stripol.stripol_xprssns
        r.add "}"
        if stripol.stripol_content != nil
            demill stripol.stripol_content
    
    r.add delimiter
    
▸use = ◇Rndr r ◇Node n -> 

    split = n.use_module.token.str.split " "
    while split.len > 1
        r.add &"import {split[0]}\n" 
        split = split.shift
    
    r.add "import "
    r.add split[0]
    if n.use_kind != nil and n.use_kind.token.str == '▪'
        r.add "/["
        r.rnd n.use_items
        r.add "]"
    
▸comment = ◇Rndr r ◇Node n -> 

    if n.token.str == "###"
        r.add "#["
    else
        r.tok n
        
    r.tok n.comment_content
    
    if n.token.str == "###"
        r.add "]#"
    
▸call = ◇Rndr r ◇Node n ->

    if n.callee.token.str == "log"
        r.add "echo"
    else
        r.rnd n.callee
        
    if n.callee.token.str != "export"
        r.add "("
    else
        r.add " "
        
    r.rnd n.call_args
    
    if n.callee.token.str != "export"
        r.add ")"
        
▸if = ◇Rndr r ◇Node n ->

    idt = ' '.repeat n.token.col
    line = n.token.line
    
    r.tok n
    r.add " "
    
    for i condThen in n.cond_thens
        if i > 0
            if condThen.token.line > line
                r.add "\n" & idt & "elif "
            else
                r.add " elif "
        r.rnd condThen.condition
        r.add ": "
        r.rnd condThen.then_branch
        
    if n.else_branch   
        if n.else_branch.token.line > line
            r.add "\n" & idt & "else: "
        else
            r.add " else: "
        r.rnd n.else_branch
        
▸for = ◇Rndr r ◇Node n ->

    r.add "for "
    if n.for_value.kind == ●list
        for i,v in n.for_value.list_values
            r.rnd v
            if i < n.for_value.list_values.len-1
                r.add ", "
    else
        r.rnd n.for_value
    r.add " in "
    r.rnd n.for_range
    r.add ": "
    r.rnd n.for_body
    
▸while = ◇Rndr r ◇Node n ->

   r.add "while "
   r.rnd n.while_cond
   r.add ": "
   r.rnd n.while_body
    
▸list = ◇Rndr r ◇Node n ->

    for i,item in n.list_values
        r.rnd item
        if i < n.list_values.len-1
            r.add ", "

▸curly = ◇Rndr r ◇Node n ->

    r.add "{"
    for i,item in n.list_values
        r.rnd item
        if i < n.list_values.len-1
            r.add ", "
    r.add "}"

▸squarely = ◇Rndr r ◇Node n ->

    r.add "@["
    for i,item in n.list_values
        r.rnd item
        if i < n.list_values.len-1
            r.add ", "
    r.add "]"
    
▸range = ◇Rndr r ◇Node n -> 

    r.rnd n.range_start
    if n.token.str == "..."
        r.add "..<"
    else
        r.tok n
    r.rnd n.range_end
        
▸return = ◇Rndr r ◇Node n ->

    r.add "return"
    if n.return_value
        r.spc()
        r.rnd n.return_value

▸discard = ◇Rndr r ◇Node n ->

    r.add "discard"
    if n.discard_value
        r.spc()
        r.rnd n.discard_value

▸quote = ◇Rndr r ◇Node n ->

    r.add "quote do: "
    r.rnd n.quote_body
     
▸switch = ◇Rndr r ◇Node n ->

    idt = ' '.repeat n.token.col
    
    r.add "case "
    r.rnd(n.switch_value)
    r.add ":"
    
    cdt = ' '.repeat n.switch_cases[0].token.col
    
    for i,caseNode in n.switch_cases
        r.add "\n" & cdt
        r.add "of "
        for j,whenNode in caseNode.case_when
            if j > 0
                r.add ", "
            r.rnd(whenNode)
        r.add ": "
        r.rnd(caseNode.case_then)
    
    if n.switch_default
        r.add "\n" & cdt
        r.add "else: "
        r.rnd(n.switch_default)
        
▸enum = ◇Rndr r ◇Node n ->

    r.add "type "
    r.rnd n.enum_name
    r.add " = enum"
    r.rnd n.enum_body
    
▸class = ◇Rndr r ◇Node n ->

    r.add "type "
    r.rnd n.class_name
    r.add " = ref object"
    r.rnd n.class_body

▸member = ◇Rndr r ◇Node n ->

    r.rnd n.member_key
    r.add ": "
    r.rnd n.member_value

▸testCase = ◇Rndr r ◇Node n ->

    r.add "check "
    r.rnd n.test_value
    r.add " == "
    r.rnd n.test_expected

▸testSuite = ◇Rndr r ◇Node n ->

    if n.kind == ●testSuite
        r.add "suite"
    else
        r.add "test"
    r.add " \"" 
    r.add n.token.str[4..^1] 
    r.add "\": "
    r.rnd n.test_block

rnd = ◇Rndr r ◇Node n ->

    ⮐  if n == nil
    
    switch n.kind
    
        ●block          ➜ r.▸block          n
        ●if             ➜ r.▸if             n
        ●switch         ➜ r.▸switch         n
        ●func           ➜ r.▸func           n
        ●signature      ➜ r.▸signature      n
        ●call           ➜ r.▸call           n
        ●operation      ➜ r.▸operation      n
        ●postOp         ➜ r.▸postOp         n
        ●preOp          ➜ r.▸preOp          n
        ●for            ➜ r.▸for            n
        ●while          ➜ r.▸while          n
        ●list           ➜ r.▸list           n
        ●curly          ➜ r.▸curly          n
        ●squarely       ➜ r.▸squarely       n
        ●range          ➜ r.▸range          n
        ●string         ➜ r.▸string         n
        ●comment        ➜ r.▸comment        n
        ●use            ➜ r.▸use            n
        ●propertyAccess ➜ r.▸propertyAccess n
        ●arrayAccess    ➜ r.▸arrayAccess    n
        ●var            ➜ r.▸var            n
        ●arg            ➜ r.▸arg            n
        ●let            ➜ r.▸let            n
        ●return         ➜ r.▸return         n
        ●discard        ➜ r.▸discard        n
        ●enum           ➜ r.▸enum           n
        ●class          ➜ r.▸class          n
        ●quote          ➜ r.▸quote          n
        ●member         ➜ r.▸member         n
        ●testCase       ➜ r.▸testCase       n
        ●testSuite 
        ●testSection    ➜ r.▸testSuite      n
        ●literal 
        ●keyword 
        ●type           
        ●typeDef 
        ●import 
        ●proc 
        ●macro 
        ●template 
        ●converter      ➜ r.tok             n
                        ➜ 
                          log "unhandled #{n} #{n.kind}"
                          r.tok n

render* = ◇string code autovar=true ➜string ->

    # profileStart "ast"
    root = ast(code)
    # profileStop "ast"
    if autovar
        # profileStart "vars"
        root = variables(root)
        # profileStop "vars"
    r = Rndr(code:code)
    # profileStart "rnd"
    r.rnd(root)
    # profileStop "rnd"
    r.s
    
file* = ◇string file ➜string ->

    profileScope "rndr.file"

    fileOut = file.swapLastPathComponentAndExt("kim", "nim")
    kimCode = file.readFile()
    nimCode = render kimCode 
    fileOut.writeFile nimCode
    fileOut
    
files* = ◇seq[string] files ➜seq[string] ->

    transpiled ◇ seq[string]
    for f in files
        transpiled.add file(f)
    transpiled
        
                            