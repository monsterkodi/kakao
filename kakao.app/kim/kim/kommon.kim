###
    ███   ███   ███████   ██     ██  ██     ██   ███████   ███   ███
    ███  ███   ███   ███  ███   ███  ███   ███  ███   ███  ████  ███
    ███████    ███   ███  █████████  █████████  ███   ███  ███ █ ███
    ███  ███   ███   ███  ███ █ ███  ███ █ ███  ███   ███  ███  ████
    ███   ███   ███████   ███   ███  ███   ███   ███████   ███   ███
###

use std ▪ monotimes times sequtils paths tables typetraits strformat strutils unicode pegs unittest macros terminal enumutils sets
use system/ansi_c

export monotimes times
export sequtils  tables    typetraits
export enumutils sets
export strutils  strformat unicode pegs
export unittest  macros
export terminal

type lineInfo* = tuple[filename: string, line: int, column: int]

fg* = ◇auto c ➜auto ->
    ansiForegroundColorCode(c)
sc* = ◇auto c ➜auto ->
    ansiStyleCode(c)

underscore* = ◇uint64 n ➜string ->
    var s = $n
    result = newStringOfCap(s.len + (s.len - 1).div(3))
    var count = 0
    for i in countdown(s.high, 0)
        if count != 0 and count.mod(3) == 0
          result.add('_')
        result.add(s[i])
        inc(count)
    result = reversed(result)

indent* = ◇string s i=4 ➜string ->

    let idt = ' '.repeat i
    let lines = s.split "\n"
    idt & lines.join "\n" & idt
    
indentLen* = ◇string s ➜int ->

    var i = 0
    while i < s.len and s[i] == ' '
        i += 1
    i
    
indentLen* = ◇seq[string] lines ➜int -> 

    var m = high(int)
    for l in lines
        m = min(m, indentLen(l))
    m

testCmp* = ◇string a ◇auto r ◇auto b  ◇lineInfo l -> 

    if r != b
        log ""
        styledEcho fgWhite $l.line fgWhite styleDim ":"  l.filename.split(".")[0]
        styledEcho fgBlue    indent($a)
        styledEcho fgMagenta "|>"
        styledEcho fgGreen   indent($b)
        # styledEcho fgRed     "!="
        styledEcho fgYellow  indent($r)
        styledEcho fgRed styleDim "<|"
        fail()

converter toBool*(x: int): bool = x != 0
converter toBool*[T](x: seq[T]): bool = x.len > 0

swapLastPathComponentAndExt* = ◇string file ◇string src ◇string tgt ➜string ->

    let (dir _ _) = splitFile(file.Path)
    var dirParts = dir.string.split(DirSep)
    
    if dirParts[0] == "" and dirParts.len == 1
        dirParts.delete(0..0)
    
    for i in countdown(dirParts.high, 0)
        if dirParts[i] == src
            dirParts[i] = tgt
            break
            
    dirParts.add file.Path.changeFileExt("." & tgt).splitPath[1].string
    dirParts.join "/"
    
# ████████   ████████    ███████   ████████  ███  ███      ████████
# ███   ███  ███   ███  ███   ███  ███       ███  ███      ███     
# ████████   ███████    ███   ███  ██████    ███  ███      ███████ 
# ███        ███   ███  ███   ███  ███       ███  ███      ███     
# ███        ███   ███   ███████   ███       ███  ███████  ████████

var timers : Table[string, tuple[m:MonoTime, t:uint64]]
proc mach_absolute_time(): uint64 {.importc, header: "<mach/mach_time.h>".}
    
profileStart* = ◇string msg ->
    # GC_disableOrc()
    if not timers.contains(msg)
        timers[msg] = (getMonoTime(), mach_absolute_time())
    else
        stderr.writeLine &"[WARNING] Duplicate profileStart for '{msg}'"

profileStop* = ◇string msg ->
    
    if not timers.contains(msg)
        stderr.writeLine &"[ERROR] profileStop for unknown label '{msg}'"
        ⮐  

    let mono = getMonoTime() - timers[msg][0]
    let tick = mach_absolute_time() - timers[msg][1]
    var mons = ""

    if mono.inMicroseconds < 1000
        mons = &" {mono.inMicroseconds} {sc(styleDim)}µs "
    else
        mons = &" {mono.inMilliseconds} {sc(styleDim)}ms "
                
    styledEcho fgBlue msg fgGreen mons fgMagenta underscore(tick) resetStyle
    # GC_enableOrc()    
    timers.del(msg)
    
macro profileScope*(msg: string): untyped =
    quote
        profileStart(`msg`)
        defer: profileStop(`msg`)
    
# ███   ███   ███████  ████████   ███████ 
# ███  ███   ███       ███       ███      
# ███████    ███████   ███████   ███  ████
# ███  ███        ███  ███       ███   ███
# ███   ███  ███████   ████████   ███████ 

# Splits a string into grapheme clusters (user-perceived characters)

kseg* = ◇string s ➜seq[string] ->
  
    var i = 0
    while i < s.len
        let clusterSize = graphemeLen(s, i)
        result.add(s.substr(i, i + clusterSize - 1))
        i += clusterSize
    
# ████████   ███   ███   ███████  ███   ███          ████████    ███████   ████████ 
# ███   ███  ███   ███  ███       ███   ███    ██    ███   ███  ███   ███  ███   ███
# ████████   ███   ███  ███████   █████████  ██████  ████████   ███   ███  ████████ 
# ███        ███   ███       ███  ███   ███    ██    ███        ███   ███  ███      
# ███         ███████   ███████   ███   ███          ███         ███████   ███      

proc pops*[T](s: var seq[T]): seq[T] {. discardable .} =
    if s.len > 0 ➜ s.setLen(s.len - 1)
    s

proc push*[T](s: var seq[T], item: T): seq[T] {. discardable .} =
    s.add item
    s
        
proc shift*[T](s: var seq[T]): seq[T] {. discardable .} =
    if s.len > 0 ➜ s.delete 0
    s
        
proc unshift*[T](s: var seq[T], item: T): seq[T] {. discardable .} =
    s.insert @[item]
    s
    
# ████████   ███████   ███   ███   ███████   ███    
# ███       ███   ███  ███   ███  ███   ███  ███    
# ███████   ███ ██ ██  ███   ███  █████████  ███    
# ███       ███ ████   ███   ███  ███   ███  ███    
# ████████   █████ ██   ███████   ███   ███  ███████

proc deepEqual*[T](a, b: T): bool =

    when 
        T is (seq or array)
            if a.len != b.len
                log &"{a.len} != {b.len} length differs"
                ⮐  false
            for i in 0..<a.len
                if not deepEqual(a[i], b[i])
                    log &"{a[i]} != {b[i]}"
                    ⮐  false
        T is (Table or TableRef or OrderedTable)
            if a.len != b.len
                log &"{a.len} != {b.len} length differs"
                ⮐  false
            for key valA in a.pairs
                if not b.hasKey(key)
                    log &"{key} not in {b}"
                    ⮐  false
                if not deepEqual(valA, b[key])
                    log &"{valA} != {b[key]}"
                    ⮐  false
        T is object
            if a != b
                log &"{a} != {b}"
                ⮐  false
        T is tuple
            if a != b
                log &"{a} != {b}"
                ⮐  false
        ➜ 
            if a != b
                log &"{a} != {b}"
                ⮐  false
    true
    
# ███████    ███████     ███████ 
# ███   ███  ███   ███  ███      
# ███   ███  ███████    ███  ████
# ███   ███  ███   ███  ███   ███
# ███████    ███████     ███████ 

macro dbg*(args: varargs[untyped]): untyped =
    
    result = newStmtList()
    
    let lineInfo = args[0].lineInfoObj
    
    result.add quote
        styledEcho bgBlue styleBright `lineInfo`.filename styleDim ":" $`lineInfo`.line resetStyle
    
    for arg in args
        result.add quote
            styledEcho(fgYellow styleBright "  " `arg`.astToStr() resetStyle
                styleDim " = " resetStyle fgGreen $`arg` resetStyle
                fgBlue " " $typeof(`arg`) resetStyle)
