
#  ███████  ███       ███████    ███████   ███████
# ███       ███      ███   ███  ███       ███     
# ███       ███      █████████  ███████   ███████ 
# ███       ███      ███   ███       ███       ███
#  ███████  ███████  ███   ███  ███████   ███████ 

# Copyright (c) 2011 Enrique García Cota

_createIndexWrapper = aClass f ->

    if f == nil
        ⮐   aClass.__instanceDict
        
    elif type(f) == "function"
        ⮐  (self name) ->
            value = aClass.__instanceDict[name]
            
            if value != nil
                ⮐  value
            else
                ⮐  f(self, name)
                
    else # if  type(f) == "table"
        ⮐  (self name) ->
            value = aClass.__instanceDict[name]
            
            if value != nil
                ⮐  value
            else
                ⮐  f[name]

_propagateInstanceMethod = aClass name f ->

    f = name == "__index" and _createIndexWrapper(aClass, f) or f
    
    aClass.__instanceDict[name] = f
    
    for subclass in pairs(aClass.subclasses)
        if rawget(subclass.__declaredMethods, name) == nil
            _propagateInstanceMethod(subclass, name, f)

_declareInstanceMethod = aClass name f ->
  
    aClass.__declaredMethods[name] = f
    
    if f == nil and aClass.super
        f = aClass.super.__instanceDict[name]
    
    _propagateInstanceMethod(aClass, name, f)

_tostring = self -> ⮐  "class " .. self.name
_call = self ... -> ⮐  self:new(...)

_createClass = name super ->

    dict = {}
    dict.__index = dict
    
    aClass = { 
        name:  name
        super: super
        static: {}
        __instanceDict: dict
        __declaredMethods: {}
        subclasses: setmetatable({}, {__mode='k'}) 
        }
    
    if super
        setmetatable(aClass.static, {
            __index: (_ k) ->
                result = rawget(dict,k)
                if result == nil
                      ⮐  super.static[k]
                ⮐  result
        })
    else
        setmetatable(aClass.static, { __index = ((_ k) -> ⮐  rawget(dict,k)) })
    
    setmetatable(aClass, {  
        __index     = aClass.static, 
        __tostring  = _tostring,
        __call      = _call, 
        __newindex  = _declareInstanceMethod })
        
    ⮐  aClass

_includeMixin = aClass mixin ->

    assert(type(mixin) == 'table', "Invalid Mixin table")
    
    for name meth in pairs(mixin)
        if name != "included" and name != "static" 
            aClass[name] = meth
    
    for name meth in pairs(mixin.static or {})
        aClass.static[name] = meth
    
    if type(mixin.included)=="function" ➜ mixin:included(aClass)
    ⮐  aClass

DefaultMixin = {
    __tostring: (self) -> ⮐  "instance of " .. tostring(self.class)
    
    init: (self ...) ->
    
    isOf: (self aClass) ->
        assert(type(self) == 'table', "Use :isOf instead of .isOf")
        ⮐  type(aClass) == 'table' and type(self) == 'table' and (self.class == aClass or type(self.class) == 'table' and type(self.class.extends) == 'function' and self.class:extends(aClass))
    
    static: {
        allocate: (self) ->
            assert(type(self) == 'table', "Use :allocate instead of .allocate")
            ⮐  setmetatable({ class = self }, self.__instanceDict)
        
        new: (self ...) ->
            assert(type(self) == 'table', "Use :new instead of .new")
            instance = self:allocate()
            instance:init(...)
            ⮐  instance
        
        subclass: (self name) ->
            assert(type(self) == 'table', "Use :subclass instead of .subclass")
            assert(type(name) == "string", "Invalid subclass name")
            
            subclass = _createClass(name, self)
            
            for methodName, f in pairs(self.__instanceDict)
                if not (methodName == "__index" and type(f) == "table")
                    _propagateInstanceMethod(subclass, methodName, f)
            subclass.init = ((instance, ...) -> ⮐  self.init(instance, ...))
            
            self.subclasses[subclass] = true
            self:subclassed(subclass)
            
            ⮐  subclass
        
        subclassed: (self other) ->
        
        extends: (self other) ->
            assert(type(self) == 'table', "Use :extends instead of .extends")
            ⮐  type(other) == 'table' and type(self.super) == 'table' and ( self.super == other or self.super:extends(other) )
        
        include: (self ...) ->
            assert(type(self) == 'table', "Use :include instead of .include")
            for _,mixin in ipairs({...}) ➜  _includeMixin(self, mixin)
            ⮐  self
    }
}

middleclass = {}

middleclass.class = name super ->
    assert(type(name) == 'string', "Invalid class name")
    ⮐  super and super:subclass(name) or _includeMixin(_createClass(name), DefaultMixin)

setmetatable(middleclass, { __call = ((_ ...) -> ⮐  middleclass.class(...)) })

⮐  middleclass
