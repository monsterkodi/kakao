###
    ████████    ███████   ███   ███  ███   ███  ███████    ████████  ███████  
    ███   ███  ███   ███  ███   ███  ████  ███  ███   ███  ███       ███   ███
    ███████    ███   ███  ███   ███  ███ █ ███  ███   ███  ███████   ███   ███
    ███   ███  ███   ███  ███   ███  ███  ████  ███   ███  ███       ███   ███
    ███   ███   ███████    ███████   ███   ███  ███████    ████████  ███████  
###

use ../../kxk      ◆ nfs
use                ◆ png

function rounded

    @cache: {}

    @img: w h ->
        
        buff = new ArrayBuffer w*h*4
        view = new DataView buff
    
        w:    w
        h:    h
        buff: buff
        view: view

    @set: img x y rgba ->
    
        ⮐  if x < 0 or y < 0
        ⮐  if x >= img.w
        ⮐  if y >= img.h
        
        for i in 0...rgba.length
            img.view.setUint8 ((x+y*img.w)*4)+i rgba[i]
        if rgba.length == 3
             img.view.setUint8 ((x+y*img.w)*4)+3 255
            
    @encode: img ->
    
        img.png = Buffer.from png.encode([img.buff] img.w img.h 2)
        img
        
    @circle: img cx cy r fg ->
    
        rsq = r * r
        for x in cx-r..cx+r
            for y in cy-r..cy+r
                if (cx-x)**2 + (cy-y)**2 <= rsq
                    @set img x y fg
                    
    @fill: img x y w h fg ->
        
        for r in x..x+w
            for c in y..y+h
                @set img r c fg
                    
    @rect: w h r fg ->
        
        img = @img w h
        rx = r
        ry = r
        rw = w-2*r
        rh = h-2*r
        @fill img rx ry rw rh fg
        @encode img

    @topLeft: w h fg ->
    
        img = @img w h
        r   = min w h
        @circle img r r r   fg
        @fill   img 0 r w h fg
        @encode img 

    @borderTopLeft: w h fg ->    
    
        img = @img w h
        r   = int w/2
        h2  = int h/2 
        
        @circle img w h2+r r        fg
        @fill   img r h2+r r h-h2-r fg
        @encode img 
        
    @borderTopRight: w h fg ->
        
        img = @img w h
        r   = int(w/2)-1
        h2  = int h/2
        
        @circle img 0 h2+r r        fg
        @fill   img 0 h2+r r h-h2-r fg
        @encode img 

    @borderBottomLeft: w h fg ->
    
        img = @img w h
        r   = int w/2
        h2  = int h/2
        
        @circle img w h2-r r   fg
        @fill   img r 0 r h2-r fg
        @encode img 

    @borderBottomRight: w h fg ->
        
        img = @img w h
        r   = int(w/2)-1
        h2  = int h/2
        
        @circle img 0 h2-r r   fg    
        @fill   img 0 0 r h2-r fg
        @encode img 
        
    @place: x y name fg bg ->
        
        key = name+fg+bg 
        img = @cache[key]

        if empty img
            csz = ked_ttio.cellsz
            img = switch name 
                'rounded.border.tl' ➜ @borderTopLeft     csz[0] csz[1] fg 
                'rounded.border.tr' ➜ @borderTopRight    csz[0] csz[1] fg 
                'rounded.border.bl' ➜ @borderBottomLeft  csz[0] csz[1] fg 
                'rounded.border.br' ➜ @borderBottomRight csz[0] csz[1] fg 
            @cache[key] = img

        ked_ttio.placeImg img x y
            
export rounded
