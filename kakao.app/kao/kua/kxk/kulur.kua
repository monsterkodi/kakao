###
000   000  000   000  000      000   000  00000000
000  000   000   000  000      000   000  000   000
0000000    000   000  000      000   000  0000000
000  000   000   000  000      000   000  000   000
000   000   0000000   0000000   0000000   000   000
###

# use kxk/kxk
use kxk/extlang

#swtch =
#    pug:
#        script: next:'.' to:'js' indent:1
#    md:
#        coffeescript: turd:'```' to:'coffee' end:'```' add:'code triple'
#        javascript:   turd:'```' to:'js'     end:'```' add:'code triple'
#        
#for ext in exts
#    swtch.md[ext] = turd:'```' to:ext end:'```' add:'code triple'

SPACE   = "%s"
HEADER  = "^[0█]+$"
PUNCT   = "[^%wäöüßÄÖÜáéíóúÁÉÍÓÚñÑçÇàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛãõÃÕåÅæÆœŒøØłŁđĐ]+"
NUMBER  = "^%d+$"
FLOAT   = "^%d+f$"
HEXNUM  = "^0x[a-fA-F%d]+$"
HEX     = "^[a-fA-F%d]+$"
NEWLINE = "%r?%n"
LI      = "(%sli%d%s|%sh%d%s)"

codeTypes = ['interpolation' 'code triple']

#  0000000  000   000  000   000  000   000  000   000  00000000  0000000
# 000       000   000  000   000  0000  000  000  000   000       000   000
# 000       000000000  000   000  000 0 000  0000000    0000000   000   000
# 000       000   000  000   000  000  0000  000  000   000       000   000
#  0000000  000   000   0000000   000   000  000   000  00000000  0000000

###
    returns array of

        chunks: [
                    turd:   s
                    clss:   s
                    match:  s
                    start:  n
                    length: n
                ]
        ext:    s
        chars:  n
        index:  n
        number: n+1
###

chunked = segls ext ->
    
    if string.sub(ext 1 1) == '.'
        ext = kstr.slice(ext 2) 
        
    if not extlang.exts∙has(ext)
        ext = 'txt' 

    # write ◌y "CHUNKED " ext

    lineno = 0
    chunkd = []
    
    for segs in segls
        lineno += 1
        chnks = {
            chunks: []
            chars:  0
            index:  lineno
            number: lineno
            ext:    ext}
            
        chunkd∙push chnks            

        if valid segs
        
            chunks = kseg.chunks kseg.detab(segs)
            
            if valid chunks
            
                lastWord = nil
                lastWordIndex = -1
                
                pushLastWord = ->
                    
                    if lastWord
                        chnks.chunks∙push {start:kseg.widthAtSegi(segs lastWordIndex) length:kseg.width(lastWord) match:kseg.str(lastWord) clss:'text'}
                        lastWord = nil
                        lastWordIndex = -1
                
                for chnk in chunks
                    
                    pushLastWord()
                    
                    for segIndex s in chnk.segl
                        
                        isUniko = ch -> 
                            ⮐  false if kstr.has '■▪◆●○▸➜⮐' ch 
                            ⮐  true if ch.len > 1
                            false
                        
                        m = string.match s PUNCT
                        if m
                
                            pushLastWord()
                            
                            turd = ''
                            
                            # write ◌c noon(chnk)
                            # write ◌m chnk.segl.class
                            
                            for t in chnk.segl∙slice(segIndex)∙each()
                
                                if string.match t PUNCT
                                    turd &= t
                                else
                                    break
                
                            clss = 'punct'
                
                            if isUniko s
                                clss = 'text unicode'
                            else
                                clss = 'punct' 
                                if [','';''{''}''('')']∙has(s)
                                    clss &= ' minor'
                
                            chnks.chunks∙push {start:kseg.widthAtSegi(segs chnk.index+segIndex) length:kseg.width(s) match:s turd:turd clss:clss}
                        else
                            if lastWord == nil
                                lastWord = []
                                lastWordIndex = chnk.index+segIndex
                
                            lastWord∙push s
                            
                pushLastWord()
                
                if chnks.chunks.len > 0
                    l = chnks.chunks[^1]
                    chnks.chars = l.start + l.len

    chunkd
    
###
000   000   0000000   000   000  0000000    000      00000000  00000000    0000000
000   000  000   000  0000  000  000   000  000      000       000   000  000
000000000  000000000  000 0 000  000   000  000      0000000   0000000    0000000
000   000  000   000  000  0000  000   000  000      000       000   000       000
000   000  000   000  000   000  0000000    0000000  00000000  000   000  0000000
###

extStack   = []
stack      = []
handl      = []
extTop     = {}
stackTop   = {}
notCode    = false # shortcut for top of stack not in codeTypes
topType    = ''
ext        = ''
chunk      = {}
chunkIndex = 1

#  0000000   0000000   00     00  00     00  00000000  000   000  000000000
# 000       000   000  000   000  000   000  000       0000  000     000
# 000       000   000  000000000  000000000  0000000   000 0 000     000
# 000       000   000  000 0 000  000 0 000  000       000  0000     000
#  0000000   0000000   000   000  000   000  00000000  000   000     000

fillComment = n ->

    for i in 0...n
        addValue i 'comment'
    if chunkIndex < line.chunks.len-n
        restChunks = line.chunks∙slice(chunkIndex+n)
        mightBeHeader = true
        for c in restChunks
            c.clss = 'comment'
            if mightBeHeader and not string.match(c.match HEADER)
                mightBeHeader = false
        if mightBeHeader
            for c in restChunks
                c.clss &= ' header'
    line.chunks.len - chunkIndex + n

hashComment = ->

    ⮐  if stackTop and topType != 'regexp triple'
    if stackTop and stackTop.lineno == line.number
        ⮐ # comments inside triple regexp only valid on internal lines?

    if chunk.match == "#"
        fillComment 1

noonComment = ->

    ⮐  if stackTop

    if chunk.match == "#" and chunkIndex == 0
        fillComment 1

slashComment = ->

    ⮐  if stackTop

    if kstr.startsWith chunk.turd "//"
        fillComment 2

blockComment = ->
    
    ⮐  if not chunk.turd or chunk.turd.len < 3

    typ = 'comment triple'

    ⮐  if topType and topType != 'interpolation' and topType != typ

    head = string.sub chunk.turd 1 3
    if head == '###'
        
        if topType == typ
            popStack()
        else
            pushStack {type:typ strong:true}
        ⮐  addAndJoinValues 3 typ

nimComment = ->
    
    ⮐  if not chunk.turd or chunk.turd.len < 2

    typ = 'comment triple'

    ⮐  if topType and topType != 'interpolation' and topType != typ

    head = string.sub chunk.turd 1 2
    if head == "#[" or heaad == "]#"
        
        if topType == typ
            popStack()
        else
            pushStack {type:typ strong:true}
        ⮐  addAndJoinValues 2 typ

luaComment = ->
    
    ⮐  if stackTop
    
    ⮐  if not chunk.turd or chunk.turd.len < 2

    if kstr.startsWith chunk.turd "--"
        fillComment 2
        ⮐  

    ⮐  if chunk.turd.len < 2

    typ = 'comment triple'

    # ⮐  if topType and topType not in ['interpolation' type]

    head = string.sub chunk.turd 1 4
    if head == "--[[" or head == "--]]"
        
        if topType == typ
            popStack()
        else
            pushStack {type:typ strong:true}
            
        ⮐  addAndJoinValues 4 typ
        
starComment = ->

    ⮐  if not chunk.turd

    typ = 'comment triple'

    ⮐  if topType and topType != typ

    if string.sub(chunk.turd 1 2) == '/*' and not topType
        pushStack {type:typ strong:true}
        ⮐  addValues 2 typ
    if string.sub(chunk.turd 1 2) == '*/' and topType == typ
        popStack()
        ⮐  addValues 2 typ

#  0000000   00000000    0000000    0000000  
# 000   000  000   000  000        000       
# 000000000  0000000    000  0000  0000000   
# 000   000  000   000  000   000       000  
# 000   000  000   000   0000000   0000000   

funcArgs = ->
    
    ⮐  if notCode
    ⮐  if not chunk.turd
    
    kturd = kseg(chunk.turd)
    if kturd[1] == '○' ➜ kturd∙shift()
    # turd = chunk.turd[0] == '○' ? chunk.turd[1..2] : chunk.turd[0..1]
    # if turd[0] in '=-' and turd[1] == '>'
    if (kturd[1] == '=' or kturd[1] == '-') and kturd[2] == '>'
        prev = getChunk(-1)
        ⮐  if prev and kstr.has(':)' prev.match)
        if ['text''dictionary key']∙has(line.chunks[1].clss) and kstr.has(':=' line.chunks[2].match)
            for ch in line.chunks∙slice(2 chunkIndex)∙each()
                if ['function call' 'text']∙has ch.clss
                    ch.clss = 'function argument'
    ⮐ 

#  0000000   00000000   00000000    0000000   000   000
# 000   000  000   000  000   000  000   000  000 0 000
# 000000000  0000000    0000000    000   000  000000000
# 000   000  000   000  000   000  000   000  000   000
# 000   000  000   000  000   000   0000000   00     00

dashArrow = ->

    ⮐  if notCode
    
    # log 'dashArrow' line.chunks
    # log 'dashArrow chunk' chunkIndex, chunk

    markFunc = ->
    
        if line.chunks[1].clss == 'text'
            if line.chunks[2].match == '=' and line.chunks[3].match != '>'
                line.chunks[1].clss = 'function'
                line.chunks[2].clss &= ' function'
            elif line.chunks[2].match == ':'
                line.chunks[1].clss = 'method'
                line.chunks[2].clss &= ' method'

    if chunk.turd
        
        if kstr.startsWith chunk.turd '○->'
            markFunc()
            addValue 0 'function async'
            addValue 1 'function tail'
            addValue 2 'function head'
            if line.chunks[1].clss == 'dictionary key' or line.chunks[1].turd and string.sub(line.chunks[1].turd 1 2) == '@:'
                line.chunks[1].clss = 'method'
                line.chunks[2].clss = 'punct method'
            elif line.chunks[1].match == '@' and line.chunks[2].clss == 'dictionary key'
                line.chunks[1].clss = 'punct method class'
                line.chunks[2].clss = 'method class'
                line.chunks[3].clss = 'punct method class'
            ⮐  3
            
        if kstr.startsWith chunk.turd '○=>'
            markFunc()
            addValue 0 'function bound async'
            addValue 1 'function bound tail'
            addValue 2 'function bound head'
            if line.chunks[1].clss == 'dictionary key'
                line.chunks[1].clss = 'method'
                line.chunks[2].clss = 'punct method'
            ⮐  3

        if kstr.startsWith chunk.turd '->'
            markFunc()
            if line.chunks[1].clss == 'dictionary key' or line.chunks[1].turd and string.sub(line.chunks[1].turd 1 2) == '@:'
                line.chunks[1].clss = 'method'
                line.chunks[2].clss = 'punct method'
            elif line.chunks[1].match == '@' and line.chunks[2].clss == 'dictionary key'
                line.chunks[1].clss = 'punct method class'
                line.chunks[2].clss = 'method class'
                line.chunks[3].clss = 'punct method class'
            ⮐  addAndJoinValues 2 'function'

        if kstr.startsWith chunk.turd '=>'
            markFunc()
            if line.chunks[1].clss == 'dictionary key'
                line.chunks[1].clss = 'method'
                line.chunks[2].clss = 'punct method'
            ⮐  addAndJoinValues 2 'function bound'

cppPointer = ->
    
    ⮐  if notCode
    
    if chunk.turd
        if kstr.startsWith chunk.turd '->'
            addValue 0 'arrow tail'
            addValue 1 'arrow head'
            ⮐  2
            
commentHeader = ->

    if topType == 'comment triple'
        if string.match chunk.match HEADER
            chunk.clss = 'comment triple header'
            ⮐  1

# 000   000   0000000   0000000    00000000  
# 000  000   000   000  000   000  000       
# 0000000    000   000  000   000  0000000   
# 000  000   000   000  000   000  000       
# 000   000   0000000   0000000    00000000  

kolorPunct = ->

    ⮐  if notCode
    
    if chunk.match == '◌'
        ⮐  addValue 0 'range'
        
kodePunct = ->

    ⮐  if notCode

    if chunk.match == '▸' or chunk.match == '➜'
        ⮐  addValue 0 'keyword'
        
    if chunk.match == '⮐'
        ⮐  addValue 0 'keyword return'

    next = getChunk 1
    if next
        
        if chunk.match == '○' and next.match != '-' and next.match != '='
            ⮐  addValue 0 'await'
            
        if ['==''!=''>=''<=']∙has chunk.turd
            addValue 0 'compare'
            addValue 1 'compare'
            ⮐  2

        if (chunk.match == '<' or chunk.match == '>') and not chunk.turd
            ⮐  addValue 0 'compare'
            
        if chunk.match == '◆'        
            if ['dir''file''main']∙has next.match
                addValue 0 'keyword'
                setValue 1 'keyword'
                ⮐  2
                
    prev = getChunk -1
    if prev
        
        if kstr.endsWith(prev.clss 'require') and chunk.match != '"'
            setValue 0 'punct require'
            ⮐  1

        if kstr.startsWith(chunk.turd '..') and prev.match != '.'
            if chunk.turd[2] != '.'
                ⮐  addValues 2 'range'
            if chunk.turd[3] != '.'
                ⮐  addValues 3 'range'

        if kstr.startsWith(prev.clss 'text') or prev.clss == 'property'

            prevEnd = prev.start+prev.len
            if chunk.match == '(' and prevEnd == chunk.start
                ⮐  thisCall()
            elif prevEnd < chunk.start # spaced
                prevPrev = getChunk(-2)
                if chunkIndex == 1 or prevPrev and ['⮐' '=' 'return']∙has(prevPrev.match)
                    if kstr.has '@[({"\'' chunk.match
                        ⮐  thisCall()
                    elif kstr.has '+-/' chunk.match
                        next = getChunk 1
                        if not next or next.match != '=' and next.start == chunk.start+1
                            ⮐  thisCall()

# 000   000   0000000   0000000    00000000  000   000   0000000   00000000   0000000    
# 000  000   000   000  000   000  000       000 0 000  000   000  000   000  000   000  
# 0000000    000   000  000   000  0000000   000000000  000   000  0000000    000   000  
# 000  000   000   000  000   000  000       000   000  000   000  000   000  000   000  
# 000   000   0000000   0000000    00000000  00     00   0000000   000   000  0000000    

kodeWord = ->

    ⮐  if notCode
        
    if chunk.match == 'use'
        if getChunk(1).start > chunk.start + chunk.len
            setValue 0 'keyword require'
            ⮐  1
        else
            setValue 0 'text'
            ⮐  0
            
    prev = getChunk -1
    if prev
        
        if prev.match == 'use'
            setValue 0 'require'
            ⮐  1

        if prev.match == '▸'
            if empty getChunk -2
                for c in line.chunks∙slice(chunkIndex)
                    c.clss = 'section'
                ⮐ line.chunks.len - chunkIndex
                
        if ['class' 'extends' 'function']∙has(prev.match)
            setValue 0 'class'
            ⮐  1
            
        if prev.match == 'is' and ['str''num''obj''arr''func''elem']∙has(chunk.match)
            setValue 0 'keyword'
            ⮐  1

        if kstr.startsWith chunk.clss 'keyword'

            ⮐  1 # we are done with the keyword

        if prev.match == '@'
            addValue -1 'this'
            addValue  0 'this'
            ⮐  1
            
        if kstr.endsWith prev.clss 'require'
            addValue 0 'require'
            if kstr.endsWith(prev.clss 'punct require') and kstr.has('▪◆●' prev.match)
                addValue 0 'string'
            elif chunkIndex == line.chunks.len-1
                addValue 0 'string'
            ⮐  1

        if kstr.endsWith prev.clss 'require string'
            addValue 0 'require string'
            ⮐  1
                                    
        if (kstr.startsWith(prev.clss 'text') or prev.clss == 'property') and prev.start+prev.len < chunk.start # spaced
            prevPrev = getChunk(-2)
            if chunkIndex == 1 or prevPrev and ['return' '=' '⮐']∙has(prevPrev.match)
                ⮐  thisCall()
            
#  0000000   0000000   00000000  00000000  00000000  00000000
# 000       000   000  000       000       000       000
# 000       000   000  000000    000000    0000000   0000000
# 000       000   000  000       000       000       000
#  0000000   0000000   000       000       00000000  00000000

thisCall = ->
    
    setValue -1 'function call'
    if getmatch(-2) == '@'
        setValue -2 'punct function call'
    0

coffeePunct = ->

    ⮐  if notCode

    if chunk.match == '▸'
        ⮐  addValue 0 'meta'

    if chunk.turd == '~>'
        ⮐  addValues 2 'meta'
        
    prev = getChunk -1
    if prev

        if kstr.startsWith(chunk.turd '..') and prev.match != '.'
            if chunk.turd[2] != '.'
                ⮐  addValues 2 'range'
            if chunk.turd[3] != '.'
                ⮐  addValues 3 'range'

        if kstr.startsWith(prev.clss 'text') or prev.clss == 'property'

            prevEnd = prev.start+prev.len
            if chunk.match == '(' and prevEnd == chunk.start
                ⮐  thisCall()
            elif prevEnd < chunk.start # spaced
                if kstr.has '@[({"\'' chunk.match
                    ⮐  thisCall()
                elif kstr.has '+-/' chunk.match
                    next = getChunk 1
                    if not next or next.match != '=' and next.start == chunk.start+1
                        ⮐  thisCall()

coffeeWord = ->

    ⮐  if notCode

    prev = getChunk -1
    if prev

        if prev.clss == 'punct meta'
            if chunk.start == prev.start+1
                setValue 0 'meta'
                ⮐ 0 # give switch a chance

        if prev.match == 'class' or prev.match == 'extends'
            setValue 0 'class'
            ⮐  1

        if kstr.startsWith chunk.clss 'keyword'

            ⮐  1 # we are done with the keyword

        if prev.match == '@'
            addValue -1 'this'
            addValue  0 'this'
            ⮐  1

        if (kstr.startsWith(prev.clss 'text') or prev.clss == 'property') and prev.start+prev.len < chunk.start # spaced
            ⮐ thisCall()

property = ->

    ⮐  if notCode

    if kstr.has ".∙" getmatch(-1)

        prevPrev = getChunk -2

        if not prevPrev or not kstr.has(".∙" prevPrev.match)
            setValue -1 'punct property'
            setValue 0 'property'
            if prevPrev
                if not ['property' 'number']∙has(prevPrev.clss) and not kstr.startsWith(prevPrev.clss 'punct')
                    setValue -2 'obj'
            ⮐  1

cppWord = ->

    ⮐  if notCode
    
    p = property()
    
    if p then ⮐  p
    prevPrev = getChunk(-2)
    if prevPrev and prevPrev.turd == '::'

        prevPrevPrev = getChunk -3
        if prevPrevPrev
            setValue -3 'punct obj'
            addValue -2 'obj'
            addValue -1 'obj'
            setValue  0 'method'
            ⮐  1

    if getmatch(-1) == '<' and kstr.has(',>' getmatch(1)) or getmatch(1) == '>' and getmatch(-1) == ','

        setValue -1 'punct template'
        setValue  0 'template'
        setValue  1 'punct template'
        ⮐  2

    if chunk.match[1] and string.match(chunk.match[1] "[A-Z]")
        switch chunk.match[0]
            'T'
                if getmatch(1) == '<'
                    setValue 0 'keyword type'
                    ⮐  1

            'F'
                setValue 0 'struct'
                ⮐  1

            'A' 'U'
                setValue 0 'obj'
                ⮐  1

    if chunk.clss == 'text' and getmatch(1) == '('
        setValue 0 'function call'
        ⮐  1

# 000   000   0000000    0000000   000   000
# 0000  000  000   000  000   000  0000  000
# 000 0 000  000   000  000   000  000 0 000
# 000  0000  000   000  000   000  000  0000
# 000   000   0000000    0000000   000   000

noonProp = ->

    prev = getChunk -1
    if prev

        if prev.start+prev.len+1 < chunk.start
            if prev.clss != 'obj'
                i = chunkIndex-1
                while i >= 1
                    if i < chunkIndex-1 and line.chunks[i].start+line.chunks[i].len+1 < line.chunks[i+1].start
                        break
                    if line.chunks[i].clss == 'text' or line.chunks[i].clss == 'obj'
                        line.chunks[i].clss = 'property'
                        i -= 1
                    elif line.chunks[i].clss == 'punct'
                        line.chunks[i].clss = 'punct property'
                        i -= 1
                    else
                        break
        elif prev.clss == 'obj'
            setValue 0 'obj'
            ⮐  1
    0

noonPunct = ->

    noonProp()

noonWord = ->

    if chunk.start == 0
    
        setValue 0 'obj'
        ⮐  1

    noonProp()

# 000   000  00000000   000
# 000   000  000   000  000
# 000   000  0000000    000
# 000   000  000   000  000
#  0000000   000   000  0000000

urlPunct = ->

    prev = getChunk -1
    if prev
        if chunk.turd == '://'
            if getmatch(4) == '.' and getChunk(5)
                setValue -1 'url protocol'
                addValues 3 'url'
                setValue  3 'url domain'
                setValue  4 'punct url tld'
                setValue  5 'url tld'
                ⮐  6

        if chunk.match == '.'
            if not kstr.startsWith(prev.clss 'number') and prev.clss != 'semver' and not kstr.has('\\./' prev.match) and not string.match(prev.match "%d+") and empty topType
                next = getChunk 1
                if next
                    if next.start == chunk.start+chunk.len
                        fileext = next.match
                        if not kstr.has '\\./*+' fileext
                            setValue -1 'file_'+fileext
                            setValue  0 'file_punct_'+fileext
                            setValue  1 'file_ext_'+fileext
                            ⮐  2

        if chunk.match == '/'

            for i in chunkIndex..0
                break if line.chunks[i].start+line.chunks[i].len < line.chunks[i+1].start
                break if kstr.endsWith line.chunks[i].clss 'dir'
                break if kstr.startsWith line.chunks[i].clss 'url'
                break if line.chunks[i].match == '"'
                if kstr.startsWith line.chunks[i].clss 'punct'
                    line.chunks[i].clss = 'punct dir'
                else
                    line.chunks[i].clss = 'text dir'

            ⮐  1
    0

urlWord = ->

    prev = getChunk -1
    if prev
        if prev.match == '\\' or prev.match == '/'
            next = getChunk 1
            if not next or next.start > chunk.start+chunk.len or not kstr.has('\\./' next.match)
                addValue 0, 'file'

#       000   0000000
#       000  000
#       000  0000000
# 000   000       000
#  0000000   0000000

jsPunct = ->

    ⮐  if notCode

    prev = getChunk -1
    if prev
        if chunk.match == '('
            if kstr.startsWith(prev.clss 'text') or prev.clss == 'property'
                setValue -1 'function call'
                ⮐  1

jsWord = ->

    if chunk.clss == 'keyword function'
        if getmatch(-1) == '=' and kstr.startsWith(getValue(-2) 'text')
            setValue -2 'function'
    0

dictionary = ->

    ⮐  if notCode

    if chunk.match == ':' and not kstr.startsWith(chunk.turd '::')
        prev = getChunk -1
        if prev
            if ['string' 'number' 'text' 'keyword']∙has(kstr.split(prev.clss ' ')[1])
                setValue -1 'dictionary key'
                setValue  0 'punct dictionary'
                ⮐  1
            if prev.match == '*' and ['text' 'keyword']∙has(kstr.split(getChunk(-2).clss ' ')[1])
                setValue -1 'dictionary key'
                setValue -2 'dictionary key'
                setValue  0 'punct dictionary'
                ⮐  1

#       000   0000000   0000000   000   000
#       000  000       000   000  0000  000
#       000  0000000   000   000  000 0 000
# 000   000       000  000   000  000  0000
#  0000000   0000000    0000000   000   000

jsonPunct = ->

    ⮐  if notCode

    if chunk.match == ':'
        prev = getChunk -1
        if prev
            if prev.match == '"'
                for i in max(0 chunkIndex-2)..0
                    if line.chunks[i].clss == 'punct string double'
                        line.chunks[i].clss = 'punct dictionary'
                        break
                    line.chunks[i].clss = 'dictionary key' if line.chunks[i]
                setValue -1 'punct dictionary'
                setValue  0 'punct dictionary'
                ⮐  1

jsonWord = ->

    prev = getChunk -1
    if prev and (topType == 'string double' or topType == 'string single')
        if kstr.has '"^~=' prev.match
            if string.match(getmatch(0) NUMBER) and getmatch(1) == '.' and string.match(getmatch(2) NUMBER) and getmatch(3) == '.' and string.match(getmatch(4) NUMBER)
                if kstr.has '^~=' prev.match
                    setValue -1 'punct semver' 
                    if getmatch(-2) == '>'
                        setValue -2 'punct semver' 
                setValue 0 'semver'
                setValue 1 'punct semver'
                setValue 2 'semver'
                setValue 3 'punct semver'
                setValue 4 'semver'
                ⮐  5

# 00000000   00000000   0000000   00000000  000   000  00000000
# 000   000  000       000        000        000 000   000   000
# 0000000    0000000   000  0000  0000000     00000    00000000
# 000   000  000       000   000  000        000 000   000
# 000   000  00000000   0000000   00000000  000   000  000

kescape = ->

    if chunk.match == '\\' and (kstr.startsWith(topType 'regexp') or kstr.startsWith(topType 'string'))
        if chunkIndex == 0 or not getChunk(-1).escape
            if getChunk(1).start == chunk.start+1
                chunk.escape = true
                addValue 0 'escape'
                
                if topType == 'string single' and getChunk(1).match == "'"
                    setValue 0 topType
                    ⮐  1
                if topType == 'string double' and getChunk(1).match == '"'
                    setValue 0 topType
                    ⮐  1
                ⮐  stacked()
    0

regexp = ->

    ⮐  if kstr.startsWith topType 'string'

    prev = getChunk(-1)
    if prev and prev.escape then ⮐  stacked()

    if chunk.match == '/'

        if topType == 'regexp'
            chunk.clss &= ' regexp end'
            popStack()
            ⮐  1

        if chunkIndex
            prev = getChunk -1
            next = getChunk +1
            if not kstr.startsWith(prev.clss 'punct') and not kstr.startsWith(prev.clss 'keyword') or kstr.has(")]" prev.match)
                ⮐  if (prev.start+prev.len <  chunk.start) and next.start >  chunk.start+1
                ⮐  if (prev.start+prev.len == chunk.start) and next.start == chunk.start+1

            ⮐  if next.match == '='
            ⮐  if kstr.startsWith prev.clss 'number'

        pushStack {type:'regexp'}
        ⮐  addValue 0 'regexp start'

    kescape()

tripleRegexp = ->

    ⮐  if not chunk.turd or chunk.turd.len < 3

    typ = 'regexp triple'

    ⮐  if topType and topType != 'interpolation' and topType != typ
    if string.sub(chunk.turd 1 3) == '///'
        if topType == typ
            popStack()
        else
            pushStack {type:typ, lineno:line.number}
        ⮐  addValues 3 typ

#  0000000  000000000  00000000   000  000   000   0000000
# 000          000     000   000  000  0000  000  000
# 0000000      000     0000000    000  000 0 000  000  0000
#      000     000     000   000  000  000  0000  000   000
# 0000000      000     000   000  000  000   000   0000000

simpleString = ->

    ⮐  if topType == 'regexp'
    
    prev = getChunk(-1)
    if prev and prev.escape then ⮐  stacked()
    
    if kstr.has '`"\'' chunk.match

        typ = switch chunk.match
            '`' ➜ 'string double'
            '"' ➜ 'string double'
            "'" ➜ 'string single'

        if chunk.match == "'"
            next = getChunk 1
            
            if next and ['s' 'd' 't' 'll' 're']∙has next.match
                if next.start == chunk.start + chunk.len
                    scnd = getChunk 2
                    if not scnd or scnd.match != "'"
                        ⮐  stacked()
        
        if chunk.clss == 'punct code triple'
            ⮐  0
                        
        if topType == typ
            addValue 0 typ
            popStack()
            ⮐  1
        elif notCode
            if topType == "string double nsstring"
                addValue  0 topType
                popStack()
                ⮐  1
            else
                ⮐  stacked()

        pushStack {strong:true type:typ}
        addValue 0 typ
        ⮐  1
        
    kescape()

tripleString = ->

    ⮐  if not chunk.turd or chunk.turd.len < 3
    ⮐  if ['regexp''string single''string double']∙has topType

    prev = getChunk(-1)
    if prev and prev.escape ➜ ⮐  stacked()

    if string.sub(chunk.turd 1 3) == '"""'
        typ = 'string triple'
        ⮐  if typ != topType and kstr.startsWith(topType 'string')

        if topType == typ
            popStack()
        else
            pushStack {strong:true type:typ}

        ⮐  addValues 3 typ

    kescape()
    
luaString = ->

    ⮐  if not chunk.turd or chunk.turd.len < 2
    ⮐  if ['regexp''string single''string double']∙has topType

    prev = getChunk(-1)
    if prev and prev.escape then ⮐  stacked()

    head = string.sub(chunk.turd 1 2)
    typ = switch head
        '[[' ➜ 'string triple'
        ']]' ➜ 'string triple'

    if typ

        ⮐  if typ != topType and kstr.startsWith(topType 'string')

        if topType == typ
            popStack()
        else
            pushStack {strong:true type:typ}

        ⮐  addValues 2 typ

    kescape()

# 000   000  000   000  00     00  0000000    00000000  00000000
# 0000  000  000   000  000   000  000   000  000       000   000
# 000 0 000  000   000  000000000  0000000    0000000   0000000
# 000  0000  000   000  000 0 000  000   000  000       000   000
# 000   000   0000000   000   000  0000000    00000000  000   000

number = ->

    ⮐  0 if kstr.startsWith topType 'string'

    if string.match chunk.match NUMBER
        prev = getmatch(-1)
        if prev == '.'

            if getValue(-4) == 'number float' and getValue(-2) == 'number float'
                if kstr.has '^~=' getmatch(-5)
                    setValue -5 'punct semver' 
                    if getmatch(-6) == '>'
                        setValue -6 'punct semver' 
                setValue -4 'semver'
                setValue -3 'punct semver'
                setValue -2 'semver'
                setValue -1 'punct semver'
                setValue  0 'semver'
                ⮐  1

            if getValue(-2) == 'number'
                setValue -2 'number float'
                setValue -1 'punct number float'
                setValue  0 'number float'
                ⮐  1
                
        if prev == '#'
            chunk.clss = 'number hex'
        else
            chunk.clss = 'number'
        ⮐  1

    if string.match chunk.match HEXNUM

        chunk.clss = 'number hex'
        ⮐  1
        
    if string.match chunk.match HEX
        if getmatch(-1) == '#'
            chunk.clss = 'number hex'
            ⮐  1

# 00000000  000       0000000    0000000   000000000
# 000       000      000   000  000   000     000
# 000000    000      000   000  000000000     000
# 000       000      000   000  000   000     000
# 000       0000000   0000000   000   000     000

float = ->

    if string.match chunk.match FLOAT
        if getmatch(-1) == '.'

            if getValue(-2) == 'number'
                setValue -2 'number float'
                addValue -1 'number float'
                setValue  0 'number float'
                ⮐  1

        chunk.clss = 'number float'
        ⮐  1

#  0000000   0000000   0000000
# 000       000       000
# 000       0000000   0000000
# 000            000       000
#  0000000  0000000   0000000

cssWord = ->

    tail2 = string.sub(chunk.match chunk.match.len-1 chunk.match.len)
    head2 = string.sub(chunk.match 1 chunk.match.len-2)
    
    if ['px''em''ex']∙has(tail2) and string.match(head2 NUMBER)
        setValue 0 'number'
        ⮐  1

    tail1 = string.sub(chunk.match chunk.match.len chunk.match.len)
    head1 = string.sub(chunk.match 1 chunk.match.len-1)

    if tail1 == 's' and string.match(head1 NUMBER)
        setValue 0 'number'
        ⮐  1

    prev = getChunk -1
    if prev

        if prev.match == '.' and getChunk(-2).clss != 'number' and empty topType
            addValue -1 'class'
            setValue  0 'class'
            ⮐  1

        if prev.match == "#"

            if chunk.match.len == 3 or chunk.match.len == 6
                if string.match chunk.match HEX
                    addValue -1 'number hex'
                    setValue  0 'number hex'
                    ⮐  1

            addValue -1 'function'
            setValue  0 'function'
            ⮐  1

        if prev.match == '-'
            prevPrev = getChunk -2
            if prevPrev
                if prevPrev.clss == 'class' or prevPrev.clss == 'function'
                    addValue -1 prevPrev.clss
                    setValue  0 prevPrev.clss
                    ⮐  1

# 00     00  0000000
# 000   000  000   000
# 000000000  000   000
# 000 0 000  000   000
# 000   000  0000000

mdPunct = ->

    if chunkIndex == 0

        if chunk.turd.len <= 1 and kstr.has('-*' chunk.match) and getChunk(1).start > chunk.start+1
            typ = ['li1''li2''li3''li4''li5'][int(chunk.start/4)+1]
            pushStack {merge:true fill:true type:typ}
            ⮐  addValue 0 typ & ' marker'

        if chunk.match == '#'
            switch chunk.turd
                '#'
                    pushStack {merge:true fill:true type:'h1'}
                    ⮐  addValue 0 'h1'
                '##'
                    pushStack {merge:true fill:true type:'h2'}
                    ⮐  addValues 2 'h2'
                '###'
                    pushStack {merge:true fill:true type:'h3'}
                    ⮐  addValues 3 'h3'
                '####'
                    pushStack {merge:true fill:true type:'h4'}
                    ⮐  addValues 4 'h4'
                '#####'
                    pushStack {merge:true fill:true type:'h5'}
                    ⮐  addValues 5 'h5'

    if chunk.match == '*'

        if string.sub(chunk.turd 1 2) == '**'

            typ = 'bold'
            if kstr.endsWith topType typ
                addValues 2 topType
                popStack()
                ⮐  2

            if stackTop and stackTop.merge
                typ = stackTop.type & ' ' & typ 
            pushStack {merge:true type:typ}
            ⮐  addValues 2 typ

        typ = 'italic'
        if kstr.endsWith topType typ
            addValue 0 topType
            popStack()
            ⮐  1

        if stackTop and stackTop.merge
            typ = stackTop.type & ' ' & typ
        pushStack {merge:true type:typ}
        addValue 0 typ
        ⮐  1

    if chunk.match == '`'

        if string.sub(chunk.turd 1 3) == '```'

            typ = 'code triple'

            if ['coffeescript''javascript''js']∙has getmatch(3)
                setValue 3 'comment'
                ⮐  addValues 3 typ

            pushStack {weak:true type:typ}
            ⮐  addValues 3 typ

        typ = 'code'
        if kstr.endsWith topType typ
            addValue 0 topType
            popStack()
            ⮐  1

        if stackTop and stackTop.merge
            typ = stackTop.type & ' ' & typ 

        pushStack {merge:true type:typ}
        ⮐  addValue 0 typ

# 000  000   000  000000000  00000000  00000000   00000000    0000000   000
# 000  0000  000     000     000       000   000  000   000  000   000  000
# 000  000 0 000     000     0000000   0000000    00000000   000   000  000
# 000  000  0000     000     000       000   000  000        000   000  000
# 000  000   000     000     00000000  000   000  000         0000000   0000000

interpolation = ->

    if kstr.startsWith topType 'string double'

        if string.sub(chunk.turd 1 1) == "#" and string.sub(chunk.turd 1 1) == "{"
            pushStack {type:'interpolation' weak:true}
            setValue 0 'punct string interpolation'
            setValue 1 'punct string interpolation'
            ⮐  2

    elif topType == 'interpolation'

        if chunk.match == '}'
            setValue 0 'punct string interpolation'
            popStack()
            ⮐  1

# 000   000  00000000  000   000  000   000   0000000   00000000   0000000
# 000  000   000        000 000   000 0 000  000   000  000   000  000   000
# 0000000    0000000     00000    000000000  000   000  0000000    000   000
# 000  000   000          000     000   000  000   000  000   000  000   000
# 000   000  00000000     000     00     00   0000000   000   000  0000000

spaced = -> 

    prev = getChunk(-1)
    if prev
        ⮐  prev.start + prev.len < chunk.start
    false

keyword = ->

    ⮐  if notCode

    ⮐  if not extlang.lang[ext]

    prev = getChunk(-1)

    if extlang.lang[ext][chunk.match] and (not prev or (prev.match != '.' and (spaced() or ['@''[']∙has(prev.match) or (prev.clss != 'punct'))))
        chunk.clss = extlang.lang[ext][chunk.match]
        ⮐ 

# 000   000  00     00  000
#  000 000   000   000  000
#   00000    000000000  000
#  000 000   000 0 000  000
# 000   000  000   000  0000000

xmlPunct = ->

    if chunk.turd == '</'
        ⮐  addValues 2 'keyword'

    if chunk.match == '<' or chunk.match == '>'
        ⮐  addValue 0 'keyword'

#  0000000  00000000   00000000
# 000       000   000  000   000
# 000       00000000   00000000
# 000       000        000
#  0000000  000        000

cppMacro = ->

    if chunk.match == "#"
        addValue 0 'define'
        setValue 1 'define'
        ⮐  2

# 00     00  00     00  
# 000   000  000   000  
# 000000000  000000000  
# 000 0 000  000 0 000  
# 000   000  000   000  

mmMacro = ->

    if chunk.match == "@"
        addValue 0 'define'
        setValue 1 'define'
        ⮐  2
        
mmString = ->
    
    ⮐  if not chunk.turd or chunk.turd.len < 2
    
    typ = 'string double nsstring'
    
    if string.sub(chunk.turd 1 2) == '@"'

        pushStack {strong:true merge:true type:typ}

        ⮐  addValues 2 typ

#  0000000  000   000
# 000       000   000
# 0000000   000000000
#      000  000   000
# 0000000   000   000

shPunct = ->

    ⮐  if notCode

    if chunk.match == '/' and getChunk(-1).start + getChunk(-1).len == chunk.start
        ⮐  addValue -1 'dir'

    if chunk.turd == '--' and getChunk(2).start == chunk.start+2 and getChunk(-1).start+getChunk(-1).len < chunk.start
        addValue 0 'argument'
        addValue 1 'argument'
        setValue 2 'argument'
        ⮐  3

    if chunk.match == '-' and getChunk(1).start == chunk.start+1 and getChunk(-1).start+getChunk(-1).len < chunk.start
        addValue 0 'argument'
        setValue 1 'argument'
        ⮐  2
        
    if chunk.match == '~' and (not getChunk(-1) or getChunk(-1).start + getChunk(-1).len < chunk.start)
        setValue 0 'text dir'
        ⮐  1

#  0000000  000000000   0000000    0000000  000   000
# 000          000     000   000  000       000  000
# 0000000      000     000000000  000       0000000
#      000     000     000   000  000       000  000
# 0000000      000     000   000   0000000  000   000

stacked = ->

    if stackTop
        ⮐  if stackTop.weak
        if stackTop.strong
            chunk.clss = topType
        else
            chunk.clss &= ' ' & topType
        ⮐  1
    0

pushExt = (mtch) ->
    extTop = {switch:mtch, start:line, stack:stack}
    extStack∙push extTop

actExt = ->
    stack    = []
    stackTop = nil
    topType  = ''
    notCode  = false

popExt = ->
    stack = extTop.stack
    line.ext = extTop.start.ext
    extStack∙pop()
    extTop = extStack[^1]

    stackTop = stack[^1]
    topType = stackTop.type
    notCode = stackTop and not codeTypes∙has(topType)

pushStack = o ->
    stack∙push o
    stackTop = o
    topType = o.type
    notCode = not codeTypes∙has(topType)

popStack = ->
    stack∙pop()
    stackTop = stack[^1]
    if stackTop
        topType = stackTop.type
        notCode = not codeTypes∙has(topType)
    else
        topType = ''
        notCode = false

getChunk = d ->
 
    if line
        ⮐  line.chunks[chunkIndex+d]
    
setValue = d value -> 

    if line
        if 1 <= chunkIndex+d and chunkIndex+d <= line.chunks.len 
            line.chunks[chunkIndex+d].clss = value
        
getValue = d -> 
    chnk = getChunk(d)
    if chnk
        chnk.clss or ''
    
getmatch = d -> 
    chnk = getChunk(d)
    if chnk
        chnk.match 

addValue = d value ->
    if line
        if 1 <= chunkIndex+d and chunkIndex+d <= line.chunks.len
            line.chunks[chunkIndex+d].clss &= ' ' & value
    1

addValues = n value ->
    for i in 0...n
        addValue i value
    n
    
addAndJoinValues = n value ->

    line.chunks[chunkIndex].clss &= ' ' & value
    for i in 1...n
        line.chunks[chunkIndex].match &= line.chunks[chunkIndex+i].match
        line.chunks[chunkIndex]["length"] += 1
    line.chunks∙splice chunkIndex+1 n-1
    1

handlers = {
    coffee: {
            punct:[ blockComment hashComment tripleRegexp coffeePunct tripleString simpleString interpolation dashArrow regexp dictionary ]
            word: [ keyword coffeeWord number property ] }
    kode:   {
            punct:[ blockComment hashComment tripleRegexp kodePunct tripleString simpleString interpolation funcArgs dashArrow regexp dictionary ]
            word: [ keyword kodeWord number property ] }
    kim:    {
            punct:[ blockComment hashComment kodePunct tripleString interpolation simpleString funcArgs dashArrow dictionary ]
            word: [ keyword kodeWord number property] }
    kua:    {
            punct:[ blockComment hashComment kodePunct kolorPunct tripleString interpolation simpleString funcArgs dashArrow dictionary ]
            word: [ keyword kodeWord number property] }
    nim:   {punct:[ nimComment   hashComment simpleString funcArgs dashArrow                ] word:[ keyword number property        ]}
    lua:   {punct:[ luaComment   simpleString luaString funcArgs dashArrow                  ] word:[ keyword number property        ]}
    noon:  {punct:[ noonComment  noonPunct urlPunct                                         ] word:[ noonWord urlWord number        ]}
    js:    {punct:[ starComment  slashComment jsPunct simpleString dashArrow regexp dictionary ] word:[ keyword jsWord number property ]}
    ts:    {punct:[ starComment  slashComment jsPunct simpleString dashArrow regexp dictionary ] word:[ keyword jsWord number property ]}
    iss:   {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword number                 ]}
    ini:   {punct:[ starComment  slashComment simpleString cppMacro cppPointer              ] word:[         number                 ]}
    cpp:   {punct:[ starComment  slashComment simpleString cppMacro cppPointer              ] word:[ keyword number float cppWord   ]}
    mm:    {punct:[ starComment  slashComment simpleString cppPointer                       ] word:[ keyword number float cppWord   ]}
    zig:   {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword number float cppWord   ]}
    frag:  {punct:[ starComment  slashComment simpleString cppMacro cppPointer              ] word:[ keyword number float cppWord   ]}
    vert:  {punct:[ starComment  slashComment simpleString cppMacro cppPointer              ] word:[ keyword number float cppWord   ]}
    hpp:   {punct:[ starComment  slashComment simpleString cppMacro cppPointer              ] word:[ keyword number float cppWord   ]}
    c:     {punct:[ starComment  slashComment simpleString cppMacro cppPointer              ] word:[ keyword number float cppWord   ]}
    h:     {punct:[ starComment  slashComment simpleString cppMacro cppPointer              ] word:[ keyword number float cppWord   ]}
    cs:    {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword number                 ]}
    pug:   {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword cssWord number         ]}
    styl:  {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword cssWord number         ]}
    css:   {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword cssWord number         ]}
    sass:  {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword cssWord number         ]}
    scss:  {punct:[ starComment  slashComment simpleString                                  ] word:[ keyword cssWord number         ]}
    swift: {punct:[ starComment  slashComment simpleString dictionary                       ] word:[ keyword number property        ]}
    svg:   {punct:[              simpleString xmlPunct                                      ] word:[ keyword number                 ]}
    html:  {punct:[              simpleString xmlPunct                                      ] word:[ keyword number                 ]}
    htm:   {punct:[              simpleString xmlPunct                                      ] word:[ keyword number                 ]}
    xml:   {punct:[              simpleString xmlPunct                                      ] word:[ number                         ]}
    sh:    {punct:[ hashComment  simpleString urlPunct shPunct                              ] word:[ keyword urlWord number         ]}
    json:  {punct:[              simpleString jsonPunct urlPunct                            ] word:[ keyword jsonWord urlWord number ]}
    yml:   {punct:[ hashComment  simpleString urlPunct shPunct dictionary                   ] word:[ keyword jsonWord urlWord number property ]}
    yaml:  {punct:[ hashComment  simpleString urlPunct shPunct dictionary                   ] word:[ keyword jsonWord urlWord number property ]}
    log:   {punct:[              simpleString urlPunct dictionary                           ] word:[ urlWord number                 ]}
    md:    {punct:[                   mdPunct urlPunct xmlPunct                             ] word:[ urlWord number                 ]}
    fish:  {punct:[              hashComment simpleString                                   ] word:[ keyword number                 ]}
    py:    {punct:[              hashComment simpleString                                   ] word:[ keyword number                 ]}
    }
    
for ext in extlang.exts
    if not handlers[ext]
        handlers[ext] = {punct:[ simpleString ] word:[ number ]}

for ext obj of handlers
    handlers[ext].punct∙push stacked
    handlers[ext].word∙push stacked

###
0000000    000       0000000    0000000  000   000  00000000  0000000
000   000  000      000   000  000       000  000   000       000   000
0000000    000      000   000  000       0000000    0000000   000   000
000   000  000      000   000  000       000  000   000       000   000
0000000    0000000   0000000    0000000  000   000  00000000  0000000

    lines: array of chunked lines

    returns lines with
    - 'ext' switched in some lines
    - 'value' changed in chunks that match language patterns
###

blocked = lines ->

    extStack   = []
    stack      = []
    handl      = []
    extTop     = nil
    stackTop   = nil
    notCode    = false # shortcut for top of stack not in codeTypes
    topType    = ''
    ext        = ''
    chunk      = nil
    chunkIndex = 1
    
    # 000      000  000   000  00000000   0000000
    # 000      000  0000  000  000       000
    # 000      000  000 0 000  0000000   0000000
    # 000      000  000  0000  000            000
    # 0000000  000  000   000  00000000  0000000

    # write "BLOCKED LINES " lines
    for l in lines
        # write "BLOCKED L " l
        _G.line = l
        # write "BLOCKED LINE " _G.line
        # write "BLOCKED LINE " line
    
        if not line
            write ◌r "DAFUK? NOLINE"

        continue = false
        if stackTop

            if stackTop.type == 'comment triple'

                mightBeHeader = true
                for chunk in line.chunks
                    if not string.match chunk.match HEADER
                        mightBeHeader = false
                        break
                if mightBeHeader
                    for chunk in line.chunks
                        chunk.clss = 'comment triple header'
                    continue = true

            if not continue
                if stackTop.fill then popStack()

        if not continue
            if extTop
                if extTop.switch.indent and line.chunks[1].start <= extTop.start.chunks[1].start
                    popExt()                        # end of extension block reached that is terminated by indentation
                else
                    line.ext = extTop.switch.to     # make sure the current line ext matches the topmost from stack
            
            if ext != line.ext                      # either at start of file or we switched extension
                actExt()
                ext = line.ext
                handl = handlers[ext]               # install new handlers
                # ▴ handl
                if not handl
                    write ◌r 'no handl? ext ' ◌y ext
                    write ◌r 'no handl? ext ' ◌g line.ext
                    write ◌r 'no handl? line ' ◌y line
                    write ◌r 'no handl? handl ' ◌y handlers[ext]
            
            #  0000000  000   000  000   000  000   000  000   000   0000000
            # 000       000   000  000   000  0000  000  000  000   000
            # 000       000000000  000   000  000 0 000  0000000    0000000
            # 000       000   000  000   000  000  0000  000  000        000
            #  0000000  000   000   0000000   000   000  000   000  0000000
            
            chunkIndex = 1
            while chunkIndex <= line.chunks.len
            
                chunk = line.chunks[chunkIndex]
            
                beforeIndex = chunkIndex
            
                if kstr.startsWith chunk.clss 'punct'
            
                    if extTop
                        if extTop.switch.ende and extTop.switch.ende == chunk.turd
                            if extTop.switch.add
                                addValues chunk.turd.len extTop.switch.add 
                            popExt() # end of extension block reached that is terminated by turd
            
                    for idx hnd in handl.punct
                        advance = hnd()
                        if advance is "string"
                            write ◌r "STRING ADVANCE #{ext} |#{advance}| " idx " " hnd
                        if advance and advance != 0
                            chunkIndex += advance
                            break
            
                else # words, numbers
            
                    #if not notCode
                    #    if mtch = swtch[line.ext]?[chunk.match]
                    #        if mtch.turd
                    #            turdChunk = getChunk -mtch.turd.len
                    #            if mtch.turd == (turdChunk.turd ? turdChunk.match)
                    #                # push a new extension onto the stack, ext will change on start of next line
                    #                pushExt mtch
                    #        elif mtch.next and getChunk(1).match == mtch.next
                    #            pushExt mtch
                    
                    for hnd in handl.word
                        advance = hnd()
                        if advance is "string"
                            write ◌r "STRING ADVANCE " hnd
                        if advance and advance != 0
                            chunkIndex += advance
                            break
            
                if chunkIndex == beforeIndex
                    chunkIndex += 1
    lines
        
# 00000000    0000000   00000000    0000000  00000000  
# 000   000  000   000  000   000  000       000       
# 00000000   000000000  0000000    0000000   0000000   
# 000        000   000  000   000       000  000       
# 000        000   000  000   000  0000000   00000000  

parse = segls ext='kode' -> 

    lines = chunked(segls ext)
    # write "PARSE " lines
    # write "PARSE " line    
    blocked(lines)

# 000   000   0000000   000       0000000   00000000   000  0000000  00000000  
# 000  000   000   000  000      000   000  000   000  000     000   000       
# 0000000    000   000  000      000   000  0000000    000    000    0000000   
# 000  000   000   000  000      000   000  000   000  000   000     000       
# 000   000   0000000   0000000   0000000   000   000  000  0000000  00000000  

kolorize = chunk -> 
    
    cn = kolor.map[chunk.clss]
    if cn
        if cn is array
            v = chunk.match
            for cr in cn
                v = kolor[cr](v)
            ⮐  v
        else
            ⮐  kolor[cn](chunk.match)
            
    if kstr.endsWith chunk.clss 'file'
        w8 chunk.match
    elif kstr.endsWith chunk.clss 'ext'
        w3 chunk.match
    elif kstr.startsWith chunk.clss 'punct'
        if string.match chunk.clss LI
            kolorize {match:chunk.match, clss:chunk.clss.replace(LI ' ')}
        else
            w2 chunk.match
    else
        if string.match chunk.clss LI
            kolorize {match:chunk.match, clss:chunk.clss.replace(LI ' ')}
        else
            chunk.match

kolorizeChunks = chunks=[] ->
    
    clrzd = ''
    c = 1
    for i in 1..chunks.len
        while c < chunks[i].start 
            clrzd &= ' '
            c += 1
        clrzd &= kolorize chunks[i]
        c += chunks[i].len
    clrzd
            
#  0000000  000   000  000   000  000000000   0000000   000   000  
# 000        000 000   0000  000     000     000   000   000 000   
# 0000000     00000    000 0 000     000     000000000    00000    
#      000     000     000  0000     000     000   000   000 000   
# 0000000      000     000   000     000     000   000  000   000  

syntax = arg ->
    
    arg ?= {}
    text = arg.text
    ext  = arg.ext or 'coffee'

    lines = kstr.lines text
    rngs  = parse(lines ext)∙map((l) -> l.chunks)
    
    clines = []
    for index in 0...lines.len
        if ext == 'js' and kstr.startsWith(lines[index] '//# source')
            _ = nil
        else
            clines∙push kolorizeChunks(rngs[index])
    clines.join '\n'
    
# 0000000    000   0000000   0000000  00000000   0000000  000000000  
# 000   000  000  000       000       000       000          000     
# 000   000  000  0000000   0000000   0000000   000          000     
# 000   000  000       000       000  000       000          000     
# 0000000    000  0000000   0000000   00000000   0000000     000     

dissect = segls ext='kode' ->
    
    ⮐  [] if empty segls

    segls = kseg.segls segls
    parse(segls ext)∙map((l) -> l.chunks)
    
ranges = str ext='kode' ->
    
    parse([kseg(str)] ext)[1].chunks

# 00000000  000   000  00000000    0000000   00000000   000000000   0000000  
# 000        000 000   000   000  000   000  000   000     000     000       
# 0000000     00000    00000000   000   000  0000000       000     0000000   
# 000        000 000   000        000   000  000   000     000          000  
# 00000000  000   000  000         0000000   000   000     000     0000000   

⮐  {
    klor:           klor
    exts:           exts
    parse:          parse
    chunked:        chunked
    ranges:         ranges
    dissect:        dissect
    kolorize:       kolorize
    kolorizeChunks: kolorizeChunks
    syntax:         syntax
   }
