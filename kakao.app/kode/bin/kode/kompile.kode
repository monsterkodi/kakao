###
000   000   0000000   0000000    00000000
000  000   000   000  000   000  000
0000000    000   000  000   000  0000000
000  000   000   000  000   000  000
000   000   0000000   0000000    00000000
###

import Lexer     from './lexer.js'
import print     from './print.js'
import Parser    from './parser.js'
import Scoper    from './scoper.js'
import Stripol   from './stripol.js'
import Returner  from './returner.js'
import Operator  from './operator.js'
import Renderer  from './renderer.js'
import vm        from 'vm'
import slash     from '../../lib/kxk/slash.js'

class Kode

    @: (@args) ->
        
        @args ?= {}
        @args.header  = true
        @version  = '0.256.0'

        @literals = ['bool''num''regex''single''double''triple']
        @atoms    = @literals.concat ['var']

        @lexer    = new Lexer    @
        @parser   = new Parser   @
        @scoper   = new Scoper   @
        @stripol  = new Stripol  @
        @returner = new Returner @
        @operator = new Operator @
        @renderer = new Renderer @

    # 00000000  000   000   0000000   000
    # 000       000   000  000   000  000
    # 0000000    000 000   000000000  000
    # 000          000     000   000  000
    # 00000000      0      000   000  0000000

    eval: (text, file, glob) ->

        return if empty text

        # vm = require 'vm'
        
        sandbox = vm.createContext()
        if glob then sandbox[k] = v for k,v of glob

        sandbox.__filename = file ? 'eval'
        sandbox.__dirname  = slash.dir sandbox.__filename
        sandbox.console    = console
        sandbox.process    = process
        sandbox.global     = global

        # if not (sandbox.module or sandbox.require) or file
            # Module = require 'module'
            # sandbox.module   = _module  = new Module 'eval'
            # sandbox.require  = _require = (file) -> Module._load file, _module, true
            # _module.filename = sandbox.__filename
            # for r in Object.getOwnPropertyNames require
                # if r not in ['paths' 'arguments' 'caller' 'length' 'name']
                    # _require[r] = require[r]

            # _require.paths = _module.paths = Module._nodeModulePaths process.cwd()
            # _require.resolve = (request) -> Module._resolveFilename request, _module
            
        try
            js = @compile text, file
            vm.runInContext js, sandbox
        catch err
            error err
            throw err
        
    #  0000000   0000000   00     00  00000000   000  000      00000000
    # 000       000   000  000   000  000   000  000  000      000
    # 000       000   000  000000000  00000000   000  000      0000000
    # 000       000   000  000 0 000  000        000  000      000
    #  0000000   0000000   000   000  000        000  0000000  00000000

    @compile: (text, opt={}) -> (new Kode opt).compile text
    
    compile: (text, file) ->

        return '' if empty trim text

        @renderer.render @ast(text), file

    astr: (text, scopes) -> print.astr @ast(text), scopes
        
    ast: (text) ->

        # print.code 'kode' text, 'coffee' if @args.verbose or @args.debug or @args.kode

        # ●▸ token
        tokens = @lexer.tokenize text
        # ●▪ token

        # if @args.raw    then print.noon 'raw tokens' tokens
        # if @args.tokens then print.tokens 'tokens'   tokens

        block = @lexer.blockify tokens

        # if @args.raw   then print.noon 'raw block' block
        # if @args.block then print.block 'tl block' block

        @operator.collect @returner.collect @scoper.collect @stripol.collect @parser.parse block

export Kode
