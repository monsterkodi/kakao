###
00     00   0000000   000000000  00000000   000  000   000
000   000  000   000     000     000   000  000   000 000 
000000000  000000000     000     0000000    000    00000  
000 0 000  000   000     000     000   000  000   000 000 
000   000  000   000     000     000   000  000  000   000
###

use ../kxk ▪ fade randRange randInt randIntRange

function matrix

    @: ->
        
        @eggFadeTime       = 6.0
        @critMoveTime      = 4.0 
        @critDieTime       = 2.3
        
        @numLeaves         = 7
        @critterMaxAge     = 3000
        @critterEggTime    = 500
        @eggMaxAge         = 50
        @leafMaxAge        = 100
        @critterEatTime    = 90
        @critterStarveTime = 50
        
        @start()
        
    #  0000000  000000000   0000000   00000000   000000000  
    # 000          000     000   000  000   000     000     
    # 0000000      000     000000000  0000000       000     
    #      000     000     000   000  000   000     000     
    # 0000000      000     000   000  000   000     000     
    
    start: =>
        
        @plants   = []
        @tubes    = []
        @eggs     = []
        @critters = []
        
        @addEgg @ws/2 @ws/2
        
        for x in 0..@ws/3
            for y in 0..@ws/3
                @addPlant x*3 y*3
        
    #  0000000   0000000    000   000   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000   000  0000  000  000       000       
    # 000000000  000   000   000 000   000000000  000 0 000  000       0000000   
    # 000   000  000   000     000     000   000  000  0000  000       000       
    # 000   000  0000000        0      000   000  000   000   0000000  00000000  
    
    advance: sec =>
        
        for e in @eggs
            
            e.age += sec
            
            if e.age > @eggMaxAge and e.age-sec <= @eggMaxAge
                @addCritter e.x, e.y
                
            if e.age > @eggMaxAge+@eggFadeTime
                @eggs.splice @eggs.indexOf(e), 1
                
        for c in @critters
            
            c.age += sec
            c.eat -= sec
                        
            if c.age > @critterMaxAge or c.eat < -@critterStarveTime
                c.df ?= 0
                c.df += sec / @critDieTime
                if c.df > 1
                    @critters.splice @critters.indexOf(c), 1
                continue
                
            if c.eat < 0
                if l = @neighborLeaf c
                    c.eat = @critterEatTime
                    l.age = 0
                continue
            
            if Math.floor(c.age / @critterEggTime) > c.eggs
                if n = @emptyNeighbor c
                    @addEgg n.x, n.y
                    c.eggs++

            if c.sf > 0
                c.sf -= sec / @critMoveTime
                c.sf  = max 0 c.sf
                c.tx = fade c.x, c.sx, c.sf
                c.ty = fade c.y, c.sy, c.sf
                continue
                          
            if randInt(3) == 0 or c.age < 1
                c.sx = c.x
                c.sy = c.y
                c.sf = 0.5
                continue
                
            n = @randomOffset c
            if @isInWorld(n) and @isEmpty n
                c.sx = c.x
                c.sy = c.y
                c.sf = 1
                c.x = n[0]
                c.y = n[1]
                
        for p in @plants
                        
            for l in p.leaves
                
                l.age += sec
                
    #  0000000   0000000    0000000      
    # 000   000  000   000  000   000    
    # 000000000  000   000  000   000    
    # 000   000  000   000  000   000    
    # 000   000  0000000    0000000      
    
    addEgg: x y => 
    
        x = parseInt x
        y = parseInt y
    
        @eggs.push x:x, y:y, age:0
    
    addCritter: x y => 
    
        x = parseInt x
        y = parseInt y
        
        @critters.push x:x, y:y, age:0, sx:0, sy:0, sf:0, eggs:0, eat:@critterEatTime
    
    addTube: x y idx =>
        
        x = parseInt x
        y = parseInt y
        
        @tubes.push x:x, y:y, idx:idx
        
    addPlant: x y =>
        
        x = parseInt x
        y = parseInt y
            
        leaves = [] 
        for l in 0...@numLeaves
            leaves.push age:l*@leafMaxAge/@numLeaves
        
        @plants.push x:x, y:y, leaves:leaves

    # 0000000    00000000  000      
    # 000   000  000       000      
    # 000   000  0000000   000      
    # 000   000  000       000      
    # 0000000    00000000  0000000  
    
    delAt: p =>
        
        if pl = @plantAt p
            @plants.splice @plants.indexOf(pl), 1
            ⮐ 
            
        if tb = @tubeAt p
            @tubes.splice @tubes.indexOf(tb), 1
            ⮐ 

    # 00000000    0000000    0000000    
    # 000   000  000   000  000         
    # 00000000   000   000  0000000     
    # 000        000   000       000    
    # 000         0000000   0000000     
    
    isInWorld: p => p[0] >= 0 and p[1] >= 0 and p[0] < @ws and p[1] < @ws
    isEmpty:   p =>
        
        for o in @critters ➜ ⮐ false if o.x == p[0] and o.y == p[1] 
        for o in @eggs     ➜ ⮐ false if o.x == p[0] and o.y == p[1] 
        for o in @plants   ➜ ⮐ false if o.x == p[0] and o.y == p[1] 
        true
        
    buildingAtPos: p =>
        
        for o in @plants   ➜ ⮐ true if o.x == p[0] and o.y == p[1] 
        false
        
    emptyNeighbor: o =>
        
        en = []
        
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                c = [o.x+x, o.y+y]
                continue if not @isInWorld c
                if @isEmpty c
                    en.push x:c[0], y:c[1]
                    
        if en.length
            ⮐ en[randInt(en.length)]
        null
    
    validNeighbors: o =>
        
        vn = []
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                c = [o.x+x, o.y+y]
                if @isInWorld c
                    vn.push c
        vn
        
    neighbors: o =>
        
        n = [] 
        for x in -1..1
            for y in -1..1
                continue if x == y == 0
                n.push [o.x+x, o.y+y]
        n
        
    plantAt: p =>
        
        for pl in @plants
            if pl.x == p[0] and pl.y == p[1]
                ⮐ pl
        null

    tubeAt: p =>
        
        for tb in @tubes
            if tb.x == p[0] and tb.y == p[1]
                ⮐ tb
        null
        
    leafToEatAt: p =>
        
        if pl = @plantAt p
            for l in pl.leaves
                if l.age > @leafMaxAge
                    ⮐ l
        null
                        
    neighborLeaf: o =>
        
        nl = []
        for vn in @neighbors o
            if l = @leafToEatAt vn
                nl.push l
                    
        if nl.length
            ⮐ nl[randInt(nl.length)]
        null
        
    randomOffset: c =>
        
        o = [[-1 1], [0, 1], [1, 1], [-1 0], [1 0], [-1 -1], [0, -1], [1, -1]][randInt 8]
        [c.x+o[0], c.y+o[1]]

    randomOffsetCross: c =>
        
        o = [[0, 1], [-1 0], [1 0], [0, -1]][randInt 4]
        [c.x+o[0], c.y+o[1]]
            
export matrix
